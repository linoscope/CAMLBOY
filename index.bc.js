//# 1 "index.bc.runtime.js"
// Generated by js_of_ocaml 3.11.0+git-25a3fa7
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return joo_global_object.process && joo_global_object.process.platform
              ?joo_global_object.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root");
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res)
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.log10(x)}
    function unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)caml_failwith("unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)caml_failwith("unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function bigstringaf_memcmp_bigstring(ba1,ba1_off,ba2,ba2_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba1,ba1_off + i),caml_ba_get_1(ba2,ba2_off + i));
        if(c != 0)return c}
      return 0}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function unix_has_symlink(unit){return fs_node_supported()?1:0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_string_to_ba(src,src_off,dst,dst_off,len)}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function unix_getuid(unit)
     {if(joo_global_object.process && joo_global_object.process.getuid)
       return joo_global_object.process.getuid();
      caml_raise_not_found()}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    var
     os_type=
      joo_global_object.process
       &&
       joo_global_object.process.platform
       &&
       joo_global_object.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_log2_float(x){return Math.log2(x)}
    function caml_gc_huge_fallback_count(unit){return 0}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_ba_to_bytes(src,src_off,dst,dst_off,len)}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)caml_failwith("unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    var unix_lstat_64=unix_lstat;
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         handler(err,false);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)at_exit(0);
          joo_global_object.console.error
           ("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    var win_filedescr_of_channel=caml_channel_descriptor;
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_asinh_float(x){return Math.asinh(x)}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function bigstringaf_memcmp_string(ba,ba_off,str,str_off,len)
     {for(var i=0;i < len;i++)
       {var
         c=
          caml_int_compare
           (caml_ba_get_1(ba,ba_off + i),
            caml_string_unsafe_get(str,str_off + i));
        if(c != 0)return c}
      return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_get_major_credit(n){return 0}
    function bigstringaf_memchr(ba,ba_off,chr,len)
     {for(var i=0;i < len;i++)
       if(caml_ba_get_1(ba,ba_off + i) == chr)return ba_off + i;
      return - 1}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var refill=null;
      if(fd == 0 && fs_node_supported())
       {var fs=require("fs");
        refill
        =
        function(){return caml_string_of_jsstring(fs.readFileSync(0,"utf8"))}}
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    var unix_stat_64=unix_stat;
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    function caml_get_major_bucket(n){return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith("unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function unix_getpwuid(unit){caml_raise_not_found()}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)caml_failwith("unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_eventlog_pause(unit){return 0}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    function bigstringaf_blit_to_bigstring(src,src_off,dst,dst_off,len)
     {return caml_bigstring_blit_ba_to_ba(src,src_off,dst,dst_off,len)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    function caml_setup_uncaught_exception_handler()
     {var g=joo_global_object;
      if(g.process && g.process.on)
       g.process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);g.process.exit(2)});
      else
       if(g.addEventListener)
        g.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    joo_global_object.jsoo_runtime
    =
    {bigstringaf_memchr:bigstringaf_memchr,
     bigstringaf_memcmp_string:bigstringaf_memcmp_string,
     bigstringaf_memcmp_bigstring:bigstringaf_memcmp_bigstring,
     bigstringaf_blit_from_bytes:bigstringaf_blit_from_bytes,
     bigstringaf_blit_to_bigstring:bigstringaf_blit_to_bigstring,
     bigstringaf_blit_to_bytes:bigstringaf_blit_to_bytes,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_has_symlink:unix_has_symlink,
     unix_getpwuid:unix_getpwuid,
     unix_getuid:unix_getuid,
     unix_unlink:unix_unlink,
     unix_readlink:unix_readlink,
     unix_symlink:unix_symlink,
     unix_rmdir:unix_rmdir,
     unix_mkdir:unix_mkdir,
     unix_lstat_64:unix_lstat_64,
     unix_lstat:unix_lstat,
     unix_stat_64:unix_stat_64,
     unix_stat:unix_stat,
     make_unix_err_args:make_unix_err_args,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     os_type:os_type,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     caml_format_exception:caml_format_exception,
     caml_is_special_exception:caml_is_special_exception,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_obj_add_offset:caml_obj_add_offset,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     win_filedescr_of_channel:win_filedescr_of_channel,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_fma_float:caml_fma_float,
     caml_erfc_float:caml_erfc_float,
     caml_erf_float:caml_erf_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_round_float:caml_round_float,
     caml_atanh_float:caml_atanh_float,
     caml_tanh_float:caml_tanh_float,
     caml_asinh_float:caml_asinh_float,
     caml_sinh_float:caml_sinh_float,
     caml_acosh_float:caml_acosh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log2_float:caml_log2_float,
     caml_log1p_float:caml_log1p_float,
     caml_exp2_float:caml_exp2_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_get_major_credit:caml_get_major_credit,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_minor_free:caml_get_minor_free,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     path_is_absolute:path_is_absolute,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_get_root:caml_get_root,
     caml_current_dir:caml_current_dir,
     caml_trailing_slash:caml_trailing_slash,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_args:caml_raise_with_args,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_ba_set_2=runtime.caml_ba_set_2,
     caml_ba_set_3=runtime.caml_ba_set_3,
     caml_ba_set_generic=runtime.caml_ba_set_generic,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_blit=runtime.caml_floatarray_blit,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.13.1"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     empty$1=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_combine=caml_string_of_jsbytes("Array.combine"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst_Fatal_error_out_of_memory_=
      caml_string_of_jsbytes
       ("Fatal error: out of memory in uncaught exception handler"),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_full_int=caml_string_of_jsbytes("Random.full_int"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_Hashtbl_unsupported_hash_t=
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst_CamlinternalMod_update_mod=
      caml_string_of_jsbytes("CamlinternalMod.update_mod: not a module"),
     cst_CamlinternalMod_init_mod_n=
      caml_string_of_jsbytes("CamlinternalMod.init_mod: not a module"),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _q_=[0,caml_string_of_jsbytes("obj.ml"),100,4],
     _u_=[0,caml_string_of_jsbytes("array.ml"),322,4],
     _w_=[0,caml_string_of_jsbytes("float.ml"),395,6],
     _v_=[0,caml_string_of_jsbytes("float.ml"),222,14],
     _H_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _G_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _F_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _I_=[0,0,0,0],
     _J_=[0,0,0],
     _K_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _L_=[0,0,0,0],
     _M_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _N_=[0,0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _P_=[0,0],
     _Q_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     ___=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _av_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aE_=[1,0],
     _aF_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aO_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aT_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _aw_=[0,0,4],
     _aq_=[0,103],
     _$_=[0,0,0],
     _bj_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _be_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a6_=[0,caml_string_of_jsbytes("-help")],
     _a7_=[0,caml_string_of_jsbytes("--help")],
     _a4_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a2_=[0,caml_string_of_jsbytes("-help")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bo_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bA_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bB_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Fatal error in uncaught exception handler: exception "),
        [2,0,[12,10,0]]],
       caml_string_of_jsbytes
        ("Fatal error in uncaught exception handler: exception %s\n")],
     _bz_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bx_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bs_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _by_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections:      %d\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("major_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections:      %d\n")],
     _bK_=
      [0,
       [11,
        caml_string_of_jsbytes("compactions:            "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:            %d\n")],
     _bL_=
      [0,
       [11,
        caml_string_of_jsbytes("forced_major_collections: "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("forced_major_collections: %d\n")],
     _bM_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bN_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bO_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bP_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bQ_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bR_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bS_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bX_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bZ_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _b0_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _b1_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _b2_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b__=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b$_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ca_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _ce_=[0,0],
     _cd_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _ck_=[3,0,3],
     _cj_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _ch_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _ci_=[0,0],
     _cg_=[0,caml_string_of_jsbytes("")],
     _cf_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cA_=[0,91],
     _cz_=[0,123],
     _cB_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cC_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cy_=[0,37,caml_string_of_jsbytes("")],
     _cx_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cw_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cr_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _cq_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cp_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _co_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cn_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _cm_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cJ_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),439,17],
     _cI_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),421,13],
     _cH_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),418,13],
     _cG_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),415,13],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),412,13],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),409,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cK_=[0,caml_string_of_jsbytes("camlinternalMod.ml"),72,5],
     _cL_=[0,caml_string_of_jsbytes("camlinternalMod.ml"),81,2],
     _cO_=[0,0],
     _cN_=[0,0],
     _cM_=[0,0],
     _cT_=[0,7,0],
     _cS_=[0,1,[0,3,[0,5,0]]],
     _cR_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cQ_=[0,caml_string_of_jsbytes('"'),0],
     _cU_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (745,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function set(r,v){r[1] = v;return 0}
    function exchange(r,v){var cur=r[1];r[1] = v;return cur}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function fetch_and_add(r,n){var cur=r[1];r[1] = cur + n | 0;return cur}
    function incr(r){fetch_and_add(r,1);return 0}
    function decr(r){fetch_and_add(r,-1);return 0}
    var
     include=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(746,include,"CamlinternalAtomic");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function cat(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _CE_=[0,caml_int_of_string(s)];return _CE_}
      catch(_CF_)
       {_CF_ = caml_wrap_exception(_CF_);
        if(_CF_[1] === Failure)return 0;
        throw _CF_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return cat(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _CC_=[0,caml_float_of_string(s)];return _CC_}
      catch(_CD_)
       {_CD_ = caml_wrap_exception(_CD_);
        if(_CD_[1] === Failure)return 0;
        throw _CD_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_CB_)
             {_CB_ = caml_wrap_exception(_CB_);
              if(_CB_[1] !== Sys_error)throw _CB_;
              var _CA_=_CB_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_Cz_){}
      try
       {var _Cx_=caml_ml_close_channel(oc);return _Cx_}
      catch(_Cy_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _Cw_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _Cw_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _Cw_=res}
        return caml_string_of_bytes(_Cw_)}}
    function close_in_noerr(ic)
     {try
       {var _Cu_=caml_ml_close_channel(ic);return _Cu_}
      catch(_Cv_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol(param,_Cs_)
     {var
       str2=_Cs_[2],
       fmt2=_Cs_[1],
       str1=param[2],
       fmt1=param[1],
       _Ct_=cat(str1,cat(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_Ct_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {for(;;)
       {var
         f_yet_to_run=[0,1],
         old_exit=exit_function[1],
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {if(compare_and_set(f_yet_to_run,1,0))caml_call1(f,0);
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _Cr_=1 - success;
        if(_Cr_)continue;
        return _Cr_}}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    caml_register_named_value
     (caml_string_of_jsbytes("Pervasives.do_at_exit"),do_at_exit);
    if(runtime.caml_sys_const_naked_pointers_checked(0))
     at_exit(function(_Cq_){return runtime.caml_gc_major(_Cq_)});
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       cat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(759,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_Pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       cat,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(760,Stdlib_Pervasives,"Stdlib__Pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Cp_){return append$0(next,seq2,_Cp_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Cn_=function(_Co_){return map(f,next,_Co_)};
        return [0,caml_call1(f,x),_Cn_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Cm_){return filter_map(f,next,_Cm_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Cl_){return filter(f,next,_Cl_)}];
          var seq$0=next;
          continue}
        return 0}}
    function concat(seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Cj_=0;
        return append$0(x,function(_Ck_){return concat(next,_Ck_)},_Cj_)}
      return 0}
    function flat_map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Cg_=0,
         _Ch_=function(_Ci_){return flat_map(f,next,_Ci_)};
        return append$0(caml_call1(f,x),_Ch_,_Cg_)}
      return 0}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_Cf_){return unfold(f,u$0,_Cf_)}]}
      return 0}
    var
     Stdlib_Seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       concat,
       flat_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(761,Stdlib_Seq,"Stdlib__Seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get$0(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Ce_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Ce_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Cd_){return return$0(v,_Cd_)}}
      return empty}
    var
     Stdlib_Option=
      [0,
       none,
       some,
       value,
       get$0,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(762,Stdlib_Option,"Stdlib__Option");
    function left(v){return [0,v]}
    function right(v){return [1,v]}
    function is_left(param){return 0 === param[0]?1:0}
    function is_right(param){return 0 === param[0]?0:1}
    function find_left(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function find_right(param)
     {if(0 === param[0])return 0;var v=param[1];return [0,v]}
    function map_left(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_right(f,e)
     {if(0 === e[0])return e;var v=e[1];return [1,caml_call1(f,v)]}
    function map$1(left,right,param)
     {if(0 === param[0]){var v=param[1];return [0,caml_call1(left,v)]}
      var v$0=param[1];
      return [1,caml_call1(right,v$0)]}
    function fold$0(left,right,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(left,v)}
      var v$0=param[1];
      return caml_call1(right,v$0)}
    function equal$0(left,right,e1,e2)
     {if(0 === e1[0])
       {var _Cb_=e1[1];
        if(0 === e2[0]){var v2=e2[1];return caml_call2(left,_Cb_,v2)}}
      else
       {var _Cc_=e1[1];
        if(0 !== e2[0]){var v2$0=e2[1];return caml_call2(right,_Cc_,v2$0)}}
      return 0}
    function compare$0(left,right,e1,e2)
     {if(0 === e1[0])
       {var _B$_=e1[1];
        if(0 === e2[0]){var v2=e2[1];return caml_call2(left,_B$_,v2)}
        return -1}
      var _Ca_=e1[1];
      if(0 === e2[0])return 1;
      var v2$0=e2[1];
      return caml_call2(right,_Ca_,v2$0)}
    var
     Stdlib_Either=
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map$1,
       fold$0,
       fold$0,
       fold$0,
       equal$0,
       compare$0];
    caml_register_global(763,Stdlib_Either,"Stdlib__Either");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$2(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$1(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$1(ok,error,r0,r1)
     {if(0 === r0[0])
       {var _B9_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return caml_call2(ok,_B9_,v1)}}
      else
       {var _B__=r0[1];
        if(0 !== r1[0]){var e1=r1[1];return caml_call2(error,_B__,e1)}}
      return 0}
    function compare$1(ok,error,r0,r1)
     {if(0 === r0[0])
       {var _B7_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return caml_call2(ok,_B7_,v1)}
        return -1}
      var _B8_=r0[1];
      if(0 === r1[0])return 1;
      var e1=r1[1];
      return caml_call2(error,_B8_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_B6_){return return$0(v,_B6_)}}
      return empty}
    var
     Stdlib_Result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$2,
       map_error,
       fold$1,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$1,
       compare$1,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(764,Stdlib_Result,"Stdlib__Result");
    function equal$2(_B5_,_B4_){return _B5_ === _B4_?1:0}
    var compare$2=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_B3_){return _B3_}
    var
     Stdlib_Bool=
      [0,
       function(_B2_){return 1 - _B2_},
       equal$2,
       compare$2,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(765,Stdlib_Bool,"Stdlib__Bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _B1_=c - 192 | 0,switch$0=0;
      if(30 < _B1_ >>> 0)
       {if(! (25 < (_B1_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _B1_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _B0_=c - 224 | 0,switch$0=0;
      if(30 < _B0_ >>> 0)
       {if(! (25 < (_B0_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _B0_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    function compare$3(c1,c2){return c1 - c2 | 0}
    function equal$3(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_Char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$3,
       equal$3];
    caml_register_global(766,Stdlib_Char,"Stdlib__Char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _BW_=0 <= i?1:0,_BX_=_BW_?i <= 55295?1:0:_BW_;
      if(_BX_)
       var _BY_=_BX_;
      else
       var _BZ_=57344 <= i?1:0,_BY_=_BZ_?i <= 1114111?1:0:_BZ_;
      return _BY_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (cat(caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (cat
                  (cst_U,
                   cat
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_BV_){return _BV_}
    function equal$4(_BU_,_BT_){return _BU_ === _BT_?1:0}
    var compare$4=caml_int_compare;
    function hash(_BS_){return _BS_}
    function _n_(_BR_){return _BR_}
    var
     Stdlib_Uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_BQ_){return _BQ_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$4,
       compare$4,
       hash];
    caml_register_global(767,Stdlib_Uchar,"Stdlib__Uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _BO_=[0,caml_sys_getenv(s)];return _BO_}
      catch(_BP_)
       {_BP_ = caml_wrap_exception(_BP_);
        if(_BP_ === Not_found)return 0;
        throw _BP_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_BN_,_BM_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_Sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(768,Stdlib_Sys,"Stdlib__Sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$3(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$3(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BL_=caml_call1(p,a);
          if(_BL_){var param$0=l;continue}
          return _BL_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BK_=caml_call1(p,a);
          if(_BK_)return _BK_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _BJ_=caml_call2(p,a1,a2);
            if(_BJ_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _BJ_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _BI_=caml_call2(p,a1,a2);
            if(_BI_)return _BI_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BH_=0 === caml_compare(a,x)?1:0;
          if(_BH_)return _BH_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BG_=a === x?1:0;
          if(_BG_)return _BG_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _BF_=0 === caml_compare(a,x)?1:0;
          if(_BF_)return _BF_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_BE_=a === x?1:0;
          if(_BE_)return _BE_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _BD_=rev(no);
        return [0,rev(yes),_BD_]}}
    function partition_map(p,param)
     {var left=0,right=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],match=caml_call1(p,x);
          if(0 === match[0])
           {var v=match[1],left$0=[0,v,left],left=left$0,param$0=l;continue}
          var v$0=match[1],right$0=[0,v$0,right],right=right$0,param$0=l;
          continue}
        var _BC_=rev(right);
        return [0,rev(left),_BC_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,l2)
     {if(l1)
       {if(l2)
         {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,l2)]}
        return l1}
      return l2}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _By_=l[2];
            if(_By_)
             {var
               tl=_By_[2],
               x2=_By_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _BA_=l[2];
           if(_BA_)
            {var _BB_=_BA_[2];
             if(_BB_)
              {var
                tl$1=_BB_[2],
                x3=_BB_[1],
                x2$0=_BA_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _Bz_=rev_append(l1,accu)}
          else
           var _Bz_=rev_append(l2,accu);
          return [0,_Bz_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bu_=l[2];
            if(_Bu_)
             {var
               tl=_Bu_[2],
               x2=_Bu_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Bw_=l[2];
           if(_Bw_)
            {var _Bx_=_Bw_[2];
             if(_Bx_)
              {var
                tl$1=_Bx_[2],
                x3=_Bx_[1],
                x2$0=_Bw_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _Bv_=rev_append(l1,accu)}
          else
           var _Bv_=rev_append(l2,accu);
          return [0,_Bv_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bl_=l[2];
            if(_Bl_)
             {var
               tl=_Bl_[2],
               x2=_Bl_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Bn_=l[2];
           if(_Bn_)
            {var _Bo_=_Bn_[2];
             if(_Bo_)
              {var
                tl$1=_Bo_[2],
                x3=_Bo_[1],
                x2$0=_Bn_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _Bp_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_Bp_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _Bq_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _Bq_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _Br_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _Bq_=_Br_;
                  var s$0=_Bq_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _Bs_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _Bs_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _Bt_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _Bs_=_Bt_;
                  var s$0=_Bs_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _Bm_=rev_append(l1,accu)}
          else
           var _Bm_=rev_append(l2,accu);
          return [0,_Bm_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bc_=l[2];
            if(_Bc_)
             {var
               tl=_Bc_[2],
               x2=_Bc_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Be_=l[2];
           if(_Be_)
            {var _Bf_=_Be_[2];
             if(_Bf_)
              {var
                tl$1=_Bf_[2],
                x3=_Bf_[1],
                x2$0=_Be_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _Bg_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_Bg_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _Bh_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _Bi_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _Bh_=_Bi_;
                   else
                    var _Bh_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_Bh_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _Bj_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _Bk_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _Bj_=_Bk_;
                   else
                    var _Bj_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_Bj_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _Bd_=rev_append(l1,accu)}
          else
           var _Bd_=rev_append(l2,accu);
          return [0,_Bd_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function equal$5(eq,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _Bb_=caml_call2(eq,a1,a2);
            if(_Bb_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _Bb_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function compare$5(cmp,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _A$_=l1$0[2],_Ba_=l1$0[1];
          if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],c=caml_call2(cmp,_Ba_,a2);
            if(0 === c){var l1$0=_A$_,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_A__){return aux(tail,_A__)}]}
        return 0}
      return function(_A9_){return aux(l,_A9_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _A8_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_A8_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include$0=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(769,include$0,"Stdlib__List");
    var zero=0,one=1,minus_one=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$6(_A7_,_A6_){return _A7_ === _A6_?1:0}
    var compare$6=caml_int_compare;
    function min$1(x,y){return x <= y?x:y}
    function max$1(x,y){return y <= x?x:y}
    function to_string$1(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_Int=
      [0,
       zero,
       one,
       minus_one,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$6,
       compare$6,
       min$1,
       max$1,
       to_string$1];
    caml_register_global(770,Stdlib_Int,"Stdlib__Int");
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_A4_=n - 1 | 0,_A3_=0;
      if(! (_A4_ < 0))
       {var i=_A3_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _A5_=i + 1 | 0;
          if(_A4_ !== i){var i=_A5_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function of_bytes(b){return caml_string_of_bytes(copy(b))}
    function to_bytes(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$0(a,b)
     {var c=a + b | 0,_A2_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_A2_ && ! match)switch$0 = 1}
      else
       if(! _A2_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$0(symbol$0(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min$1(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _A0_=caml_ml_bytes_length(a) - 1 | 0,_AZ_=0;
      if(! (_A0_ < 0))
       {var i=_AZ_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _A1_=i + 1 | 0;
          if(_A0_ !== i){var i=_A1_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _AX_=caml_ml_bytes_length(a) - 1 | 0,_AW_=0;
      if(! (_AX_ < 0))
       {var i=_AW_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _AY_=i + 1 | 0;
          if(_AX_ !== i){var i=_AY_;continue}
          break}}
      return 0}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _AT_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_AT_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _AV_=caml_ml_bytes_length(_AT_) + acc | 0}
          else
           var _AV_=acc;
          var dst=caml_create_bytes(_AV_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _AU_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_AU_,0,dst,pos,caml_ml_bytes_length(_AU_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_AU_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_AU_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_AU_,0,dst,pos,caml_ml_bytes_length(_AU_));
              return dst}
            return dst}}}
      return empty$0}
    function cat$0(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _AS_=param - 9 | 0,switch$0=0;
      if(4 < _AS_ >>> 0)
       {if(23 === _AS_)switch$0 = 1}
      else
       if(2 !== _AS_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_AL_=caml_ml_bytes_length(s) - 1 | 0,_AK_=0;
      if(! (_AL_ < 0))
       {var i$0=_AK_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _AP_=match - 34 | 0,switch$1=0;
            if(58 < _AP_ >>> 0)
             {if(93 <= _AP_)switch$1 = 1}
            else
             if(56 < (_AP_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _AQ_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _AQ_=4;break;case 1:var _AQ_=2;break}
          n[1] = n[1] + _AQ_ | 0;
          var _AR_=i$0 + 1 | 0;
          if(_AL_ !== i$0){var i$0=_AR_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _AN_=caml_ml_bytes_length(s) - 1 | 0,_AM_=0;
      if(! (_AN_ < 0))
       {var i=_AM_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _AO_=i + 1 | 0;
          if(_AN_ !== i){var i=_AO_;continue}
          break}}
      return s$0}
    function map$4(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_AI_=l - 1 | 0,_AH_=0;
      if(! (_AI_ < 0))
       {var i=_AH_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _AJ_=i + 1 | 0;
          if(_AI_ !== i){var i=_AJ_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_AF_=l - 1 | 0,_AE_=0;
      if(! (_AF_ < 0))
       {var i=_AE_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _AG_=i + 1 | 0;
          if(_AF_ !== i){var i=_AG_;continue}
          break}}
      return r}
    function fold_left$1(f,x,a)
     {var r=[0,x],_AC_=caml_ml_bytes_length(a) - 1 | 0,_AB_=0;
      if(! (_AC_ < 0))
       {var i=_AB_;
        for(;;)
         {r[1] = caml_call2(f,r[1],caml_bytes_unsafe_get(a,i));
          var _AD_=i + 1 | 0;
          if(_AC_ !== i){var i=_AD_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_Az_=caml_ml_bytes_length(a) - 1 | 0;
      if(! (_Az_ < 0))
       {var i=_Az_;
        for(;;)
         {r[1] = caml_call2(f,caml_bytes_unsafe_get(a,i),r[1]);
          var _AA_=i - 1 | 0;
          if(0 !== i){var i=_AA_;continue}
          break}}
      return r[1]}
    function exists$0(p,s)
     {var n=caml_ml_bytes_length(s),i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,caml_bytes_unsafe_get(s,i)))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,s)
     {var n=caml_ml_bytes_length(s),i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,caml_bytes_unsafe_get(s,i)))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function uppercase_ascii$0(s){return map$4(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$4(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function starts_with(prefix,s)
     {var
       len_s=caml_ml_bytes_length(s),
       len_pre=caml_ml_bytes_length(prefix),
       _Ay_=len_pre <= len_s?1:0;
      if(_Ay_)
       {var i=0;
        for(;;)
         {if(i === len_pre)return 1;
          if(caml_bytes_unsafe_get(s,i) !== caml_bytes_unsafe_get(prefix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _Ay_}
    function ends_with(suffix,s)
     {var
       len_s=caml_ml_bytes_length(s),
       len_suf=caml_ml_bytes_length(suffix),
       diff=len_s - len_suf | 0,
       _Ax_=0 <= diff?1:0;
      if(_Ax_)
       {var i=0;
        for(;;)
         {if(i === len_suf)return 1;
          if
           (caml_bytes_unsafe_get(s,diff + i | 0)
            !==
            caml_bytes_unsafe_get(suffix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _Ax_}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _Av_=1;return _Av_}
       catch(_Aw_)
        {_Aw_ = caml_wrap_exception(_Aw_);
         if(_Aw_ === Not_found)return 0;
         throw _Aw_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _At_=1;return _At_}
       catch(_Au_)
        {_Au_ = caml_wrap_exception(_Au_);
         if(_Au_ === Not_found)return 0;
         throw _Au_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$7(x,y){return runtime.caml_bytes_compare(x,y)}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_bytes_length(s)],
       _Ap_=caml_ml_bytes_length(s) - 1 | 0;
      if(! (_Ap_ < 0))
       {var i=_Ap_;
        for(;;)
         {if(caml_bytes_unsafe_get(s,i) === sep)
           {var _Ar_=r[1];
            r[1] = [0,sub(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_Ar_];
            j[1] = i}
          var _As_=i - 1 | 0;
          if(0 !== i){var i=_As_;continue}
          break}}
      var _Aq_=r[1];
      return [0,sub(s,0,j[1]),_Aq_]}
    function uppercase$0(s){return map$4(uppercase,s)}
    function lowercase$0(s){return map$4(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_An_=i + 1 | 0;
        return [0,x,function(_Ao_){return aux(_An_,_Ao_)}]}
      var _Al_=0;
      return function(_Am_){return aux(_Al_,_Am_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_Aj_=i + 1 | 0;
        return [0,[0,i,x],function(_Ak_){return aux(_Aj_,_Ak_)}]}
      var _Ah_=0;
      return function(_Ai_){return aux(_Ah_,_Ai_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make$0(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min$1(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make$0(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$7=runtime.caml_bytes_equal,
     include$1=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       to_bytes,
       of_bytes,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat$0,
       cat$0,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$7,
       equal$7,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(771,include$1,"Stdlib__Bytes");
    function make$1(n,c){return caml_string_of_bytes(make$0(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$1(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _Ae_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_Ae_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _Ag_=caml_ml_string_length(_Ae_) + acc | 0}
          else
           var _Ag_=acc;
          var dst=caml_create_bytes(_Ag_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _Af_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_Af_,0,dst,pos,caml_ml_string_length(_Af_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_Af_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_Af_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_Af_,0,dst,pos,caml_ml_string_length(_Af_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _Ac_=caml_ml_string_length(s) - 1 | 0,_Ab_=0;
      if(! (_Ac_ < 0))
       {var i=_Ab_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _Ad_=i + 1 | 0;
          if(_Ac_ !== i){var i=_Ad_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _z$_=caml_ml_string_length(s) - 1 | 0,_z__=0;
      if(! (_z$_ < 0))
       {var i=_z__;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _Aa_=i + 1 | 0;
          if(_z$_ !== i){var i=_Aa_;continue}
          break}}
      return 0}
    function map$5(f,s)
     {return caml_string_of_bytes(map$4(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function fold_right$1(f,x,a)
     {return fold_right$0(f,caml_bytes_of_string(x),a)}
    function fold_left$2(f,a,x)
     {return fold_left$1(f,a,caml_bytes_of_string(x))}
    function exists$1(f,s){return exists$0(f,caml_bytes_of_string(s))}
    function for_all$1(f,s){return for_all$0(f,caml_bytes_of_string(s))}
    function is_space$0(param)
     {var _z9_=param - 9 | 0,switch$0=0;
      if(4 < _z9_ >>> 0)
       {if(23 === _z9_)switch$0 = 1}
      else
       if(2 !== _z9_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_z8_=match - 32 | 0,switch$0=0;
        if(59 < _z8_ >>> 0)
         {if(33 < (_z8_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _z8_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _z6_=1;return _z6_}
       catch(_z7_)
        {_z7_ = caml_wrap_exception(_z7_);
         if(_z7_ === Not_found)return 0;
         throw _z7_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _z4_=1;return _z4_}
       catch(_z5_)
        {_z5_ = caml_wrap_exception(_z5_);
         if(_z5_ === Not_found)return 0;
         throw _z5_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function starts_with$0(prefix,s)
     {var
       len_s=caml_ml_string_length(s),
       len_pre=caml_ml_string_length(prefix),
       _z3_=len_pre <= len_s?1:0;
      if(_z3_)
       {var i=0;
        for(;;)
         {if(i === len_pre)return 1;
          if(caml_string_unsafe_get(s,i) !== caml_string_unsafe_get(prefix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _z3_}
    function ends_with$0(suffix,s)
     {var
       len_s=caml_ml_string_length(s),
       len_suf=caml_ml_string_length(suffix),
       diff=len_s - len_suf | 0,
       _z2_=0 <= diff?1:0;
      if(_z2_)
       {var i=0;
        for(;;)
         {if(i === len_suf)return 1;
          if
           (caml_string_unsafe_get(s,diff + i | 0)
            !==
            caml_string_unsafe_get(suffix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _z2_}
    function split_on_char$0(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _zY_=caml_ml_string_length(s) - 1 | 0;
      if(! (_zY_ < 0))
       {var i=_zY_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _z0_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_z0_];
            j[1] = i}
          var _z1_=i - 1 | 0;
          if(0 !== i){var i=_z1_;continue}
          break}}
      var _zZ_=r[1];
      return [0,sub$0(s,0,j[1]),_zZ_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function compare$8(x,y){return caml_string_compare(x,y)}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    function get_int8$0(s,i){return get_int8(caml_bytes_of_string(s),i)}
    function get_uint16_le$0(s,i)
     {return caml_bytes_get16(caml_bytes_of_string(s),i)}
    function get_uint16_be$0(s,i)
     {return get_uint16_be(caml_bytes_of_string(s),i)}
    function get_int16_ne$0(s,i)
     {return get_int16_ne(caml_bytes_of_string(s),i)}
    function get_int16_le$0(s,i)
     {return get_int16_le(caml_bytes_of_string(s),i)}
    function get_int16_be$0(s,i)
     {return get_int16_be(caml_bytes_of_string(s),i)}
    function get_int32_le$0(s,i)
     {return caml_bytes_get32(caml_bytes_of_string(s),i)}
    function get_int32_be$0(s,i)
     {return get_int32_be(caml_bytes_of_string(s),i)}
    function get_int64_le$0(s,i)
     {return caml_bytes_get64(caml_bytes_of_string(s),i)}
    function get_int64_be$0(s,i)
     {return get_int64_be(caml_bytes_of_string(s),i)}
    var
     get_int64_ne$0=runtime.caml_string_get64,
     get_int32_ne$0=runtime.caml_string_get32,
     get_uint16_ne$0=runtime.caml_string_get16,
     get_uint8$0=caml_string_get,
     equal$8=caml_string_equal,
     include$2=
      [0,
       make$1,
       init$1,
       empty$1,
       of_bytes,
       to_bytes,
       concat$1,
       cat,
       equal$8,
       compare$8,
       starts_with$0,
       ends_with$0,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char$0,
       map$5,
       mapi$1,
       fold_left$2,
       fold_right$1,
       for_all$1,
       exists$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       get_uint8$0,
       get_int8$0,
       get_uint16_ne$0,
       get_uint16_be$0,
       get_uint16_le$0,
       get_int16_ne$0,
       get_int16_be$0,
       get_int16_le$0,
       get_int32_ne$0,
       get_int32_be$0,
       get_int32_le$0,
       get_int64_ne$0,
       get_int64_be$0,
       get_int64_le$0];
    caml_register_global(772,include$2,"Stdlib__String");
    function equal$9(param,_zX_){return 1}
    function compare$9(param,_zW_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_Unit=[0,equal$9,compare$9,to_string$2];
    caml_register_global(773,Stdlib_Unit,"Stdlib__Unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_Marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(774,Stdlib_Marshal,"Stdlib__Marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _zV_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_zV_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function info(obj)
     {if(caml_obj_tag(obj) === 247)
       {var
         info=runtime.caml_obj_raw_field(obj,1),
         arity=info >> 24,
         start_env=info << 8 >>> 9 | 0;
        return [0,arity,start_env]}
      throw [0,Assert_failure,_q_]}
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _zT_=0 <= l?1:0,_zU_=_zT_?l <= max_ephe_length?1:0:_zT_;
      if(1 - _zU_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _zQ_=0 <= o?1:0,_zR_=_zQ_?o < length$0(e)?1:0:_zQ_,_zS_=1 - _zR_;
      return _zS_?invalid_arg(msg):_zS_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _zO_=0 !== l?1:0,
         _zP_=_zO_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_zO_;
        return _zP_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _r_=runtime.caml_ephe_blit_data,
     _s_=runtime.caml_ephe_check_data,
     _t_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_zN_){return runtime.caml_ephe_unset_data(_zN_)},
       _s_,
       _r_,
       max_ephe_length],
     Stdlib_Obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0,info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _t_];
    caml_register_global(775,Stdlib_Obj,"Stdlib__Obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_zL_=l - 1 | 0,_zK_=1;
        if(! (_zL_ < 1))
         {var i=_zK_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _zM_=i + 1 | 0;
            if(_zL_ !== i){var i=_zM_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_zI_=sx - 1 | 0,_zH_=0;
      if(! (_zI_ < 0))
       {var x=_zH_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _zJ_=x + 1 | 0;
          if(_zI_ !== x){var x=_zJ_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _zF_=a.length - 1 - 1 | 0,_zE_=0;
      if(! (_zF_ < 0))
       {var i=_zE_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _zG_=i + 1 | 0;
          if(_zF_ !== i){var i=_zG_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _zC_=a.length - 1 - 1 | 0,_zB_=0;
      if(! (_zC_ < 0))
       {var i=_zB_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _zD_=i + 1 | 0;
          if(_zC_ !== i){var i=_zD_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_zz_=l - 1 | 0,_zy_=1;
      if(! (_zz_ < 1))
       {var i=_zy_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _zA_=i + 1 | 0;
          if(_zz_ !== i){var i=_zA_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_zw_=la - 1 | 0,_zv_=1;
      if(! (_zw_ < 1))
       {var i=_zv_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _zx_=i + 1 | 0;
          if(_zw_ !== i){var i=_zx_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _zt_=a.length - 1 - 1 | 0,_zs_=0;
      if(! (_zt_ < 0))
       {var i=_zs_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _zu_=i + 1 | 0;
          if(_zt_ !== i){var i=_zu_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_zq_=l - 1 | 0,_zp_=1;
      if(! (_zq_ < 1))
       {var i=_zp_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _zr_=i + 1 | 0;
          if(_zq_ !== i){var i=_zr_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$3(f,x,a)
     {var r=[0,x],_zn_=a.length - 1 - 1 | 0,_zm_=0;
      if(! (_zn_ < 0))
       {var i=_zm_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _zo_=i + 1 | 0;
          if(_zn_ !== i){var i=_zo_;continue}
          break}}
      return r[1]}
    function fold_left_map$0(f,acc,input_array)
     {var len=input_array.length - 1;
      if(0 === len)return [0,acc,[0]];
      var
       match=caml_call2(f,acc,input_array[1]),
       elt=match[2],
       acc$0=match[1],
       output_array=caml_make_vect(len,elt),
       acc$1=[0,acc$0],
       _zk_=len - 1 | 0,
       _zj_=1;
      if(! (_zk_ < 1))
       {var i=_zj_;
        for(;;)
         {var
           match$0=caml_call2(f,acc$1[1],input_array[1 + i]),
           elt$0=match$0[2],
           acc$2=match$0[1];
          acc$1[1] = acc$2;
          output_array[1 + i] = elt$0;
          var _zl_=i + 1 | 0;
          if(_zk_ !== i){var i=_zl_;continue}
          break}}
      return [0,acc$1[1],output_array]}
    function fold_right$2(f,a,x)
     {var r=[0,x],_zh_=a.length - 1 - 1 | 0;
      if(! (_zh_ < 0))
       {var i=_zh_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _zi_=i - 1 | 0;
          if(0 !== i){var i=_zi_;continue}
          break}}
      return r[1]}
    function exists$2(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$2(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function find_opt$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        var x=a[1 + i];
        if(caml_call1(p,x))return [0,x];
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function find_map$0(f,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        var r=caml_call1(f,a[1 + i]);
        if(r)return r;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function split$0(x)
     {if(caml_equal(x,[0]))return [0,[0],[0]];
      var
       match=x[1],
       b0=match[2],
       a0=match[1],
       n=x.length - 1,
       a=caml_make_vect(n,a0),
       b=caml_make_vect(n,b0),
       _zf_=n - 1 | 0,
       _ze_=1;
      if(! (_zf_ < 1))
       {var i=_ze_;
        for(;;)
         {var match$0=x[1 + i],bi=match$0[2],ai=match$0[1];
          a[1 + i] = ai;
          b[1 + i] = bi;
          var _zg_=i + 1 | 0;
          if(_zf_ !== i){var i=_zg_;continue}
          break}}
      return [0,a,b]}
    function combine$0(a,b)
     {var na=a.length - 1,nb=b.length - 1;
      if(na !== nb)invalid_arg(cst_Array_combine);
      if(0 === na)return [0];
      var x=caml_make_vect(na,[0,a[1],b[1]]),_zc_=na - 1 | 0,_zb_=1;
      if(! (_zc_ < 1))
       {var i=_zb_;
        for(;;)
         {x[1 + i] = [0,a[1 + i],b[1 + i]];
          var _zd_=i + 1 | 0;
          if(_zc_ !== i){var i=_zd_;continue}
          break}}
      return x}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _y6_=i31 + 1 | 0,_y7_=caml_check_bound(a,_y6_)[1 + _y6_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_y7_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _y8_=i31 + 2 | 0,
           _y9_=caml_check_bound(a,_y8_)[1 + _y8_],
           _y__=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_y__)[1 + _y__],_y9_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _y$_=i31 + 1 | 0,_za_=caml_check_bound(a,_y$_)[1 + _y$_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_za_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _y5_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _y5_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _y4_=trickledown(l,i,e);return _y4_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_y3_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _y3_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _y2_=bubbledown(l,i);return _y2_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_yU_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_yU_ < 0))
       {var i$2=_yU_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _y1_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_y1_;continue}
          break}}
      var _yV_=l - 1 | 0;
      if(! (_yV_ < 2))
       {var i$0=_yV_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _yZ_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _yZ_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _yT_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _yT_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _y0_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_y0_;continue a}
            break}
          break}}
      var _yW_=1 < l?1:0;
      if(_yW_)
       {var e=caml_check_bound(a,1)[2],_yX_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _yX_;
        caml_check_bound(a,0)[1] = e;
        var _yY_=0}
      else
       var _yY_=_yW_;
      return _yY_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _yL_=len - 1 | 0,_yK_=0;
        if(! (_yL_ < 0))
         {var i=_yK_;
          a:
          for(;;)
           {var
             _yM_=srcofs + i | 0,
             e=caml_check_bound(a,_yM_)[1 + _yM_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _yN_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_yN_)[1 + _yN_],e))
                 {var
                   _yO_=j[1],
                   _yP_=caml_check_bound(dst,_yO_)[1 + _yO_],
                   _yQ_=j[1] + 1 | 0;
                  caml_check_bound(dst,_yQ_)[1 + _yQ_] = _yP_;
                  j[1] += -1;
                  continue}}
              var _yR_=j[1] + 1 | 0;
              caml_check_bound(dst,_yR_)[1 + _yR_] = e;
              var _yS_=i + 1 | 0;
              if(_yL_ !== i){var i=_yS_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yI_=i + 1 | 0;
          return [0,x,function(_yJ_){return aux(_yI_,_yJ_)}]}
        return 0}
      var _yG_=0;
      return function(_yH_){return aux(_yG_,_yH_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yE_=i + 1 | 0;
          return [0,[0,i,x],function(_yF_){return aux(_yE_,_yF_)}]}
        return 0}
      var _yC_=0;
      return function(_yD_){return aux(_yC_,_yD_)}}
    function of_seq$2(i$2)
     {var _yB_=0,l=fold_left(function(acc,x){return [0,x,acc]},_yB_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$2=caml_array_concat,
     include$3=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$2,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$3,
       fold_left_map$0,
       fold_right$2,
       iter2$0,
       map2$0,
       for_all$2,
       exists$2,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       find_opt$0,
       find_map$0,
       split$0,
       combine$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(776,include$3,"Stdlib__Array");
    var zero$0=0.,one$0=1.,minus_one$0=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _yA_=x == runtime.caml_trunc_float(x)?1:0;
      return _yA_?is_finite(x):_yA_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$10(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$2(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$2(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _yy_=(ofs + len | 0) - 1 | 0;
      if(! (_yy_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _yz_=i + 1 | 0;
          if(_yy_ !== i){var i=_yz_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _yu_=ofs < 0?1:0;
      if(_yu_)
       var _yv_=_yu_;
      else
       {var _yw_=len < 0?1:0;
        if(_yw_)
         var _yv_=_yw_;
        else
         var
          _yx_=(ofs + len | 0) < 0?1:0,
          _yv_=_yx_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _yv_?invalid_arg(msg):_yv_}
    function make$2(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_ys_=l - 1 | 0,_yr_=0;
        if(! (_ys_ < 0))
         {var i=_yr_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _yt_=i + 1 | 0;
            if(_ys_ !== i){var i=_yt_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      caml_floatarray_blit(a1,0,result,0,l1);
      caml_floatarray_blit(a2,0,result,l1,l2);
      return result}
    function concat$3(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            caml_floatarray_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_v_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      caml_floatarray_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      caml_floatarray_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return caml_floatarray_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_yq_){return a[1 + _yq_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _yo_=a.length - 1 - 1 | 0,_yn_=0;
      if(! (_yo_ < 0))
       {var i=_yn_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _yp_=i + 1 | 0;
          if(_yo_ !== i){var i=_yp_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _yl_=a.length - 1 - 1 | 0,_yk_=0;
      if(! (_yl_ < 0))
       {var i=_yk_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _ym_=i + 1 | 0;
          if(_yl_ !== i){var i=_ym_;continue}
          break}}
      return 0}
    function map$7(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_yi_=l - 1 | 0,_yh_=0;
      if(! (_yi_ < 0))
       {var i=_yh_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _yj_=i + 1 | 0;
          if(_yi_ !== i){var i=_yj_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_yf_=la - 1 | 0,_ye_=0;
      if(! (_yf_ < 0))
       {var i=_ye_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _yg_=i + 1 | 0;
          if(_yf_ !== i){var i=_yg_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _yc_=a.length - 1 - 1 | 0,_yb_=0;
      if(! (_yc_ < 0))
       {var i=_yb_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _yd_=i + 1 | 0;
          if(_yc_ !== i){var i=_yd_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_x$_=l - 1 | 0,_x__=0;
      if(! (_x$_ < 0))
       {var i=_x__;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _ya_=i + 1 | 0;
          if(_x$_ !== i){var i=_ya_;continue}
          break}}
      return r}
    function fold_left$4(f,x,a)
     {var r=[0,x],_x8_=a.length - 1 - 1 | 0,_x7_=0;
      if(! (_x8_ < 0))
       {var i=_x7_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _x9_=i + 1 | 0;
          if(_x8_ !== i){var i=_x9_;continue}
          break}}
      return r[1]}
    function fold_right$3(f,a,x)
     {var r=[0,x],_x5_=a.length - 1 - 1 | 0;
      if(! (_x5_ < 0))
       {var i=_x5_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _x6_=i - 1 | 0;
          if(0 !== i){var i=_x6_;continue}
          break}}
      return r[1]}
    function exists$3(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$3(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _x4_=trickledown(l,i,e);return _x4_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _x3_=bubbledown(l,i);return _x3_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xX_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xX_ < 0))
       {var i$2=_xX_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _x2_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_x2_;continue}
          break}}
      var _xY_=l - 1 | 0;
      if(! (_xY_ < 2))
       {var i$0=_xY_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_w_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _x1_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_x1_;continue a}
            break}
          break}}
      var _xZ_=1 < l?1:0;
      if(_xZ_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _x0_=caml_array_set(a,0,e)}
      else
       var _x0_=_xZ_;
      return _x0_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xV_=len - 1 | 0,_xU_=0;
        if(! (_xV_ < 0))
         {var i=_xU_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _xW_=i + 1 | 0;
              if(_xV_ !== i){var i=_xW_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xS_=i + 1 | 0;
          return [0,x,function(_xT_){return aux(_xS_,_xT_)}]}
        return 0}
      var _xQ_=0;
      return function(_xR_){return aux(_xQ_,_xR_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xO_=i + 1 | 0;
          return [0,[0,i,x],function(_xP_){return aux(_xO_,_xP_)}]}
        return 0}
      var _xM_=0;
      return function(_xN_){return aux(_xM_,_xN_)}}
    function of_seq$3(i$2)
     {var
       _xL_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_xL_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xJ_=l - 1 | 0,_xI_=1;
      if(! (_xJ_ < 1))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xG_=l - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r}
    var
     _x_=caml_floatarray_create,
     _y_=caml_array_set,
     _z_=caml_array_get,
     _A_=
      [0,
       function(_xE_){return _xE_.length - 1},
       _z_,
       _y_,
       make$2,
       _x_,
       init$3,
       append$2,
       concat$3,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$7,
       mapi$3,
       fold_left$4,
       fold_right$3,
       iter2$1,
       map2$1,
       for_all$3,
       exists$3,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     Stdlib_Float=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$10,
       min$2,
       max$2,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_xD_){return _xD_.length - 1},
        _D_,
        _C_,
        make$2,
        _B_,
        init$3,
        append$2,
        concat$3,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$4,
        fold_right$3,
        iter2$1,
        map2$1,
        for_all$3,
        exists$3,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _A_];
    caml_register_global(777,Stdlib_Float,"Stdlib__Float");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$3(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _xB_=[0,caml_int_of_string(s)];return _xB_}
      catch(_xC_)
       {_xC_ = caml_wrap_exception(_xC_);
        if(_xC_[1] === Failure)return 0;
        throw _xC_}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function min$3(x,y){return caml_lessequal(x,y)?x:y}
    function max$3(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_Int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$3,
       compare$10,
       unsigned_compare,
       equal$11,
       min$3,
       max$3];
    caml_register_global(778,Stdlib_Int32,"Stdlib__Int32");
    function succ$2(n){return caml_int64_add(n,_E_)}
    function pred$2(n){return caml_int64_sub(n,_F_)}
    function abs$2(n)
     {return caml_greaterequal(n,_G_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_H_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$4(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _xz_=[0,caml_int64_of_string(s)];return _xz_}
      catch(_xA_)
       {_xA_ = caml_wrap_exception(_xA_);
        if(_xA_[1] === Failure)return 0;
        throw _xA_}}
    function compare$11(x,y){return caml_int64_compare(x,y)}
    function equal$12(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function min$4(x,y){return caml_lessequal(x,y)?x:y}
    function max$4(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_Int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$4,
       compare$11,
       unsigned_compare$0,
       equal$12,
       min$4,
       max$4];
    caml_register_global(779,Stdlib_Int64,"Stdlib__Int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$5(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _xx_=[0,caml_int_of_string(s)];return _xx_}
      catch(_xy_)
       {_xy_ = caml_wrap_exception(_xy_);
        if(_xy_[1] === Failure)return 0;
        throw _xy_}}
    function compare$12(x,y){return caml_int_compare(x,y)}
    function equal$13(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function min$5(x,y){return caml_lessequal(x,y)?x:y}
    function max$5(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_Nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$5,
       compare$12,
       unsigned_compare$1,
       equal$13,
       min$5,
       max$5];
    caml_register_global(780,Stdlib_Nativeint,"Stdlib__Nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _xu_=0 <= result?1:0,
       _xv_=_xu_?buf[12] !== dummy_pos?1:0:_xu_;
      if(_xv_)
       {buf[11] = buf[12];
        var _xw_=buf[12];
        buf[12] = [0,_xw_[1],_xw_[2],_xw_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _xr_=0 <= result?1:0,
       _xs_=_xr_?buf[12] !== dummy_pos?1:0:_xr_;
      if(_xs_)
       {buf[11] = buf[12];
        var _xt_=buf[12];
        buf[12] = [0,_xt_[1],_xt_[2],_xt_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _xd_=with_positions?zero_pos:dummy_pos,
       _xe_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _xf_=[0],
       _xg_=0,
       _xh_=0,
       _xi_=0,
       _xj_=0,
       _xk_=0,
       _xl_=0,
       _xm_=0,
       _xn_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min$1
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_xp_=t.length - 1 - 1 | 0,_xo_=0;
                  if(! (_xp_ < 0))
                   {var i=_xo_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _xq_=i + 1 | 0;
                      if(_xp_ !== i){var i=_xq_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _xn_,
              _xm_,
              _xl_,
              _xk_,
              _xj_,
              _xi_,
              _xh_,
              _xg_,
              _xf_,
              _xe_,
              _xd_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _w4_=with_positions?zero_pos:dummy_pos,
       _w5_=with_positions?zero_pos:dummy_pos,
       _w6_=[0],
       _w7_=1,
       _w8_=0,
       _w9_=0,
       _w__=0,
       _w$_=0,
       _xa_=0,
       _xb_=caml_ml_string_length(s),
       _xc_=to_bytes(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _xc_,
              _xb_,
              _xa_,
              _w$_,
              _w__,
              _w9_,
              _w8_,
              _w7_,
              _w6_,
              _w5_,
              _w4_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _w3_=lexbuf[12];
      lexbuf[12] = [0,fname,_w3_[2],_w3_[3],_w3_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _w1_=lcp !== dummy_pos?1:0,
       _w2_=_w1_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_w1_;
      return _w2_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_Lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(781,Stdlib_Lexing,"Stdlib__Lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _wV_=env[13],
                _wW_=
                 caml_call1(caml_check_bound(tables[1],_wV_)[1 + _wV_],env),
                _wX_=4,
                arg$1=_wW_,
                cmd$0=_wX_}
             catch(_w0_)
              {_w0_ = caml_wrap_exception(_w0_);
               if(_w0_ !== Parse_error)throw _w0_;
               var arg$1=0,cmd$0=5,_wY_=_w0_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _wZ_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_wZ_)[1 + _wZ_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _wU_=env[11] - n | 0;return caml_check_bound(env[2],_wU_)[1 + _wU_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _wR_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_wR_)[1 + _wR_],
           _wS_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_wS_)[1 + _wS_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _wT_=env[11];
        return caml_check_bound(env[4],_wT_)[1 + _wT_]}}
    function symbol_end_pos(param)
     {var _wQ_=env[11];return caml_check_bound(env[4],_wQ_)[1 + _wQ_]}
    function rhs_start_pos(n)
     {var _wP_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_wP_)[1 + _wP_]}
    function rhs_end_pos(n)
     {var _wO_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_wO_)[1 + _wO_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_Parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_wN_){return runtime.caml_set_parser_trace(_wN_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(782,Stdlib_Parsing,"Stdlib__Parsing");
    var
     Stdlib_Set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _wM_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wM_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_wH_=height(lr);
               if(_wH_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_wI_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_wI_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_wJ_=height(rl);
               if(_wJ_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_wK_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_wK_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _wL_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wL_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wG_=param$0[1];
               if(_wG_){var param$0=_wG_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wF_=param$0[1];
               if(_wF_){var param$0=_wF_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _wE_=param[1];
             if(_wE_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_wE_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t1,t2)
          {if(t1)
            {if(t2)
              {var _wD_=remove_min_elt(t2);return join(t1,min_elt(t2),_wD_)}
             return t1}
           return t2}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _I_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _wC_=0 === c?1:0;
               if(_wC_)return _wC_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _wB_=remove_min_elt(r);return bal(l,min_elt(r),_wB_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[4],
                r2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[4],
                r1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,s1);
                 var
                  match=split(v1,s2),
                  r2$0=match[3],
                  l2$0=match[1],
                  _wz_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_wz_)}
               if(1 === h1)return add(v1,s2);
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                l1$0=match$0[1],
                _wA_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_wA_)}
             return s1}
           return s2}
         function inter(s1,s2)
          {if(s1)
            {if(s2)
              {var r1=s1[3],v1=s1[2],l1=s1[1],_wv_=split(v1,s2),_ww_=_wv_[1];
               if(_wv_[2])
                {var r2=_wv_[3],_wx_=inter(r1,r2);
                 return join(inter(l1,_ww_),v1,_wx_)}
               var r2$0=_wv_[3],_wy_=inter(r1,r2$0);
               return concat(inter(l1,_ww_),_wy_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_wu_=disjoint(l1,l2);
                 if(_wu_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _wu_}
               return 0}
             return 1}}
         function diff(s1,s2)
          {if(s1)
            {if(s2)
              {var r1=s1[3],v1=s1[2],l1=s1[1],_wq_=split(v1,s2),_wr_=_wq_[1];
               if(_wq_[2])
                {var r2=_wq_[3],_ws_=diff(r1,r2);
                 return concat(diff(l1,_wr_),_ws_)}
               var r2$0=_wq_[3],_wt_=diff(r1,r2$0);
               return join(diff(l1,_wr_),v1,_wt_)}
             return s1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _wn_=subset(l1,l2);
                   if(_wn_){var s1$0=r1,s2$0=r2;continue}
                   return _wn_}
                 if(0 <= c)
                  {var _wo_=subset([0,0,v1,r1,0],r2);
                   if(_wo_){var s1$0=l1;continue}
                   return _wo_}
                 var _wp_=subset([0,l1,v1,0,0],l2);
                 if(_wp_){var s1$0=r1;continue}
                 return _wp_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _wk_=caml_call1(p,v);
               if(_wk_)
                {var _wl_=for_all(p,l);
                 if(_wl_){var param$0=r;continue}
                 var _wm_=_wl_}
               else
                var _wm_=_wk_;
               return _wm_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _wh_=caml_call1(p,v);
               if(_wh_)
                var _wi_=_wh_;
               else
                {var _wj_=exists(p,l);
                 if(! _wj_){var param$0=r;continue}
                 var _wi_=_wj_}
               return _wi_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _wf_=concat(lf,rf);return [0,join(lt,v,rt),_wf_]}
             var _wg_=join(lf,v,rf);
             return [0,concat(lt,rt),_wg_]}
           return _J_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_we_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _we_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _wd_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_wd_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _wc_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_wc_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t1=filter_map(f,l),
              v$0=caml_call1(f,v),
              t2=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t1 && v === v$1 && r === t2)return t;
               return try_join(t1,v$1,t2)}
             if(t1)
              {if(t2)
                {var _wb_=remove_min_elt(t2);
                 return try_join(t1,min_elt(t2),_wb_)}
               return t1}
             return t2}
           return 0}
         function of_list(l)
          {if(l)
            {var _v2_=l[2],_v3_=l[1];
             if(_v2_)
              {var _v4_=_v2_[2],_v5_=_v2_[1];
               if(_v4_)
                {var _v6_=_v4_[2],_v7_=_v4_[1];
                 if(_v6_)
                  {var _v8_=_v6_[2],_v9_=_v6_[1];
                   if(_v8_)
                    {if(_v8_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _v__=l[2];
                                 if(_v__)
                                  {var l$4=_v__[2],x1=_v__[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _v$_=l[2];
                                 if(_v$_)
                                  {var _wa_=_v$_[2];
                                   if(_wa_)
                                    {var l$5=_wa_[2],x2=_wa_[1],x1$0=_v$_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_K_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_v8_[1];
                     return add(x4,add(_v9_,add(_v7_,add(_v5_,singleton(_v3_)))))}
                   return add(_v9_,add(_v7_,add(_v5_,singleton(_v3_))))}
                 return add(_v7_,add(_v5_,singleton(_v3_)))}
               return add(_v5_,singleton(_v3_))}
             return singleton(_v3_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_v0_=cons_enum(t,rest);
             return [0,x,function(_v1_){return seq_of_enum(_v0_,_v1_)}]}
           return 0}
         function to_seq(c)
          {var _vY_=cons_enum(c,0);
           return function(_vZ_){return seq_of_enum(_vY_,_vZ_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vW_=snoc_enum(t,rest);
             return [0,x,function(_vX_){return rev_seq_of_enum(_vW_,_vX_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vU_=snoc_enum(c,0);
           return function(_vV_){return rev_seq_of_enum(_vU_,_vV_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _vS_=[0,v,r,c]}
             else
              var _vS_=c;
             return function(_vT_){return seq_of_enum(_vS_,_vT_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 to_rev_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(783,Stdlib_Set,"Stdlib__Set");
    var
     Stdlib_Map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_vR_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vR_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_vM_=height(lr);
               if(_vM_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _vN_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_vN_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_vO_=height(rl);
               if(_vO_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _vP_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_vP_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _vQ_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vQ_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vL_=0 === c?1:0;
               if(_vL_)return _vL_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vK_=param$0[1];
               if(_vK_){var param$0=_vK_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vJ_=param$0[1];
               if(_vJ_){var param$0=_vJ_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _vI_=param[1];
             if(_vI_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_vI_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _vh_(t1,t2)
          {if(t1)
            {if(t2)
              {var match=min_binding(t2),d=match[2],x=match[1];
               return bal(t1,x,d,remove_min_binding(t2))}
             return t1}
           return t2}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _vh_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _vh_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vF_=caml_call2(p,v,d);
               if(_vF_)
                {var _vG_=for_all(p,l);
                 if(_vG_){var param$0=r;continue}
                 var _vH_=_vG_}
               else
                var _vH_=_vF_;
               return _vH_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vC_=caml_call2(p,v,d);
               if(_vC_)
                var _vD_=_vC_;
               else
                {var _vE_=exists(p,l);
                 if(! _vE_){var param$0=r;continue}
                 var _vD_=_vE_}
               return _vD_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t1,t2)
          {if(t1)
            {if(t2)
              {var match=min_binding(t2),d=match[2],x=match[1];
               return join(t1,x,d,remove_min_binding(t2))}
             return t1}
           return t2}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _L_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _vy_=merge(f,r1,r2),
                _vz_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_vz_,_vy_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _vA_=merge(f,r1$0,r2$0),
              _vB_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_vB_,_vA_)}
           throw [0,Assert_failure,_M_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _vw_=concat(lf,rf);return [0,join(lt,v,d,rt),_vw_]}
             var _vx_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_vx_]}
           return _N_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _vt_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_vt_)
                  {var _vu_=caml_call2(cmp,d1,d2);
                   if(_vu_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _vv_=_vu_}
                 else
                  var _vv_=_vt_;
                 return _vv_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_vs_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _vs_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_vq_=cons_enum(t,rest);
             return [0,[0,k,v],function(_vr_){return seq_of_enum(_vq_,_vr_)}]}
           return 0}
         function to_seq(m)
          {var _vo_=cons_enum(m,0);
           return function(_vp_){return seq_of_enum(_vo_,_vp_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[4],
                d=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,d,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_vm_=snoc_enum(t,rest);
             return [0,
                     [0,k,v],
                     function(_vn_){return rev_seq_of_enum(_vm_,_vn_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vk_=snoc_enum(c,0);
           return function(_vl_){return rev_seq_of_enum(_vk_,_vl_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _vi_=[0,v,d,r,c]}
             else
              var _vi_=c;
             return function(_vj_){return seq_of_enum(_vi_,_vj_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_rev_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(784,Stdlib_Map,"Stdlib__Map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _vg_=s[1];
      if(_vg_)
       {var tl=_vg_[2],hd=_vg_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _vf_=s[1];
      if(_vf_)
       {var tl=_vf_[2],hd=_vf_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _ve_=s[1];if(_ve_){var hd=_ve_[1];return hd}throw Empty}
    function top_opt(s)
     {var _vd_=s[1];if(_vd_){var hd=_vd_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$2(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_Stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$2,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(785,Stdlib_Stack,"Stdlib__Stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_vc_=q[3];
      return _vc_
              ?(q[1] = q[1] + 1 | 0,_vc_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _vb_=q[2];if(_vb_){var content=_vb_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _va_=q[2];if(_va_){var content=_va_[1];return [0,content]}return 0}
    function take(q)
     {var _u__=q[2];
      if(_u__)
       {var _u$_=_u__[1];
        if(_u__[2])
         {var next=_u__[2];q[1] = q[1] - 1 | 0;q[2] = next;return _u$_}
        clear$0(q);
        return _u$_}
      throw Empty$0}
    function take_opt(q)
     {var _u8_=q[2];
      if(_u8_)
       {var _u9_=_u8_[1];
        if(_u8_[2])
         {var next=_u8_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_u9_]}
        clear$0(q);
        return [0,_u9_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$3(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _u6_=0 < q1[1]?1:0;
      if(_u6_)
       {var _u7_=q2[3];
        return _u7_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _u7_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _u6_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_u5_){return aux(next,_u5_)}]}
        return 0}
      var _u3_=q[2];
      return function(_u4_){return aux(_u3_,_u4_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_Queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$3,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(786,Stdlib_Queue,"Stdlib__Queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(787,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    function map$8(f,x)
     {return [246,
              function(_u0_)
               {var
                 _u1_=caml_obj_tag(x),
                 _u2_=250 === _u1_?x[1]:246 === _u1_?force_lazy_block(x):x;
                return caml_call1(f,_u2_)}]}
    function map_val(f,x)
     {if(is_val(x))
       {var
         _uV_=caml_obj_tag(x),
         _uW_=250 === _uV_?x[1]:246 === _uV_?force_lazy_block(x):x;
        return from_val(caml_call1(f,_uW_))}
      return [246,
              function(_uX_)
               {var
                 _uY_=caml_obj_tag(x),
                 _uZ_=250 === _uY_?x[1]:246 === _uY_?force_lazy_block(x):x;
                return caml_call1(f,_uZ_)}]}
    var
     Stdlib_Lazy=
      [0,
       Undefined,
       map$8,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(788,Stdlib_Lazy,"Stdlib__Lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=d$0[1],
             _uR_=caml_obj_tag(f),
             d$1=250 === _uR_?f[1]:246 === _uR_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _uS_=d$0[1],_uT_=_uS_[1];
            if(_uT_)
             {var _uU_=_uT_[1];
              if(_uU_){var a$0=_uU_[1];_uS_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_uS_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _uS_[1] = _P_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _uM_=s[2];
        if(typeof _uM_ === "number")
         return 0;
        else
         switch(_uM_[0])
          {case 0:var a=_uM_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=_uM_[1],
             _uN_=caml_obj_tag(f),
             _uO_=250 === _uN_?f[1]:246 === _uN_?force_lazy_block(f):f;
            s[2] = _uO_;
            continue;
           case 3:
            var _uP_=_uM_[1],_uQ_=_uP_[1];
            if(_uQ_){var a$1=_uQ_[1];return a$1}
            var x=caml_call1(_uP_[2],s[1]);
            _uP_[1] = [0,x];
            return x;
           default:
            var b=_uM_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _uK_=s[2];
        if(typeof _uK_ !== "number")
         switch(_uK_[0])
          {case 0:var d=_uK_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _uL_=_uK_[1];
            if(_uL_[1]){s[1] = s[1] + 1 | 0;_uL_[1] = 0;return 0}
            break;
           case 4:
            var b=_uK_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$2(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _uJ_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_uJ_)]]}
    function of_string(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _uI_=data(s);return [0,[0,0,[1,data(i),_uI_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uG_)
                  {var _uH_=data(s);return [1,data(caml_call1(f,0)),_uH_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uE_)
                  {var _uF_=data(s);return [0,caml_call1(f,0),_uF_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_uD_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_uC_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_Stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string,
       of_bytes$0,
       of_channel,
       iter$9,
       next,
       empty$2,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(789,Stdlib_Stream,"Stdlib__Stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes$0(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_R_]}
        throw [0,Assert_failure,_S_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _uz_=offset < 0?1:0;
      if(_uz_)
       var _uA_=_uz_;
      else
       var
        _uB_=len < 0?1:0,
        _uA_=_uB_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_uA_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ux_=len < 0?1:0,_uy_=_ux_ || (max_string_length < len?1:0);
      if(_uy_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_uw_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_uw_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Z_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _uu_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,___];var _uu_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _uu_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _uv_=92 === previous?1:0;
        return _uv_?add_char(b,previous):_uv_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_us_=i + 1 | 0;
        return [0,x,function(_ut_){return aux(_us_,_ut_)}]}
      var _uq_=0;
      return function(_ur_){return aux(_uq_,_ur_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_uo_=i + 1 | 0;
        return [0,[0,i,x],function(_up_){return aux(_uo_,_up_)}]}
      var _um_=0;
      return function(_un_){return aux(_um_,_un_)}}
    function add_seq$1(b,seq)
     {return iter(function(_ul_){return add_char(b,_ul_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_Buffer=
      [0,
       create$2,
       contents,
       to_bytes$0,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(790,Stdlib_Buffer,"Stdlib__Buffer");
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return of_bytes(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _uk_=i + 1 | 0;
        if(31 !== i){var i=_uk_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_uj_=[0,ndec];else var _uj_=0;
          return [0,[8,_$_,pad_of_pad_opt(pad_opt$5),_uj_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _uh_=len < min_len?1:0;
      if(_uh_)
       {var
         new_len=max$1(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _ui_=0}
      else
       var _ui_=_uh_;
      return _ui_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return cat(cst$19,make$1(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _uf_=caml_ml_string_length(str) - 1 | 0,_ue_=0;
      if(! (_uf_ < 0))
       {var i=_ue_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _ug_=i + 1 | 0;
          if(_uf_ !== i){var i=_ug_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _t6_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_t$_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _ua_=is_in_char_set(_t$_,c);
                 if(_ua_)
                  var
                   _ub_=is_in_char_set(_t$_,before),
                   _uc_=_ub_?is_in_char_set(_t$_,after):_ub_,
                   _ud_=1 - _uc_;
                 else
                  var _ud_=_ua_;
                 return _ud_}
               return is_alone},
            is_alone=is_alone$0(_t6_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_t6_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_t6_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_t6_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_t6_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_t6_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _t7_=108;break;
             case 1:var _t7_=110;break;
             default:var _t7_=78}
           buffer_add_char(buf,_t7_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _t9_=int_of_custom_arity(arity),
            _t8_=1;
           if(! (_t9_ < 1))
            {var i$8=_t8_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _t__=i$8 + 1 | 0;
               if(_t9_ !== i$8){var i$8=_t__;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,ty2)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof ty2 === "number")
        return 0;
       else
        switch(ty2[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_tN_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 0:var rest2=ty2[1];return [0,trans(_tN_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_tO_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 1:var rest2$0=ty2[1];return [1,trans(_tO_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_tP_=ty1[1];
          if(typeof ty2 === "number")
           switch$3 = 1;
          else
           switch(ty2[0])
            {case 2:var rest2$1=ty2[1];return [2,trans(_tP_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_tQ_=ty1[1];
          if(typeof ty2 === "number")
           switch$4 = 1;
          else
           switch(ty2[0])
            {case 3:var rest2$2=ty2[1];return [3,trans(_tQ_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_tR_=ty1[1];
          if(typeof ty2 === "number")
           switch$5 = 1;
          else
           switch(ty2[0])
            {case 4:var rest2$3=ty2[1];return [4,trans(_tR_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_tS_=ty1[1];
          if(typeof ty2 === "number")
           switch$6 = 1;
          else
           switch(ty2[0])
            {case 5:var rest2$4=ty2[1];return [5,trans(_tS_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_tT_=ty1[1];
          if(typeof ty2 === "number")
           switch$7 = 1;
          else
           switch(ty2[0])
            {case 6:var rest2$5=ty2[1];return [6,trans(_tT_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_tU_=ty1[1];
          if(typeof ty2 === "number")
           switch$8 = 1;
          else
           switch(ty2[0])
            {case 7:var rest2$6=ty2[1];return [7,trans(_tU_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_tV_=ty1[2],_tW_=ty1[1];
          if(typeof ty2 === "number")
           switch$9 = 1;
          else
           switch(ty2[0])
            {case 8:
              var rest2$7=ty2[2],ty2$0=ty2[1],_tX_=trans(_tV_,rest2$7);
              return [8,trans(_tW_,ty2$0),_tX_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var switch$10=0,_tY_=ty1[3],_tZ_=ty1[2],_t0_=ty1[1];
          if(typeof ty2 === "number")
           switch$10 = 1;
          else
           switch(ty2[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=ty2[3],
               ty22=ty2[2],
               ty21=ty2[1],
               ty=trans(symm(_tZ_),ty21),
               match=fmtty_rel_det(ty),
               f4=match[4],
               f2=match[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_t0_,ty22,trans(_tY_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _t1_=ty1[1];
          if(typeof ty2 !== "number" && 10 === ty2[0])
           {var rest2$9=ty2[1];return [10,trans(_t1_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var switch$11=0,_t2_=ty1[1];
          if(typeof ty2 === "number")
           switch$11 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:var rest2$10=ty2[1];return [11,trans(_t2_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var switch$12=0,_t3_=ty1[1];
          if(typeof ty2 === "number")
           switch$12 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=ty2[1];return [12,trans(_t3_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var switch$13=0,_t4_=ty1[1];
          if(typeof ty2 === "number")
           switch$13 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=ty2[1];return [13,trans(_t4_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var switch$14=0,_t5_=ty1[1];
          if(typeof ty2 === "number")
           switch$14 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=ty2[1];return [14,trans(_t5_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _tp_=function(param){return 0},
         _tq_=function(param){return 0},
         _tr_=function(param){return 0};
        return [0,function(param){return 0},_tr_,_tq_,_tp_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _ts_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_ts_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _tt_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _tt_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _tu_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _tu_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _tv_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _tv_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _tw_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _tw_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _tx_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _tx_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _ty_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _ty_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _tz_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _tz_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _tA_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _tA_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _tB_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _tC_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _tD_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _tD_,
                  _tC_,
                  _tB_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _tE_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _tE_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _tF_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _tF_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _tG_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _tG_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _tH_=function(param){caml_call1(de$12,0);return 0},
           _tI_=function(param){caml_call1(ed$12,0);return 0},
           _tJ_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _tJ_,
                  _tI_,
                  _tH_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _tK_=function(param){caml_call1(de$13,0);return 0},
           _tL_=function(param){caml_call1(ed$13,0);return 0},
           _tM_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _tM_,
                  _tL_,
                  _tK_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _tn_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_to_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _to_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_to_,_tn_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,fmtty)
     {if(typeof pad === "number")
       return [0,0,fmtty];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],fmtty]}
        if(typeof fmtty !== "number" && 2 === fmtty[0])
         {var rest=fmtty[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _tm_=match[2];
          if(typeof _tm_ !== "number" && 2 === _tm_[0])
           {var rest=_tm_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,fmtty)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,fmtty)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             sub_fmtty_rest=sub_fmtty[1],
             match=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match[2],
             sub_fmtty_rest$0=match[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$0[2],
             sub_fmtty_rest$2=match$0[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$1=fmtty[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$1[2],
             sub_fmtty_rest$4=match$1[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof fmtty !== "number" && 3 === fmtty[0])
           {var
             fmtty_rest$2=fmtty[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$2[2],
             sub_fmtty_rest$6=match$2[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof fmtty !== "number" && 4 === fmtty[0])
           {var
             fmtty_rest$3=fmtty[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$3[2],
             sub_fmtty_rest$8=match$3[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof fmtty !== "number" && 5 === fmtty[0])
           {var
             fmtty_rest$4=fmtty[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$4[2],
             sub_fmtty_rest$10=match$4[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof fmtty !== "number" && 6 === fmtty[0])
           {var
             fmtty_rest$5=fmtty[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$5[2],
             sub_fmtty_rest$12=match$5[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof fmtty !== "number" && 7 === fmtty[0])
           {var
             fmtty_rest$6=fmtty[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$6[2],
             sub_fmtty_rest$14=match$6[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$7=fmtty[2],
             sub2_fmtty=fmtty[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$7[2],
             sub_fmtty_rest$16=match$7[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$8=fmtty[3],
             sub2_fmtty$1=fmtty[2],
             sub1_fmtty=fmtty[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _tk_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_tk_))
             throw Type_mismatch;
            var _tl_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_tl_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$8=fmtty_rel_det(sub_fmtty$0),
             f4=match$8[4],
             f2=match$8[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$9=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$9[2],
             sub_fmtty_rest$18=match$9[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$10=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$10[2],
             sub_fmtty_rest$20=match$10[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$11[2],
             sub_fmtty_rest$22=match$11[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$12[2],
             sub_fmtty_rest$24=match$12[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 14 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$13[2],
             sub_fmtty_rest$26=match$13[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _s5_=match$1[2],
           _s4_=match$1[1];
          if(typeof _s5_ !== "number" && 1 === _s5_[0])
           {var
             fmtty_rest$1=_s5_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_s4_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _s7_=match$3[2],
           _s6_=match$3[1];
          if(typeof _s7_ !== "number" && 1 === _s7_[0])
           {var
             fmtty_rest$2=_s7_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_s6_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _s9_=match$5[3],
           _s8_=match$5[1];
          if(typeof _s9_ !== "number" && 2 === _s9_[0])
           {var
             fmtty_rest$3=_s9_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_s8_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _s$_=match$7[3],
           _s__=match$7[1];
          if(typeof _s$_ !== "number" && 3 === _s$_[0])
           {var
             fmtty_rest$4=_s$_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_s__,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _tb_=match$9[3],
           _ta_=match$9[1];
          if(typeof _tb_ !== "number" && 4 === _tb_[0])
           {var
             fmtty_rest$5=_tb_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_ta_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _td_=match$11[3],
           _tc_=match$11[1];
          if(typeof _td_ !== "number" && 5 === _td_[0])
           {var
             fmtty_rest$6=_td_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_tc_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _tf_=match$13[3],
           _te_=match$13[1];
          if(typeof _tf_ !== "number" && 6 === _tf_[0])
           {var
             fmtty_rest$7=_tf_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_te_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _th_=match$15[2],
           _tg_=match$15[1];
          if(typeof _th_ !== "number" && 7 === _th_[0])
           {var
             fmtty_rest$8=_th_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_tg_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _ti_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_ti_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _tj_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_tj_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_tj_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _s3_=type_format_gen(fmt,fmtty);
      if(typeof _s3_[2] === "number"){var fmt$0=_s3_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _s2_=2 === padty$0?48:32,res=make$0(width$0,_s2_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make$0(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make$0(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make$0(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make$0(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_aq_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_sX_=caml_ml_string_length(s) - 1 | 0,_sW_=0;
        if(! (_sX_ < 0))
         {var i$0=_sW_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _s1_=i$0 + 1 | 0;
            if(_sX_ !== i$0){var i$0=_s1_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _sZ_=caml_ml_string_length(s) - 1 | 0,
         _sY_=0;
        if(! (_sZ_ < 0))
         {var i=_sY_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _s0_=i + 1 | 0;
            if(_sZ_ !== i){var i=_s0_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _sV_=cst_d$3;break;
        case 2:var _sV_=cst_d$4;break;
        case 4:var _sV_=cst_i$1;break;
        case 5:var _sV_=cst_i$2;break;
        case 6:var _sV_=cst_x;break;
        case 7:var _sV_=cst_x$0;break;
        case 8:var _sV_=cst_X$0;break;
        case 9:var _sV_=cst_X$1;break;
        case 10:var _sV_=cst_o;break;
        case 11:var _sV_=cst_o$0;break;
        case 0:
        case 13:var _sV_=cst_d$2;break;
        case 3:
        case 14:var _sV_=cst_i$0;break;
        default:var _sV_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_sV_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _sU_=cst_ld$0;break;
        case 2:var _sU_=cst_ld$1;break;
        case 4:var _sU_=cst_li$1;break;
        case 5:var _sU_=cst_li$2;break;
        case 6:var _sU_=cst_lx;break;
        case 7:var _sU_=cst_lx$0;break;
        case 8:var _sU_=cst_lX;break;
        case 9:var _sU_=cst_lX$0;break;
        case 10:var _sU_=cst_lo;break;
        case 11:var _sU_=cst_lo$0;break;
        case 0:
        case 13:var _sU_=cst_ld;break;
        case 3:
        case 14:var _sU_=cst_li$0;break;
        default:var _sU_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_sU_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _sT_=cst_nd$0;break;
        case 2:var _sT_=cst_nd$1;break;
        case 4:var _sT_=cst_ni$1;break;
        case 5:var _sT_=cst_ni$2;break;
        case 6:var _sT_=cst_nx;break;
        case 7:var _sT_=cst_nx$0;break;
        case 8:var _sT_=cst_nX;break;
        case 9:var _sT_=cst_nX$0;break;
        case 10:var _sT_=cst_no;break;
        case 11:var _sT_=cst_no$0;break;
        case 0:
        case 13:var _sT_=cst_nd;break;
        case 3:
        case 14:var _sT_=cst_ni$0;break;
        default:var _sT_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_sT_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _sS_=cst_Ld$0;break;
        case 2:var _sS_=cst_Ld$1;break;
        case 4:var _sS_=cst_Li$1;break;
        case 5:var _sS_=cst_Li$2;break;
        case 6:var _sS_=cst_Lx;break;
        case 7:var _sS_=cst_Lx$0;break;
        case 8:var _sS_=cst_LX;break;
        case 9:var _sS_=cst_LX$0;break;
        case 10:var _sS_=cst_Lo;break;
        case 11:var _sS_=cst_Lo$0;break;
        case 0:
        case 13:var _sS_=cst_Ld;break;
        case 3:
        case 14:var _sS_=cst_Li$0;break;
        default:var _sS_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_sS_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _sQ_=0;
           else
            {var match=caml_string_get(str,i),_sP_=match - 46 | 0,switch$0=0;
             if(23 < _sP_ >>> 0)
              {if(55 === _sP_)switch$0 = 1}
             else
              if(21 < (_sP_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _sQ_=1}
           var _sR_=_sQ_?str:cat(str,cst$29);
           return caml_special_val(_sR_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make$0(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _sM_=pad$5[2],_sN_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_sN_,_sM_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_sN_,_sM_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_sN_,_sM_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _sO_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_sO_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_sO_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_sO_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _sK_=fmt$0[1];
           if(0 === _sK_[0])
            {var
              rest$13=fmt$0[2],
              match=_sK_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_sK_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _sL_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_sL_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_sL_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_sJ_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _sI_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sI_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_sI_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _sH_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sH_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_sH_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,prec,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         return prec
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=prec[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _sE_=pad[2],_sF_=pad[1];
          if(typeof prec === "number")
           return prec
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_sF_,_sE_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_sF_,_sE_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=prec[1];
          return function(x)
           {var
             str=
              fix_padding
               (_sF_,_sE_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _sG_=pad[1];
        if(typeof prec === "number")
         return prec
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_sG_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_sG_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=prec[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_sG_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_rV_=make_iprintf(k$0,o,rest);
           return function(_sD_){return _rV_};
          case 1:
           var rest$0=fmt$0[1],_rW_=make_iprintf(k$0,o,rest$0);
           return function(_sC_){return _rW_};
          case 2:
           var _rX_=fmt$0[1];
           if(typeof _rX_ === "number")
            {var rest$1=fmt$0[2],_rY_=make_iprintf(k$0,o,rest$1);
             return function(_sy_){return _rY_}}
           else
            {if(0 === _rX_[0])
              {var rest$2=fmt$0[2],_rZ_=make_iprintf(k$0,o,rest$2);
               return function(_sB_){return _rZ_}}
             var
              rest$3=fmt$0[2],
              _r0_=make_iprintf(k$0,o,rest$3),
              _r1_=function(_sA_){return _r0_};
             return function(_sz_){return _r1_}}
          case 3:
           var _r2_=fmt$0[1];
           if(typeof _r2_ === "number")
            {var rest$4=fmt$0[2],_r3_=make_iprintf(k$0,o,rest$4);
             return function(_su_){return _r3_}}
           else
            {if(0 === _r2_[0])
              {var rest$5=fmt$0[2],_r4_=make_iprintf(k$0,o,rest$5);
               return function(_sx_){return _r4_}}
             var
              rest$6=fmt$0[2],
              _r5_=make_iprintf(k$0,o,rest$6),
              _r6_=function(_sw_){return _r5_};
             return function(_sv_){return _r6_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _r7_=fmt$0[1];
           if(typeof _r7_ === "number")
            {var rest$12=fmt$0[2],_r8_=make_iprintf(k$0,o,rest$12);
             return function(_sq_){return _r8_}}
           else
            {if(0 === _r7_[0])
              {var rest$13=fmt$0[2],_r9_=make_iprintf(k$0,o,rest$13);
               return function(_st_){return _r9_}}
             var
              rest$14=fmt$0[2],
              _r__=make_iprintf(k$0,o,rest$14),
              _r$_=function(_ss_){return _r__};
             return function(_sr_){return _r$_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_sa_=make_iprintf(k$0,o,rest$15);
           return function(_sp_){return _sa_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _sb_=make_iprintf(k$0,o,rest$17),
            _sc_=function(_so_){return _sb_};
           return function(_sn_){return _sc_};
          case 16:
           var rest$18=fmt$0[1],_sd_=make_iprintf(k$0,o,rest$18);
           return function(_sm_){return _sd_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _se_=fmt$0[1];
           if(0 === _se_[0])
            {var
              rest$19=fmt$0[2],
              match=_se_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_se_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_sf_=make_iprintf(k$0,o,rest$21);
           return function(_sl_){return _sf_};
          case 21:
           var rest$22=fmt$0[2],_sg_=make_iprintf(k$0,o,rest$22);
           return function(_sk_){return _sg_};
          case 22:
           var rest$23=fmt$0[1],_sh_=make_iprintf(k$0,o,rest$23);
           return function(_sj_){return _sh_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_si_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_si_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_rT_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_rU_){return _rT_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _rp_=make_iprintf(k,o,fmt),_rq_=function(_rH_){return _rp_};
            return function(_rG_){return _rq_}}
          var _rr_=make_iprintf(k,o,fmt);
          return function(_rF_){return _rr_}}
        var _rs_=make_iprintf(k,o,fmt);
        return function(_rE_){return _rs_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _rt_=make_iprintf(k,o,fmt),_ru_=function(_rS_){return _rt_};
              return function(_rR_){return _ru_}}
            var _rv_=make_iprintf(k,o,fmt);
            return function(_rQ_){return _rv_}}
          var _rw_=make_iprintf(k,o,fmt);
          return function(_rP_){return _rw_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _rx_=make_iprintf(k,o,fmt),
             _ry_=function(_rO_){return _rx_},
             _rz_=function(_rN_){return _ry_};
            return function(_rM_){return _rz_}}
          var _rA_=make_iprintf(k,o,fmt),_rB_=function(_rL_){return _rA_};
          return function(_rK_){return _rB_}}
        var _rC_=make_iprintf(k,o,fmt),_rD_=function(_rJ_){return _rC_};
        return function(_rI_){return _rD_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _rn_=acc$0[2],_ro_=acc$0[1];
           if(0 === _rn_[0])
            {var acc$1=_rn_[1];
             output_acc(o,_ro_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_rn_[1];
           output_acc(o,_ro_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _rl_=acc$0[2],_rm_=acc$0[1];
           if(0 === _rl_[0])
            {var acc$1=_rl_[1];
             bufput_acc(b,_rm_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_rl_[1];
           bufput_acc(b,_rm_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _rj_=acc$0[2],_rk_=acc$0[1];
           if(0 === _rj_[0])
            {var acc$1=_rj_[1];
             strput_acc(b,_rk_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_rj_[1];
           strput_acc(b,_rk_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _rh_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_rh_}
       catch(_ri_)
        {_ri_ = caml_wrap_exception(_ri_);
         if(_ri_[1] !== Failure)throw _ri_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aV_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _rf_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _rf_=0;
          var _re_=_rf_}
        catch(_rg_)
         {_rg_ = caml_wrap_exception(_rg_);
          if(_rg_ !== Not_found && _rg_[1] !== Failure)throw _rg_;
          var _re_=0}
        if(_re_)
         {var
           match=_re_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _q9_=str_ind === end_ind?1:0,
           _q__=_q9_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_q__)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _q$_=[0,s,width,0],
             _ra_=str_ind_3 + 1 | 0,
             formatting_lit$0=_q$_,
             next_ind=_ra_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _rb_=[0,s$0,width,offset],
               _rc_=str_ind_5 + 1 | 0,
               formatting_lit$0=_rb_,
               next_ind=_rc_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_rd_)
         {_rd_ = caml_wrap_exception(_rd_);
          if(_rd_ !== Not_found && _rd_[1] !== Failure)throw _rd_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _q7_=[0,[18,formatting$0,fmt_rest$0]];
            return _q7_}
          throw Not_found}
        catch(_q8_)
         {_q8_ = caml_wrap_exception(_q8_);
          if(_q8_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _q8_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _q4_=flag[1],_q5_=_q4_?1 - legacy_behavior$0:_q4_;
          if(_q5_)
           {var _q6_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_q6_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _qZ_=space[1],
           _q0_=hash[1],
           _q1_=plus[1],
           _q2_=minus[1],
           _q3_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _q3_
             ?_q2_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_q2_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _q2_,
                       _q1_,
                       _q0_,
                       _qZ_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _q2_,
                     _q1_,
                     _q0_,
                     _qZ_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,_aC_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _qY_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_qY_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,prec)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   prec,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof prec === "number" && ! prec)return parse_conv(0);
          if(minus)
           {if(typeof prec === "number")return parse_conv(_aE_);
            var n=prec[1];
            return parse_conv([0,0,n])}
          if(typeof prec === "number")return parse_conv(_aF_);
          var n$0=prec[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _qv_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _qv_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_qv_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _qx_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_qx_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_qD_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _qD_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_qD_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _qE_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _qE_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_qE_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _qX_=i + 1 | 0;
                    if(c !== i){var i=_qX_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _qW_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_qW_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_qW_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _qU_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_qU_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_qU_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _qV_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_qV_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_qV_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _qT_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_qT_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_qT_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _qJ_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _qJ_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_qJ_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _qK_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _qL_=_qK_;
              else
               var
                _qL_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _qM_=_qL_}
            else
             var _qM_=char_format(fmt_rest$21);
            var fmt_result=_qM_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _qN_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_qN_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _qO_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _qO_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_qO_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _qP_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _qP_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_qP_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _qw_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _qw_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_qw_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _qQ_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _qQ_ >>> 0))
               switch(_qQ_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _qC_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _qC_=0;
              if(_qC_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_qB_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _qB_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_qB_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aL_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _qF_=get_space(0),
             _qG_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_qG_,_qF_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _qH_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _qI_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_qI_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _qH_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_qH_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _qR_=1;break;
                  case 1:var _qR_=0;break;
                  case 2:var _qR_=3;break;
                  default:var _qR_=6}
                var kind=_qR_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _qS_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _qS_=4;break;
                 default:var _qS_=7}
               if(! switch$5)var kind=_qS_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aW_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _qy_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_qy_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_qy_],
               _qz_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _qA_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_qA_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _qz_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_qz_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _qf_=caml_string_get(str,str_ind),
                 _qg_=get_space(0),
                 _qh_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_qh_,_qg_,_qf_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _qi_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _qk_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_qk_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _qi_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _qj_=_qi_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _ql_=caml_string_get(str,str_ind),
                 _qm_=get_space(0),
                 _qn_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_qn_,_qm_,_ql_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _qo_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _qp_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_qp_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _qo_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _qj_=_qo_}
             if(! switch$8)var fmt_result=_qj_}
          else
           if(76 === symb)
            {var
              _qq_=caml_string_get(str,str_ind),
              _qr_=get_space(0),
              _qs_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_qs_,_qr_,_qq_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _qt_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _qu_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_qu_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _qt_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_qt_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _p8_=1 - plus_used[1],plus$0=_p8_?plus:_p8_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _p9_=1 - hash_used[1],hash$0=_p9_?hash:_p9_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _p__=1 - space_used[1],space$0=_p__?space:_p__;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _p$_=1 - pad_used[1],_qa_=_p$_?caml_notequal([0,pad],_aJ_):_p$_;
          if(_qa_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _qb_=1 - prec_used[1],
           _qc_=_qb_?caml_notequal([0,prec],_aK_):_qb_;
          if(_qc_)
           {var _qd_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_qd_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _qe_=1 - ign_used[1],ign$0=_qe_?ign:_qe_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _p7_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_p7_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aN_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aO_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _p5_=[0,type_format(fmt,fmtty),str];return _p5_}
      catch(_p6_)
       {_p6_ = caml_wrap_exception(_p6_);
        if(_p6_ === Type_mismatch)
         {var _p4_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_p4_)}
        throw _p6_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _p2_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _p2_}
      catch(_p3_)
       {_p3_ = caml_wrap_exception(_p3_);
        if(_p3_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _p3_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(791,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_p1_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _p1_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_p0_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _p0_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_pZ_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_pY_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_pX_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_pW_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_Printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(792,Stdlib_Printf,"Stdlib__Printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$1(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _pV_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_pV_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_pU_=cat(prefix,h);
        return cat
                (fold_left$0(function(x,y){return cat(x,cat(sep,y))},_pU_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _pR_=0,_pP_=_pR_}
      catch(_pT_)
       {_pT_ = caml_wrap_exception(_pT_);
        if(_pT_ !== Not_found)throw _pT_;
        var
         _pP_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _pQ_=0,add2=_pQ_}
      catch(_pS_)
       {_pS_ = caml_wrap_exception(_pS_);
        if(_pS_ !== Not_found)throw _pS_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_pP_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _pM_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _pN_=0 < caml_ml_string_length(doc)?1:0;
                 if(_pN_)
                  {if(11 === spec[0])
                    {var l=spec[1],_pO_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_pO_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _pN_},
               _pM_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _pL_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_pL_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _pJ_=[0,bool_of_string(x)];return _pJ_}
      catch(_pK_)
       {_pK_ = caml_wrap_exception(_pK_);
        if(_pK_[1] === Invalid_argument)return 0;
        throw _pK_}}
    function int_of_string_opt$0(x)
     {try
       {var _pH_=[0,caml_int_of_string(x)];return _pH_}
      catch(_pI_)
       {_pI_ = caml_wrap_exception(_pI_);
        if(_pI_[1] === Failure)return 0;
        throw _pI_}}
    function float_of_string_opt(x)
     {try
       {var _pF_=[0,caml_float_of_string(x)];return _pF_}
      catch(_pG_)
       {_pG_ = caml_wrap_exception(_pG_);
        if(_pG_[1] === Failure)return 0;
        throw _pG_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _pE_=error[1];
           if
            (caml_string_notequal(_pE_,cst_help$3)
             &&
             caml_string_notequal(_pE_,cst_help$4))
            caml_call2(bprintf(b,_a5_),progname,_pE_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_) && ! caml_equal(error,_a7_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _pt_=current[1],
             s=caml_check_bound(argv[1],_pt_)[1 + _pt_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _pv_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_pv_}
              catch(_pC_)
               {_pC_ = caml_wrap_exception(_pC_);
                if(_pC_ !== Not_found)throw _pC_;
                try
                 {var
                   match=split$1(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _pu_=assoc3(keyword,speclist[1])}
                catch(_pD_)
                 {_pD_ = caml_wrap_exception(_pD_);
                  if(_pD_ === Not_found)throw [0,Stop,[0,s]];
                  throw _pD_;
                  var _pw_=_pD_}
                var follow$0=follow,action=_pu_,_px_=_pC_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _pB_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_pB_)[1 + _pB_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               cat(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _py_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_py_)[1 + _py_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      case 13:
                       var f$6=param[1];
                       no_arg(0);
                       var acc=[0,0];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pA_=current[1] + 1 | 0,_pz_=acc[1];
                           acc[1] = [0,caml_check_bound(argv[1],_pA_)[1 + _pA_],_pz_];
                           consume_arg(0);
                           continue}
                         return caml_call1(f$6,rev(acc[1]))}
                      default:
                       var f$7=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$7,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _ps_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _ps_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _pr_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _pr_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _pq_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _pq_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_po_)
       {_po_ = caml_wrap_exception(_po_);
        if(_po_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_pp_)
           {_pp_ = caml_wrap_exception(_pp_);
            if(_pp_ === Not_found)return len;
            throw _pp_}
          return loop(n + 1 | 0)}
        throw _po_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max$1(cur,caml_ml_string_length(kwd))
              :max$1(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$5
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min$1(len,limit);
      return map$3
              (function(ksd)
                {var _pm_=ksd[1],_pn_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _pn_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$1(max$1(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _pm_,
                             _pn_,
                             cat(cst$59,cat(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_pm_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$1(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_pm_,spec,cat(prefix,cat(spaces,suffix))]}
                   return [0,_pm_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _pl_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _pl_=s;
          var word=_pl_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_pk_)
       {_pk_ = caml_wrap_exception(_pk_);
        if(_pk_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _pk_}}
    var _bf_=10,_bg_=1;
    function read_arg(_pj_){return read_aux(_bg_,_bf_,_pj_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_pi_){return read_aux(_bi_,_bh_,_pi_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_pg_,_ph_){return write_aux(_bk_,_pg_,_ph_)}
    var _bl_=0;
    function write_arg0(_pe_,_pf_){return write_aux(_bl_,_pe_,_pf_)}
    var
     Stdlib_Arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(793,Stdlib_Arg,"Stdlib__Arg");
    var
     Stdlib_Atomic=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(794,Stdlib_Atomic,"Stdlib__Atomic");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _pc_=other_fields(x,i + 1 | 0),_pd_=field(x,i);
      return caml_call2(sprintf(_bo_),_pd_,_pc_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_pb_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _o9_=other_fields(x,2),
          _o__=field(x,1),
          _pa_=caml_call2(sprintf(_bp_),_o__,_o9_);
        else
         switch(match)
          {case 0:var _pa_=cst$62;break;
           case 1:var _pa_=cst$63;break;
           default:var _o$_=field(x,1),_pa_=caml_call1(sprintf(_bq_),_o$_)}
        return cat(constructor,_pa_)}
      return x[1]}
    function to_string$6(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _o8_=caml_call1(fct,arg);return _o8_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _o7_=to_string$6(x);
        caml_call1(eprintf(_br_),_o7_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _o6_=caml_call1(fct,arg);return _o6_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _o5_=to_string$6(x);
        caml_call1(eprintf(_bs_),_o5_);
        return exit(2)}}
    function raw_backtrace_entries(bt){return bt}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _oX_=slot[5],
         _oY_=slot[4],
         _oZ_=slot[3],
         _o0_=slot[6]?cst_inlined:cst$64,
         _o1_=slot[2],
         _o2_=slot[7],
         _o3_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bt_),_o3_,_o2_,_o1_,_o0_,_oZ_,_oY_,_oX_)]}
      if(slot[1])return 0;
      var _o4_=info(0);
      return [0,caml_call1(sprintf(_bu_),_o4_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_oV_=a.length - 1 - 1 | 0,_oU_=0;
        if(! (_oV_ < 0))
         {var i=_oU_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _oW_=i + 1 | 0;
            if(_oV_ !== i){var i=_oW_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_oS_=a.length - 1 - 1 | 0,_oR_=0;
        if(! (_oS_ < 0))
         {var i=_oR_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _oT_=i + 1 | 0;
            if(_oS_ !== i){var i=_oT_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _oQ_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _oP_=0 === param[0]?1:0;
            if(! _oP_){var i$0=i - 1 | 0,i=i$0;continue}
            var _oQ_=_oP_}
          return _oQ_?[0,backtrace]:0}}
      return 0}
    function backtrace_slots_of_raw_entry(entry)
     {return backtrace_slots([0,entry])}
    function raw_backtrace_length(bt){return bt.length - 1}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=printers[1],
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _oO_=1 - success;
        if(_oO_)continue;
        return _oO_}}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var errors=_by_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _oM_=to_string$6(exn);
      caml_call1(eprintf(_bz_),_oM_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=runtime.caml_ml_debug_info_status(0);
      if(status < 0)
       {var _oN_=abs(status);
        prerr_endline(caml_check_bound(errors,_oN_)[1 + _oN_])}
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    var empty_backtrace=[0];
    function handle_uncaught_exception(exn,debugger_in_use)
     {try
       {try
         {var
           raw_backtrace=
            debugger_in_use?empty_backtrace:caml_get_exception_raw_backtra(0);
          try {do_at_exit(0)}catch(_oL_){}
          try
           {var
             _oH_=caml_call2(uncaught_exception_handler[1],exn,raw_backtrace),
             _oG_=_oH_}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            var
             raw_backtrace$0=caml_get_exception_raw_backtra(0),
             _oE_=to_string$6(exn);
            caml_call1(eprintf(_bA_),_oE_);
            print_raw_backtrace(stderr,raw_backtrace);
            var _oF_=to_string$6(exn$0);
            caml_call1(eprintf(_bB_),_oF_);
            print_raw_backtrace(stderr,raw_backtrace$0);
            var _oG_=caml_ml_flush(stderr)}
          var _oI_=_oG_}
        catch(_oK_)
         {_oK_ = caml_wrap_exception(_oK_);
          if(_oK_ !== Out_of_memory)throw _oK_;
          var _oI_=prerr_endline(cst_Fatal_error_out_of_memory_)}
        return _oI_}
      catch(_oJ_){return 0}}
    caml_register_named_value
     (caml_string_of_jsbytes("Printexc.handle_uncaught_exception"),
      handle_uncaught_exception);
    function _bC_(_oD_){return runtime.caml_raw_backtrace_next_slot(_oD_)}
    function _bD_(_oC_){return runtime.caml_convert_raw_backtrace_slot(_oC_)}
    function _bE_(_oB_,_oA_)
     {return runtime.caml_raw_backtrace_slot(_oB_,_oA_)}
    var
     _bF_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bG_(_oz_){return caml_get_exception_raw_backtra(_oz_)}
    function _bH_(_oy_){return runtime.caml_backtrace_status(_oy_)}
    var
     Stdlib_Printexc=
      [0,
       to_string$6,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_ox_){return runtime.caml_record_backtrace(_ox_)},
       _bH_,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       _bG_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _bF_,
       raw_backtrace_length,
       _bE_,
       _bD_,
       _bC_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(795,Stdlib_Printexc,"Stdlib__Printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,cat(cst_Fun_Finally_raised,to_string$6(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _ow_=caml_call1(finally$0,0);return _ow_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_Fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(796,Stdlib_Fun,"Stdlib__Fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_oe_=st[4];
      caml_call1(fprintf(c,_bI_),_oe_);
      var _of_=st[5];
      caml_call1(fprintf(c,_bJ_),_of_);
      var _og_=st[14];
      caml_call1(fprintf(c,_bK_),_og_);
      var _oh_=st[17];
      caml_call1(fprintf(c,_bL_),_oh_);
      fprintf(c,_bM_);
      var
       _oi_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bN_),_oi_)),
       _oj_=st[1];
      caml_call2(fprintf(c,_bO_),l1,_oj_);
      var _ok_=st[2];
      caml_call2(fprintf(c,_bP_),l1,_ok_);
      var _ol_=st[3];
      caml_call2(fprintf(c,_bQ_),l1,_ol_);
      fprintf(c,_bR_);
      var
       _om_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bS_),_om_)),
       _on_=st[15];
      caml_call2(fprintf(c,_bT_),l2,_on_);
      var _oo_=st[6];
      caml_call2(fprintf(c,_bU_),l2,_oo_);
      var _op_=st[8];
      caml_call2(fprintf(c,_bV_),l2,_op_);
      var _oq_=st[10];
      caml_call2(fprintf(c,_bW_),l2,_oq_);
      var _or_=st[12];
      caml_call2(fprintf(c,_bX_),l2,_or_);
      var _os_=st[13];
      caml_call2(fprintf(c,_bY_),l2,_os_);
      fprintf(c,_bZ_);
      var _ot_=st[9];
      caml_call1(fprintf(c,_b0_),_ot_);
      var _ou_=st[11];
      caml_call1(fprintf(c,_b1_),_ou_);
      var _ov_=st[7];
      return caml_call1(fprintf(c,_b2_),_ov_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b3_(param){return 0}
    function _b4_(param){return 0}
    function _b5_(param){return 0}
    function _b6_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b6_,_b5_,_b4_,_b3_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b7_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b8_(_od_){return runtime.caml_final_release(_od_)}
    function _b9_(_oc_,_ob_)
     {return runtime.caml_final_register_called_without_value(_oc_,_ob_)}
    var
     Stdlib_Gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_oa_,_n$_){return runtime.caml_final_register(_oa_,_n$_)},
       _b9_,
       _b8_,
       create_alarm,
       delete_alarm,
       _b7_];
    caml_register_global(797,Stdlib_Gc,"Stdlib__Gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _n__=10 <= n?87:48;return n + _n__ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _n9_=i + 1 | 0;
        if(15 !== i){var i=_n9_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_n7_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _n7_ | 0));
        var _n8_=i + 1 | 0;
        if(15 !== i){var i=_n8_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_Digest=
      [0,
       compare$8,
       equal$8,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(798,Stdlib_Digest,"Stdlib__Digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _n6_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_n6_;continue}
        var accu=[0,cst_x$1],_n2_=54 + max$1(55,l) | 0,_n1_=0;
        if(! (_n2_ < 0))
         {var i=_n1_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(cat(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _n3_=accu[1],
             _nX_=caml_string_get(_n3_,3) << 24,
             _nY_=caml_string_get(_n3_,2) << 16,
             _nZ_=caml_string_get(_n3_,1) << 8,
             _n0_=((caml_string_get(_n3_,0) + _nZ_ | 0) + _nY_ | 0) + _nX_ | 0,
             _n4_=(caml_check_bound(s[1],j)[1 + j] ^ _n0_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _n4_;
            var _n5_=i + 1 | 0;
            if(_n2_ !== i){var i=_n5_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$3(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$3(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _nU_=s[2],
       curval=caml_check_bound(s[1],_nU_)[1 + _nU_],
       _nV_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_nV_)[1 + _nV_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _nW_=s[2];
      caml_check_bound(s[1],_nW_)[1 + _nW_] = newval30;
      return newval30}
    function intaux(s,n)
     {for(;;)
       {var r=bits(s),v=caml_mod(r,n);
        if(((1073741823 - n | 0) + 1 | 0) < (r - v | 0))continue;
        return v}}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)return intaux(s,bound);
      return invalid_arg(cst_Random_int)}
    function full_int(s,bound)
     {if(0 < bound)
       {if(1073741823 < bound)
         for(;;)
          {var b1=bits(s),b2=bits(s);
           if(bound <= 2147483647)
            var bpos=(b2 & 1073725440) << 1 | b1 >>> 15 | 0,r=bpos;
           else
            var
             b3=bits(s),
             bpos$0=
              ((b3 & 1073741312) << 12 | b2 >>> 9 | 0)
              <<
              20
              |
              b1
              >>>
              10
              |
              0,
             r=bpos$0;
           var v=caml_mod(r,bound);
           if(((2147483647 - bound | 0) + 1 | 0) < (r - v | 0))continue;
           return v}
        return intaux(s,bound)}
      return invalid_arg(cst_Random_full_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b$_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b__)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_ca_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function full_int$0(bound){return full_int(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _cb_=
      [0,
       make$3,
       make_self_init,
       copy$5,
       bits,
       int$0,
       full_int,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_Random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _cb_,
       get_state,
       set_state];
    caml_register_global(799,Stdlib_Random,"Stdlib__Random");
    function ongoing_traversal(h)
     {var _nS_=h.length - 1 < 4?1:0,_nT_=_nS_ || (h[4] < 0?1:0);return _nT_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cY_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cY_}
    catch(_nQ_)
     {_nQ_ = caml_wrap_exception(_nQ_);
      if(_nQ_ !== Not_found)throw _nQ_;
      try
       {var _cX_=caml_sys_getenv(cst_CAMLRUNPARAM),_cc_=_cX_}
      catch(_nR_)
       {_nR_ = caml_wrap_exception(_nR_);
        if(_nR_ !== Not_found)throw _nR_;
        var _cc_=cst$66}
      var params=_cc_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_nP_){return caml_call1(_cb_[2],0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,initial_size);
      if(random)
       var
        _nN_=caml_obj_tag(prng),
        _nO_=250 === _nN_?prng[1]:246 === _nN_?force_lazy_block(prng):prng,
        seed=caml_call1(_cb_[4],_nO_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _nM_=0 < h[1]?1:0;
      return _nM_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_nM_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_cd_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _nJ_=init[4],_nK_=init[3],_nL_=map$6(copy_bucketlist,init[2]);
      return [0,init[1],_nL_,_nK_,_nJ_]}
    function length$4(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var
       nsize=ndata.length - 1,
       ndata_tail=caml_make_vect(nsize,0),
       _nD_=odata.length - 1 - 1 | 0,
       _nC_=0;
      if(! (_nD_ < 0))
       {var i$0=_nC_;
        a:
        for(;;)
         {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
          for(;;)
           {if(cell)
             {var
               key=cell[1],
               data=cell[2],
               next=cell[3],
               cell$0=inplace?cell:[0,key,data,0],
               nidx=caml_call1(indexfun,key),
               match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
              if(match)
               match[3] = cell$0;
              else
               caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
              caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
              var cell=next;
              continue}
            var _nI_=i$0 + 1 | 0;
            if(_nD_ !== i$0){var i$0=_nI_;continue a}
            break}
          break}}
      if(inplace)
       {var _nF_=nsize - 1 | 0,_nE_=0;
        if(! (_nF_ < 0))
         {var i=_nE_;
          for(;;)
           {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
            if(match$0)match$0[3] = 0;
            var _nH_=i + 1 | 0;
            if(_nF_ !== i){var i=_nH_;continue}
            break}}
        var _nG_=0}
      else
       var _nG_=inplace;
      return _nG_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _nB_=nsize < max_array_length?1:0;
      if(_nB_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _nB_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_nx_=d.length - 1 - 1 | 0,_nw_=0;
        if(! (_nx_ < 0))
         {var i=_nw_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _nA_=i + 1 | 0;
            if(_nx_ !== i){var i=_nA_;continue}
            break}}
        var _ny_=1 - old_trav,_nz_=_ny_?flip_ongoing_traversal(h):_ny_;
        return _nz_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _ns_=d.length - 1 - 1 | 0,_nr_=0;
        if(! (_ns_ < 0))
         {var i=_nr_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _nv_=i + 1 | 0;
            if(_ns_ !== i){var i=_nv_;continue}
            break}}
        var _nt_=1 - old_trav,_nu_=_nt_?flip_ongoing_traversal(h):_nt_;
        return _nu_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$4(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_nn_=d.length - 1 - 1 | 0,_nm_=0;
        if(! (_nn_ < 0))
         {var i=_nm_;
          for(;;)
           {var _np_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_np_);
            var _nq_=i + 1 | 0;
            if(_nn_ !== i){var i=_nq_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _no_=accu[1];
        return _no_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _ni_=h[2],
       _nj_=0,
       mbl=
        fold_left$3
         (function(m,b){return max$1(m,bucket_length(0,b))},_nj_,_ni_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _nk_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _nl_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _nl_;
          return 0},
        _nk_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_nh_){return aux(i$0,next,_nh_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _ne_=0,_nf_=0;
      return function(_ng_){return aux(_nf_,_ne_,_ng_)}}
    function to_seq_keys(m)
     {var _na_=to_seq$9(m);
      function _nb_(_nd_){return _nd_[1]}
      return function(_nc_){return map(_nb_,_na_,_nc_)}}
    function to_seq_values(m)
     {var _m8_=to_seq$9(m);
      function _m9_(_m$_){return _m$_[2]}
      return function(_m__){return map(_m9_,_m8_,_m__)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _m7_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _m7_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _m6_=h[2].length - 1 << 1 < h[1]?1:0;
        return _m6_?resize$0(key_index,h):_m6_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _m5_=key_index(h,key),match=caml_check_bound(h[2],_m5_)[1 + _m5_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _m4_=key_index(h,key),match=caml_check_bound(h[2],_m4_)[1 + _m4_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _m3_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_m3_)[1 + _m3_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _m0_=0}
          else
           var _m0_=1;
          if(_m0_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _m1_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_m1_)return resize$0(key_index,h);
            var _m2_=_m1_}
          else
           var _m2_=_m0_;
          return _m2_}}
      function mem(h,key)
       {var
         _mZ_=key_index(h,key),
         param$0=caml_check_bound(h[2],_mZ_)[1 + _mZ_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_mY_=caml_call2(H[1],k,key);
            if(_mY_)return _mY_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$4,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _mX_=include[1];
      function create(sz){return caml_call2(_mX_,_ce_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 4 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :invalid_arg(cst_Hashtbl_unsupported_hash_t)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mW_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mW_?resize$0(key_index,h):_mW_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mV_=key_index(h,key),match=caml_check_bound(h[2],_mV_)[1 + _mV_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$1(h,key)
     {var _mU_=key_index(h,key),match=caml_check_bound(h[2],_mU_)[1 + _mU_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _mT_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_mT_)[1 + _mT_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mQ_=0}
        else
         var _mQ_=1;
        if(_mQ_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mR_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mR_)return resize$0(key_index,h);
          var _mS_=_mR_}
        else
         var _mS_=_mQ_;
        return _mS_}}
    function mem$2(h,key)
     {var
       _mP_=key_index(h,key),
       param$0=caml_check_bound(h[2],_mP_)[1 + _mP_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_mO_=0 === caml_compare(k,key)?1:0;
          if(_mO_)return _mO_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function rebuild(opt,h)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,h[2].length - 1);
      if(random)
       var
        _mH_=caml_obj_tag(prng),
        _mI_=250 === _mH_?prng[1]:246 === _mH_?force_lazy_block(prng):prng,
        seed=caml_call1(_cb_[4],_mI_);
      else
       var seed=4 <= h.length - 1?h[3]:0;
      var
       _mJ_=4 <= h.length - 1?h[4]:s,
       h$0=[0,h[1],caml_make_vect(s,0),seed,_mJ_],
       _mK_=h$0[2],
       _mL_=h[2],
       _mM_=0;
      insert_all_buckets
       (function(_mN_){return key_index(h$0,_mN_)},_mM_,_mL_,_mK_);
      return h$0}
    var
     Stdlib_Hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$1,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$4,
       length$4,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(800,Stdlib_Hashtbl,"Stdlib__Hashtbl");
    function weak_create(l)
     {var _mF_=0 <= l?1:0,_mG_=_mF_?l <= _t_[15]?1:0:_mF_;
      if(1 - _mG_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _mC_=0 <= o?1:0,_mD_=_mC_?o < length$5(e)?1:0:_mC_,_mE_=1 - _mD_;
      return _mE_?invalid_arg(msg):_mE_}
    function set$0(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$1(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _mA_=0 !== l?1:0,
         _mB_=_mA_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_mA_;
        return _mB_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _my_=(ofs + len | 0) - 1 | 0;
        if(! (_my_ < ofs))
         {var i=ofs;
          for(;;)
           {set$0(ar,i,x);
            var _mz_=i + 1 | 0;
            if(_my_ !== i){var i=_mz_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _mw_=t[1].length - 1 - 1 | 0,_mv_=0;
        if(! (_mw_ < 0))
         {var i=_mv_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _mx_=i + 1 | 0;
            if(_mw_ !== i){var i=_mx_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _mu_=t[1],i=0;
        return fold_right$2
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$1(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mu_,
                 init)}
      function iter(f,t)
       {var _mt_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$1(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mt_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _ms_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _ms_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _mn_=0,_mo_=t[1],_mp_=0;
        return fold_right$2
                (function(_mq_,_mr_){return count_bucket(_mp_,_mq_,_mr_)},
                 _mo_,
                 _mn_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min$1(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _mj_=sz <= t[3]?1:0,_mk_=_mj_?t[3] < newsz?1:0:_mj_;
            if(_mk_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _l$_=t[5],
                 bucket=caml_check_bound(t[1],_l$_)[1 + _l$_],
                 _ma_=t[5],
                 hbucket=caml_check_bound(t[2],_ma_)[1 + _ma_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _mb_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _mb_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _mc_=t[5];
                      caml_check_bound(t[1],_mc_)[1 + _mc_] = emptybucket;
                      var _md_=t[5];
                      caml_check_bound(t[2],_md_)[1 + _md_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _mg_=t[5];
                      caml_check_bound(t[1],_mg_)[1 + _mg_] = newbucket;
                      var _mh_=sub$1(hbucket,0,prev_len),_mi_=t[5];
                      caml_check_bound(t[2],_mi_)[1 + _mi_] = _mh_}
                    var _me_=t[3] < n?1:0,_mf_=_me_?prev_len <= t[3]?1:0:_me_;
                    if(_mf_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _mm_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_mm_;continue}
                break}}
            var _ml_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_ml_)
             {var
               n$0=t[1].length - 1,
               newlen=min$1(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_l__=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _l__);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _ml_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,set$0,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index){add_aux(t,set$0,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$1(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _l9_=0;
        return find_shadow(t,d,function(w,i){return set$0(w,i,0)},_l9_)}
      function mem(t,d)
       {var _l8_=0;return find_shadow(t,d,function(w,i){return 1},_l8_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$6(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _l0_=0,
         totlen=
          fold_left$3(function(_l7_,_l6_){return _l7_ + _l6_ | 0},_l0_,lens),
         _l1_=len - 1 | 0,
         _l3_=len / 2 | 0,
         _l2_=caml_check_bound(lens,_l1_)[1 + _l1_],
         _l4_=caml_check_bound(lens,_l3_)[1 + _l3_],
         _l5_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_l5_,_l4_,_l2_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_Weak=
      [0,
       weak_create,
       length$5,
       set$0,
       get$1,
       get_copy,
       check$0,
       fill$2,
       blit$4,
       Make$1];
    caml_register_global(801,Stdlib_Weak,"Stdlib__Weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _lZ_=caml_string_notequal(s,cst$67);
      return _lZ_?format_pp_text(state,caml_ml_string_length(s),s):_lZ_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min$1(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_cf_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _lX_=0 <= size$0?1:0,
           _lY_=_lX_ || (state[9] <= pending_count?1:0);
          if(_lY_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_lV_=tabs$0[1];
                  if(_lV_)
                   {var first=_lV_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _lW_=head}
                      else
                       var _lW_=first;
                      var tab=_lW_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _lY_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_cg_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _lQ_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _lR_=queue_elem[2];
        if(typeof _lR_ !== "number")
         switch(_lR_[0])
          {case 3:
            var
             _lT_=1 - ty,
             _lU_=
              _lT_
               ?(queue_elem[1] = state[13] + _lQ_ | 0,pop_opt(state[1]),0)
               :_lT_;
            return _lU_;
           case 1:
           case 2:
            var
             _lS_=
              ty?(queue_elem[1] = state[13] + _lQ_ | 0,pop_opt(state[1]),0):ty;
            return _lS_
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _lO_=state[14] === state[15]?1:0;
      if(_lO_)
       {var _lP_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_lP_),_lP_)}
      return _lO_}
    function pp_close_box(state,param)
     {var _lM_=1 < state[14]?1:0;
      if(_lM_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _lN_=0}
      else
       var _lN_=_lM_;
      return _lN_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _lL_=state[23];
      if(_lL_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _lL_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _lJ_=state[22];
      if(_lJ_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _lK_=0}
      else
       var _lK_=_lJ_;
      return _lK_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _lI_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_lI_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _lH_=state[14] < state[15]?1:0;
      return _lH_?enqueue_string_as(state,size,s):_lH_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_bytes(state,s)
     {return pp_print_as(state,caml_ml_bytes_length(s),of_bytes(s))}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$1(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _lG_=state[14] < state[15]?1:0;
      return _lG_?enqueue_advance(state,[0,size,3,0]):_lG_}
    function pp_print_if_newline(state,param)
     {var _lF_=state[14] < state[15]?1:0;
      return _lF_?enqueue_advance(state,[0,size,4,0]):_lF_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _lE_=state[14] < state[15]?1:0;
      if(_lE_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _lE_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _lD_=state[14] < state[15]?1:0;
      if(_lD_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _lD_}
    function pp_close_tbox(state,param)
     {var _lA_=1 < state[14]?1:0;
      if(_lA_)
       {var _lB_=state[14] < state[15]?1:0;
        if(_lB_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _lC_=0}
        else
         var _lC_=_lB_}
      else
       var _lC_=_lA_;
      return _lC_}
    function pp_print_tbreak(state,width,offset)
     {var _lz_=state[14] < state[15]?1:0;
      if(_lz_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _lz_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _ly_=state[14] < state[15]?1:0;
      if(_ly_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _ly_}
    function pp_set_max_boxes(state,n)
     {var _lw_=1 < n?1:0,_lx_=_lw_?(state[15] = n,0):_lw_;return _lx_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _lv_=1 < n$0?1:0;
      if(_lv_)
       {var n$1=state[6] - n$0 | 0,_lu_=1 <= n$1?1:0;
        if(_lu_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _lu_}
      return _lv_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _lt_=1 <= n?1:0;
      if(_lt_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max$1(max$1(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _lt_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_ch_:_ci_:_cj_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,cat(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$1(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _ls_=0 < n$0?1:0;
        if(_ls_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _ls_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_lp_,_lq_,_lr_){return output_substring(oc,_lp_,_lq_,_lr_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_lo_){return display_newline(state,_lo_)};
      state[20] = function(_ln_){return display_indent(state,_ln_)};
      state[21] = function(_lm_){return display_indent(state,_lm_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return cat(cst$78,cat(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return cat(cst$81,cat(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_ll_){return 0}
    function default_pp_print_close_tag(_lk_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_ck_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _lh_=create$0(0),_li_=create$0(0),_lj_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _lj_,
              _li_,
              _lh_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _k$_(_lg_){return 0}
      function _la_(_lf_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_le_){return 0},_la_,_k$_);
      ppf[19] = function(_ld_){return display_newline(ppf,_ld_)};
      ppf[20] = function(_lc_){return display_indent(ppf,_lc_)};
      ppf[21] = function(_lb_){return display_indent(ppf,_lb_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _k7_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_k8_,_k9_,_k__)
                {return output_substring(oc,_k8_,_k9_,_k__)},
               _k7_)}
    function formatter_of_buffer(b)
     {function _k2_(_k6_){return 0}
      return make_formatter
              (function(_k3_,_k4_,_k5_)
                {return add_substring(b,_k3_,_k4_,_k5_)},
               _k2_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_k1_){return add_symbolic_output_item(sob,0)}
      function h(_k0_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kZ_){return pp_open_hbox(std_formatter,_kZ_)}
    function open_vbox(_kY_){return pp_open_vbox(std_formatter,_kY_)}
    function open_hvbox(_kX_){return pp_open_hvbox(std_formatter,_kX_)}
    function open_hovbox(_kW_){return pp_open_hovbox(std_formatter,_kW_)}
    function open_box(_kV_){return pp_open_box(std_formatter,_kV_)}
    function close_box(_kU_){return pp_close_box(std_formatter,_kU_)}
    function open_tag(_kT_){return pp_open_tag(std_formatter,_kT_)}
    function close_tag(_kS_){return pp_close_tag(std_formatter,_kS_)}
    function open_stag(_kR_){return pp_open_stag(std_formatter,_kR_)}
    function close_stag(_kQ_){return pp_close_stag(std_formatter,_kQ_)}
    function print_as(_kO_,_kP_){return pp_print_as(std_formatter,_kO_,_kP_)}
    function print_string$0(_kN_){return pp_print_string(std_formatter,_kN_)}
    function print_bytes$0(_kM_){return pp_print_bytes(std_formatter,_kM_)}
    function print_int$0(_kL_){return pp_print_int(std_formatter,_kL_)}
    function print_float$0(_kK_){return pp_print_float(std_formatter,_kK_)}
    function print_char$0(_kJ_){return pp_print_char(std_formatter,_kJ_)}
    function print_bool(_kI_){return pp_print_bool(std_formatter,_kI_)}
    function print_break(_kG_,_kH_)
     {return pp_print_break(std_formatter,_kG_,_kH_)}
    function print_cut(_kF_){return pp_print_cut(std_formatter,_kF_)}
    function print_space(_kE_){return pp_print_space(std_formatter,_kE_)}
    function force_newline(_kD_){return pp_force_newline(std_formatter,_kD_)}
    function print_flush(_kC_){return pp_print_flush(std_formatter,_kC_)}
    function print_newline$0(_kB_)
     {return pp_print_newline(std_formatter,_kB_)}
    function print_if_newline(_kA_)
     {return pp_print_if_newline(std_formatter,_kA_)}
    function open_tbox(_kz_){return pp_open_tbox(std_formatter,_kz_)}
    function close_tbox(_ky_){return pp_close_tbox(std_formatter,_ky_)}
    function print_tbreak(_kw_,_kx_)
     {return pp_print_tbreak(std_formatter,_kw_,_kx_)}
    function set_tab(_kv_){return pp_set_tab(std_formatter,_kv_)}
    function print_tab(_ku_){return pp_print_tab(std_formatter,_ku_)}
    function set_margin(_kt_){return pp_set_margin(std_formatter,_kt_)}
    function get_margin(_ks_){return std_formatter[6]}
    function set_max_indent(_kr_)
     {return pp_set_max_indent(std_formatter,_kr_)}
    function get_max_indent(_kq_){return std_formatter[8]}
    function set_geometry(_ko_,_kp_)
     {return pp_set_geometry(std_formatter,_ko_,_kp_)}
    function safe_set_geometry(_km_,_kn_)
     {return pp_safe_set_geometry(std_formatter,_km_,_kn_)}
    function get_geometry(_kl_){return pp_get_geometry(std_formatter,_kl_)}
    function update_geometry(_kk_)
     {return pp_update_geometry(std_formatter,_kk_)}
    function set_max_boxes(_kj_){return pp_set_max_boxes(std_formatter,_kj_)}
    function get_max_boxes(_ki_){return std_formatter[15]}
    function over_max_boxes(_kh_)
     {return pp_over_max_boxes(std_formatter,_kh_)}
    function set_ellipsis_text(_kg_)
     {return pp_set_ellipsis_text(std_formatter,_kg_)}
    function get_ellipsis_text(_kf_){return std_formatter[16]}
    function set_formatter_out_channel(_ke_)
     {return pp_set_formatter_out_channel(std_formatter,_ke_)}
    function set_formatter_out_functions(_kd_)
     {return pp_set_formatter_out_functions(std_formatter,_kd_)}
    function get_formatter_out_functions(_kc_)
     {return pp_get_formatter_out_functions(std_formatter,_kc_)}
    function set_formatter_output_functions(_ka_,_kb_)
     {return pp_set_formatter_output_functi(std_formatter,_ka_,_kb_)}
    function get_formatter_output_functions(_j$_)
     {return pp_get_formatter_output_functi(std_formatter,_j$_)}
    function set_formatter_stag_functions(_j__)
     {return pp_set_formatter_stag_function(std_formatter,_j__)}
    function get_formatter_stag_functions(_j9_)
     {return pp_get_formatter_stag_function(std_formatter,_j9_)}
    function set_print_tags(_j8_)
     {return pp_set_print_tags(std_formatter,_j8_)}
    function get_print_tags(_j7_){return std_formatter[22]}
    function set_mark_tags(_j6_){return pp_set_mark_tags(std_formatter,_j6_)}
    function get_mark_tags(_j5_){return std_formatter[23]}
    function set_tags(_j4_){return pp_set_tags(std_formatter,_j4_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _j3_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_j3_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_j3_)}
        return 0}}
    function pp_print_seq(opt,pp_v,ppf,seq$1)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=pp_print_cut;
      var match$0=caml_call1(seq$1,0);
      if(match$0)
       {var seq$2=match$0[2],v$0=match$0[1];
        caml_call2(pp_v,ppf,v$0);
        var seq=seq$2;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var seq$0=match[2],v=match[1];
            caml_call2(pp_sep,ppf,0);
            caml_call2(pp_v,ppf,v);
            var seq=seq$0;
            continue}
          return 0}}
      return 0}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _j2_=left[1] !== len?1:0;
        return _j2_?flush(0):_j2_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_j1_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function pp_print_either(left,right,ppf,param)
     {if(0 === param[0]){var l=param[1];return caml_call2(left,ppf,l)}
      var r=param[1];
      return caml_call2(right,ppf,r)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jR_=acc[2],_jS_=acc[1];
          if(0 === _jR_[0])
           {var acc$0=_jR_[1];
            output_acc$0(ppf,_jS_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_jR_[1];
          output_acc$0(ppf,_jS_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jT_=acc[1],switch$1=0;
          if(typeof _jT_ !== "number" && 0 === _jT_[0])
           {var _jU_=_jT_[2],switch$2=0;
            if(typeof _jU_ !== "number" && 1 === _jU_[0])
             {var s$0=acc[2],size=_jU_[2],p$1=_jT_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jT_;switch$0 = 2}
          break;
         case 3:
          var _jV_=acc[1],switch$3=0;
          if(typeof _jV_ !== "number" && 0 === _jV_[0])
           {var _jW_=_jV_[2],switch$4=0;
            if(typeof _jW_ !== "number" && 1 === _jW_[0])
             {var c$0=acc[2],size$0=_jW_[2],p$3=_jV_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jV_;switch$0 = 3}
          break;
         case 4:
          var _jX_=acc[1],switch$5=0;
          if(typeof _jX_ !== "number" && 0 === _jX_[0])
           {var _jY_=_jX_[2],switch$6=0;
            if(typeof _jY_ !== "number" && 1 === _jY_[0])
             {var s$0=acc[2],size=_jY_[2],p$1=_jX_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jX_;switch$0 = 2}
          break;
         case 5:
          var _jZ_=acc[1],switch$7=0;
          if(typeof _jZ_ === "number" || ! (0 === _jZ_[0]))
           switch$7 = 1;
          else
           {var _j0_=_jZ_[2],switch$8=0;
            if(typeof _j0_ !== "number" && 1 === _j0_[0])
             {var c$0=acc[2],size$0=_j0_[2],p$3=_jZ_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jZ_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jF_=acc[2],_jG_=acc[1];
          if(0 === _jF_[0])
           {var acc$0=_jF_[1];
            strput_acc$0(ppf,_jG_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_jF_[1];
          strput_acc$0(ppf,_jG_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jH_=acc[1],switch$1=0;
          if(typeof _jH_ !== "number" && 0 === _jH_[0])
           {var _jI_=_jH_[2],switch$2=0;
            if(typeof _jI_ !== "number" && 1 === _jI_[0])
             {var s$0=acc[2],size=_jI_[2],p$1=_jH_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jH_;switch$0 = 2}
          break;
         case 3:
          var _jJ_=acc[1],switch$3=0;
          if(typeof _jJ_ !== "number" && 0 === _jJ_[0])
           {var _jK_=_jJ_[2],switch$4=0;
            if(typeof _jK_ !== "number" && 1 === _jK_[0])
             {var c$0=acc[2],size$0=_jK_[2],p$3=_jJ_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jJ_;switch$0 = 3}
          break;
         case 4:
          var _jL_=acc[1],switch$5=0;
          if(typeof _jL_ !== "number" && 0 === _jL_[0])
           {var _jM_=_jL_[2],switch$6=0;
            if(typeof _jM_ !== "number" && 1 === _jM_[0])
             {var s$0=acc[2],size=_jM_[2],p$1=_jL_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jL_;switch$0 = 2}
          break;
         case 5:
          var _jN_=acc[1],switch$7=0;
          if(typeof _jN_ === "number" || ! (0 === _jN_[0]))
           switch$7 = 1;
          else
           {var _jO_=_jN_[2],switch$8=0;
            if(typeof _jO_ !== "number" && 1 === _jO_[0])
             {var c$0=acc[2],size$0=_jO_[2],p$3=_jN_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jN_;switch$0 = 3}
          break;
         case 6:
          var _jP_=acc[1];
          if(typeof _jP_ !== "number" && 0 === _jP_[0])
           {var _jQ_=_jP_[2];
            if(typeof _jQ_ !== "number" && 1 === _jQ_[0])
             {var f$1=acc[2],size$1=_jQ_[2],p$4=_jP_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_jP_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_jE_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _jE_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_jC_=0;
      return make_iprintf(function(_jD_){return 0},_jC_,fmt)}
    function fprintf$0(ppf)
     {function _jz_(_jB_){return 0}
      return function(_jA_){return kfprintf$0(_jz_,ppf,_jA_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_jy_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _jy_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_ju_,_jv_,_jw_,_jx_)
     {return pp_set_all_formatter_output_fu(std_formatter,_ju_,_jv_,_jw_,_jx_)}
    function get_all_formatter_output_funct(_jt_)
     {return pp_get_all_formatter_output_fu(std_formatter,_jt_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_js_){return stringify(mot,cst$84,_js_)};
      state[25] = function(_jr_){return stringify(mct,cst$85,_jr_)};
      var _jn_=0;
      state[26] = function(_jq_){return stringify(pot,_jn_,_jq_)};
      var _jo_=0;
      state[27] = function(_jp_){return stringify(pct,_jo_,_jp_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_jm_)
     {return pp_set_formatter_tag_functions(std_formatter,_jm_)}
    function get_formatter_tag_functions(_jl_)
     {return pp_get_formatter_tag_functions(std_formatter,_jl_)}
    var
     Stdlib_Format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_bytes,
       print_bytes$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(802,Stdlib_Format,"Stdlib__Format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_jk_)
       {_jk_ = caml_wrap_exception(_jk_);
        if(_jk_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _jk_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _jj_=ib[9];
      if(typeof _jj_ === "number")
       return 0 === _jj_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _jj_[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_jj_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _cl_=0;
    function from_function$0(_ji_){return create$4(_cl_,_ji_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_jh_){return open_in_file(open_in,_jh_)}
    function from_file_bin(_jg_){return open_in_file(open_in_bin,_jg_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _jf_=ib[9];
      if(typeof _jf_ === "number")
       return 0;
      else
       {if(0 === _jf_[0]){var ic=_jf_[1];return caml_ml_close_channel(ic)}
        var ic$0=_jf_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _jd_=assq(ic,memo[1]);return _jd_}
      catch(_je_)
       {_je_ = caml_wrap_exception(_je_);
        if(_je_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _je_}}
    function memo_from_channel(_jc_)
     {return memo_from_ic(scan_raise_at_end,_jc_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_cm_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cn_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cp_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_ja_=1 - ib[1];
         if(_ja_)
          {var _jb_=c - 9 | 0,switch$0=0;
           if(4 < _jb_ >>> 0)
            {if(23 === _jb_)switch$0 = 1}
           else
            if(1 < (_jb_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _ja_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_cq_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cr_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=cat(cst_0b,token_string(ib));break;
        case 3:var tok=cat(cst_0o,token_string(ib));break;
        case 4:var tok=cat(cst_0u,token_string(ib));break;
        case 5:var tok=cat(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cs_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ct_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_i__,_i$_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_i__,_i$_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_i8_,_i9_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_i8_,_i9_)}
    function is_hexa_digit(param)
     {var _i7_=param - 48 | 0,switch$0=0;
      if(22 < _i7_ >>> 0)
       {if(! (5 < (_i7_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_i7_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_i5_,_i6_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_i5_,_i6_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min$1(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _i2_=len - 1 | 0,
       _i1_=0;
      if(! (_i2_ < 0))
       {var i=_i1_;
        for(;;)
         {var c=peek_char(ib),_i3_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _i3_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _i4_=i + 1 | 0;
          if(_i2_ !== i){var i=_i4_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _iO_=0 === width?1:0,_iP_=_iO_ || end_of_input(ib);
      if(_iP_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _iQ_=0 === width$0?1:0,
       _iR_=_iQ_ || end_of_input(ib);
      if(_iR_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _iS_=0 === width$1?1:0,
             _iT_=_iS_ || end_of_input(ib);
            if(_iT_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _iW_=0 === width$3?1:0,
           _iX_=_iW_ || end_of_input(ib);
          if(_iX_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_iY_=match - 46 | 0,switch$1=0;
            if(34 < _iY_ >>> 0)
             {if(66 === _iY_)switch$1 = 1}
            else
             if(32 < (_iY_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min$1(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _iZ_=0 === width$9?1:0,
                 _i0_=_iZ_ || end_of_input(ib);
                if(_i0_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _iU_=0 === width$2?1:0,
         _iV_=_iU_ || end_of_input(ib);
        if(_iV_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _iK_=0 === width?1:0,_iL_=_iK_ || end_of_input(ib);
      if(_iL_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _iM_=0 === width$0?1:0,
       _iN_=_iM_ || end_of_input(ib);
      if(_iN_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min$1(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _iw_=0 === width?1:0,_ix_=_iw_ || end_of_input(ib);
      if(_ix_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _iy_=0 === width$0?1:0,
       _iz_=_iy_ || end_of_input(ib);
      if(_iz_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _iA_=0 === width$1?1:0,
           _iB_=_iA_ || end_of_input(ib);
          if(_iB_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _iC_=0 === width$2?1:0,
          _iD_=_iC_ || end_of_input(ib);
         if(_iD_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _iE_=0 === width$3?1:0,
          _iF_=_iE_ || end_of_input(ib);
         if(_iF_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _iG_=0 === width$4?1:0,
          _iH_=_iG_ || end_of_input(ib);
         if(_iH_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min$1(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _iI_=0 === width$9?1:0,
            _iJ_=_iI_ || end_of_input(ib);
           if(_iJ_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _iv_=c - 9 | 0,switch$0=0;
        if(4 < _iv_ >>> 0)
         {if(23 === _iv_)switch$0 = 1}
        else
         if(1 < (_iv_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_co_),message)):c}
    function check_next_char_for_char(_it_,_iu_)
     {return check_next_char(cst_a_Char,_it_,_iu_)}
    function check_next_char_for_string(_ir_,_is_)
     {return check_next_char(cst_a_String,_ir_,_is_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_iq_=c - 48 | 0,switch$0=0;
                  if(22 < _iq_ >>> 0)
                   {if(! (5 < (_iq_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_iq_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _im_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _im_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _io_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _io_=bad_input(caml_call2(sprintf(_cv_),c1,c2));
              return store_char(width - 2 | 0,ib,_io_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _ip_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _ip_=bad_input(caml_call3(sprintf(_cu_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ip_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _in_=10;break;
             case 4:var _in_=13;break;
             case 6:var _in_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _in_=8;else switch$3 = 1;
        if(switch$3)var _in_=c0;
        return store_char(width,ib,_in_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _ik_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_ik_)}
              return caml_trampoline_return(skip_spaces,[0,_ik_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _il_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_il_)}
                return caml_trampoline_return(skip_spaces,[0,_il_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_ig_=0 < i$0?1:0;
          if(_ig_)
           {var _ih_=1 - ib[1];
            if(_ih_)
             var _ii_=is_in_char_set(char_set,c),_ij_=_ii_?c !== stp?1:0:_ii_;
            else
             var _ij_=_ih_}
          else
           var _ij_=_ig_;
          if(_ij_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _ij_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _if_=1 - ib[1];
        if(_if_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _if_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cx_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cy_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_id_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_id_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_id_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _ie_=fmt$0[1];
           if(0 === _ie_[0])
            {var
              rest$0=fmt$0[2],
              match=_ie_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_ie_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _h2_=fmt$0[1],_h3_=fmt$0[2];
           if(typeof _h3_ !== "number")
            switch(_h3_[0])
             {case 17:
               var
                rest$2=_h3_[2],
                fmting_lit=_h3_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_h2_,0,scan$0,token_string);
              case 18:
               var _h4_=_h3_[1];
               if(0 === _h4_[0])
                {var
                  rest$3=_h3_[2],
                  match$0=_h4_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cz_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _h2_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_h3_[2],
                match$1=_h4_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cA_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _h2_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_h2_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_ic_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cw_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_ib_){return check_char(ib,_ib_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _h5_=format_of_string_fmtty(s,fmtty),fmt$3=_h5_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _h7_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_h7_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _h6_=bad_input(msg$0),
              fmt$5=_h6_[2],
              fmt$4=_h6_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _h8_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_ia_){return check_char(ib,_ia_)},_h8_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _h9_=fmt$0[1];
           if(0 === _h9_[0])
            {var rest$20=fmt$0[2],match$4=_h9_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_h9_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _h__=fmt$0[1],_h$_=fmt$0[3];
           if(typeof _h$_ !== "number" && 17 === _h$_[0])
            {var
              rest$23=_h$_[2],
              fmting_lit$0=_h$_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_h__);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_h__);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cB_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _h1_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_h1_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_h1_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _h0_=[0,make_scanf(ib,fmt,readers)],_hZ_=_h0_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hY_=
              invalid_arg
               (cat(msg,cat(cst_in_format,cat(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hY_=[1,exc];
          var _hZ_=_hY_}
        if(0 === _hZ_[0]){var args=_hZ_[1];return apply(f,args)}
        var exc=_hZ_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _hX_=format_of_string_format(str,format),fmt=_hX_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _hW_(x){return x}
      return sscanf_format(cat(cst$90,cat(escaped$1(s),cst$89)),fmt,_hW_)}
    function unescaped(s)
     {function _hV_(x){return x}
      return caml_call1(sscanf(cat(cst$92,cat(s,cst$91)),_cC_),_hV_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_Scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(803,Stdlib_Scanf,"Stdlib__Scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_Callback=[0,register,register_exception];
    caml_register_global(804,Stdlib_Callback,"Stdlib__Callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_hS_=caml_ml_string_length(s) - 1 | 0,_hR_=0;
      if(! (_hS_ < 0))
       {var i=_hR_;
        for(;;)
         {var _hT_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _hT_ | 0;
          var _hU_=i + 1 | 0;
          if(_hS_ !== i){var i=_hU_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$13(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_Map[1],[0,compare$13]);
    function compare$14(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_Map[1],[0,compare$14]),
     compare$15=caml_int_compare,
     Labs=caml_call1(Stdlib_Map[1],[0,compare$15]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _hL_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _hL_;
      var _hN_=len - 1 | 0,_hM_=0;
      if(! (_hN_ < 0))
       {var i=_hM_;
        for(;;)
         {var
           _hP_=(i * 2 | 0) + 3 | 0,
           _hO_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_hP_)[1 + _hP_] = _hO_;
          var _hQ_=i + 1 | 0;
          if(_hN_ !== i){var i=_hQ_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_hJ_=old_size < new_size?1:0;
      if(_hJ_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _hK_=0}
      else
       var _hK_=_hJ_;
      return _hK_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _hH_=caml_call2(Meths[28],name,table[3]);return _hH_}
      catch(_hI_)
       {_hI_ = caml_wrap_exception(_hI_);
        if(_hI_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _hI_}}
    function get_method_labels(table,names)
     {return map$6(function(_hG_){return get_method_label(table,_hG_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _hE_=assoc(label,table[6]);return _hE_}
      catch(_hF_)
       {_hF_ = caml_wrap_exception(_hF_);
        if(_hF_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _hF_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$3
         (function(_hD_){return get_method_label(table,_hD_)},virt_meths$0),
       concr_meth_labs=
        map$3
         (function(_hC_){return get_method_label(table,_hC_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _ht_=Vars[1],_hu_=table[7];
      function _hv_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_hv_,_hu_,_ht_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _hy_=by_label[1];
          try
           {var _hA_=caml_call2(Labs[28],label,table[4]),_hz_=_hA_}
          catch(_hB_)
           {_hB_ = caml_wrap_exception(_hB_);
            if(_hB_ !== Not_found)throw _hB_;
            var _hz_=1}
          by_label[1] = caml_call3(Labs[4],label,_hz_,_hy_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _hw_=0,_hx_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _hx_,
        _hw_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _hs_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_hs_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _hr_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _hr_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _hp_=caml_call2(Vars[28],name,table[7]);return _hp_}
      catch(_hq_)
       {_hq_ = caml_wrap_exception(_hq_);
        if(_hq_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _hq_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _hh_=nmeths - 1 | 0,
       _hg_=0;
      if(! (_hh_ < 0))
       {var i$0=_hg_;
        for(;;)
         {var
           _hn_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _hn_;
          var _ho_=i$0 + 1 | 0;
          if(_hh_ !== i$0){var i$0=_ho_;continue}
          break}}
      var _hj_=nvals - 1 | 0,_hi_=0;
      if(! (_hj_ < 0))
       {var i=_hi_;
        for(;;)
         {var
           _hl_=i + nmeths | 0,
           _hk_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_hl_)[1 + _hl_] = _hk_;
          var _hm_=i + 1 | 0;
          if(_hj_ !== i){var i=_hm_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _he_=caml_call2(Vars[28],name,table[7]);return _he_}
      catch(_hf_)
       {_hf_ = caml_wrap_exception(_hf_);
        if(_hf_ === Not_found)throw [0,Assert_failure,_cD_];
        throw _hf_}}
    function get_variables(table,names)
     {return map$6(function(_hd_){return get_variable(table,_hd_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$6(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _g__=0,
       _g$_=to_array(concr_meths),
       _ha_=
        [0,
         map$6
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_g$_),
         _g__],
       _hb_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$6(function(_hc_){return get_variable(cla,_hc_)},_hb_),
                 _ha_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_g9_=0 !== inits?1:0;
      return _g9_?iter_f(obj,inits):_g9_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cH_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_g5_=0;
      if(! (n < 0))
       {var i=_g5_;
        for(;;)
         {var _g7_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_g7_,0];
          var _g8_=i + 1 | 0;
          if(n !== i){var i=_g8_;continue}
          break}}
      var _g6_=r[1];
      if(tables){tables[2] = _g6_;return res}
      throw [0,Assert_failure,_cE_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cJ_]}
                if(tables$0)
                 {var _g4_=tables$0[3];
                  if(_g4_){var tables$0=_g4_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cF_]}
                throw [0,Assert_failure,_cI_]}
              throw [0,Assert_failure,_cG_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gY_=i[1],
           label=caml_check_bound(methods,_gY_)[1 + _gY_],
           next=
            function(param)
             {i[1]++;
              var _g3_=i[1];
              return caml_check_bound(methods,_g3_)[1 + _g3_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _g1_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_g1_)}}
                 (n$15,m$1);
              break;
             case 20:
              var m$2=next(0),x$9=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,x)
                  {return function(obj)
                    {return caml_call1(caml_get_public_method(x,m,0),x)}}
                 (m$2,x$9);
              break;
             case 21:
              var m$3=next(0),n$16=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _g0_=obj[1 + n];
                     return caml_call1(caml_get_public_method(_g0_,m,0),_g0_)}}
                 (m$3,n$16);
              break;
             case 22:
              var m$4=next(0),e$4=next(0),n$17=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,e,n)
                  {return function(obj)
                    {var _gZ_=obj[1 + e][1 + n];
                     return caml_call1(caml_get_public_method(_gZ_,m,0),_gZ_)}}
                 (m$4,e$4,n$17);
              break;
             default:
              var m$5=next(0),n$18=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _g2_=caml_call1(obj[1][1 + n],obj);
                     return caml_call1(caml_get_public_method(_g2_,m,0),_g2_)}}
                 (m$5,n$18)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(805,CamlinternalOO,"CamlinternalOO");
    var Stdlib_Oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(806,Stdlib_Oo,"Stdlib__Oo");
    function init_mod_block(loc,comps$0)
     {var
       length=comps$0.length - 1,
       modu=caml_obj_block(0,length),
       _gU_=length - 1 | 0,
       _gT_=0;
      if(! (_gU_ < 0))
       {var i=_gT_;
        for(;;)
         {var shape=caml_check_bound(comps$0,i)[1 + i];
          if(typeof shape === "number")
           switch(shape)
            {case 0:
              var
               fn$0=
                function(i)
                 {function fn(x)
                   {var fn$0=modu[1 + i];
                    if(fn === fn$0)throw [0,Undefined_recursive_module,loc];
                    return caml_call1(fn$0,x)}
                  return fn},
               fn=fn$0(i),
               init=fn;
              break;
             case 1:
              var l=[];
              runtime.caml_update_dummy
               (l,
                [246,
                 function(l,i)
                   {return function(_gW_)
                     {var l$0=modu[1 + i];
                      if(l === l$0)throw [0,Undefined_recursive_module,loc];
                      var _gX_=caml_obj_tag(l$0);
                      return 250 === _gX_
                              ?l$0[1]
                              :246 === _gX_?force_lazy_block(l$0):l$0}}
                  (l,i)]);
              var init=l;
              break;
             default:var init=dummy_class(loc)}
          else
           if(0 === shape[0])
            var comps=shape[1],init=init_mod_block(loc,comps);
           else
            var v=shape[1],init=v;
          modu[1 + i] = init;
          var _gV_=i + 1 | 0;
          if(_gU_ !== i){var i=_gV_;continue}
          break}}
      return modu}
    function init_mod(loc,shape)
     {if(typeof shape !== "number" && 0 === shape[0])
       {var comps=shape[1];return init_mod_block(loc,comps)}
      return failwith(cst_CamlinternalMod_init_mod_n)}
    function update_mod_block(comps$0,o,n)
     {if(0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1)
       {var _gR_=comps$0.length - 1 - 1 | 0,_gQ_=0;
        if(! (_gR_ < 0))
         {var i=_gQ_;
          for(;;)
           {var n$0=n[1 + i],shape=caml_check_bound(comps$0,i)[1 + i];
            if(typeof shape === "number")
             if(2 === shape)
              {var switch$0=0;
               if(0 === caml_obj_tag(n$0) && 4 === n$0.length - 1)
                {var cl=o[1 + i],j=0;
                 for(;;)
                  {cl[1 + j] = n$0[1 + j];
                   var _gP_=j + 1 | 0;
                   if(3 !== j){var j=_gP_;continue}
                   break}}
               else
                switch$0 = 1;
               if(switch$0)throw [0,Assert_failure,_cK_]}
             else
              o[1 + i] = n$0;
            else
             if(0 === shape[0])
              {var comps=shape[1];update_mod_block(comps,o[1 + i],n$0)}
            var _gS_=i + 1 | 0;
            if(_gR_ !== i){var i=_gS_;continue}
            break}}
        return 0}
      throw [0,Assert_failure,_cL_]}
    function update_mod(shape,o,n)
     {if(typeof shape !== "number" && 0 === shape[0])
       {var comps=shape[1];return update_mod_block(comps,o,n)}
      return failwith(cst_CamlinternalMod_update_mod)}
    var CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(807,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_Hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_Hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _gN_=caml_call2(Stdlib_Hashtbl[6],kwd_table,id);return _gN_}
        catch(_gO_)
         {_gO_ = caml_wrap_exception(_gO_);
          if(_gO_ === Not_found)return [1,id];
          throw _gO_}}
      function keyword_or_error(c)
       {var s=make$1(1,c);
        try
         {var _gL_=caml_call2(Stdlib_Hashtbl[6],kwd_table,s);return _gL_}
        catch(_gM_)
         {_gM_ = caml_wrap_exception(_gM_);
          if(_gM_ === Not_found)throw [0,Error,cat(cst_Illegal_character,s)];
          throw _gM_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _gK_=match$1[1];
                    if(41 === _gK_){junk(strm);return 0}
                    if(42 === _gK_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gH_=match[1];
          if(58 <= _gH_)
           {var switcher=_gH_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _gH_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _gI_=match$0[1],switcher$0=_gI_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _gJ_=match$1[1],switcher$1=_gJ_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_gH_ - 48 | 0) * 100 | 0)
                               +
                               ((_gI_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_gJ_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _gH_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gG_=match[1],switcher=_gG_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_gG_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gF_=match[1],switch$0=0;
          if(43 !== _gF_ && 45 !== _gF_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_gF_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _gC_=match[1];
            if(58 <= _gC_)
             {var switch$0=0;
              if(69 === _gC_ || 101 === _gC_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _gC_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _gD_=match$0[1],_gE_=_gD_ - 69 | 0;
                    if(32 < _gE_ >>> 0)
                     {var switcher=_gE_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_gD_);continue}}
                    else
                     {var switcher$0=_gE_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _gC_){junk(s);store(_gC_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gA_=match[1],switch$0=0;
            if(94 <= _gA_)
             {var _gB_=_gA_ - 95 | 0;
              if(30 < _gB_ >>> 0)
               {if(! (32 <= _gB_))switch$0 = 1}
              else
               if(29 === _gB_)switch$0 = 1}
            else
             if(65 <= _gA_)
              {if(92 === _gA_)switch$0 = 1}
             else
              if(33 <= _gA_)
               switch(_gA_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_gA_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _gz_=match[1],switcher=_gz_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_gz_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gx_=match[1],switch$0=0;
            if(91 <= _gx_)
             {var _gy_=_gx_ - 95 | 0;
              if(27 < _gy_ >>> 0)
               {if(97 <= _gy_)switch$0 = 1}
              else
               if(1 !== _gy_)switch$0 = 1}
            else
             if(48 <= _gx_)
              {if(6 < (_gx_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _gx_)switch$0 = 1;
            if(switch$0){junk(strm);store(_gx_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gn_=match[1],switch$0=0;
            if(124 <= _gn_)
             {if(127 <= _gn_)
               {if(192 <= _gn_)switch$0 = 1}
              else
               if(125 !== _gn_)switch$0 = 2}
            else
             {var _go_=_gn_ - 65 | 0;
              if(57 < _go_ >>> 0)
               {if(! (58 <= _go_))
                 {var switcher=_go_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _gq_=match$1[1];
                         if(34 === _gq_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _gq_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_gw_)
                            {_gw_ = caml_wrap_exception(_gw_);
                             if(_gw_ === Failure$0)throw [0,Error,cst$96];
                             throw _gw_;
                             var _gt_=_gw_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_gq_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _gr_=match$2[1];
                       if(92 === _gr_)
                        {junk(strm);
                         try
                          {var _gs_=escape(strm)}
                         catch(_gv_)
                          {_gv_ = caml_wrap_exception(_gv_);
                           if(_gv_ === Failure$0)throw [0,Error,cst$97];
                           throw _gv_}
                         var c=_gs_}
                       else
                        {junk(strm);var c=_gr_}}
                     catch(_gu_)
                      {_gu_ = caml_wrap_exception(_gu_);
                       if(_gu_ === Failure$0)throw [0,Error,cst$94];
                       throw _gu_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$95];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_gn_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _gp_=_go_ - 26 | 0;
                if(5 < _gp_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_gp_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_gn_)];
              case 1:
               junk(strm);reset_buffer(0);store(_gn_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_gn_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_Genlex=[0,make_lexer];
    caml_register_global(808,Stdlib_Genlex,"Stdlib__Genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_gm_){return caml_call1(_cb_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_Hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _gk_=caml_obj_tag(prng),
            _gl_=250 === _gk_?prng[1]:246 === _gk_?force_lazy_block(prng):prng,
            seed=caml_call1(_cb_[4],_gl_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_gi_=len - 1 | 0,_gh_=0;
        if(! (_gi_ < 0))
         {var i=_gh_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _gj_=i + 1 | 0;
            if(_gi_ !== i){var i=_gj_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _ge_=init[4],_gf_=init[3],_gg_=copy$1(init[2]);
        return [0,init[1],_gg_,_gf_,_ge_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_gb_=d.length - 1 - 1 | 0,_ga_=0;
        if(! (_gb_ < 0))
         {var i=_ga_;
          for(;;)
           {var _gc_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _gc_;
            var _gd_=i + 1 | 0;
            if(_gb_ !== i){var i=_gd_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _f5_=nsize < max_array_length?1:0,
         _f6_=_f5_?(osize >>> 1 | 0) <= h[1]?1:0:_f5_;
        if(_f6_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _f$_=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _f$_;
                return 0}
              return 0},
           _f8_=osize - 1 | 0,
           _f7_=0;
          if(! (_f8_ < 0))
           {var i=_f7_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _f__=i + 1 | 0;
              if(_f8_ !== i){var i=_f__;continue}
              break}}
          var _f9_=0}
        else
         var _f9_=_f6_;
        return _f9_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _f4_=h[2].length - 1 << 1 < h[1]?1:0;
        return _f4_?resize(h):_f4_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _f3_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _f3_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f2_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f2_)[1 + _f2_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f1_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f1_)[1 + _f1_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _f0_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_f0_)[1 + _f0_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fY_=replace_bucket(l);return _fY_}
        catch(_fZ_)
         {_fZ_ = caml_wrap_exception(_fZ_);
          if(_fZ_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fX_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fX_?resize(h):_fX_}
          throw _fZ_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fW_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fW_)[1 + _fW_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fU_=d$0.length - 1 - 1 | 0,_fT_=0;
        if(! (_fU_ < 0))
         {var i=_fT_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fV_=i + 1 | 0;
              if(_fU_ !== i){var i=_fV_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fQ_=d$0.length - 1 - 1 | 0,_fP_=0;
        if(! (_fQ_ < 0))
         {var i=_fP_;
          a:
          for(;;)
           {var
             _fR_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fR_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fS_=i + 1 | 0;
              if(_fQ_ !== i){var i=_fS_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fM_=d.length - 1 - 1 | 0,_fL_=0;
        if(! (_fM_ < 0))
         {var i=_fL_;
          for(;;)
           {var _fN_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fN_;
            var _fO_=i + 1 | 0;
            if(_fM_ !== i){var i=_fO_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _fH_=h[2],
         _fI_=0,
         mbl=
          fold_left$3
           (function(m,b){return max$1(m,bucket_length(0,b))},_fI_,_fH_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fJ_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _fK_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fK_;
            return 0},
          _fJ_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _fD_=h[2],
         _fE_=0,
         mbl=
          fold_left$3
           (function(m,b){return max$1(m,bucket_length_alive(0,b))},_fE_,_fD_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fF_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _fG_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fG_;
            return 0},
          _fF_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_fC_){return aux(i$0,next,_fC_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _fz_=0,_fA_=0;
        return function(_fB_){return aux(_fA_,_fz_,_fB_)}}
      function to_seq_keys(m)
       {var _fv_=to_seq(m);
        function _fw_(_fy_){return _fy_[1]}
        return function(_fx_){return map(_fw_,_fv_,_fx_)}}
      function to_seq_values(m)
       {var _fr_=to_seq(m);
        function _fs_(_fu_){return _fu_[2]}
        return function(_ft_){return map(_fs_,_fr_,_ft_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_t_[1],1)}
    function get_key$0(t){return caml_call2(_t_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_t_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_t_[6],t,0)}
    function check_key$0(t){return caml_call2(_t_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_t_[9],t)}
    function get_data_copy(t){return caml_call1(_t_[10],t)}
    function set_data(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data(t){return caml_call1(_t_[12],t)}
    function check_data(t){return caml_call1(_t_[13],t)}
    function blit_data(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fq_=include[1];
      function create(sz){return caml_call2(_fq_,_cM_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_t_[1],2)}
    function get_key1(t){return caml_call2(_t_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_t_[4],t,0)}
    function set_key1(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_t_[6],t,0)}
    function check_key1(t){return caml_call2(_t_[7],t,0)}
    function get_key2(t){return caml_call2(_t_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_t_[4],t,1)}
    function set_key2(t,k){return caml_call3(_t_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_t_[6],t,1)}
    function check_key2(t){return caml_call2(_t_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_t_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_t_[9],t)}
    function get_data_copy$0(t){return caml_call1(_t_[10],t)}
    function set_data$0(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$0(t){return caml_call1(_t_[12],t)}
    function check_data$0(t){return caml_call1(_t_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _fp_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _fp_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _fo_=check_key1(c);return _fo_?check_key2(c):_fo_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_fm_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_fm_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fn_=include[1];
      function create(sz){return caml_call2(_fn_,_cN_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_t_[1],n)}
    function length$6(k){return caml_call1(_t_[2],k)}
    function get_key$1(t,n){return caml_call2(_t_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_t_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_t_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_t_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_t_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_t_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_t_[9],t)}
    function get_data_copy$1(t){return caml_call1(_t_[10],t)}
    function set_data$1(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$1(t){return caml_call1(_t_[12],t)}
    function check_data$1(t){return caml_call1(_t_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _fk_=k.length - 1 - 1 | 0,_fj_=0;
        if(! (_fk_ < 0))
         {var i=_fj_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fl_=i + 1 | 0;
            if(_fk_ !== i){var i=_fl_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_ff_=k.length - 1 - 1 | 0,_fe_=0;
        if(! (_ff_ < 0))
         {var i=_fe_;
          for(;;)
           {var _fg_=h[1],_fh_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_fh_) * 65599 | 0) + _fg_ | 0;
            var _fi_=i + 1 | 0;
            if(_ff_ !== i){var i=_fi_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_fd_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_fd_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _fb_=k.length - 1 - 1 | 0,_fa_=0;
        if(! (_fb_ < 0))
         {var i=_fa_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fc_=i + 1 | 0;
            if(_fb_ !== i){var i=_fc_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _e9_=i < 0?1:0;
          if(_e9_)
           var _e__=_e9_;
          else
           {var _e$_=check_key$1(c,i);
            if(_e$_){var i$0=i - 1 | 0,i=i$0;continue}
            var _e__=_e$_}
          return _e__}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _e8_=include[1];
      function create(sz){return caml_call2(_e8_,_cO_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_Ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_e7_)
         {return MakeSeeded$0
                  ([0,_e7_[3],_e7_[1],_e7_[2],_e7_[5],_e7_[4],_e7_[6],_e7_[7]])}]];
    caml_register_global(809,Stdlib_Ephemeron,"Stdlib__Ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _e5_=caml_ml_string_length(n) < 1?1:0,
       _e6_=_e5_ || (47 !== caml_string_get(n,0)?1:0);
      return _e6_}
    function is_implicit(n)
     {var _e0_=is_relative(n);
      if(_e0_)
       {var
         _e1_=caml_ml_string_length(n) < 2?1:0,
         _e2_=_e1_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_e2_)
         var
          _e3_=caml_ml_string_length(n) < 3?1:0,
          _e4_=_e3_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _e4_=_e2_}
      else
       var _e4_=_e0_;
      return _e4_}
    function check_suffix(name,suff){return ends_with$0(suff,name)}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cW_=caml_sys_getenv(cst_TMPDIR),_cP_=_cW_}
    catch(_eZ_)
     {_eZ_ = caml_wrap_exception(_eZ_);
      if(_eZ_ !== Not_found)throw _eZ_;
      var _cP_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eX_=l - 1 | 0,_eW_=0;
      if(! (_eX_ < 0))
       {var i=_eW_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _eY_=i + 1 | 0;
          if(_eX_ !== i){var i=_eY_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _eQ_=caml_equal(stderr,stdout)?cst_2_1:cat(cst_2,quote(f)),
        _eR_=_eQ_;
      else
       var _eR_=cst$109;
      if(stdout)
       var f$0=stdout[1],_eS_=cat(cst$104,quote(f$0));
      else
       var _eS_=cst$108;
      var _eT_=cat(_eS_,_eR_);
      if(stdin)
       var f$1=stdin[1],_eU_=cat(cst$105,quote(f$1));
      else
       var _eU_=cst$107;
      var _eV_=cat(_eU_,_eT_);
      return cat(concat$1(cst$106,map$3(quote,[0,cmd,args])),_eV_)}
    function basename(_eP_)
     {return generic_basename(is_dir_sep,current_dir_name,_eP_)}
    function dirname(_eO_)
     {return generic_dirname(is_dir_sep,current_dir_name,_eO_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cP_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_eL_=47 === c?1:0;
      if(_eL_)
       var _eM_=_eL_;
      else
       var _eN_=92 === c?1:0,_eM_=_eN_ || (58 === c?1:0);
      return _eM_}
    function is_relative$0(n)
     {var
       _eF_=caml_ml_string_length(n) < 1?1:0,
       _eG_=_eF_ || (47 !== caml_string_get(n,0)?1:0);
      if(_eG_)
       {var
         _eH_=caml_ml_string_length(n) < 1?1:0,
         _eI_=_eH_ || (92 !== caml_string_get(n,0)?1:0);
        if(_eI_)
         var
          _eJ_=caml_ml_string_length(n) < 2?1:0,
          _eK_=_eJ_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _eK_=_eI_}
      else
       var _eK_=_eG_;
      return _eK_}
    function is_implicit$0(n)
     {var _ew_=is_relative$0(n);
      if(_ew_)
       {var
         _ex_=caml_ml_string_length(n) < 2?1:0,
         _ey_=_ex_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_ey_)
         {var
           _ez_=caml_ml_string_length(n) < 2?1:0,
           _eA_=_ez_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_eA_)
           {var
             _eB_=caml_ml_string_length(n) < 3?1:0,
             _eC_=_eB_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_eC_)
             var
              _eD_=caml_ml_string_length(n) < 3?1:0,
              _eE_=_eD_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _eE_=_eC_}
          else
           var _eE_=_eA_}
        else
         var _eE_=_ey_}
      else
       var _eE_=_ew_;
      return _eE_}
    function check_suffix$0(name,suff)
     {var _et_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_et_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _eu_=lowercase_ascii$1(suff),
        _ev_=caml_string_equal(lowercase_ascii$1(s),_eu_);
      else
       var _ev_=_et_;
      return _ev_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _es_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_es_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cV_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cV_}
    catch(_er_)
     {_er_ = caml_wrap_exception(_er_);
      if(_er_ !== Not_found)throw _er_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _ep_=1;
        if(! (n < 1))
         {var j=_ep_;
          for(;;)
           {add_char(b,92);
            var _eq_=j + 1 | 0;
            if(n !== j){var j=_eq_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _en_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_en_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_en_,i$0])}
          if(92 === c)
           {var _eo_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_eo_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_eo_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _em_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_em_)}
            return caml_trampoline_return(loop$0,[0,_em_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?cat(cst$116,cat(f,cst$115)):f;
      return failwith(cat(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _ed_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :cat(cst_2$0,quote_cmd_filename(f)),
        _ee_=_ed_;
      else
       var _ee_=cst$125;
      var _ef_=[0,_ee_,_cQ_];
      if(stdout)
       var f$0=stdout[1],_eg_=cat(cst$117,quote_cmd_filename(f$0));
      else
       var _eg_=cst$124;
      var _eh_=[0,_eg_,_ef_];
      if(stdin)
       var f$1=stdin[1],_ei_=cat(cst$118,quote_cmd_filename(f$1));
      else
       var _ei_=cst$123;
      var
       s=concat$1(cst$119,map$3(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _ej_=[0,_ei_,_eh_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _el_=c - 63 | 0;
            if(60 < _el_ >>> 0)
             {if(! (62 <= _el_))switch$0 = 1}
            else
             if(31 === _el_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _ek_=[0,cst$120,[0,contents(b),_ej_]];
      return concat$1(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_ek_]])}
    function drive_and_path(s)
     {var _d$_=2 <= caml_ml_string_length(s)?1:0;
      if(_d$_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _ea_=switch$0?1:0,_eb_=_ea_?58 === caml_string_get(s,1)?1:0:_ea_}
      else
       var _eb_=_d$_;
      if(_eb_)
       {var _ec_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_ec_]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return cat(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_d__)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_d__)}
    function dirname$1(_d9_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_d9_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cP_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$4(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return cat(dirname,cat(dir_sep$2,filename));
      return cat(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_d8_){return caml_call1(_cb_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _d6_=caml_obj_tag(prng$0),
       _d7_=
        250 === _d6_?prng$0[1]:246 === _d6_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_cb_[4],_d7_) & 16777215;
      return concat$4(temp_dir,caml_call3(sprintf(_cR_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cS_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_d4_,_d3_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cT_;
      if(_d4_)var sth$0=_d4_[1],perms=sth$0;else var perms=384;
      if(_d3_)
       var sth$1=_d3_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _d5_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _d5_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_Filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$4,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(810,Stdlib_Filename,"Stdlib__Filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cU_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _d2_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_d2_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_Complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(811,Stdlib_Complex,"Stdlib__Complex");
    var
     Stdlib_ArrayLabels=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$2,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$3,
       fold_left_map$0,
       fold_right$2,
       iter2$0,
       map2$0,
       for_all$2,
       exists$2,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       find_opt$0,
       find_map$0,
       split$0,
       combine$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(812,Stdlib_ArrayLabels,"Stdlib__ArrayLabels");
    var
     Stdlib_ListLabels=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(813,Stdlib_ListLabels,"Stdlib__ListLabels");
    var
     Stdlib_BytesLabels=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       to_bytes,
       of_bytes,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat$0,
       cat$0,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$7,
       equal$7,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(814,Stdlib_BytesLabels,"Stdlib__BytesLabels");
    var
     Stdlib_StringLabels=
      [0,
       make$1,
       init$1,
       empty$1,
       of_bytes,
       to_bytes,
       concat$1,
       cat,
       equal$8,
       compare$8,
       starts_with$0,
       ends_with$0,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char$0,
       map$5,
       mapi$1,
       fold_left$2,
       fold_right$1,
       for_all$1,
       exists$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       get_uint8$0,
       get_int8$0,
       get_uint16_ne$0,
       get_uint16_be$0,
       get_uint16_le$0,
       get_int16_ne$0,
       get_int16_be$0,
       get_int16_le$0,
       get_int32_ne$0,
       get_int32_be$0,
       get_int32_le$0,
       get_int64_ne$0,
       get_int64_be$0,
       get_int64_le$0];
    caml_register_global(815,Stdlib_StringLabels,"Stdlib__StringLabels");
    var Stdlib_MoreLabels=[0,Stdlib_Hashtbl,Stdlib_Map,Stdlib_Set];
    caml_register_global(816,Stdlib_MoreLabels,"Stdlib__MoreLabels");
    var Stdlib_StdLabels=[0];
    caml_register_global(817,Stdlib_StdLabels,"Stdlib__StdLabels");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function cloop(arr,idx,f,col,max)
     {if(col === idx.length - 1)
       return caml_ba_set_generic(arr,idx,caml_call1(f,idx));
      var _d0_=caml_check_bound(max,col)[1 + col] - 1 | 0,_dZ_=0;
      if(! (_d0_ < 0))
       {var j=_dZ_;
        for(;;)
         {caml_check_bound(idx,col)[1 + col] = j;
          cloop(arr,idx,f,col + 1 | 0,max);
          var _d1_=j + 1 | 0;
          if(_d0_ !== j){var j=_d1_;continue}
          break}}
      return 0}
    function floop(arr,idx,f,col,max)
     {if(0 <= col)
       {var _dX_=caml_check_bound(max,col)[1 + col],_dW_=1;
        if(! (_dX_ < 1))
         {var j=_dW_;
          for(;;)
           {caml_check_bound(idx,col)[1 + col] = j;
            floop(arr,idx,f,col - 1 | 0,max);
            var _dY_=j + 1 | 0;
            if(_dX_ !== j){var j=_dY_;continue}
            break}}
        return 0}
      return caml_ba_set_generic(arr,idx,caml_call1(f,idx))}
    function init$5(kind,layout,dims,f)
     {var arr=caml_ba_create(kind,layout,dims),dlen=dims.length - 1;
      return 0 === dlen
              ?arr
              :layout
                ?(floop(arr,caml_make_vect(dlen,1),f,dlen - 1 | 0,dims),arr)
                :(cloop(arr,caml_make_vect(dlen,0),f,0,dims),arr)}
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dT_=n - 1 | 0,_dS_=0;
      if(! (_dT_ < 0))
       {var i=_dS_;
        for(;;)
         {var _dU_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dU_;
          var _dV_=i + 1 | 0;
          if(_dT_ !== i){var i=_dV_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dR_=fold_left$3(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dR_)}
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$2(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$1(arr)
     {var _dP_=[0];
      return function(_dQ_){return caml_ba_set_generic(arr,_dP_,_dQ_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set$1(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _dO_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dO_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function init$6(kind,layout,dim,f)
     {var arr=create$9(kind,layout,dim);
      if(layout)
       {var _dM_=1;
        if(! (dim < 1))
         {var i$0=_dM_;
          for(;;)
           {caml_ba_set_1(arr,i$0,caml_call1(f,i$0));
            var _dN_=i$0 + 1 | 0;
            if(dim !== i$0){var i$0=_dN_;continue}
            break}}
        return arr}
      var _dK_=dim - 1 | 0,_dJ_=0;
      if(! (_dK_ < 0))
       {var i=_dJ_;
        for(;;)
         {caml_ba_set_1(arr,i,caml_call1(f,i));
          var _dL_=i + 1 | 0;
          if(_dK_ !== i){var i=_dL_;continue}
          break}}
      return arr}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dH_=data.length - 1 - 1 | 0,
       _dG_=0;
      if(! (_dH_ < 0))
       {var i=_dG_;
        for(;;)
         {caml_ba_set_1(ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dI_=i + 1 | 0;
          if(_dH_ !== i){var i=_dI_;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _dE_=caml_ba_dim_2(arr),_dF_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dF_),_dE_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function init$7(kind,layout,dim1,dim2,f)
     {var arr=create$10(kind,layout,dim1,dim2);
      if(layout)
       {var _dA_=1;
        if(! (dim2 < 1))
         {var j$0=_dA_;
          for(;;)
           {var _dB_=1;
            if(! (dim1 < 1))
             {var i$0=_dB_;
              for(;;)
               {caml_ba_set_2(arr,i$0,j$0,caml_call2(f,i$0,j$0));
                var _dD_=i$0 + 1 | 0;
                if(dim1 !== i$0){var i$0=_dD_;continue}
                break}}
            var _dC_=j$0 + 1 | 0;
            if(dim2 !== j$0){var j$0=_dC_;continue}
            break}}
        return arr}
      var _dv_=dim1 - 1 | 0,_du_=0;
      if(! (_dv_ < 0))
       {var i=_du_;
        for(;;)
         {var _dx_=dim2 - 1 | 0,_dw_=0;
          if(! (_dx_ < 0))
           {var j=_dw_;
            for(;;)
             {caml_ba_set_2(arr,i,j,caml_call2(f,i,j));
              var _dz_=j + 1 | 0;
              if(_dx_ !== j){var j=_dz_;continue}
              break}}
          var _dy_=i + 1 | 0;
          if(_dv_ !== i){var i=_dy_;continue}
          break}}
      return arr}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _dp_=dim1 - 1 | 0,
       _do_=0;
      if(! (_dp_ < 0))
       {var i=_do_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _dr_=dim2 - 1 | 0,_dq_=0;
          if(! (_dr_ < 0))
           {var j=_dq_;
            for(;;)
             {caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _dt_=j + 1 | 0;
              if(_dr_ !== j){var j=_dt_;continue}
              break}}
          var _ds_=i + 1 | 0;
          if(_dp_ !== i){var i=_ds_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _dl_=runtime.caml_ba_dim_3(arr),
       _dm_=caml_ba_dim_2(arr),
       _dn_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dn_),_dm_),
               _dl_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function init$8(kind,layout,dim1,dim2,dim3,f)
     {var arr=create$11(kind,layout,dim1,dim2,dim3);
      if(layout)
       {var _df_=1;
        if(! (dim3 < 1))
         {var k$0=_df_;
          for(;;)
           {var _dg_=1;
            if(! (dim2 < 1))
             {var j$0=_dg_;
              for(;;)
               {var _di_=1;
                if(! (dim1 < 1))
                 {var i$0=_di_;
                  for(;;)
                   {caml_ba_set_3(arr,i$0,j$0,k$0,caml_call3(f,i$0,j$0,k$0));
                    var _dk_=i$0 + 1 | 0;
                    if(dim1 !== i$0){var i$0=_dk_;continue}
                    break}}
                var _dj_=j$0 + 1 | 0;
                if(dim2 !== j$0){var j$0=_dj_;continue}
                break}}
            var _dh_=k$0 + 1 | 0;
            if(dim3 !== k$0){var k$0=_dh_;continue}
            break}}
        return arr}
      var _c9_=dim1 - 1 | 0,_c8_=0;
      if(! (_c9_ < 0))
       {var i=_c8_;
        for(;;)
         {var _c$_=dim2 - 1 | 0,_c__=0;
          if(! (_c$_ < 0))
           {var j=_c__;
            for(;;)
             {var _dc_=dim3 - 1 | 0,_db_=0;
              if(! (_dc_ < 0))
               {var k=_db_;
                for(;;)
                 {caml_ba_set_3(arr,i,j,k,caml_call3(f,i,j,k));
                  var _de_=k + 1 | 0;
                  if(_dc_ !== k){var k=_de_;continue}
                  break}}
              var _dd_=j + 1 | 0;
              if(_c$_ !== j){var j=_dd_;continue}
              break}}
          var _da_=i + 1 | 0;
          if(_c9_ !== i){var i=_da_;continue}
          break}}
      return arr}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _c0_=dim1 - 1 | 0,
       _cZ_=0;
      if(! (_c0_ < 0))
       {var i=_cZ_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _c2_=dim2 - 1 | 0,_c1_=0;
          if(! (_c2_ < 0))
           {var j=_c1_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _c5_=dim3 - 1 | 0,_c4_=0;
              if(! (_c5_ < 0))
               {var k=_c4_;
                for(;;)
                 {caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c7_=k + 1 | 0;
                  if(_c5_ !== k){var k=_c7_;continue}
                  break}}
              var _c6_=j + 1 | 0;
              if(_c2_ !== j){var j=_c6_;continue}
              break}}
          var _c3_=i + 1 | 0;
          if(_c0_ !== i){var i=_c3_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_Bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0,init$5,dims,size_in_bytes],
       [0,
        create$8,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get$2,
        set$1,
        of_value],
       [0,
        create$9,
        init$6,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$10,
        init$7,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        init$8,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(818,Stdlib_Bigarray,"Stdlib__Bigarray");
    return}
  (function(){return this}()));


//# 1 "../../.js/brr/brr.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_js_from_bool=runtime.caml_js_from_bool,
     caml_js_get=runtime.caml_js_get,
     caml_js_instanceof=runtime.caml_js_instanceof,
     caml_js_meth_call=runtime.caml_js_meth_call,
     caml_js_new=runtime.caml_js_new,
     caml_js_to_bool=runtime.caml_js_to_bool,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_list_to_js_array=runtime.caml_list_to_js_array,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_substr=caml_string_of_jsbytes("substr"),
     cst_slice=caml_string_of_jsbytes("slice"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_NotAllowedError=caml_string_of_jsbytes("NotAllowedError"),
     cst_InvalidAccessError=caml_string_of_jsbytes("InvalidAccessError"),
     cst_AbortError=caml_string_of_jsbytes("AbortError"),
     cst_ConstraintError=caml_string_of_jsbytes("ConstraintError"),
     cst_DataCloneError=caml_string_of_jsbytes("DataCloneError"),
     cst_DataError=caml_string_of_jsbytes("DataError"),
     cst_EncodingError=caml_string_of_jsbytes("EncodingError"),
     cst_HierarchyRequestError=caml_string_of_jsbytes("HierarchyRequestError"),
     cst_IndexSizeError=caml_string_of_jsbytes("IndexSizeError"),
     cst_InvalidCharacterError=caml_string_of_jsbytes("InvalidCharacterError"),
     cst_InvalidModificationError=
      caml_string_of_jsbytes("InvalidModificationError"),
     cst_InvalidNodeTypeError=caml_string_of_jsbytes("InvalidNodeTypeError"),
     cst_InvalidStateError=caml_string_of_jsbytes("InvalidStateError"),
     cst_NamespaceError=caml_string_of_jsbytes("NamespaceError"),
     cst_NetworkError=caml_string_of_jsbytes("NetworkError"),
     cst_NoModificationAllowedError=
      caml_string_of_jsbytes("NoModificationAllowedError"),
     cst_SyntaxError=caml_string_of_jsbytes("SyntaxError"),
     cst_NotFoundError=caml_string_of_jsbytes("NotFoundError"),
     cst_NotReadableError=caml_string_of_jsbytes("NotReadableError"),
     cst_NotSupportedError=caml_string_of_jsbytes("NotSupportedError"),
     cst_OperationError=caml_string_of_jsbytes("OperationError"),
     cst_QuotaExceededError=caml_string_of_jsbytes("QuotaExceededError"),
     cst_ReadOnlyError=caml_string_of_jsbytes("ReadOnlyError"),
     cst_SecurityError=caml_string_of_jsbytes("SecurityError"),
     cst_TimeoutError=caml_string_of_jsbytes("TimeoutError"),
     cst_TransactionInactiveError=
      caml_string_of_jsbytes("TransactionInactiveError"),
     cst_TypeMismatchError=caml_string_of_jsbytes("TypeMismatchError"),
     cst_URLMismatchError=caml_string_of_jsbytes("URLMismatchError"),
     cst_UnknownError=caml_string_of_jsbytes("UnknownError"),
     cst_VersionError=caml_string_of_jsbytes("VersionError"),
     cst_WrongDocumentError=caml_string_of_jsbytes("WrongDocumentError"),
     cst_Jv_Error=caml_string_of_jsbytes("Jv.Error"),
     cst_clearMeasures=caml_string_of_jsbytes("clearMeasures"),
     cst_clearMarks=caml_string_of_jsbytes("clearMarks"),
     cst_timeOrigin=caml_string_of_jsbytes("timeOrigin"),
     cst_redirectCount=caml_string_of_jsbytes("redirectCount"),
     cst_type$3=caml_string_of_jsbytes("type'"),
     cst_loadEventEnd=caml_string_of_jsbytes("loadEventEnd"),
     cst_loadEventStart=caml_string_of_jsbytes("loadEventStart"),
     cst_domComplete=caml_string_of_jsbytes("domComplete"),
     cst_domContentLoadedEventEnd=
      caml_string_of_jsbytes("domContentLoadedEventEnd"),
     cst_domContentLoadedEventStart=
      caml_string_of_jsbytes("domContentLoadedEventStart"),
     cst_domInteractive=caml_string_of_jsbytes("domInteractive"),
     cst_unloadEventEnd=caml_string_of_jsbytes("unloadEventEnd"),
     cst_unloadEventStart=caml_string_of_jsbytes("unloadEventStart"),
     cst_decodedBodySize=caml_string_of_jsbytes("decodedBodySize"),
     cst_encodedBodySize=caml_string_of_jsbytes("encodedBodySize"),
     cst_transferSize=caml_string_of_jsbytes("transferSize"),
     cst_responseEnd=caml_string_of_jsbytes("responseEnd"),
     cst_responseStart=caml_string_of_jsbytes("responseStart"),
     cst_requestStart=caml_string_of_jsbytes("requestStart"),
     cst_secureConnectionStart=caml_string_of_jsbytes("secureConnectionStart"),
     cst_connectEnd=caml_string_of_jsbytes("connectEnd"),
     cst_connectStart=caml_string_of_jsbytes("connectStart"),
     cst_domainLookupEnd=caml_string_of_jsbytes("domainLookupEnd"),
     cst_domainLookupStart=caml_string_of_jsbytes("domainLookupStart"),
     cst_fetchStart=caml_string_of_jsbytes("fetchStart"),
     cst_redirectEnd=caml_string_of_jsbytes("redirectEnd"),
     cst_redirectStart=caml_string_of_jsbytes("redirectStart"),
     cst_workerStart=caml_string_of_jsbytes("workerStart"),
     cst_nextHopProtocol=caml_string_of_jsbytes("nextHopProtocol"),
     cst_initiatorType=caml_string_of_jsbytes("initiatorType"),
     cst_duration=caml_string_of_jsbytes("duration"),
     cst_endTime=caml_string_of_jsbytes("endTime"),
     cst_startTime=caml_string_of_jsbytes("startTime"),
     cst_entryType=caml_string_of_jsbytes("entryType"),
     cst_name$1=caml_string_of_jsbytes("name"),
     cst_onLine=caml_string_of_jsbytes("onLine"),
     cst_languages=caml_string_of_jsbytes("languages"),
     cst_language=caml_string_of_jsbytes("language"),
     cst_scrollRestoration$0=caml_string_of_jsbytes("scrollRestoration"),
     cst_scrollRestoration=caml_string_of_jsbytes("scrollRestoration"),
     cst_length$3=caml_string_of_jsbytes("length"),
     cst_matches=caml_string_of_jsbytes("matches"),
     cst_devicePixelRatio=caml_string_of_jsbytes("devicePixelRatio"),
     cst_scrollY=caml_string_of_jsbytes("scrollY"),
     cst_scrollX=caml_string_of_jsbytes("scrollX"),
     cst_closed=caml_string_of_jsbytes("closed"),
     cst_timeStamp$0=caml_string_of_jsbytes("timeStamp"),
     cst_profileEnd=caml_string_of_jsbytes("profileEnd"),
     cst_profile=caml_string_of_jsbytes("profile"),
     cst_timeEnd=caml_string_of_jsbytes("timeEnd"),
     cst_timeLog=caml_string_of_jsbytes("timeLog"),
     cst_time=caml_string_of_jsbytes("time"),
     cst_countReset=caml_string_of_jsbytes("countReset"),
     cst_count=caml_string_of_jsbytes("count"),
     cst_groupCollapsed=caml_string_of_jsbytes("groupCollapsed"),
     cst_group=caml_string_of_jsbytes("group"),
     cst_groupEnd=caml_string_of_jsbytes("groupEnd"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_dir=caml_string_of_jsbytes("dir"),
     cst_assert=caml_string_of_jsbytes("assert"),
     cst_debug=caml_string_of_jsbytes("debug"),
     cst_info=caml_string_of_jsbytes("info"),
     cst_warn=caml_string_of_jsbytes("warn"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_trace=caml_string_of_jsbytes("trace"),
     cst_log=caml_string_of_jsbytes("log"),
     cst_clear=caml_string_of_jsbytes("clear"),
     cst_aborted=caml_string_of_jsbytes("aborted"),
     cst_fullscreenEnabled=caml_string_of_jsbytes("fullscreenEnabled"),
     cst_visibilityState=caml_string_of_jsbytes("visibilityState"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_referrer=caml_string_of_jsbytes("referrer"),
     cst_files=caml_string_of_jsbytes("files"),
     cst_navigationUI=caml_string_of_jsbytes("navigationUI"),
     cst_scrollHeight=caml_string_of_jsbytes("scrollHeight"),
     cst_scrollWidth=caml_string_of_jsbytes("scrollWidth"),
     cst_scrollTop=caml_string_of_jsbytes("scrollTop"),
     cst_scrollLeft=caml_string_of_jsbytes("scrollLeft"),
     cst_height$0=caml_string_of_jsbytes("height"),
     cst_width$0=caml_string_of_jsbytes("width"),
     cst_y=caml_string_of_jsbytes("y"),
     cst_x=caml_string_of_jsbytes("x"),
     cst_clientHeight=caml_string_of_jsbytes("clientHeight"),
     cst_clientWidth=caml_string_of_jsbytes("clientWidth"),
     cst_clientTop=caml_string_of_jsbytes("clientTop"),
     cst_clientLeft=caml_string_of_jsbytes("clientLeft"),
     cst_after=caml_string_of_jsbytes("after"),
     cst_before=caml_string_of_jsbytes("before"),
     cst_replaceWith=caml_string_of_jsbytes("replaceWith"),
     cst_append=caml_string_of_jsbytes("append"),
     cst_prepend=caml_string_of_jsbytes("prepend"),
     cst_parentNode=caml_string_of_jsbytes("parentNode"),
     cst_length$2=caml_string_of_jsbytes("length"),
     cst_nodeValue=caml_string_of_jsbytes("nodeValue"),
     cst_nodeName=caml_string_of_jsbytes("nodeName"),
     cst_nodeType$0=caml_string_of_jsbytes("nodeType"),
     cst_nodeType=caml_string_of_jsbytes("nodeType"),
     cst=caml_string_of_jsbytes("\xc2\xa0"),
     cst_length$1=caml_string_of_jsbytes("length"),
     cst_port$0=caml_string_of_jsbytes("port"),
     cst_protocol=caml_string_of_jsbytes("protocol"),
     cst_hostname=caml_string_of_jsbytes("hostname"),
     cst_port=caml_string_of_jsbytes("port"),
     cst_pathname=caml_string_of_jsbytes("pathname"),
     cst_search=caml_string_of_jsbytes("search"),
     cst_hash=caml_string_of_jsbytes("hash"),
     cst_lastModified$0=caml_string_of_jsbytes("lastModified"),
     cst_name$0=caml_string_of_jsbytes("name"),
     cst_lastModified=caml_string_of_jsbytes("lastModified"),
     cst_result=caml_string_of_jsbytes("result"),
     cst_type$2=caml_string_of_jsbytes("type"),
     cst_size=caml_string_of_jsbytes("size"),
     cst_type$1=caml_string_of_jsbytes("type"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_name=caml_string_of_jsbytes("name"),
     cst_Float32Array=caml_string_of_jsbytes("Float32Array"),
     cst_Float64Array=caml_string_of_jsbytes("Float64Array"),
     cst_Int16Array=caml_string_of_jsbytes("Int16Array"),
     cst_Int32Array=caml_string_of_jsbytes("Int32Array"),
     cst_Int8Array=caml_string_of_jsbytes("Int8Array"),
     cst_Uint16Array=caml_string_of_jsbytes("Uint16Array"),
     cst_Uint32Array=caml_string_of_jsbytes("Uint32Array"),
     cst_Uint8Array=caml_string_of_jsbytes("Uint8Array"),
     cst_Uint8ClampedArray=caml_string_of_jsbytes("Uint8ClampedArray"),
     cst_length$0=caml_string_of_jsbytes("length"),
     cst_byteLength$0=caml_string_of_jsbytes("byteLength"),
     cst_byteOffset=caml_string_of_jsbytes("byteOffset"),
     cst_byteLength=caml_string_of_jsbytes("byteLength"),
     cst_deltaMode=caml_string_of_jsbytes("deltaMode"),
     cst_deltaZ=caml_string_of_jsbytes("deltaZ"),
     cst_deltaY=caml_string_of_jsbytes("deltaY"),
     cst_deltaX=caml_string_of_jsbytes("deltaX"),
     cst_isPrimary=caml_string_of_jsbytes("isPrimary"),
     cst_pointerType=caml_string_of_jsbytes("pointerType"),
     cst_azimuthAngle=caml_string_of_jsbytes("azimuthAngle"),
     cst_altitudeAngle=caml_string_of_jsbytes("altitudeAngle"),
     cst_twist=caml_string_of_jsbytes("twist"),
     cst_tiltY=caml_string_of_jsbytes("tiltY"),
     cst_tiltX=caml_string_of_jsbytes("tiltX"),
     cst_tangentialPressure=caml_string_of_jsbytes("tangentialPressure"),
     cst_pressure=caml_string_of_jsbytes("pressure"),
     cst_height=caml_string_of_jsbytes("height"),
     cst_width=caml_string_of_jsbytes("width"),
     cst_pointerId=caml_string_of_jsbytes("pointerId"),
     cst_dataTransfer$0=caml_string_of_jsbytes("dataTransfer"),
     cst_metaKey$0=caml_string_of_jsbytes("metaKey"),
     cst_shiftKey$0=caml_string_of_jsbytes("shiftKey"),
     cst_ctrlKey$0=caml_string_of_jsbytes("ctrlKey"),
     cst_altKey$0=caml_string_of_jsbytes("altKey"),
     cst_buttons=caml_string_of_jsbytes("buttons"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_movementY=caml_string_of_jsbytes("movementY"),
     cst_movementX=caml_string_of_jsbytes("movementX"),
     cst_screenY=caml_string_of_jsbytes("screenY"),
     cst_screenX=caml_string_of_jsbytes("screenX"),
     cst_pageY=caml_string_of_jsbytes("pageY"),
     cst_pageX=caml_string_of_jsbytes("pageX"),
     cst_clientY=caml_string_of_jsbytes("clientY"),
     cst_clientX=caml_string_of_jsbytes("clientX"),
     cst_offsetY=caml_string_of_jsbytes("offsetY"),
     cst_offsetX=caml_string_of_jsbytes("offsetX"),
     cst_relatedTarget$0=caml_string_of_jsbytes("relatedTarget"),
     cst_metaKey=caml_string_of_jsbytes("metaKey"),
     cst_shiftKey=caml_string_of_jsbytes("shiftKey"),
     cst_ctrlKey=caml_string_of_jsbytes("ctrlKey"),
     cst_altKey=caml_string_of_jsbytes("altKey"),
     cst_isComposing$0=caml_string_of_jsbytes("isComposing"),
     cst_repeat=caml_string_of_jsbytes("repeat"),
     cst_location=caml_string_of_jsbytes("location"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_key=caml_string_of_jsbytes("key"),
     cst_isComposing=caml_string_of_jsbytes("isComposing"),
     cst_inputType=caml_string_of_jsbytes("inputType"),
     cst_dataTransfer=caml_string_of_jsbytes("dataTransfer"),
     cst_data$0=caml_string_of_jsbytes("data"),
     cst_newURL=caml_string_of_jsbytes("newURL"),
     cst_oldURL=caml_string_of_jsbytes("oldURL"),
     cst_relatedTarget=caml_string_of_jsbytes("relatedTarget"),
     cst_colno=caml_string_of_jsbytes("colno"),
     cst_lineno=caml_string_of_jsbytes("lineno"),
     cst_filename=caml_string_of_jsbytes("filename"),
     cst_message=caml_string_of_jsbytes("message"),
     cst_data=caml_string_of_jsbytes("data"),
     cst_clipboardData=caml_string_of_jsbytes("clipboardData"),
     cst_effectAllowed$0=caml_string_of_jsbytes("effectAllowed"),
     cst_effectAllowed=caml_string_of_jsbytes("effectAllowed"),
     cst_dropEffect$0=caml_string_of_jsbytes("dropEffect"),
     cst_dropEffect=caml_string_of_jsbytes("dropEffect"),
     cst_length=caml_string_of_jsbytes("length"),
     cst_type$0=caml_string_of_jsbytes("type"),
     cst_kind=caml_string_of_jsbytes("kind"),
     cst_capture=caml_string_of_jsbytes("capture"),
     cst_once=caml_string_of_jsbytes("once"),
     cst_passive=caml_string_of_jsbytes("passive"),
     cst_timeStamp=caml_string_of_jsbytes("timeStamp"),
     cst_isTrusted=caml_string_of_jsbytes("isTrusted"),
     cst_composed$0=caml_string_of_jsbytes("composed"),
     cst_defaultPrevented=caml_string_of_jsbytes("defaultPrevented"),
     cst_cancelable$0=caml_string_of_jsbytes("cancelable"),
     cst_bubbles$0=caml_string_of_jsbytes("bubbles"),
     cst_eventPhase=caml_string_of_jsbytes("eventPhase"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_bubbles=caml_string_of_jsbytes("bubbles"),
     cst_cancelable=caml_string_of_jsbytes("cancelable"),
     cst_composed=caml_string_of_jsbytes("composed"),
     cst_isSecureContext=caml_string_of_jsbytes("isSecureContext"),
     cst_reason=caml_string_of_jsbytes("reason"),
     cst_code$2=caml_string_of_jsbytes("code"),
     cst_wasClean=caml_string_of_jsbytes("wasClean"),
     cst_protocol$0=caml_string_of_jsbytes("protocol"),
     cst_extensions=caml_string_of_jsbytes("extensions"),
     cst_bufferedAmount=caml_string_of_jsbytes("bufferedAmount"),
     cst_readyState$1=caml_string_of_jsbytes("readyState"),
     cst_url$2=caml_string_of_jsbytes("url"),
     cst_binaryType$0=caml_string_of_jsbytes("binaryType"),
     cst_binaryType=caml_string_of_jsbytes("binaryType"),
     cst_storageArea=caml_string_of_jsbytes("storageArea"),
     cst_url$1=caml_string_of_jsbytes("url"),
     cst_newValue=caml_string_of_jsbytes("newValue"),
     cst_oldValue=caml_string_of_jsbytes("oldValue"),
     cst_key$0=caml_string_of_jsbytes("key"),
     cst_length$5=caml_string_of_jsbytes("length"),
     cst_action$2=caml_string_of_jsbytes("action"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_timestamp$1=caml_string_of_jsbytes("timestamp"),
     cst_silent$0=caml_string_of_jsbytes("silent"),
     cst_requireInteraction$0=caml_string_of_jsbytes("requireInteraction"),
     cst_renotify$0=caml_string_of_jsbytes("renotify"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_icon$2=caml_string_of_jsbytes("icon"),
     cst_tag=caml_string_of_jsbytes("tag"),
     cst_lang$0=caml_string_of_jsbytes("lang"),
     cst_dir$1=caml_string_of_jsbytes("dir"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_badge$0=caml_string_of_jsbytes("badge"),
     cst_dir$0=caml_string_of_jsbytes("dir"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_icon$1=caml_string_of_jsbytes("icon"),
     cst_badge=caml_string_of_jsbytes("badge"),
     cst_timestamp$0=caml_string_of_jsbytes("timestamp"),
     cst_renotify=caml_string_of_jsbytes("renotify"),
     cst_silent=caml_string_of_jsbytes("silent"),
     cst_requireInteraction=caml_string_of_jsbytes("requireInteraction"),
     cst_data$1=caml_string_of_jsbytes("data"),
     cst_icon$0=caml_string_of_jsbytes("icon"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_action$1=caml_string_of_jsbytes("action"),
     cst_action$0=caml_string_of_jsbytes("action"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_icon=caml_string_of_jsbytes("icon"),
     cst_maxActions=caml_string_of_jsbytes("maxActions"),
     cst_permission=caml_string_of_jsbytes("permission"),
     cst_lastEventId=caml_string_of_jsbytes("lastEventId"),
     cst_origin=caml_string_of_jsbytes("origin"),
     cst_name$3=caml_string_of_jsbytes("name"),
     cst_targetOrigin=caml_string_of_jsbytes("targetOrigin"),
     cst_transfer=caml_string_of_jsbytes("transfer"),
     cst_defaultMuted$0=caml_string_of_jsbytes("defaultMuted"),
     cst_defaultMuted=caml_string_of_jsbytes("defaultMuted"),
     cst_muted$1=caml_string_of_jsbytes("muted"),
     cst_muted$0=caml_string_of_jsbytes("muted"),
     cst_volume$0=caml_string_of_jsbytes("volume"),
     cst_volume=caml_string_of_jsbytes("volume"),
     cst_controls$0=caml_string_of_jsbytes("controls"),
     cst_controls=caml_string_of_jsbytes("controls"),
     cst_loop$0=caml_string_of_jsbytes("loop"),
     cst_loop=caml_string_of_jsbytes("loop"),
     cst_autoplay$0=caml_string_of_jsbytes("autoplay"),
     cst_autoplay=caml_string_of_jsbytes("autoplay"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_playbackRate$0=caml_string_of_jsbytes("playbackRate"),
     cst_playbackRate=caml_string_of_jsbytes("playbackRate"),
     cst_defaultPlaybackRate$0=caml_string_of_jsbytes("defaultPlaybackRate"),
     cst_defaultPlaybackRate=caml_string_of_jsbytes("defaultPlaybackRate"),
     cst_paused=caml_string_of_jsbytes("paused"),
     cst_duration$0=caml_string_of_jsbytes("duration"),
     cst_currentTime$0=caml_string_of_jsbytes("currentTime"),
     cst_currentTime=caml_string_of_jsbytes("currentTime"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_readyState$0=caml_string_of_jsbytes("readyState"),
     cst_preload$0=caml_string_of_jsbytes("preload"),
     cst_preload=caml_string_of_jsbytes("preload"),
     cst_networkState=caml_string_of_jsbytes("networkState"),
     cst_crossOrigin$0=caml_string_of_jsbytes("crossOrigin"),
     cst_crossOrigin=caml_string_of_jsbytes("crossOrigin"),
     cst_currentSrc=caml_string_of_jsbytes("currentSrc"),
     cst_src$0=caml_string_of_jsbytes("src"),
     cst_src=caml_string_of_jsbytes("src"),
     cst_length$4=caml_string_of_jsbytes("length"),
     cst_message$1=caml_string_of_jsbytes("message"),
     cst_code$1=caml_string_of_jsbytes("code"),
     cst_groupId=caml_string_of_jsbytes("groupId"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_kind$1=caml_string_of_jsbytes("kind"),
     cst_deviceId=caml_string_of_jsbytes("deviceId"),
     cst_timecode=caml_string_of_jsbytes("timecode"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_audioBitrateMode$0=caml_string_of_jsbytes("audioBitrateMode"),
     cst_audioBitsPerSecond$0=caml_string_of_jsbytes("audioBitsPerSecond"),
     cst_videoBitsPerSecond$0=caml_string_of_jsbytes("videoBitsPerSecond"),
     cst_state=caml_string_of_jsbytes("state"),
     cst_mimeType$0=caml_string_of_jsbytes("mimeType"),
     cst_mimeType=caml_string_of_jsbytes("mimeType"),
     cst_audioBitsPerSecond=caml_string_of_jsbytes("audioBitsPerSecond"),
     cst_videoBitsPerSecond=caml_string_of_jsbytes("videoBitsPerSecond"),
     cst_bitsPerSecond=caml_string_of_jsbytes("bitsPerSecond"),
     cst_audioBitrateMode=caml_string_of_jsbytes("audioBitrateMode"),
     cst_active=caml_string_of_jsbytes("active"),
     cst_id$0=caml_string_of_jsbytes("id"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_applyConstraints=caml_string_of_jsbytes("applyConstraints"),
     cst_enabled$0=caml_string_of_jsbytes("enabled"),
     cst_enabled=caml_string_of_jsbytes("enabled"),
     cst_readyState=caml_string_of_jsbytes("readyState"),
     cst_muted=caml_string_of_jsbytes("muted"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_kind$0=caml_string_of_jsbytes("kind"),
     cst_isolated=caml_string_of_jsbytes("isolated"),
     cst_id=caml_string_of_jsbytes("id"),
     cst_exact$2=caml_string_of_jsbytes("exact"),
     cst_ideal$2=caml_string_of_jsbytes("ideal"),
     cst_min$4=caml_string_of_jsbytes("min"),
     cst_max$4=caml_string_of_jsbytes("max"),
     cst_exact$1=caml_string_of_jsbytes("exact"),
     cst_ideal$1=caml_string_of_jsbytes("ideal"),
     cst_max$3=caml_string_of_jsbytes("max"),
     cst_min$3=caml_string_of_jsbytes("min"),
     cst_min$2=caml_string_of_jsbytes("min"),
     cst_max$2=caml_string_of_jsbytes("max"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_exact$0=caml_string_of_jsbytes("exact"),
     cst_ideal$0=caml_string_of_jsbytes("ideal"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_exact=caml_string_of_jsbytes("exact"),
     cst_ideal=caml_string_of_jsbytes("ideal"),
     cst_enableHighAccuracy=caml_string_of_jsbytes("enableHighAccuracy"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_maximumAge=caml_string_of_jsbytes("maximumAge"),
     cst_timestamp=caml_string_of_jsbytes("timestamp"),
     cst_speed=caml_string_of_jsbytes("speed"),
     cst_heading=caml_string_of_jsbytes("heading"),
     cst_altitudeAccuracy=caml_string_of_jsbytes("altitudeAccuracy"),
     cst_accuracy=caml_string_of_jsbytes("accuracy"),
     cst_altitude=caml_string_of_jsbytes("altitude"),
     cst_longitude=caml_string_of_jsbytes("longitude"),
     cst_latitude=caml_string_of_jsbytes("latitude"),
     cst_message$0=caml_string_of_jsbytes("message"),
     cst_code$0=caml_string_of_jsbytes("code"),
     cst_replacesClientId=caml_string_of_jsbytes("replacesClientId"),
     cst_resultingClientId=caml_string_of_jsbytes("resultingClientId"),
     cst_clientId=caml_string_of_jsbytes("clientId"),
     cst_ignoreSearch=caml_string_of_jsbytes("ignoreSearch"),
     cst_ignoreMethod=caml_string_of_jsbytes("ignoreMethod"),
     cst_ignoreVary=caml_string_of_jsbytes("ignoreVary"),
     cst_cacheName=caml_string_of_jsbytes("cacheName"),
     cst_url$0=caml_string_of_jsbytes("url"),
     cst_statusText$0=caml_string_of_jsbytes("statusText"),
     cst_status$0=caml_string_of_jsbytes("status"),
     cst_redirected=caml_string_of_jsbytes("redirected"),
     cst_ok=caml_string_of_jsbytes("ok"),
     cst_redirect$1=caml_string_of_jsbytes("redirect"),
     cst_headers$0=caml_string_of_jsbytes("headers"),
     cst_status=caml_string_of_jsbytes("status"),
     cst_statusText=caml_string_of_jsbytes("statusText"),
     cst_url=caml_string_of_jsbytes("url"),
     cst_referrerPolicy$0=caml_string_of_jsbytes("referrerPolicy"),
     cst_referrer$1=caml_string_of_jsbytes("referrer"),
     cst_redirect$0=caml_string_of_jsbytes("redirect"),
     cst_mode$0=caml_string_of_jsbytes("mode"),
     cst_method$1=caml_string_of_jsbytes("method'"),
     cst_keepalive$0=caml_string_of_jsbytes("keepalive"),
     cst_isReloadNavigation=caml_string_of_jsbytes("isReloadNavigation"),
     cst_isHistoryNavigation=caml_string_of_jsbytes("isHistoryNavigation"),
     cst_integrity$0=caml_string_of_jsbytes("integrity"),
     cst_destination=caml_string_of_jsbytes("destination"),
     cst_credentials$0=caml_string_of_jsbytes("credentials"),
     cst_cache$0=caml_string_of_jsbytes("cache"),
     cst_cache=caml_string_of_jsbytes("cache"),
     cst_credentials=caml_string_of_jsbytes("credentials"),
     cst_headers=caml_string_of_jsbytes("headers"),
     cst_integrity=caml_string_of_jsbytes("integrity"),
     cst_keepalive=caml_string_of_jsbytes("keepalive"),
     cst_method$0=caml_string_of_jsbytes("method"),
     cst_mode=caml_string_of_jsbytes("mode"),
     cst_redirect=caml_string_of_jsbytes("redirect"),
     cst_referrer$0=caml_string_of_jsbytes("referrer"),
     cst_referrerPolicy=caml_string_of_jsbytes("referrerPolicy"),
     cst_bodyUsed=caml_string_of_jsbytes("bodyUsed"),
     cst_requestSubmit=caml_string_of_jsbytes("requestSubmit"),
     cst_noValidate=caml_string_of_jsbytes("noValidate"),
     cst_autocomplete=caml_string_of_jsbytes("autocomplete"),
     cst_acceptCharset=caml_string_of_jsbytes("acceptCharset"),
     cst_enctype=caml_string_of_jsbytes("enctype"),
     cst_action=caml_string_of_jsbytes("action"),
     cst_target=caml_string_of_jsbytes("target"),
     cst_method=caml_string_of_jsbytes("method"),
     cst_name$2=caml_string_of_jsbytes("name"),
     cst_delayed=caml_string_of_jsbytes("delayed"),
     cst_lastModified$1=caml_string_of_jsbytes("lastModified"),
     cst_presentationStyle$0=caml_string_of_jsbytes("presentationStyle"),
     cst_presentationStyle=caml_string_of_jsbytes("presentationStyle"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst_rangeMax=caml_string_of_jsbytes("rangeMax"),
     cst_rangeMin=caml_string_of_jsbytes("rangeMin"),
     cst_name$4=caml_string_of_jsbytes("name"),
     cst_type$5=caml_string_of_jsbytes("type"),
     cst_size$0=caml_string_of_jsbytes("size"),
     cst_isContextLost=caml_string_of_jsbytes("isContextLost"),
     cst_drawingBufferHeight=caml_string_of_jsbytes("drawingBufferHeight"),
     cst_drawingBufferWidth=caml_string_of_jsbytes("drawingBufferWidth"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_webgl=caml_string_of_jsbytes("webgl"),
     cst_webgl2=caml_string_of_jsbytes("webgl2"),
     cst_desynchronized$1=caml_string_of_jsbytes("desynchronized"),
     cst_powerPreference$0=caml_string_of_jsbytes("powerPreference"),
     cst_preserveDrawingBuffer$0=
      caml_string_of_jsbytes("preserveDrawingBuffer"),
     cst_premultipliedApha$0=caml_string_of_jsbytes("premultipliedApha"),
     cst_antialias$0=caml_string_of_jsbytes("antialias"),
     cst_stencil$0=caml_string_of_jsbytes("stencil"),
     cst_depth$0=caml_string_of_jsbytes("depth"),
     cst_alpha$1=caml_string_of_jsbytes("alpha"),
     cst_alpha$0=caml_string_of_jsbytes("alpha"),
     cst_depth=caml_string_of_jsbytes("depth"),
     cst_stencil=caml_string_of_jsbytes("stencil"),
     cst_antialias=caml_string_of_jsbytes("antialias"),
     cst_premultipliedApha=caml_string_of_jsbytes("premultipliedApha"),
     cst_preserveDrawingBuffer=caml_string_of_jsbytes("preserveDrawingBuffer"),
     cst_powerPreference=caml_string_of_jsbytes("powerPreference"),
     cst_failIfMajorPerformanceCave=
      caml_string_of_jsbytes("failIfMajorPerformanceCaveat"),
     cst_desynchronized$0=caml_string_of_jsbytes("desynchronized"),
     cst_height$4=caml_string_of_jsbytes("height"),
     cst_width$5=caml_string_of_jsbytes("width"),
     cst_ideographicBaseline=caml_string_of_jsbytes("ideographicBaseline"),
     cst_alphabeticBaseline=caml_string_of_jsbytes("alphabeticBaseline"),
     cst_hangingBaseline=caml_string_of_jsbytes("hangingBaseline"),
     cst_emHeightDescent=caml_string_of_jsbytes("emHeightDescent"),
     cst_emHeightAscent=caml_string_of_jsbytes("emHeightAscent"),
     cst_actualBoundingBoxDescent=
      caml_string_of_jsbytes("actualBoundingBoxDescent"),
     cst_actualBoundingBoxAscent=
      caml_string_of_jsbytes("actualBoundingBoxAscent"),
     cst_fontBoundingBoxDescent=
      caml_string_of_jsbytes("fontBoundingBoxDescent"),
     cst_fontBoundingBoxAscent=caml_string_of_jsbytes("fontBoundingBoxAscent"),
     cst_actualBoundingBoxRight=
      caml_string_of_jsbytes("actualBoundingBoxRight"),
     cst_actualBoundingBoxLeft=caml_string_of_jsbytes("actualBoundingBoxLeft"),
     cst_width$4=caml_string_of_jsbytes("width"),
     cst_strokeText=caml_string_of_jsbytes("strokeText"),
     cst_fillText=caml_string_of_jsbytes("fillText"),
     cst_direction$0=caml_string_of_jsbytes("direction"),
     cst_direction=caml_string_of_jsbytes("direction"),
     cst_textBaseline$0=caml_string_of_jsbytes("textBaseline"),
     cst_textBaseline=caml_string_of_jsbytes("textBaseline"),
     cst_textAlign$0=caml_string_of_jsbytes("textAlign"),
     cst_textAlign=caml_string_of_jsbytes("textAlign"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_shadowColor$0=caml_string_of_jsbytes("shadowColor"),
     cst_shadowColor=caml_string_of_jsbytes("shadowColor"),
     cst_shadowOffsetY$0=caml_string_of_jsbytes("shadowOffsetY"),
     cst_shadowOffsetY=caml_string_of_jsbytes("shadowOffsetY"),
     cst_shadowOffsetX$0=caml_string_of_jsbytes("shadowOffsetX"),
     cst_shadowOffsetX=caml_string_of_jsbytes("shadowOffsetX"),
     cst_shadowBlur$0=caml_string_of_jsbytes("shadowBlur"),
     cst_shadowBlur=caml_string_of_jsbytes("shadowBlur"),
     cst_lineDashOffset$0=caml_string_of_jsbytes("lineDashOffset"),
     cst_lineDashOffset=caml_string_of_jsbytes("lineDashOffset"),
     cst_miterLimit$0=caml_string_of_jsbytes("miterLimit"),
     cst_miterLimit=caml_string_of_jsbytes("miterLimit"),
     cst_lineJoin$0=caml_string_of_jsbytes("lineJoin"),
     cst_lineJoin=caml_string_of_jsbytes("lineJoin"),
     cst_lineCap$0=caml_string_of_jsbytes("lineCap"),
     cst_lineCap=caml_string_of_jsbytes("lineCap"),
     cst_lineWidth$0=caml_string_of_jsbytes("lineWidth"),
     cst_lineWidth=caml_string_of_jsbytes("lineWidth"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_globalCompositeOperation$0=
      caml_string_of_jsbytes("globalCompositeOperation"),
     cst_globalCompositeOperation=
      caml_string_of_jsbytes("globalCompositeOperation"),
     cst_globalAlpha$0=caml_string_of_jsbytes("globalAlpha"),
     cst_globalAlpha=caml_string_of_jsbytes("globalAlpha"),
     cst_imageSmoothingQuality$0=
      caml_string_of_jsbytes("imageSmoothingQuality"),
     cst_imageSmoothingQuality=caml_string_of_jsbytes("imageSmoothingQuality"),
     cst_imageSmoothingEnabled$0=
      caml_string_of_jsbytes("imageSmoothingEnabled"),
     cst_imageSmoothingEnabled=caml_string_of_jsbytes("imageSmoothingEnabled"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_desynchronized=caml_string_of_jsbytes("desynchronized"),
     cst_alpha=caml_string_of_jsbytes("alpha"),
     cst_addPath=caml_string_of_jsbytes("addPath"),
     cst_captureStrseam=caml_string_of_jsbytes("captureStrseam"),
     cst_toBlob=caml_string_of_jsbytes("toBlob"),
     cst_toDataURL=caml_string_of_jsbytes("toDataURL"),
     cst_quality$0=caml_string_of_jsbytes("quality"),
     cst_type$4=caml_string_of_jsbytes("type"),
     cst_quality=caml_string_of_jsbytes("quality"),
     cst_height$3=caml_string_of_jsbytes("height"),
     cst_width$3=caml_string_of_jsbytes("width"),
     cst_height$2=caml_string_of_jsbytes("height"),
     cst_width$2=caml_string_of_jsbytes("width"),
     cst_width$1=caml_string_of_jsbytes("width"),
     cst_height$1=caml_string_of_jsbytes("height"),
     cst_w=caml_string_of_jsbytes("w"),
     cst_z=caml_string_of_jsbytes("z"),
     cst_y$0=caml_string_of_jsbytes("y"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst_f=caml_string_of_jsbytes("f"),
     cst_e=caml_string_of_jsbytes("e"),
     cst_d=caml_string_of_jsbytes("d"),
     cst_c=caml_string_of_jsbytes("c"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_m44=caml_string_of_jsbytes("m44"),
     cst_m43=caml_string_of_jsbytes("m43"),
     cst_m42=caml_string_of_jsbytes("m42"),
     cst_m41=caml_string_of_jsbytes("m41"),
     cst_m34=caml_string_of_jsbytes("m34"),
     cst_m33=caml_string_of_jsbytes("m33"),
     cst_m32=caml_string_of_jsbytes("m32"),
     cst_m31=caml_string_of_jsbytes("m31"),
     cst_m24=caml_string_of_jsbytes("m24"),
     cst_m23=caml_string_of_jsbytes("m23"),
     cst_m22=caml_string_of_jsbytes("m22"),
     cst_m21=caml_string_of_jsbytes("m21"),
     cst_m14=caml_string_of_jsbytes("m14"),
     cst_m13=caml_string_of_jsbytes("m13"),
     cst_m12=caml_string_of_jsbytes("m12"),
     cst_m11=caml_string_of_jsbytes("m11"),
     cst_isIdentity=caml_string_of_jsbytes("isIdentity"),
     cst_is2D=caml_string_of_jsbytes("is2D"),
     cst_DEPTH_BUFFER_BIT=caml_string_of_jsbytes("DEPTH_BUFFER_BIT"),
     cst_STENCIL_BUFFER_BIT=caml_string_of_jsbytes("STENCIL_BUFFER_BIT"),
     cst_COLOR_BUFFER_BIT=caml_string_of_jsbytes("COLOR_BUFFER_BIT"),
     cst_POINTS=caml_string_of_jsbytes("POINTS"),
     cst_LINES=caml_string_of_jsbytes("LINES"),
     cst_LINE_LOOP=caml_string_of_jsbytes("LINE_LOOP"),
     cst_LINE_STRIP=caml_string_of_jsbytes("LINE_STRIP"),
     cst_TRIANGLES=caml_string_of_jsbytes("TRIANGLES"),
     cst_TRIANGLE_STRIP=caml_string_of_jsbytes("TRIANGLE_STRIP"),
     cst_TRIANGLE_FAN=caml_string_of_jsbytes("TRIANGLE_FAN"),
     cst_ZERO=caml_string_of_jsbytes("ZERO"),
     cst_ONE=caml_string_of_jsbytes("ONE"),
     cst_SRC_COLOR=caml_string_of_jsbytes("SRC_COLOR"),
     cst_ONE_MINUS_SRC_COLOR=caml_string_of_jsbytes("ONE_MINUS_SRC_COLOR"),
     cst_SRC_ALPHA=caml_string_of_jsbytes("SRC_ALPHA"),
     cst_ONE_MINUS_SRC_ALPHA=caml_string_of_jsbytes("ONE_MINUS_SRC_ALPHA"),
     cst_DST_ALPHA=caml_string_of_jsbytes("DST_ALPHA"),
     cst_ONE_MINUS_DST_ALPHA=caml_string_of_jsbytes("ONE_MINUS_DST_ALPHA"),
     cst_DST_COLOR=caml_string_of_jsbytes("DST_COLOR"),
     cst_ONE_MINUS_DST_COLOR=caml_string_of_jsbytes("ONE_MINUS_DST_COLOR"),
     cst_SRC_ALPHA_SATURATE=caml_string_of_jsbytes("SRC_ALPHA_SATURATE"),
     cst_FUNC_ADD=caml_string_of_jsbytes("FUNC_ADD"),
     cst_BLEND_EQUATION=caml_string_of_jsbytes("BLEND_EQUATION"),
     cst_BLEND_EQUATION_RGB=caml_string_of_jsbytes("BLEND_EQUATION_RGB"),
     cst_BLEND_EQUATION_ALPHA=caml_string_of_jsbytes("BLEND_EQUATION_ALPHA"),
     cst_FUNC_SUBTRACT=caml_string_of_jsbytes("FUNC_SUBTRACT"),
     cst_FUNC_REVERSE_SUBTRACT=caml_string_of_jsbytes("FUNC_REVERSE_SUBTRACT"),
     cst_BLEND_DST_RGB=caml_string_of_jsbytes("BLEND_DST_RGB"),
     cst_BLEND_SRC_RGB=caml_string_of_jsbytes("BLEND_SRC_RGB"),
     cst_BLEND_DST_ALPHA=caml_string_of_jsbytes("BLEND_DST_ALPHA"),
     cst_BLEND_SRC_ALPHA=caml_string_of_jsbytes("BLEND_SRC_ALPHA"),
     cst_CONSTANT_COLOR=caml_string_of_jsbytes("CONSTANT_COLOR"),
     cst_ONE_MINUS_CONSTANT_COLOR=
      caml_string_of_jsbytes("ONE_MINUS_CONSTANT_COLOR"),
     cst_CONSTANT_ALPHA=caml_string_of_jsbytes("CONSTANT_ALPHA"),
     cst_ONE_MINUS_CONSTANT_ALPHA=
      caml_string_of_jsbytes("ONE_MINUS_CONSTANT_ALPHA"),
     cst_BLEND_COLOR=caml_string_of_jsbytes("BLEND_COLOR"),
     cst_ARRAY_BUFFER=caml_string_of_jsbytes("ARRAY_BUFFER"),
     cst_ELEMENT_ARRAY_BUFFER=caml_string_of_jsbytes("ELEMENT_ARRAY_BUFFER"),
     cst_ARRAY_BUFFER_BINDING=caml_string_of_jsbytes("ARRAY_BUFFER_BINDING"),
     cst_ELEMENT_ARRAY_BUFFER_BINDI=
      caml_string_of_jsbytes("ELEMENT_ARRAY_BUFFER_BINDING"),
     cst_STREAM_DRAW=caml_string_of_jsbytes("STREAM_DRAW"),
     cst_STATIC_DRAW=caml_string_of_jsbytes("STATIC_DRAW"),
     cst_DYNAMIC_DRAW=caml_string_of_jsbytes("DYNAMIC_DRAW"),
     cst_BUFFER_SIZE=caml_string_of_jsbytes("BUFFER_SIZE"),
     cst_BUFFER_USAGE=caml_string_of_jsbytes("BUFFER_USAGE"),
     cst_CURRENT_VERTEX_ATTRIB=caml_string_of_jsbytes("CURRENT_VERTEX_ATTRIB"),
     cst_FRONT=caml_string_of_jsbytes("FRONT"),
     cst_BACK=caml_string_of_jsbytes("BACK"),
     cst_FRONT_AND_BACK=caml_string_of_jsbytes("FRONT_AND_BACK"),
     cst_CULL_FACE=caml_string_of_jsbytes("CULL_FACE"),
     cst_BLEND=caml_string_of_jsbytes("BLEND"),
     cst_DITHER=caml_string_of_jsbytes("DITHER"),
     cst_STENCIL_TEST=caml_string_of_jsbytes("STENCIL_TEST"),
     cst_DEPTH_TEST=caml_string_of_jsbytes("DEPTH_TEST"),
     cst_SCISSOR_TEST=caml_string_of_jsbytes("SCISSOR_TEST"),
     cst_POLYGON_OFFSET_FILL=caml_string_of_jsbytes("POLYGON_OFFSET_FILL"),
     cst_SAMPLE_ALPHA_TO_COVERAGE=
      caml_string_of_jsbytes("SAMPLE_ALPHA_TO_COVERAGE"),
     cst_SAMPLE_COVERAGE=caml_string_of_jsbytes("SAMPLE_COVERAGE"),
     cst_NO_ERROR=caml_string_of_jsbytes("NO_ERROR"),
     cst_INVALID_ENUM=caml_string_of_jsbytes("INVALID_ENUM"),
     cst_INVALID_VALUE=caml_string_of_jsbytes("INVALID_VALUE"),
     cst_INVALID_OPERATION=caml_string_of_jsbytes("INVALID_OPERATION"),
     cst_OUT_OF_MEMORY=caml_string_of_jsbytes("OUT_OF_MEMORY"),
     cst_CW=caml_string_of_jsbytes("CW"),
     cst_CCW=caml_string_of_jsbytes("CCW"),
     cst_LINE_WIDTH=caml_string_of_jsbytes("LINE_WIDTH"),
     cst_ALIASED_POINT_SIZE_RANGE=
      caml_string_of_jsbytes("ALIASED_POINT_SIZE_RANGE"),
     cst_ALIASED_LINE_WIDTH_RANGE=
      caml_string_of_jsbytes("ALIASED_LINE_WIDTH_RANGE"),
     cst_CULL_FACE_MODE=caml_string_of_jsbytes("CULL_FACE_MODE"),
     cst_FRONT_FACE=caml_string_of_jsbytes("FRONT_FACE"),
     cst_DEPTH_RANGE=caml_string_of_jsbytes("DEPTH_RANGE"),
     cst_DEPTH_WRITEMASK=caml_string_of_jsbytes("DEPTH_WRITEMASK"),
     cst_DEPTH_CLEAR_VALUE=caml_string_of_jsbytes("DEPTH_CLEAR_VALUE"),
     cst_DEPTH_FUNC=caml_string_of_jsbytes("DEPTH_FUNC"),
     cst_STENCIL_CLEAR_VALUE=caml_string_of_jsbytes("STENCIL_CLEAR_VALUE"),
     cst_STENCIL_FUNC=caml_string_of_jsbytes("STENCIL_FUNC"),
     cst_STENCIL_FAIL=caml_string_of_jsbytes("STENCIL_FAIL"),
     cst_STENCIL_PASS_DEPTH_FAIL=
      caml_string_of_jsbytes("STENCIL_PASS_DEPTH_FAIL"),
     cst_STENCIL_PASS_DEPTH_PASS=
      caml_string_of_jsbytes("STENCIL_PASS_DEPTH_PASS"),
     cst_STENCIL_REF=caml_string_of_jsbytes("STENCIL_REF"),
     cst_STENCIL_VALUE_MASK=caml_string_of_jsbytes("STENCIL_VALUE_MASK"),
     cst_STENCIL_WRITEMASK=caml_string_of_jsbytes("STENCIL_WRITEMASK"),
     cst_STENCIL_BACK_FUNC=caml_string_of_jsbytes("STENCIL_BACK_FUNC"),
     cst_STENCIL_BACK_FAIL=caml_string_of_jsbytes("STENCIL_BACK_FAIL"),
     cst_STENCIL_BACK_PASS_DEPTH_FA=
      caml_string_of_jsbytes("STENCIL_BACK_PASS_DEPTH_FAIL"),
     cst_STENCIL_BACK_PASS_DEPTH_PA=
      caml_string_of_jsbytes("STENCIL_BACK_PASS_DEPTH_PASS"),
     cst_STENCIL_BACK_REF=caml_string_of_jsbytes("STENCIL_BACK_REF"),
     cst_STENCIL_BACK_VALUE_MASK=
      caml_string_of_jsbytes("STENCIL_BACK_VALUE_MASK"),
     cst_STENCIL_BACK_WRITEMASK=
      caml_string_of_jsbytes("STENCIL_BACK_WRITEMASK"),
     cst_VIEWPORT=caml_string_of_jsbytes("VIEWPORT"),
     cst_SCISSOR_BOX=caml_string_of_jsbytes("SCISSOR_BOX"),
     cst_COLOR_CLEAR_VALUE=caml_string_of_jsbytes("COLOR_CLEAR_VALUE"),
     cst_COLOR_WRITEMASK=caml_string_of_jsbytes("COLOR_WRITEMASK"),
     cst_UNPACK_ALIGNMENT=caml_string_of_jsbytes("UNPACK_ALIGNMENT"),
     cst_PACK_ALIGNMENT=caml_string_of_jsbytes("PACK_ALIGNMENT"),
     cst_MAX_TEXTURE_SIZE=caml_string_of_jsbytes("MAX_TEXTURE_SIZE"),
     cst_MAX_VIEWPORT_DIMS=caml_string_of_jsbytes("MAX_VIEWPORT_DIMS"),
     cst_SUBPIXEL_BITS=caml_string_of_jsbytes("SUBPIXEL_BITS"),
     cst_RED_BITS=caml_string_of_jsbytes("RED_BITS"),
     cst_GREEN_BITS=caml_string_of_jsbytes("GREEN_BITS"),
     cst_BLUE_BITS=caml_string_of_jsbytes("BLUE_BITS"),
     cst_ALPHA_BITS=caml_string_of_jsbytes("ALPHA_BITS"),
     cst_DEPTH_BITS=caml_string_of_jsbytes("DEPTH_BITS"),
     cst_STENCIL_BITS=caml_string_of_jsbytes("STENCIL_BITS"),
     cst_POLYGON_OFFSET_UNITS=caml_string_of_jsbytes("POLYGON_OFFSET_UNITS"),
     cst_POLYGON_OFFSET_FACTOR=caml_string_of_jsbytes("POLYGON_OFFSET_FACTOR"),
     cst_TEXTURE_BINDING_2D=caml_string_of_jsbytes("TEXTURE_BINDING_2D"),
     cst_SAMPLE_BUFFERS=caml_string_of_jsbytes("SAMPLE_BUFFERS"),
     cst_SAMPLES=caml_string_of_jsbytes("SAMPLES"),
     cst_SAMPLE_COVERAGE_VALUE=caml_string_of_jsbytes("SAMPLE_COVERAGE_VALUE"),
     cst_SAMPLE_COVERAGE_INVERT=
      caml_string_of_jsbytes("SAMPLE_COVERAGE_INVERT"),
     cst_COMPRESSED_TEXTURE_FORMATS=
      caml_string_of_jsbytes("COMPRESSED_TEXTURE_FORMATS"),
     cst_DONT_CARE=caml_string_of_jsbytes("DONT_CARE"),
     cst_FASTEST=caml_string_of_jsbytes("FASTEST"),
     cst_NICEST=caml_string_of_jsbytes("NICEST"),
     cst_GENERATE_MIPMAP_HINT=caml_string_of_jsbytes("GENERATE_MIPMAP_HINT"),
     cst_BYTE=caml_string_of_jsbytes("BYTE"),
     cst_UNSIGNED_BYTE=caml_string_of_jsbytes("UNSIGNED_BYTE"),
     cst_SHORT=caml_string_of_jsbytes("SHORT"),
     cst_UNSIGNED_SHORT=caml_string_of_jsbytes("UNSIGNED_SHORT"),
     cst_INT=caml_string_of_jsbytes("INT"),
     cst_UNSIGNED_INT=caml_string_of_jsbytes("UNSIGNED_INT"),
     cst_FLOAT=caml_string_of_jsbytes("FLOAT"),
     cst_DEPTH_COMPONENT=caml_string_of_jsbytes("DEPTH_COMPONENT"),
     cst_ALPHA=caml_string_of_jsbytes("ALPHA"),
     cst_RGB=caml_string_of_jsbytes("RGB"),
     cst_RGBA=caml_string_of_jsbytes("RGBA"),
     cst_LUMINANCE=caml_string_of_jsbytes("LUMINANCE"),
     cst_LUMINANCE_ALPHA=caml_string_of_jsbytes("LUMINANCE_ALPHA"),
     cst_UNSIGNED_SHORT_4_4_4_4=
      caml_string_of_jsbytes("UNSIGNED_SHORT_4_4_4_4"),
     cst_UNSIGNED_SHORT_5_5_5_1=
      caml_string_of_jsbytes("UNSIGNED_SHORT_5_5_5_1"),
     cst_UNSIGNED_SHORT_5_6_5=caml_string_of_jsbytes("UNSIGNED_SHORT_5_6_5"),
     cst_FRAGMENT_SHADER=caml_string_of_jsbytes("FRAGMENT_SHADER"),
     cst_VERTEX_SHADER=caml_string_of_jsbytes("VERTEX_SHADER"),
     cst_MAX_VERTEX_ATTRIBS=caml_string_of_jsbytes("MAX_VERTEX_ATTRIBS"),
     cst_MAX_VERTEX_UNIFORM_VECTORS=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_VECTORS"),
     cst_MAX_VARYING_VECTORS=caml_string_of_jsbytes("MAX_VARYING_VECTORS"),
     cst_MAX_COMBINED_TEXTURE_IMAGE=
      caml_string_of_jsbytes("MAX_COMBINED_TEXTURE_IMAGE_UNITS"),
     cst_MAX_VERTEX_TEXTURE_IMAGE_U=
      caml_string_of_jsbytes("MAX_VERTEX_TEXTURE_IMAGE_UNITS"),
     cst_MAX_TEXTURE_IMAGE_UNITS=
      caml_string_of_jsbytes("MAX_TEXTURE_IMAGE_UNITS"),
     cst_MAX_FRAGMENT_UNIFORM_VECTO=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_VECTORS"),
     cst_SHADER_TYPE=caml_string_of_jsbytes("SHADER_TYPE"),
     cst_DELETE_STATUS=caml_string_of_jsbytes("DELETE_STATUS"),
     cst_LINK_STATUS=caml_string_of_jsbytes("LINK_STATUS"),
     cst_VALIDATE_STATUS=caml_string_of_jsbytes("VALIDATE_STATUS"),
     cst_ATTACHED_SHADERS=caml_string_of_jsbytes("ATTACHED_SHADERS"),
     cst_ACTIVE_UNIFORMS=caml_string_of_jsbytes("ACTIVE_UNIFORMS"),
     cst_ACTIVE_ATTRIBUTES=caml_string_of_jsbytes("ACTIVE_ATTRIBUTES"),
     cst_SHADING_LANGUAGE_VERSION=
      caml_string_of_jsbytes("SHADING_LANGUAGE_VERSION"),
     cst_CURRENT_PROGRAM=caml_string_of_jsbytes("CURRENT_PROGRAM"),
     cst_NEVER=caml_string_of_jsbytes("NEVER"),
     cst_LESS=caml_string_of_jsbytes("LESS"),
     cst_EQUAL=caml_string_of_jsbytes("EQUAL"),
     cst_LEQUAL=caml_string_of_jsbytes("LEQUAL"),
     cst_GREATER=caml_string_of_jsbytes("GREATER"),
     cst_NOTEQUAL=caml_string_of_jsbytes("NOTEQUAL"),
     cst_GEQUAL=caml_string_of_jsbytes("GEQUAL"),
     cst_ALWAYS=caml_string_of_jsbytes("ALWAYS"),
     cst_KEEP=caml_string_of_jsbytes("KEEP"),
     cst_REPLACE=caml_string_of_jsbytes("REPLACE"),
     cst_INCR=caml_string_of_jsbytes("INCR"),
     cst_DECR=caml_string_of_jsbytes("DECR"),
     cst_INVERT=caml_string_of_jsbytes("INVERT"),
     cst_INCR_WRAP=caml_string_of_jsbytes("INCR_WRAP"),
     cst_DECR_WRAP=caml_string_of_jsbytes("DECR_WRAP"),
     cst_VENDOR=caml_string_of_jsbytes("VENDOR"),
     cst_RENDERER=caml_string_of_jsbytes("RENDERER"),
     cst_VERSION=caml_string_of_jsbytes("VERSION"),
     cst_NEAREST=caml_string_of_jsbytes("NEAREST"),
     cst_LINEAR=caml_string_of_jsbytes("LINEAR"),
     cst_NEAREST_MIPMAP_NEAREST=
      caml_string_of_jsbytes("NEAREST_MIPMAP_NEAREST"),
     cst_LINEAR_MIPMAP_NEAREST=caml_string_of_jsbytes("LINEAR_MIPMAP_NEAREST"),
     cst_NEAREST_MIPMAP_LINEAR=caml_string_of_jsbytes("NEAREST_MIPMAP_LINEAR"),
     cst_LINEAR_MIPMAP_LINEAR=caml_string_of_jsbytes("LINEAR_MIPMAP_LINEAR"),
     cst_TEXTURE_MAG_FILTER=caml_string_of_jsbytes("TEXTURE_MAG_FILTER"),
     cst_TEXTURE_MIN_FILTER=caml_string_of_jsbytes("TEXTURE_MIN_FILTER"),
     cst_TEXTURE_WRAP_S=caml_string_of_jsbytes("TEXTURE_WRAP_S"),
     cst_TEXTURE_WRAP_T=caml_string_of_jsbytes("TEXTURE_WRAP_T"),
     cst_TEXTURE_2D=caml_string_of_jsbytes("TEXTURE_2D"),
     cst_TEXTURE=caml_string_of_jsbytes("TEXTURE"),
     cst_TEXTURE_CUBE_MAP=caml_string_of_jsbytes("TEXTURE_CUBE_MAP"),
     cst_TEXTURE_BINDING_CUBE_MAP=
      caml_string_of_jsbytes("TEXTURE_BINDING_CUBE_MAP"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_X"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_X"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_$0=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_Y"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_$0=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_Y"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_$1=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_Z"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_$1=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_Z"),
     cst_MAX_CUBE_MAP_TEXTURE_SIZE=
      caml_string_of_jsbytes("MAX_CUBE_MAP_TEXTURE_SIZE"),
     cst_TEXTURE0=caml_string_of_jsbytes("TEXTURE0"),
     cst_TEXTURE1=caml_string_of_jsbytes("TEXTURE1"),
     cst_TEXTURE2=caml_string_of_jsbytes("TEXTURE2"),
     cst_TEXTURE3=caml_string_of_jsbytes("TEXTURE3"),
     cst_TEXTURE4=caml_string_of_jsbytes("TEXTURE4"),
     cst_TEXTURE5=caml_string_of_jsbytes("TEXTURE5"),
     cst_TEXTURE6=caml_string_of_jsbytes("TEXTURE6"),
     cst_TEXTURE7=caml_string_of_jsbytes("TEXTURE7"),
     cst_TEXTURE8=caml_string_of_jsbytes("TEXTURE8"),
     cst_TEXTURE9=caml_string_of_jsbytes("TEXTURE9"),
     cst_TEXTURE10=caml_string_of_jsbytes("TEXTURE10"),
     cst_TEXTURE11=caml_string_of_jsbytes("TEXTURE11"),
     cst_TEXTURE12=caml_string_of_jsbytes("TEXTURE12"),
     cst_TEXTURE13=caml_string_of_jsbytes("TEXTURE13"),
     cst_TEXTURE14=caml_string_of_jsbytes("TEXTURE14"),
     cst_TEXTURE15=caml_string_of_jsbytes("TEXTURE15"),
     cst_TEXTURE16=caml_string_of_jsbytes("TEXTURE16"),
     cst_TEXTURE17=caml_string_of_jsbytes("TEXTURE17"),
     cst_TEXTURE18=caml_string_of_jsbytes("TEXTURE18"),
     cst_TEXTURE19=caml_string_of_jsbytes("TEXTURE19"),
     cst_TEXTURE20=caml_string_of_jsbytes("TEXTURE20"),
     cst_TEXTURE21=caml_string_of_jsbytes("TEXTURE21"),
     cst_TEXTURE22=caml_string_of_jsbytes("TEXTURE22"),
     cst_TEXTURE23=caml_string_of_jsbytes("TEXTURE23"),
     cst_TEXTURE24=caml_string_of_jsbytes("TEXTURE24"),
     cst_TEXTURE25=caml_string_of_jsbytes("TEXTURE25"),
     cst_TEXTURE26=caml_string_of_jsbytes("TEXTURE26"),
     cst_TEXTURE27=caml_string_of_jsbytes("TEXTURE27"),
     cst_TEXTURE28=caml_string_of_jsbytes("TEXTURE28"),
     cst_TEXTURE29=caml_string_of_jsbytes("TEXTURE29"),
     cst_TEXTURE30=caml_string_of_jsbytes("TEXTURE30"),
     cst_TEXTURE31=caml_string_of_jsbytes("TEXTURE31"),
     cst_ACTIVE_TEXTURE=caml_string_of_jsbytes("ACTIVE_TEXTURE"),
     cst_REPEAT=caml_string_of_jsbytes("REPEAT"),
     cst_CLAMP_TO_EDGE=caml_string_of_jsbytes("CLAMP_TO_EDGE"),
     cst_MIRRORED_REPEAT=caml_string_of_jsbytes("MIRRORED_REPEAT"),
     cst_FLOAT_VEC2=caml_string_of_jsbytes("FLOAT_VEC2"),
     cst_FLOAT_VEC3=caml_string_of_jsbytes("FLOAT_VEC3"),
     cst_FLOAT_VEC4=caml_string_of_jsbytes("FLOAT_VEC4"),
     cst_INT_VEC2=caml_string_of_jsbytes("INT_VEC2"),
     cst_INT_VEC3=caml_string_of_jsbytes("INT_VEC3"),
     cst_INT_VEC4=caml_string_of_jsbytes("INT_VEC4"),
     cst_BOOL=caml_string_of_jsbytes("BOOL"),
     cst_BOOL_VEC2=caml_string_of_jsbytes("BOOL_VEC2"),
     cst_BOOL_VEC3=caml_string_of_jsbytes("BOOL_VEC3"),
     cst_BOOL_VEC4=caml_string_of_jsbytes("BOOL_VEC4"),
     cst_FLOAT_MAT2=caml_string_of_jsbytes("FLOAT_MAT2"),
     cst_FLOAT_MAT3=caml_string_of_jsbytes("FLOAT_MAT3"),
     cst_FLOAT_MAT4=caml_string_of_jsbytes("FLOAT_MAT4"),
     cst_SAMPLER_2D=caml_string_of_jsbytes("SAMPLER_2D"),
     cst_SAMPLER_CUBE=caml_string_of_jsbytes("SAMPLER_CUBE"),
     cst_VERTEX_ATTRIB_ARRAY_ENABLE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_ENABLED"),
     cst_VERTEX_ATTRIB_ARRAY_SIZE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_SIZE"),
     cst_VERTEX_ATTRIB_ARRAY_STRIDE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_STRIDE"),
     cst_VERTEX_ATTRIB_ARRAY_TYPE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_TYPE"),
     cst_VERTEX_ATTRIB_ARRAY_NORMAL=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_NORMALIZED"),
     cst_VERTEX_ATTRIB_ARRAY_POINTE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_POINTER"),
     cst_VERTEX_ATTRIB_ARRAY_BUFFER=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"),
     cst_IMPLEMENTATION_COLOR_READ_=
      caml_string_of_jsbytes("IMPLEMENTATION_COLOR_READ_TYPE"),
     cst_IMPLEMENTATION_COLOR_READ_$0=
      caml_string_of_jsbytes("IMPLEMENTATION_COLOR_READ_FORMAT"),
     cst_COMPILE_STATUS=caml_string_of_jsbytes("COMPILE_STATUS"),
     cst_LOW_FLOAT=caml_string_of_jsbytes("LOW_FLOAT"),
     cst_MEDIUM_FLOAT=caml_string_of_jsbytes("MEDIUM_FLOAT"),
     cst_HIGH_FLOAT=caml_string_of_jsbytes("HIGH_FLOAT"),
     cst_LOW_INT=caml_string_of_jsbytes("LOW_INT"),
     cst_MEDIUM_INT=caml_string_of_jsbytes("MEDIUM_INT"),
     cst_HIGH_INT=caml_string_of_jsbytes("HIGH_INT"),
     cst_FRAMEBUFFER=caml_string_of_jsbytes("FRAMEBUFFER"),
     cst_RENDERBUFFER=caml_string_of_jsbytes("RENDERBUFFER"),
     cst_RGBA4=caml_string_of_jsbytes("RGBA4"),
     cst_RGB5_A1=caml_string_of_jsbytes("RGB5_A1"),
     cst_RGB565=caml_string_of_jsbytes("RGB565"),
     cst_DEPTH_COMPONENT16=caml_string_of_jsbytes("DEPTH_COMPONENT16"),
     cst_STENCIL_INDEX8=caml_string_of_jsbytes("STENCIL_INDEX8"),
     cst_DEPTH_STENCIL=caml_string_of_jsbytes("DEPTH_STENCIL"),
     cst_RENDERBUFFER_WIDTH=caml_string_of_jsbytes("RENDERBUFFER_WIDTH"),
     cst_RENDERBUFFER_HEIGHT=caml_string_of_jsbytes("RENDERBUFFER_HEIGHT"),
     cst_RENDERBUFFER_INTERNAL_FORM=
      caml_string_of_jsbytes("RENDERBUFFER_INTERNAL_FORMAT"),
     cst_RENDERBUFFER_RED_SIZE=caml_string_of_jsbytes("RENDERBUFFER_RED_SIZE"),
     cst_RENDERBUFFER_GREEN_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_GREEN_SIZE"),
     cst_RENDERBUFFER_BLUE_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_BLUE_SIZE"),
     cst_RENDERBUFFER_ALPHA_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_ALPHA_SIZE"),
     cst_RENDERBUFFER_DEPTH_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_DEPTH_SIZE"),
     cst_RENDERBUFFER_STENCIL_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_STENCIL_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_OBJ=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"),
     cst_FRAMEBUFFER_ATTACHMENT_OBJ$0=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX$0=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"),
     cst_COLOR_ATTACHMENT0=caml_string_of_jsbytes("COLOR_ATTACHMENT0"),
     cst_DEPTH_ATTACHMENT=caml_string_of_jsbytes("DEPTH_ATTACHMENT"),
     cst_STENCIL_ATTACHMENT=caml_string_of_jsbytes("STENCIL_ATTACHMENT"),
     cst_DEPTH_STENCIL_ATTACHMENT=
      caml_string_of_jsbytes("DEPTH_STENCIL_ATTACHMENT"),
     cst_NONE=caml_string_of_jsbytes("NONE"),
     cst_FRAMEBUFFER_COMPLETE=caml_string_of_jsbytes("FRAMEBUFFER_COMPLETE"),
     cst_FRAMEBUFFER_INCOMPLETE_ATT=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_ATTACHMENT"),
     cst_FRAMEBUFFER_INCOMPLETE_MIS=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"),
     cst_FRAMEBUFFER_INCOMPLETE_DIM=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_DIMENSIONS"),
     cst_FRAMEBUFFER_UNSUPPORTED=
      caml_string_of_jsbytes("FRAMEBUFFER_UNSUPPORTED"),
     cst_FRAMEBUFFER_BINDING=caml_string_of_jsbytes("FRAMEBUFFER_BINDING"),
     cst_RENDERBUFFER_BINDING=caml_string_of_jsbytes("RENDERBUFFER_BINDING"),
     cst_MAX_RENDERBUFFER_SIZE=caml_string_of_jsbytes("MAX_RENDERBUFFER_SIZE"),
     cst_INVALID_FRAMEBUFFER_OPERAT=
      caml_string_of_jsbytes("INVALID_FRAMEBUFFER_OPERATION"),
     cst_UNPACK_FLIP_Y_WEBGL=caml_string_of_jsbytes("UNPACK_FLIP_Y_WEBGL"),
     cst_UNPACK_PREMULTIPLY_ALPHA_W=
      caml_string_of_jsbytes("UNPACK_PREMULTIPLY_ALPHA_WEBGL"),
     cst_CONTEXT_LOST_WEBGL=caml_string_of_jsbytes("CONTEXT_LOST_WEBGL"),
     cst_UNPACK_COLORSPACE_CONVERSI=
      caml_string_of_jsbytes("UNPACK_COLORSPACE_CONVERSION_WEBGL"),
     cst_BROWSER_DEFAULT_WEBGL=caml_string_of_jsbytes("BROWSER_DEFAULT_WEBGL"),
     cst_READ_BUFFER=caml_string_of_jsbytes("READ_BUFFER"),
     cst_UNPACK_ROW_LENGTH=caml_string_of_jsbytes("UNPACK_ROW_LENGTH"),
     cst_UNPACK_SKIP_ROWS=caml_string_of_jsbytes("UNPACK_SKIP_ROWS"),
     cst_UNPACK_SKIP_PIXELS=caml_string_of_jsbytes("UNPACK_SKIP_PIXELS"),
     cst_PACK_ROW_LENGTH=caml_string_of_jsbytes("PACK_ROW_LENGTH"),
     cst_PACK_SKIP_ROWS=caml_string_of_jsbytes("PACK_SKIP_ROWS"),
     cst_PACK_SKIP_PIXELS=caml_string_of_jsbytes("PACK_SKIP_PIXELS"),
     cst_COLOR=caml_string_of_jsbytes("COLOR"),
     cst_DEPTH=caml_string_of_jsbytes("DEPTH"),
     cst_STENCIL=caml_string_of_jsbytes("STENCIL"),
     cst_RED=caml_string_of_jsbytes("RED"),
     cst_RGB8=caml_string_of_jsbytes("RGB8"),
     cst_RGBA8=caml_string_of_jsbytes("RGBA8"),
     cst_RGB10_A2=caml_string_of_jsbytes("RGB10_A2"),
     cst_TEXTURE_BINDING_3D=caml_string_of_jsbytes("TEXTURE_BINDING_3D"),
     cst_UNPACK_SKIP_IMAGES=caml_string_of_jsbytes("UNPACK_SKIP_IMAGES"),
     cst_UNPACK_IMAGE_HEIGHT=caml_string_of_jsbytes("UNPACK_IMAGE_HEIGHT"),
     cst_TEXTURE_3D=caml_string_of_jsbytes("TEXTURE_3D"),
     cst_TEXTURE_WRAP_R=caml_string_of_jsbytes("TEXTURE_WRAP_R"),
     cst_MAX_3D_TEXTURE_SIZE=caml_string_of_jsbytes("MAX_3D_TEXTURE_SIZE"),
     cst_UNSIGNED_INT_2_10_10_10_RE=
      caml_string_of_jsbytes("UNSIGNED_INT_2_10_10_10_REV"),
     cst_MAX_ELEMENTS_VERTICES=caml_string_of_jsbytes("MAX_ELEMENTS_VERTICES"),
     cst_MAX_ELEMENTS_INDICES=caml_string_of_jsbytes("MAX_ELEMENTS_INDICES"),
     cst_TEXTURE_MIN_LOD=caml_string_of_jsbytes("TEXTURE_MIN_LOD"),
     cst_TEXTURE_MAX_LOD=caml_string_of_jsbytes("TEXTURE_MAX_LOD"),
     cst_TEXTURE_BASE_LEVEL=caml_string_of_jsbytes("TEXTURE_BASE_LEVEL"),
     cst_TEXTURE_MAX_LEVEL=caml_string_of_jsbytes("TEXTURE_MAX_LEVEL"),
     cst_MIN=caml_string_of_jsbytes("MIN"),
     cst_MAX=caml_string_of_jsbytes("MAX"),
     cst_DEPTH_COMPONENT24=caml_string_of_jsbytes("DEPTH_COMPONENT24"),
     cst_MAX_TEXTURE_LOD_BIAS=caml_string_of_jsbytes("MAX_TEXTURE_LOD_BIAS"),
     cst_TEXTURE_COMPARE_MODE=caml_string_of_jsbytes("TEXTURE_COMPARE_MODE"),
     cst_TEXTURE_COMPARE_FUNC=caml_string_of_jsbytes("TEXTURE_COMPARE_FUNC"),
     cst_CURRENT_QUERY=caml_string_of_jsbytes("CURRENT_QUERY"),
     cst_QUERY_RESULT=caml_string_of_jsbytes("QUERY_RESULT"),
     cst_QUERY_RESULT_AVAILABLE=
      caml_string_of_jsbytes("QUERY_RESULT_AVAILABLE"),
     cst_STREAM_READ=caml_string_of_jsbytes("STREAM_READ"),
     cst_STREAM_COPY=caml_string_of_jsbytes("STREAM_COPY"),
     cst_STATIC_READ=caml_string_of_jsbytes("STATIC_READ"),
     cst_STATIC_COPY=caml_string_of_jsbytes("STATIC_COPY"),
     cst_DYNAMIC_READ=caml_string_of_jsbytes("DYNAMIC_READ"),
     cst_DYNAMIC_COPY=caml_string_of_jsbytes("DYNAMIC_COPY"),
     cst_MAX_DRAW_BUFFERS=caml_string_of_jsbytes("MAX_DRAW_BUFFERS"),
     cst_DRAW_BUFFER0=caml_string_of_jsbytes("DRAW_BUFFER0"),
     cst_DRAW_BUFFER1=caml_string_of_jsbytes("DRAW_BUFFER1"),
     cst_DRAW_BUFFER2=caml_string_of_jsbytes("DRAW_BUFFER2"),
     cst_DRAW_BUFFER3=caml_string_of_jsbytes("DRAW_BUFFER3"),
     cst_DRAW_BUFFER4=caml_string_of_jsbytes("DRAW_BUFFER4"),
     cst_DRAW_BUFFER5=caml_string_of_jsbytes("DRAW_BUFFER5"),
     cst_DRAW_BUFFER6=caml_string_of_jsbytes("DRAW_BUFFER6"),
     cst_DRAW_BUFFER7=caml_string_of_jsbytes("DRAW_BUFFER7"),
     cst_DRAW_BUFFER8=caml_string_of_jsbytes("DRAW_BUFFER8"),
     cst_DRAW_BUFFER9=caml_string_of_jsbytes("DRAW_BUFFER9"),
     cst_DRAW_BUFFER10=caml_string_of_jsbytes("DRAW_BUFFER10"),
     cst_DRAW_BUFFER11=caml_string_of_jsbytes("DRAW_BUFFER11"),
     cst_DRAW_BUFFER12=caml_string_of_jsbytes("DRAW_BUFFER12"),
     cst_DRAW_BUFFER13=caml_string_of_jsbytes("DRAW_BUFFER13"),
     cst_DRAW_BUFFER14=caml_string_of_jsbytes("DRAW_BUFFER14"),
     cst_DRAW_BUFFER15=caml_string_of_jsbytes("DRAW_BUFFER15"),
     cst_MAX_FRAGMENT_UNIFORM_COMPO=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_COMPONENTS"),
     cst_MAX_VERTEX_UNIFORM_COMPONE=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_COMPONENTS"),
     cst_SAMPLER_3D=caml_string_of_jsbytes("SAMPLER_3D"),
     cst_SAMPLER_2D_SHADOW=caml_string_of_jsbytes("SAMPLER_2D_SHADOW"),
     cst_FRAGMENT_SHADER_DERIVATIVE=
      caml_string_of_jsbytes("FRAGMENT_SHADER_DERIVATIVE_HINT"),
     cst_PIXEL_PACK_BUFFER=caml_string_of_jsbytes("PIXEL_PACK_BUFFER"),
     cst_PIXEL_UNPACK_BUFFER=caml_string_of_jsbytes("PIXEL_UNPACK_BUFFER"),
     cst_PIXEL_PACK_BUFFER_BINDING=
      caml_string_of_jsbytes("PIXEL_PACK_BUFFER_BINDING"),
     cst_PIXEL_UNPACK_BUFFER_BINDIN=
      caml_string_of_jsbytes("PIXEL_UNPACK_BUFFER_BINDING"),
     cst_FLOAT_MAT2x3=caml_string_of_jsbytes("FLOAT_MAT2x3"),
     cst_FLOAT_MAT2x4=caml_string_of_jsbytes("FLOAT_MAT2x4"),
     cst_FLOAT_MAT3x2=caml_string_of_jsbytes("FLOAT_MAT3x2"),
     cst_FLOAT_MAT3x4=caml_string_of_jsbytes("FLOAT_MAT3x4"),
     cst_FLOAT_MAT4x2=caml_string_of_jsbytes("FLOAT_MAT4x2"),
     cst_FLOAT_MAT4x3=caml_string_of_jsbytes("FLOAT_MAT4x3"),
     cst_SRGB=caml_string_of_jsbytes("SRGB"),
     cst_SRGB8=caml_string_of_jsbytes("SRGB8"),
     cst_SRGB8_ALPHA8=caml_string_of_jsbytes("SRGB8_ALPHA8"),
     cst_COMPARE_REF_TO_TEXTURE=
      caml_string_of_jsbytes("COMPARE_REF_TO_TEXTURE"),
     cst_RGBA32F=caml_string_of_jsbytes("RGBA32F"),
     cst_RGB32F=caml_string_of_jsbytes("RGB32F"),
     cst_RGBA16F=caml_string_of_jsbytes("RGBA16F"),
     cst_RGB16F=caml_string_of_jsbytes("RGB16F"),
     cst_VERTEX_ATTRIB_ARRAY_INTEGE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_INTEGER"),
     cst_MAX_ARRAY_TEXTURE_LAYERS=
      caml_string_of_jsbytes("MAX_ARRAY_TEXTURE_LAYERS"),
     cst_MIN_PROGRAM_TEXEL_OFFSET=
      caml_string_of_jsbytes("MIN_PROGRAM_TEXEL_OFFSET"),
     cst_MAX_PROGRAM_TEXEL_OFFSET=
      caml_string_of_jsbytes("MAX_PROGRAM_TEXEL_OFFSET"),
     cst_MAX_VARYING_COMPONENTS=
      caml_string_of_jsbytes("MAX_VARYING_COMPONENTS"),
     cst_TEXTURE_2D_ARRAY=caml_string_of_jsbytes("TEXTURE_2D_ARRAY"),
     cst_TEXTURE_BINDING_2D_ARRAY=
      caml_string_of_jsbytes("TEXTURE_BINDING_2D_ARRAY"),
     cst_R11F_G11F_B10F=caml_string_of_jsbytes("R11F_G11F_B10F"),
     cst_UNSIGNED_INT_10F_11F_11F_R=
      caml_string_of_jsbytes("UNSIGNED_INT_10F_11F_11F_REV"),
     cst_RGB9_E5=caml_string_of_jsbytes("RGB9_E5"),
     cst_UNSIGNED_INT_5_9_9_9_REV=
      caml_string_of_jsbytes("UNSIGNED_INT_5_9_9_9_REV"),
     cst_TRANSFORM_FEEDBACK_BUFFER_=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_MODE"),
     cst_MAX_TRANSFORM_FEEDBACK_SEP=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"),
     cst_TRANSFORM_FEEDBACK_VARYING=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_VARYINGS"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$0=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_START"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$1=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_SIZE"),
     cst_TRANSFORM_FEEDBACK_PRIMITI=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"),
     cst_RASTERIZER_DISCARD=caml_string_of_jsbytes("RASTERIZER_DISCARD"),
     cst_MAX_TRANSFORM_FEEDBACK_INT=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"),
     cst_MAX_TRANSFORM_FEEDBACK_SEP$0=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"),
     cst_INTERLEAVED_ATTRIBS=caml_string_of_jsbytes("INTERLEAVED_ATTRIBS"),
     cst_SEPARATE_ATTRIBS=caml_string_of_jsbytes("SEPARATE_ATTRIBS"),
     cst_TRANSFORM_FEEDBACK_BUFFER=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$2=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_BINDING"),
     cst_RGBA32UI=caml_string_of_jsbytes("RGBA32UI"),
     cst_RGB32UI=caml_string_of_jsbytes("RGB32UI"),
     cst_RGBA16UI=caml_string_of_jsbytes("RGBA16UI"),
     cst_RGB16UI=caml_string_of_jsbytes("RGB16UI"),
     cst_RGBA8UI=caml_string_of_jsbytes("RGBA8UI"),
     cst_RGB8UI=caml_string_of_jsbytes("RGB8UI"),
     cst_RGBA32I=caml_string_of_jsbytes("RGBA32I"),
     cst_RGB32I=caml_string_of_jsbytes("RGB32I"),
     cst_RGBA16I=caml_string_of_jsbytes("RGBA16I"),
     cst_RGB16I=caml_string_of_jsbytes("RGB16I"),
     cst_RGBA8I=caml_string_of_jsbytes("RGBA8I"),
     cst_RGB8I=caml_string_of_jsbytes("RGB8I"),
     cst_RED_INTEGER=caml_string_of_jsbytes("RED_INTEGER"),
     cst_RGB_INTEGER=caml_string_of_jsbytes("RGB_INTEGER"),
     cst_RGBA_INTEGER=caml_string_of_jsbytes("RGBA_INTEGER"),
     cst_SAMPLER_2D_ARRAY=caml_string_of_jsbytes("SAMPLER_2D_ARRAY"),
     cst_SAMPLER_2D_ARRAY_SHADOW=
      caml_string_of_jsbytes("SAMPLER_2D_ARRAY_SHADOW"),
     cst_SAMPLER_CUBE_SHADOW=caml_string_of_jsbytes("SAMPLER_CUBE_SHADOW"),
     cst_UNSIGNED_INT_VEC2=caml_string_of_jsbytes("UNSIGNED_INT_VEC2"),
     cst_UNSIGNED_INT_VEC3=caml_string_of_jsbytes("UNSIGNED_INT_VEC3"),
     cst_UNSIGNED_INT_VEC4=caml_string_of_jsbytes("UNSIGNED_INT_VEC4"),
     cst_INT_SAMPLER_2D=caml_string_of_jsbytes("INT_SAMPLER_2D"),
     cst_INT_SAMPLER_3D=caml_string_of_jsbytes("INT_SAMPLER_3D"),
     cst_INT_SAMPLER_CUBE=caml_string_of_jsbytes("INT_SAMPLER_CUBE"),
     cst_INT_SAMPLER_2D_ARRAY=caml_string_of_jsbytes("INT_SAMPLER_2D_ARRAY"),
     cst_UNSIGNED_INT_SAMPLER_2D=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_2D"),
     cst_UNSIGNED_INT_SAMPLER_3D=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_3D"),
     cst_UNSIGNED_INT_SAMPLER_CUBE=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_CUBE"),
     cst_UNSIGNED_INT_SAMPLER_2D_AR=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_2D_ARRAY"),
     cst_DEPTH_COMPONENT32F=caml_string_of_jsbytes("DEPTH_COMPONENT32F"),
     cst_DEPTH32F_STENCIL8=caml_string_of_jsbytes("DEPTH32F_STENCIL8"),
     cst_FLOAT_32_UNSIGNED_INT_24_8=
      caml_string_of_jsbytes("FLOAT_32_UNSIGNED_INT_24_8_REV"),
     cst_FRAMEBUFFER_ATTACHMENT_COL=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"),
     cst_FRAMEBUFFER_ATTACHMENT_COM=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"),
     cst_FRAMEBUFFER_ATTACHMENT_RED=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_RED_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_GRE=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_BLU=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_ALP=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_DEP=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_STE=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"),
     cst_FRAMEBUFFER_DEFAULT=caml_string_of_jsbytes("FRAMEBUFFER_DEFAULT"),
     cst_UNSIGNED_INT_24_8=caml_string_of_jsbytes("UNSIGNED_INT_24_8"),
     cst_DEPTH24_STENCIL8=caml_string_of_jsbytes("DEPTH24_STENCIL8"),
     cst_UNSIGNED_NORMALIZED=caml_string_of_jsbytes("UNSIGNED_NORMALIZED"),
     cst_DRAW_FRAMEBUFFER_BINDING=
      caml_string_of_jsbytes("DRAW_FRAMEBUFFER_BINDING"),
     cst_READ_FRAMEBUFFER=caml_string_of_jsbytes("READ_FRAMEBUFFER"),
     cst_DRAW_FRAMEBUFFER=caml_string_of_jsbytes("DRAW_FRAMEBUFFER"),
     cst_READ_FRAMEBUFFER_BINDING=
      caml_string_of_jsbytes("READ_FRAMEBUFFER_BINDING"),
     cst_RENDERBUFFER_SAMPLES=caml_string_of_jsbytes("RENDERBUFFER_SAMPLES"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX$1=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"),
     cst_MAX_COLOR_ATTACHMENTS=caml_string_of_jsbytes("MAX_COLOR_ATTACHMENTS"),
     cst_COLOR_ATTACHMENT1=caml_string_of_jsbytes("COLOR_ATTACHMENT1"),
     cst_COLOR_ATTACHMENT2=caml_string_of_jsbytes("COLOR_ATTACHMENT2"),
     cst_COLOR_ATTACHMENT3=caml_string_of_jsbytes("COLOR_ATTACHMENT3"),
     cst_COLOR_ATTACHMENT4=caml_string_of_jsbytes("COLOR_ATTACHMENT4"),
     cst_COLOR_ATTACHMENT5=caml_string_of_jsbytes("COLOR_ATTACHMENT5"),
     cst_COLOR_ATTACHMENT6=caml_string_of_jsbytes("COLOR_ATTACHMENT6"),
     cst_COLOR_ATTACHMENT7=caml_string_of_jsbytes("COLOR_ATTACHMENT7"),
     cst_COLOR_ATTACHMENT8=caml_string_of_jsbytes("COLOR_ATTACHMENT8"),
     cst_COLOR_ATTACHMENT9=caml_string_of_jsbytes("COLOR_ATTACHMENT9"),
     cst_COLOR_ATTACHMENT10=caml_string_of_jsbytes("COLOR_ATTACHMENT10"),
     cst_COLOR_ATTACHMENT11=caml_string_of_jsbytes("COLOR_ATTACHMENT11"),
     cst_COLOR_ATTACHMENT12=caml_string_of_jsbytes("COLOR_ATTACHMENT12"),
     cst_COLOR_ATTACHMENT13=caml_string_of_jsbytes("COLOR_ATTACHMENT13"),
     cst_COLOR_ATTACHMENT14=caml_string_of_jsbytes("COLOR_ATTACHMENT14"),
     cst_COLOR_ATTACHMENT15=caml_string_of_jsbytes("COLOR_ATTACHMENT15"),
     cst_FRAMEBUFFER_INCOMPLETE_MUL=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"),
     cst_MAX_SAMPLES=caml_string_of_jsbytes("MAX_SAMPLES"),
     cst_HALF_FLOAT=caml_string_of_jsbytes("HALF_FLOAT"),
     cst_RG=caml_string_of_jsbytes("RG"),
     cst_RG_INTEGER=caml_string_of_jsbytes("RG_INTEGER"),
     cst_R8=caml_string_of_jsbytes("R8"),
     cst_RG8=caml_string_of_jsbytes("RG8"),
     cst_R16F=caml_string_of_jsbytes("R16F"),
     cst_R32F=caml_string_of_jsbytes("R32F"),
     cst_RG16F=caml_string_of_jsbytes("RG16F"),
     cst_RG32F=caml_string_of_jsbytes("RG32F"),
     cst_R8I=caml_string_of_jsbytes("R8I"),
     cst_R8UI=caml_string_of_jsbytes("R8UI"),
     cst_R16I=caml_string_of_jsbytes("R16I"),
     cst_R16UI=caml_string_of_jsbytes("R16UI"),
     cst_R32I=caml_string_of_jsbytes("R32I"),
     cst_R32UI=caml_string_of_jsbytes("R32UI"),
     cst_RG8I=caml_string_of_jsbytes("RG8I"),
     cst_RG8UI=caml_string_of_jsbytes("RG8UI"),
     cst_RG16I=caml_string_of_jsbytes("RG16I"),
     cst_RG16UI=caml_string_of_jsbytes("RG16UI"),
     cst_RG32I=caml_string_of_jsbytes("RG32I"),
     cst_RG32UI=caml_string_of_jsbytes("RG32UI"),
     cst_VERTEX_ARRAY_BINDING=caml_string_of_jsbytes("VERTEX_ARRAY_BINDING"),
     cst_R8_SNORM=caml_string_of_jsbytes("R8_SNORM"),
     cst_RG8_SNORM=caml_string_of_jsbytes("RG8_SNORM"),
     cst_RGB8_SNORM=caml_string_of_jsbytes("RGB8_SNORM"),
     cst_RGBA8_SNORM=caml_string_of_jsbytes("RGBA8_SNORM"),
     cst_SIGNED_NORMALIZED=caml_string_of_jsbytes("SIGNED_NORMALIZED"),
     cst_COPY_READ_BUFFER=caml_string_of_jsbytes("COPY_READ_BUFFER"),
     cst_COPY_WRITE_BUFFER=caml_string_of_jsbytes("COPY_WRITE_BUFFER"),
     cst_COPY_READ_BUFFER_BINDING=
      caml_string_of_jsbytes("COPY_READ_BUFFER_BINDING"),
     cst_COPY_WRITE_BUFFER_BINDING=
      caml_string_of_jsbytes("COPY_WRITE_BUFFER_BINDING"),
     cst_UNIFORM_BUFFER=caml_string_of_jsbytes("UNIFORM_BUFFER"),
     cst_UNIFORM_BUFFER_BINDING=
      caml_string_of_jsbytes("UNIFORM_BUFFER_BINDING"),
     cst_UNIFORM_BUFFER_START=caml_string_of_jsbytes("UNIFORM_BUFFER_START"),
     cst_UNIFORM_BUFFER_SIZE=caml_string_of_jsbytes("UNIFORM_BUFFER_SIZE"),
     cst_MAX_VERTEX_UNIFORM_BLOCKS=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_BLOCKS"),
     cst_MAX_FRAGMENT_UNIFORM_BLOCK=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_BLOCKS"),
     cst_MAX_COMBINED_UNIFORM_BLOCK=
      caml_string_of_jsbytes("MAX_COMBINED_UNIFORM_BLOCKS"),
     cst_MAX_UNIFORM_BUFFER_BINDING=
      caml_string_of_jsbytes("MAX_UNIFORM_BUFFER_BINDINGS"),
     cst_MAX_UNIFORM_BLOCK_SIZE=
      caml_string_of_jsbytes("MAX_UNIFORM_BLOCK_SIZE"),
     cst_MAX_COMBINED_VERTEX_UNIFOR=
      caml_string_of_jsbytes("MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"),
     cst_MAX_COMBINED_FRAGMENT_UNIF=
      caml_string_of_jsbytes("MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"),
     cst_UNIFORM_BUFFER_OFFSET_ALIG=
      caml_string_of_jsbytes("UNIFORM_BUFFER_OFFSET_ALIGNMENT"),
     cst_ACTIVE_UNIFORM_BLOCKS=caml_string_of_jsbytes("ACTIVE_UNIFORM_BLOCKS"),
     cst_UNIFORM_TYPE=caml_string_of_jsbytes("UNIFORM_TYPE"),
     cst_UNIFORM_SIZE=caml_string_of_jsbytes("UNIFORM_SIZE"),
     cst_UNIFORM_BLOCK_INDEX=caml_string_of_jsbytes("UNIFORM_BLOCK_INDEX"),
     cst_UNIFORM_OFFSET=caml_string_of_jsbytes("UNIFORM_OFFSET"),
     cst_UNIFORM_ARRAY_STRIDE=caml_string_of_jsbytes("UNIFORM_ARRAY_STRIDE"),
     cst_UNIFORM_MATRIX_STRIDE=caml_string_of_jsbytes("UNIFORM_MATRIX_STRIDE"),
     cst_UNIFORM_IS_ROW_MAJOR=caml_string_of_jsbytes("UNIFORM_IS_ROW_MAJOR"),
     cst_UNIFORM_BLOCK_BINDING=caml_string_of_jsbytes("UNIFORM_BLOCK_BINDING"),
     cst_UNIFORM_BLOCK_DATA_SIZE=
      caml_string_of_jsbytes("UNIFORM_BLOCK_DATA_SIZE"),
     cst_UNIFORM_BLOCK_ACTIVE_UNIFO=
      caml_string_of_jsbytes("UNIFORM_BLOCK_ACTIVE_UNIFORMS"),
     cst_UNIFORM_BLOCK_ACTIVE_UNIFO$0=
      caml_string_of_jsbytes("UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"),
     cst_UNIFORM_BLOCK_REFERENCED_B=
      caml_string_of_jsbytes("UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"),
     cst_UNIFORM_BLOCK_REFERENCED_B$0=
      caml_string_of_jsbytes("UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"),
     cst_INVALID_INDEX=caml_string_of_jsbytes("INVALID_INDEX"),
     cst_MAX_VERTEX_OUTPUT_COMPONEN=
      caml_string_of_jsbytes("MAX_VERTEX_OUTPUT_COMPONENTS"),
     cst_MAX_FRAGMENT_INPUT_COMPONE=
      caml_string_of_jsbytes("MAX_FRAGMENT_INPUT_COMPONENTS"),
     cst_MAX_SERVER_WAIT_TIMEOUT=
      caml_string_of_jsbytes("MAX_SERVER_WAIT_TIMEOUT"),
     cst_OBJECT_TYPE=caml_string_of_jsbytes("OBJECT_TYPE"),
     cst_SYNC_CONDITION=caml_string_of_jsbytes("SYNC_CONDITION"),
     cst_SYNC_STATUS=caml_string_of_jsbytes("SYNC_STATUS"),
     cst_SYNC_FLAGS=caml_string_of_jsbytes("SYNC_FLAGS"),
     cst_SYNC_FENCE=caml_string_of_jsbytes("SYNC_FENCE"),
     cst_SYNC_GPU_COMMANDS_COMPLETE=
      caml_string_of_jsbytes("SYNC_GPU_COMMANDS_COMPLETE"),
     cst_UNSIGNALED=caml_string_of_jsbytes("UNSIGNALED"),
     cst_SIGNALED=caml_string_of_jsbytes("SIGNALED"),
     cst_ALREADY_SIGNALED=caml_string_of_jsbytes("ALREADY_SIGNALED"),
     cst_TIMEOUT_EXPIRED=caml_string_of_jsbytes("TIMEOUT_EXPIRED"),
     cst_CONDITION_SATISFIED=caml_string_of_jsbytes("CONDITION_SATISFIED"),
     cst_WAIT_FAILED=caml_string_of_jsbytes("WAIT_FAILED"),
     cst_SYNC_FLUSH_COMMANDS_BIT=
      caml_string_of_jsbytes("SYNC_FLUSH_COMMANDS_BIT"),
     cst_VERTEX_ATTRIB_ARRAY_DIVISO=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_DIVISOR"),
     cst_ANY_SAMPLES_PASSED=caml_string_of_jsbytes("ANY_SAMPLES_PASSED"),
     cst_ANY_SAMPLES_PASSED_CONSERV=
      caml_string_of_jsbytes("ANY_SAMPLES_PASSED_CONSERVATIVE"),
     cst_SAMPLER_BINDING=caml_string_of_jsbytes("SAMPLER_BINDING"),
     cst_RGB10_A2UI=caml_string_of_jsbytes("RGB10_A2UI"),
     cst_INT_2_10_10_10_REV=caml_string_of_jsbytes("INT_2_10_10_10_REV"),
     cst_TRANSFORM_FEEDBACK=caml_string_of_jsbytes("TRANSFORM_FEEDBACK"),
     cst_TRANSFORM_FEEDBACK_PAUSED=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_PAUSED"),
     cst_TRANSFORM_FEEDBACK_ACTIVE=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_ACTIVE"),
     cst_TRANSFORM_FEEDBACK_BINDING=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BINDING"),
     cst_TEXTURE_IMMUTABLE_FORMAT=
      caml_string_of_jsbytes("TEXTURE_IMMUTABLE_FORMAT"),
     cst_MAX_ELEMENT_INDEX=caml_string_of_jsbytes("MAX_ELEMENT_INDEX"),
     cst_TEXTURE_IMMUTABLE_LEVELS=
      caml_string_of_jsbytes("TEXTURE_IMMUTABLE_LEVELS"),
     cst_TIMEOUT_IGNORED=caml_string_of_jsbytes("TIMEOUT_IGNORED"),
     cst_MAX_CLIENT_WAIT_TIMEOUT_WE=
      caml_string_of_jsbytes("MAX_CLIENT_WAIT_TIMEOUT_WEBGL"),
     cst_length$8=caml_string_of_jsbytes("length"),
     cst_outputLatency=caml_string_of_jsbytes("outputLatency"),
     cst_baseLatency=caml_string_of_jsbytes("baseLatency"),
     cst_latencyHint=caml_string_of_jsbytes("latencyHint"),
     cst_sampleRate$2=caml_string_of_jsbytes("sampleRate"),
     cst_state$0=caml_string_of_jsbytes("state"),
     cst_currentTime$2=caml_string_of_jsbytes("currentTime"),
     cst_sampleRate$1=caml_string_of_jsbytes("sampleRate"),
     cst_performanceTime=caml_string_of_jsbytes("performanceTime"),
     cst_contextTime=caml_string_of_jsbytes("contextTime"),
     cst_channelCount$15=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$15=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$15=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfInputs$1=caml_string_of_jsbytes("numberOfInputs"),
     cst_numberOfOutputs$0=caml_string_of_jsbytes("numberOfOutputs"),
     cst_outputChannelCount=caml_string_of_jsbytes("outputChannelCount"),
     cst_parameterData=caml_string_of_jsbytes("parameterData"),
     cst_processorOptions=caml_string_of_jsbytes("processorOptions"),
     cst_oversample$1=caml_string_of_jsbytes("oversample"),
     cst_oversample$0=caml_string_of_jsbytes("oversample"),
     cst_channelCount$14=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$14=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$14=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_oversample=caml_string_of_jsbytes("oversample"),
     cst_channelCount$13=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$13=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$13=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_pan=caml_string_of_jsbytes("pan"),
     cst_coneOuterGain$0=caml_string_of_jsbytes("coneOuterGain"),
     cst_coneOuterGain=caml_string_of_jsbytes("coneOuterGain"),
     cst_coneOuterAngle$0=caml_string_of_jsbytes("coneOuterAngle"),
     cst_coneOuterAngle=caml_string_of_jsbytes("coneOuterAngle"),
     cst_coneInnerAngle$0=caml_string_of_jsbytes("coneInnerAngle"),
     cst_coneInnerAngle=caml_string_of_jsbytes("coneInnerAngle"),
     cst_maxDistance$1=caml_string_of_jsbytes("maxDistance"),
     cst_maxDistance$0=caml_string_of_jsbytes("maxDistance"),
     cst_refDistance$1=caml_string_of_jsbytes("refDistance"),
     cst_refDistance$0=caml_string_of_jsbytes("refDistance"),
     cst_distanceModel$1=caml_string_of_jsbytes("distanceModel"),
     cst_distanceModel$0=caml_string_of_jsbytes("distanceModel"),
     cst_panningModel$1=caml_string_of_jsbytes("panningModel"),
     cst_panningModel$0=caml_string_of_jsbytes("panningModel"),
     cst_channelCount$12=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$12=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$12=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_panningModel=caml_string_of_jsbytes("panningModel"),
     cst_distanceModel=caml_string_of_jsbytes("distanceModel"),
     cst_positionX=caml_string_of_jsbytes("positionX"),
     cst_positionY=caml_string_of_jsbytes("positionY"),
     cst_positionZ=caml_string_of_jsbytes("positionZ"),
     cst_orientationX=caml_string_of_jsbytes("orientationX"),
     cst_orientationY=caml_string_of_jsbytes("orientationY"),
     cst_orientationZ=caml_string_of_jsbytes("orientationZ"),
     cst_refDistance=caml_string_of_jsbytes("refDistance"),
     cst_maxDistance=caml_string_of_jsbytes("maxDistance"),
     cst_rolloff_factor=caml_string_of_jsbytes("rolloff_factor"),
     cst_cone_inner_angle=caml_string_of_jsbytes("cone_inner_angle"),
     cst_cone_outer_angle=caml_string_of_jsbytes("cone_outer_angle"),
     cst_cone_outer_gain=caml_string_of_jsbytes("cone_outer_gain"),
     cst_type$11=caml_string_of_jsbytes("type"),
     cst_type$10=caml_string_of_jsbytes("type"),
     cst_channelCount$11=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$11=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$11=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_type$9=caml_string_of_jsbytes("type"),
     cst_frequency$0=caml_string_of_jsbytes("frequency"),
     cst_detune$1=caml_string_of_jsbytes("detune"),
     cst_periodicWave=caml_string_of_jsbytes("periodicWave"),
     cst_disableNormalization$0=caml_string_of_jsbytes("disableNormalization"),
     cst_channelCount$10=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$10=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$10=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCount$9=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$9=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$9=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCount$8=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$8=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$8=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_gain$0=caml_string_of_jsbytes("gain"),
     cst_reduction=caml_string_of_jsbytes("reduction"),
     cst_channelCount$7=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$7=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$7=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_attack=caml_string_of_jsbytes("attack"),
     cst_knee=caml_string_of_jsbytes("knee"),
     cst_ratio=caml_string_of_jsbytes("ratio"),
     cst_release=caml_string_of_jsbytes("release"),
     cst_threshold=caml_string_of_jsbytes("threshold"),
     cst_maxChannelCount=caml_string_of_jsbytes("maxChannelCount"),
     cst_channelCount$6=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$6=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$6=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_delayTime=caml_string_of_jsbytes("delayTime"),
     cst_maxDelayTime=caml_string_of_jsbytes("maxDelayTime"),
     cst_normalize$0=caml_string_of_jsbytes("normalize"),
     cst_normalize=caml_string_of_jsbytes("normalize"),
     cst_buffer$2=caml_string_of_jsbytes("buffer"),
     cst_channelCount$5=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$5=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$5=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_buffer$1=caml_string_of_jsbytes("buffer"),
     cst_disableNormalization=caml_string_of_jsbytes("disableNormalization"),
     cst_offset=caml_string_of_jsbytes("offset"),
     cst_channelCount$4=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$4=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$4=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfOutput=caml_string_of_jsbytes("numberOfOutput"),
     cst_channelCount$3=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$3=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$3=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfInputs$0=caml_string_of_jsbytes("numberOfInputs"),
     cst_loopEnd$0=caml_string_of_jsbytes("loopEnd"),
     cst_loopEnd=caml_string_of_jsbytes("loopEnd"),
     cst_loopStart$0=caml_string_of_jsbytes("loopStart"),
     cst_loopStart=caml_string_of_jsbytes("loopStart"),
     cst_loop$3=caml_string_of_jsbytes("loop"),
     cst_loop$2=caml_string_of_jsbytes("loop"),
     cst_buffer$0=caml_string_of_jsbytes("buffer"),
     cst_buffer=caml_string_of_jsbytes("buffer"),
     cst_detune$0=caml_string_of_jsbytes("detune"),
     cst_loop$1=caml_string_of_jsbytes("loop"),
     cst_loop_start=caml_string_of_jsbytes("loop_start"),
     cst_loop_end=caml_string_of_jsbytes("loop_end"),
     cst_playbackRate$1=caml_string_of_jsbytes("playbackRate"),
     cst_type$8=caml_string_of_jsbytes("type"),
     cst_type$7=caml_string_of_jsbytes("type"),
     cst_channelCount$2=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$2=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$2=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_type$6=caml_string_of_jsbytes("type"),
     cst_Q=caml_string_of_jsbytes("Q"),
     cst_detune=caml_string_of_jsbytes("detune"),
     cst_frequency=caml_string_of_jsbytes("frequency"),
     cst_gain=caml_string_of_jsbytes("gain"),
     cst_smoothingTimeConstant$1=
      caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_smoothingTimeConstant$0=
      caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_maxDecibels$1=caml_string_of_jsbytes("maxDecibels"),
     cst_maxDecibels$0=caml_string_of_jsbytes("maxDecibels"),
     cst_minDecibels$1=caml_string_of_jsbytes("minDecibels"),
     cst_minDecibels$0=caml_string_of_jsbytes("minDecibels"),
     cst_frequencyBinCount=caml_string_of_jsbytes("frequencyBinCount"),
     cst_fftSize$1=caml_string_of_jsbytes("fftSize"),
     cst_fftSize$0=caml_string_of_jsbytes("fftSize"),
     cst_channelCount$1=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$1=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$1=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_fftSize=caml_string_of_jsbytes("fftSize"),
     cst_minDecibels=caml_string_of_jsbytes("minDecibels"),
     cst_maxDecibels=caml_string_of_jsbytes("maxDecibels"),
     cst_smoothingTimeConstant=caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_channelInterpretation$0=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelInterpretation=caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCountMode$0=caml_string_of_jsbytes("channelCountMode"),
     cst_channelCountMode=caml_string_of_jsbytes("channelCountMode"),
     cst_channelCount$0=caml_string_of_jsbytes("channelCount"),
     cst_channelCount=caml_string_of_jsbytes("channelCount"),
     cst_numberOfOutputs=caml_string_of_jsbytes("numberOfOutputs"),
     cst_numberOfInputs=caml_string_of_jsbytes("numberOfInputs"),
     cst_numberOfChannels=caml_string_of_jsbytes("numberOfChannels"),
     cst_length$7=caml_string_of_jsbytes("length"),
     cst_length$6=caml_string_of_jsbytes("length"),
     cst_sampleRate$0=caml_string_of_jsbytes("sampleRate"),
     cst_sampleRate=caml_string_of_jsbytes("sampleRate"),
     cst_currentTime$1=caml_string_of_jsbytes("currentTime"),
     cst_currentFrame=caml_string_of_jsbytes("currentFrame"),
     cst_maxValue$0=caml_string_of_jsbytes("maxValue"),
     cst_minValue$0=caml_string_of_jsbytes("minValue"),
     cst_defaultValue$0=caml_string_of_jsbytes("defaultValue"),
     cst_automationRate$1=caml_string_of_jsbytes("automationRate"),
     cst_automationRate$0=caml_string_of_jsbytes("automationRate"),
     cst_value$0=caml_string_of_jsbytes("value"),
     cst_value=caml_string_of_jsbytes("value"),
     cst_automationRate=caml_string_of_jsbytes("automationRate"),
     cst_minValue=caml_string_of_jsbytes("minValue"),
     cst_maxValue=caml_string_of_jsbytes("maxValue"),
     cst_defaultValue=caml_string_of_jsbytes("defaultValue"),
     cst_iterations=caml_string_of_jsbytes("iterations"),
     cst_hash$5=caml_string_of_jsbytes("hash"),
     cst_name$20=caml_string_of_jsbytes("name"),
     cst_hash$4=caml_string_of_jsbytes("hash"),
     cst_name$19=caml_string_of_jsbytes("name"),
     cst_length$11=caml_string_of_jsbytes("length"),
     cst_hash$3=caml_string_of_jsbytes("hash"),
     cst_name$18=caml_string_of_jsbytes("name"),
     cst_tagLength=caml_string_of_jsbytes("tagLength"),
     cst_additionalData=caml_string_of_jsbytes("additionalData"),
     cst_name$17=caml_string_of_jsbytes("name"),
     cst_name$16=caml_string_of_jsbytes("name"),
     cst_length$10=caml_string_of_jsbytes("length"),
     cst_name$15=caml_string_of_jsbytes("name"),
     cst_length$9=caml_string_of_jsbytes("length"),
     cst_name$14=caml_string_of_jsbytes("name"),
     cst_name$13=caml_string_of_jsbytes("name"),
     cst_hash$2=caml_string_of_jsbytes("hash"),
     cst_name$12=caml_string_of_jsbytes("name"),
     cst_namedCurve$0=caml_string_of_jsbytes("namedCurve"),
     cst_name$11=caml_string_of_jsbytes("name"),
     cst_namedCurve=caml_string_of_jsbytes("namedCurve"),
     cst_name$10=caml_string_of_jsbytes("name"),
     cst_name$9=caml_string_of_jsbytes("name"),
     cst_saltLength=caml_string_of_jsbytes("saltLength"),
     cst_name$8=caml_string_of_jsbytes("name"),
     cst_hash$1=caml_string_of_jsbytes("hash"),
     cst_name$7=caml_string_of_jsbytes("name"),
     cst_hash$0=caml_string_of_jsbytes("hash"),
     cst_modulusLength=caml_string_of_jsbytes("modulusLength"),
     cst_name$6=caml_string_of_jsbytes("name"),
     cst_name$5=caml_string_of_jsbytes("name"),
     cst_extractable=caml_string_of_jsbytes("extractable"),
     cst_type$12=caml_string_of_jsbytes("type"),
     cst_includeUncontrolled=caml_string_of_jsbytes("includeUncontrolled"),
     cst_type$16=caml_string_of_jsbytes("type"),
     cst_focused=caml_string_of_jsbytes("focused"),
     cst_visibilityState$0=caml_string_of_jsbytes("visibilityState"),
     cst_type$15=caml_string_of_jsbytes("type"),
     cst_id$1=caml_string_of_jsbytes("id"),
     cst_frameType=caml_string_of_jsbytes("frameType"),
     cst_url$3=caml_string_of_jsbytes("url"),
     cst_scope$0=caml_string_of_jsbytes("scope"),
     cst_type$14=caml_string_of_jsbytes("type"),
     cst_updateViaCache$0=caml_string_of_jsbytes("updateViaCache"),
     cst_updateViaCache=caml_string_of_jsbytes("updateViaCache"),
     cst_scope=caml_string_of_jsbytes("scope"),
     cst_headerValue=caml_string_of_jsbytes("headerValue"),
     cst_enabled$1=caml_string_of_jsbytes("enabled"),
     cst_WorkerGlobalScope=caml_string_of_jsbytes("WorkerGlobalScope"),
     cst_type$13=caml_string_of_jsbytes("type"),
     cst_credentials$1=caml_string_of_jsbytes("credentials"),
     cst_name$21=caml_string_of_jsbytes("name"),
     Stdlib_Uchar=global_data.Stdlib__Uchar,
     Stdlib=global_data.Stdlib,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Callback=global_data.Stdlib__Callback,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Result=global_data.Stdlib__Result,
     Assert_failure=global_data.Assert_failure,
     Stdlib_Option=global_data.Stdlib__Option,
     Stdlib_Bigarray=global_data.Stdlib__Bigarray,
     Stdlib_Fun=global_data.Stdlib__Fun,
     jv_global=globalThis,
     _e_=[0,caml_string_of_jsbytes("src/fut.ml"),34,25],
     _v_=[0,0],
     _u_=[0,1],
     _r_=[0,1],
     _q_=[0,1],
     _p_=[0,-1],
     _n_=[0,1],
     _o_=[0,1],
     _g_=[0,7],
     _h_=[0,8],
     _i_=[0,0],
     _j_=[0,3],
     _k_=[0,1],
     _l_=[0,5],
     _m_=[0,2],
     _f_=[0,1],
     _bt_=[0,0],
     _bs_=[0,0],
     _bq_=[0,[0,4448519,0]],
     _br_=[0,[0,4448519,0]];
    function length(s){return s.length}
    function arg(opt,i)
     {if(opt)var sth=opt[1],base=sth;else var base=10;return i.toString(base)}
    function get(s,i)
     {if(s.length <= i)
       {var
         len=s.length,
         _oW_=arg(0,len - 1 | 0),
         _oX_=
          caml_string_of_jsstring
           ("index ".concat(arg(0,i)).concat(" not in bounds [0;").concat
              (_oW_).concat
             ("]"));
        return caml_call1(Stdlib[1],_oX_)}
      var u=s.codePointAt(i),switch$0=0;
      if(55296 <= u && ! (57343 < u)){var u$0=65533;switch$0 = 1}
      if(! switch$0)var u$0=u;
      return caml_call1(Stdlib_Uchar[9],u$0)}
    function jstr_of_uchar_int(i){return jv_global.String.fromCodePoint(i)}
    function get_jstr(s,i)
     {var _oV_=get(s,i);
      return jstr_of_uchar_int(caml_call1(Stdlib_Uchar[10],_oV_))}
    var empty="",sp=" ",nl="\n";
    function symbol(s0,s1){return s0.concat(s1)}
    function concat(opt,ss)
     {if(opt)var sth=opt[1],sep=sth;else var sep=empty;
      return caml_list_to_js_array(ss).join(sep)}
    function pad_start(opt,len,s){return s.padStart(len," ")}
    function pad_end(opt,len,s){return s.padEnd(len," ")}
    function repeat(n,s){return s.repeat(n)}
    function find_sub(opt,sub,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      var i=s.indexOf(sub,start);
      return -1 === i?0:[0,i]}
    function find_last_sub(before,sub,s)
     {if(before)var b=before[1],before$0=b;else var before$0=s.length;
      var pos=before$0 - sub.length | 0;
      if(0 <= pos){var i=s.lastIndexOf(sub,pos);return -1 === i?0:[0,i]}
      return 0}
    function slice(opt,stop,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],args=[0,start,stop$0];
      else
       var args=[0,start];
      return caml_js_meth_call(s,cst_slice,args)}
    function sub(opt,len,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(len)var len$0=len[1],args=[0,start,len$0];else var args=[0,start];
      return caml_js_meth_call(s,cst_substr,args)}
    function cuts(sep,s){return caml_list_of_js_array(s.split(sep))}
    var iterator=Symbol.iterator;
    function fold_uchars(f,s,acc)
     {var it=s[iterator](),acc$0=acc;
      for(;;)
       {var r=it.next();
        if(r.done | 0)return acc$0;
        var u=r.value.codePointAt(0),switch$0=0;
        if(55296 <= u && ! (57343 < u)){var u$0=65533;switch$0 = 1}
        if(! switch$0)var u$0=u;
        var
         acc$1=caml_call2(f,caml_call1(Stdlib_Uchar[9],u$0),acc$0),
         acc$0=acc$1;
        continue}}
    function fold_jstr_uchars(f,s,acc)
     {function f$0(u,acc)
       {return caml_call2
                (f,jstr_of_uchar_int(caml_call1(Stdlib_Uchar[10],u)),acc)}
      return fold_uchars(f$0,s,acc)}
    function trim(s){return s.trim()}
    function normalized(nf,s)
     {var
       nf$0=
        868484048 <= nf
         ?868484049 <= nf?"NFKD":"NFKC"
         :3894540 <= nf?"NFD":"NFC";
      return s.normalize(nf$0)}
    function lowercased(s){return s.toLowerCase()}
    function uppercased(s){return s.toUpperCase()}
    function is_empty(s){return 0 === s.length?1:0}
    function starts_with(prefix,s){return s.startsWith(prefix) | 0}
    function includes(affix,s){return s.includes(affix) | 0}
    function ends_with(suffix,s){return s.endsWith(suffix) | 0}
    var equal=caml_equal,compare=runtime.caml_compare;
    function of_uchar(u)
     {return jstr_of_uchar_int(caml_call1(Stdlib_Uchar[10],u))}
    function of_char(c){return jstr_of_uchar_int(c)}
    var number=jv_global.Number;
    function to_int(base,s)
     {if(base)var b=base[1],args=[0,s,b];else var args=[0,s];
      var n=caml_js_meth_call(number,cst_parseInt,args);
      return caml_equal(n,n)?[0,n]:0}
    function to_float(s){return number.parseFloat(s)}
    function of_float(frac,n)
     {if(frac){var frac$0=frac[1];return n.toFixed(frac$0)}
      return n.toString()}
    var
     Jstr=
      [0,
       length,
       get,
       get_jstr,
       empty,
       sp,
       nl,
       symbol,
       symbol,
       concat,
       pad_start,
       pad_end,
       repeat,
       find_sub,
       find_last_sub,
       slice,
       sub,
       cuts,
       fold_uchars,
       fold_jstr_uchars,
       trim,
       normalized,
       lowercased,
       uppercased,
       is_empty,
       starts_with,
       includes,
       ends_with,
       equal,
       compare,
       of_uchar,
       of_char,
       to_int,
       arg,
       to_float,
       of_float];
    caml_register_global(2923,Jstr,"Jstr");
    function strict_equal(_oU_,_oT_){return _oU_ === _oT_?1:0}
    var null$0=null,fn=undefined;
    function is_null(v){return v === null$0?1:0}
    function is_undefined(v){return v === fn?1:0}
    function is_none(v){var _oS_=is_null(v);return _oS_?_oS_:is_undefined(v)}
    function is_some(v){return 1 - is_none(v)}
    function to_option(conv,v){return is_none(v)?0:[0,caml_call1(conv,v)]}
    function of_option(none,conv,param)
     {if(param){var v=param[1];return caml_call1(conv,v)}return none}
    var target=globalThis;
    function set_if_some(o,p,param)
     {if(param){var v=param[1];return o[p] = v}return 0}
    function find(o,p){var v=o[p];return is_none(v)?0:[0,v]}
    function find_map(f,o,p)
     {var v=o[p];return is_none(v)?0:[0,caml_call1(f,v)]}
    function find_path(o,param)
     {var o$0=o,param$0=param;
      for(;;)
       {if(param$0)
         {var ps=param$0[2],p=param$0[1],match=find(o$0,p);
          if(match){var o$1=match[1],o$0=o$1,param$0=ps;continue}
          return 0}
        return [0,o$0]}}
    var true$0=true,false$0=false;
    function find$0(o,p){var b=o[p];return is_none(b)?0:[0,b | 0]}
    function get$0(o,p){return o[p] | 0}
    function set(o,p,b){return o[p] = ! ! b}
    function set_if_some$0(o,p,param)
     {if(param){var b=param[1];return set(o,p,b)}return 0}
    var Bool=[0,find$0,get$0,set,set_if_some$0];
    function find$1(o,p){var i=o[p];return is_none(i)?0:[0,i]}
    function get$1(o,p){return o[p]}
    function set$0(o,p,i){return o[p] = i}
    function set_if_some$1(o,p,param)
     {if(param){var i=param[1];return o[p] = i}return 0}
    var Int=[0,find$1,get$1,set$0,set_if_some$1];
    function find$2(o,p){var f=o[p];return is_none(f)?0:[0,f]}
    function get$2(o,p){return o[p]}
    function set$1(o,p,b){return o[p] = b}
    function set_if_some$2(o,p,param)
     {if(param){var f=param[1];return o[p] = f}return 0}
    var Float=[0,find$2,get$2,set$1,set_if_some$2];
    function find$3(o,p){var s=o[p];return is_none(s)?0:[0,s]}
    function get$3(o,p){return o[p]}
    function set$2(o,p,b){return o[p] = b}
    function set_if_some$3(o,p,param)
     {if(param){var f=param[1];return o[p] = f}return 0}
    function create(n){return new (target.Array)(n)}
    function length$0(a){return a.length}
    var Jarray=[0,create,length$0];
    function to_array(conv,v)
     {var len=caml_call1(Jarray[2],v);
      function _oR_(i){return caml_call1(conv,v[i])}
      return caml_call2(Stdlib_Array[2],len,_oR_)}
    function of_array(conv,a)
     {var
       len=a.length - 1,
       ja=caml_call1(Jarray[1],len),
       _oP_=len - 1 | 0,
       _oO_=0;
      if(! (_oP_ < 0))
       {var i=_oO_;
        for(;;)
         {ja[i] = caml_call1(conv,runtime.caml_check_bound(a,i)[1 + i]);
          var _oQ_=i + 1 | 0;
          if(_oP_ !== i){var i=_oQ_;continue}
          break}}
      return ja}
    function to_list(conv,v)
     {var len=caml_call1(Jarray[2],v);
      function _oN_(i){return caml_call1(conv,v[i])}
      return caml_call2(Stdlib_List[10],len,_oN_)}
    function of_list(conv,l)
     {var ja=caml_call1(Jarray[1],0),i=0,param=l;
      for(;;)
       {if(param)
         {var vs=param[2],v=param[1];
          ja[i] = caml_call1(conv,v);
          var i$0=i + 1 | 0,i=i$0,param=vs;
          continue}
        return ja}}
    function v(name,msg)
     {var e=new (target.Error)(msg);
      if(name){var n=name[1];e.name = n;return e}
      return e}
    function name(e){return e.name}
    function enum$0(e)
     {var
       match=caml_string_of_jsstring(e.name),
       switch$0=caml_string_compare(match,cst_NotAllowedError);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 971339429;
        var switch$1=caml_string_compare(match,cst_SyntaxError);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 148000204;
          if(! caml_string_notequal(match,cst_TimeoutError))return -129520566;
          if(! caml_string_notequal(match,cst_TransactionInactiveError))
           return -28376747;
          if(! caml_string_notequal(match,cst_TypeMismatchError))
           return -823442212;
          if(! caml_string_notequal(match,cst_URLMismatchError))
           return 147573767;
          if(! caml_string_notequal(match,cst_UnknownError))
           return -1064646157;
          if(! caml_string_notequal(match,cst_VersionError))
           return -1025659903;
          if(! caml_string_notequal(match,cst_WrongDocumentError))
           return -937074026}
        else
         {if(! caml_string_notequal(match,cst_NotFoundError))return 829592127;
          if(! caml_string_notequal(match,cst_NotReadableError))
           return -119831547;
          if(! caml_string_notequal(match,cst_NotSupportedError))
           return -935732949;
          if(! caml_string_notequal(match,cst_OperationError))
           return 115193424;
          if(! caml_string_notequal(match,cst_QuotaExceededError))
           return 246360739;
          if(! caml_string_notequal(match,cst_ReadOnlyError))return 842968798;
          if(! caml_string_notequal(match,cst_SecurityError))return 496062953}}
      else
       {var switch$2=caml_string_compare(match,cst_InvalidAccessError);
        if(0 <= switch$2)
         {if(! (0 < switch$2))return 753062229;
          if(! caml_string_notequal(match,cst_InvalidCharacterError))
           return 197539530;
          if(! caml_string_notequal(match,cst_InvalidModificationError))
           return 943132429;
          if(! caml_string_notequal(match,cst_InvalidNodeTypeError))
           return -94613768;
          if(! caml_string_notequal(match,cst_InvalidStateError))
           return 986514226;
          if(! caml_string_notequal(match,cst_NamespaceError))
           return 861236164;
          if(! caml_string_notequal(match,cst_NetworkError))return 943709719;
          if(! caml_string_notequal(match,cst_NoModificationAllowedError))
           return 320841004}
        else
         {if(! caml_string_notequal(match,cst_AbortError))return 183065241;
          if(! caml_string_notequal(match,cst_ConstraintError))
           return 539235142;
          if(! caml_string_notequal(match,cst_DataCloneError))
           return 1031143793;
          if(! caml_string_notequal(match,cst_DataError))return 483354835;
          if(! caml_string_notequal(match,cst_EncodingError))return 518067260;
          if(! caml_string_notequal(match,cst_HierarchyRequestError))
           return 227342318;
          if(! caml_string_notequal(match,cst_IndexSizeError))return 89185783}}
      return -912009552}
    function message(e){return e.message}
    function stack(e){return e.stack}
    function throw$0(name,msg)
     {var e=v(name,msg);return caml_call1(function(exn){throw exn},e)}
    var Error=[248,cst_Jv_Error,runtime.caml_fresh_oo_id(0)];
    function register_error_exception(param)
     {return caml_call2(Stdlib_Callback[2],cst_jsError,[0,Error,{}])}
    register_error_exception(0);
    var symbol$0=Symbol.iterator;
    function iterable(o)
     {var _oL_=o[symbol$0],match=to_option(function(_oM_){return _oM_},_oL_);
      if(match){var func=match[1];return func()}
      return 0}
    function iterator$0(o){return o[symbol$0]()}
    function next(it){return it.next()}
    function result_done(o)
     {var match=to_option(caml_js_to_bool,o.done);
      if(match){var d=match[1];return d}
      return 0}
    function result_value(o)
     {var _oJ_=o.value;return to_option(function(_oK_){return _oK_},_oJ_)}
    function get_result_value(o){return o.value}
    function fold(of_jv,f,it,acc)
     {var acc$0=acc;
      for(;;)
       {var r=it.next();
        if(result_done(r))return acc$0;
        var acc$1=caml_call2(f,caml_call1(of_jv,r.value),acc$0),acc$0=acc$1;
        continue}}
    function fold_bindings(key,value,f,it,acc)
     {var acc$0=acc;
      for(;;)
       {var r=it.next();
        if(result_done(r))return acc$0;
        var
         arr=r.value,
         _oI_=caml_call1(value,arr[1]),
         acc$1=caml_call3(f,caml_call1(key,arr[0]),_oI_,acc$0),
         acc$0=acc$1;
        continue}}
    var promise=target.Promise;
    function create$0(f){return new promise(f)}
    function resolve(v){return promise.resolve(v)}
    function reject(v){return promise.reject(v)}
    function await$0(p,k){p.then(k);return 0}
    function bind(p,res){return p.then(res)}
    function then(p,res,rej){return p.then(res,rej)}
    function all(arr){return promise.all(arr)}
    function find$4(o,p){var v=o[p];return is_none(v)?0:[0,v]}
    function find_map$0(f,o,p)
     {var v=o[p];return is_none(v)?0:[0,caml_call1(f,v)]}
    function obj(props)
     {function _oH_(param)
       {var v=param[2],p=param[1];return [0,caml_string_of_jsstring(p),v]}
      return runtime.caml_js_object(caml_call2(Stdlib_Array[15],_oH_,props))}
    function call(o,m,args)
     {return caml_js_meth_call(o,caml_string_of_jsstring(m),args)}
    function has(p,v){return is_some(v[p])}
    function defined(v){return is_some(v)}
    var
     Id=[0],
     _a_=[0,create$0,resolve,reject,await$0,bind,then,all],
     _b_=
      [0,
       result_done,
       result_value,
       get_result_value,
       iterable,
       iterator$0,
       next,
       fold,
       fold_bindings],
     _c_=[0,v,name,enum$0,message,stack],
     _d_=[0,find$3,get$3,set$2,set_if_some$3],
     Jv=
      [0,
       strict_equal,
       runtime.caml_js_typeof,
       caml_js_instanceof,
       null$0,
       fn,
       is_null,
       is_undefined,
       is_none,
       is_some,
       to_option,
       of_option,
       target,
       find,
       find_map,
       find_path,
       set_if_some,
       true$0,
       false$0,
       Bool,
       Int,
       Float,
       _d_,
       caml_jsstring_of_string,
       caml_string_of_jsstring,
       to_array,
       of_array,
       to_list,
       of_list,
       Jarray,
       _c_,
       Error,
       throw$0,
       register_error_exception,
       _b_,
       _a_,
       find$4,
       find_map$0,
       obj,
       call,
       has,
       defined,
       Id];
    caml_register_global(2927,Jv,"Jv");
    function promise$0(f){return f.fut}
    function create$1(param)
     {function not_set(param){throw [0,Assert_failure,_e_]}
      function is_set(param){return throw$0(0,"The future is already set")}
      var setter=[0,not_set];
      function set_setter(resolve,reject){setter[1] = resolve;return 0}
      var p=caml_call1(_a_[1],set_setter);
      function set(v){caml_call1(setter[1],v);setter[1] = is_set;return 0}
      return [0,{"fut":p},set]}
    function await$1(f,k){return caml_call2(_a_[4],f.fut,k)}
    function return$0(v){return {"fut":caml_call1(_a_[2],v)}}
    function bind$0(f,fn)
     {function _oG_(v){return caml_call1(fn,v).fut}
      return {"fut":caml_call2(_a_[5],f.fut,_oG_)}}
    function map(fn,f)
     {return bind$0(f,function(v){return return$0(caml_call1(fn,v))})}
    function pair(f0,f1)
     {function _oE_(v0)
       {function _oF_(v1){return caml_call1(_a_[2],[0,v0,v1])}
        return caml_call1(caml_call1(_a_[5],f1.fut),_oF_)}
      return {"fut":caml_call1(caml_call1(_a_[5],f0.fut),_oE_)}}
    function of_list$0(fs)
     {var arr=of_list(promise$0,fs),all=caml_call1(_a_[7],arr);
      function to_list$0(l)
       {var _oC_=to_list(function(_oD_){return _oD_},l);
        return caml_call1(_a_[2],_oC_)}
      return {"fut":caml_call2(_a_[5],all,to_list$0)}}
    function tick(ms)
     {function _oB_(res,rej){target.setTimeout(res,ms);return 0}
      return {"fut":caml_call1(_a_[1],_oB_)}}
    function ok(v){return return$0([0,v])}
    function error(e){return return$0([1,e])}
    function of_promise(ok,error,p)
     {function ok$0(v)
       {var _oA_=[0,caml_call1(ok,v)];return caml_call1(_a_[2],_oA_)}
      function error$0(e)
       {var _oz_=[1,caml_call1(error,e)];return caml_call1(_a_[2],_oz_)}
      return {"fut":caml_call3(_a_[6],p,ok$0,error$0)}}
    function to_promise(ok,error,f)
     {function _oy_(res,rej)
       {return await$1
                (f,
                 function(param)
                  {if(0 === param[0])
                    {var v=param[1];return caml_call1(res,caml_call1(ok,v))}
                   var e=param[1];
                   return caml_call1(rej,caml_call1(error,e))})}
      return caml_call1(_a_[1],_oy_)}
    function of_promise$0(ok,v)
     {return of_promise(ok,function(_ox_){return _ox_},v)}
    function to_promise$0(ok,v)
     {return to_promise(ok,function(_ow_){return _ow_},v)}
    function let$0(f,fn){return map(fn,f)}
    var Syntax=[0,bind$0,pair,let$0,pair];
    function result_pair(r0,r1)
     {if(0 === r0[0])
       {var _ov_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return [0,[0,_ov_,v1]]}
        var r=r1}
      else
       var r=r0;
      return r}
    function let$1(f,fn)
     {return bind$0
              (f,
               function(e)
                {if(0 === e[0]){var v=e[1];return caml_call1(fn,v)}
                 return return$0(e)})}
    function and(f0,f1){return map(result_pair,pair(f0,f1))}
    function let$2(f,fn){return map(caml_call1(Stdlib_Result[8],fn),f)}
    var
     Fut=
      [0,
       create$1,
       await$1,
       return$0,
       map,
       bind$0,
       pair,
       of_list$0,
       tick,
       ok,
       error,
       of_promise$0,
       to_promise$0,
       of_promise,
       to_promise,
       Syntax,
       [0,let$1,and,let$2,and]];
    caml_register_global(2930,Fut,"Fut");
    var Type=[0];
    function init(bubbles,cancelable,composed,param)
     {var o={};
      caml_call3(Bool[4],o,cst_bubbles,bubbles);
      caml_call3(Bool[4],o,cst_cancelable,cancelable);
      caml_call3(Bool[4],o,cst_composed,composed);
      return o}
    var event=target.Event;
    function create$2(opt,t)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new event(t,init)}
    function type(e){return caml_call2(_d_[2],e,cst_type)}
    function target$0(e){return e.target}
    function current_target(e){return e.currentTarget}
    function composed_path(e)
     {var _ot_=e.composedPath();
      return to_list(function(_ou_){return _ou_},_ot_)}
    function event_phase(e)
     {var match=caml_call2(Int[2],e,cst_eventPhase),switcher=match - 1 | 0;
      if(2 < switcher >>> 0)return 870530776;
      switch(switcher)
       {case 0:return 497141539;
        case 1:return -276077507;
        default:return 608305129}}
    function bubbles(e){return caml_call2(Bool[2],e,cst_bubbles$0)}
    function stop_propagation(e){e.stopPropagation();return 0}
    function stop_immediate_propagation(e)
     {e.stopImmediatePropagation();return 0}
    function cancelable(e){return caml_call2(Bool[2],e,cst_cancelable$0)}
    function prevent_default(e){e.preventDefault();return 0}
    function default_prevented(e)
     {return caml_call2(Bool[2],e,cst_defaultPrevented)}
    function composed(e){return caml_call2(Bool[2],e,cst_composed$0)}
    function is_trusted(e){return caml_call2(Bool[2],e,cst_isTrusted)}
    function timestamp_ms(e){return caml_call2(Float[2],e,cst_timeStamp)}
    function dispatch(e,t){return t.dispatchEvent(e) | 0}
    function listen_opts(capture,once,passive,param)
     {var o={};
      caml_call3(Bool[4],o,cst_capture,capture);
      caml_call3(Bool[4],o,cst_once,once);
      caml_call3(Bool[4],o,cst_passive,passive);
      return o}
    function listen(opt,type,f,t)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      t.addEventListener(type,f,opts);
      return 0}
    function unlisten(opt,type,f,t)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      t.removeEventListener(type,f,opts);
      return 0}
    function next$0(capture,type,t)
     {var
       match=create$1(0),
       set=match[2],
       fut=match[1],
       opts=listen_opts(capture,_f_,0,0);
      listen([0,opts],type,set,t);
      return fut}
    var
     none="none",
     copy="copy",
     copy_link="copyLink",
     copy_move="copyMove",
     link="link",
     link_move="linkMove",
     move="move",
     all$0="all",
     uninitialized="uninitialized",
     Effect=
      [0,
       none,
       copy,
       copy_link,
       copy_move,
       link,
       link_move,
       move,
       all$0,
       uninitialized],
     file="file",
     string="string",
     Kind=[0,file,string];
    function kind(i){return caml_call2(_d_[2],i,cst_kind)}
    function type$0(i){return caml_call2(_d_[2],i,cst_type$0)}
    function get_file(i)
     {var _or_=i.getAsFile();
      return to_option(function(_os_){return _os_},_or_)}
    function get_jstr$0(i)
     {var match=create$1(0),set_str=match[2],str=match[1];
      i.getAsString(set_str);
      return str}
    var Item=[0,Kind,kind,type$0,get_file,get_jstr$0];
    function length$1(l){return caml_call2(Int[2],l,cst_length)}
    function add_jstr(l,type,str)
     {var _op_=l.add(str,type);
      return to_option(function(_oq_){return _oq_},_op_)}
    function add_file(t,file)
     {var _on_=t.add(file);return to_option(function(_oo_){return _oo_},_on_)}
    function remove(l,i){l.remove(i);return 0}
    function clear(l){l.clear();return 0}
    function items(l)
     {var acc=[0,0],_ol_=length$1(l) - 1 | 0;
      if(! (_ol_ < 0))
       {var i=_ol_;
        for(;;)
         {acc[1] = [0,l[i],acc[1]];
          var _om_=i - 1 | 0;
          if(0 !== i){var i=_om_;continue}
          break}}
      return acc[1]}
    function drop_effect(d){return caml_call2(_d_[2],d,cst_dropEffect)}
    function set_drop_effect(d,e)
     {return caml_call3(_d_[3],d,cst_dropEffect$0,e)}
    function effect_allowed(d){return caml_call2(_d_[2],d,cst_effectAllowed)}
    function set_effect_allowed(d,e)
     {return caml_call3(_d_[3],d,cst_effectAllowed$0,e)}
    function items$0(d){return d.items}
    function data(c)
     {return find_map(function(_ok_){return _ok_},c,cst_clipboardData)}
    var Clipboard=[0,data];
    function data$0(i){return caml_call2(_d_[2],i,cst_data)}
    var Composition=[0,data$0];
    function message$0(e){return caml_call2(_d_[2],e,cst_message)}
    function filename(e){return caml_call2(_d_[2],e,cst_filename)}
    function lineno(e){return caml_call2(Int[2],e,cst_lineno)}
    function colno(e){return caml_call2(Int[2],e,cst_colno)}
    function error$0(e){return e.error}
    var Error$0=[0,message$0,filename,lineno,colno,error$0];
    function wait_until(e,fut)
     {e.waitUntil(to_promise$0(function(_oj_){return _oj_},fut));return 0}
    var Extendable=[0,wait_until];
    function related_target(m)
     {return find_map(function(_oi_){return _oi_},m,cst_relatedTarget)}
    var Focus=[0,related_target];
    function old_url(e){return caml_call2(_d_[2],e,cst_oldURL)}
    function new_url(e){return caml_call2(_d_[2],e,cst_newURL)}
    var Hash_change=[0,old_url,new_url];
    function data$1(i){return caml_call2(_d_[2],i,cst_data$0)}
    function data_transfer(i){return find(i,cst_dataTransfer)}
    function input_type(i){return caml_call2(_d_[2],i,cst_inputType)}
    function is_composing(i){return caml_call2(Bool[2],i,cst_isComposing)}
    var
     Input=[0,data$1,data_transfer,input_type,is_composing],
     Location=[0,0,1,2,3];
    function key(k){return caml_call2(_d_[2],k,cst_key)}
    function code(k){return caml_call2(_d_[2],k,cst_code)}
    function location(k){return caml_call2(Int[2],k,cst_location)}
    function repeat$0(k){return caml_call2(Bool[2],k,cst_repeat)}
    function is_composing$0(k){return caml_call2(Bool[2],k,cst_isComposing$0)}
    function alt_key(k){return caml_call2(Bool[2],k,cst_altKey)}
    function ctrl_key(k){return caml_call2(Bool[2],k,cst_ctrlKey)}
    function shift_key(k){return caml_call2(Bool[2],k,cst_shiftKey)}
    function meta_key(k){return caml_call2(Bool[2],k,cst_metaKey)}
    function get_modifier_state(k,key){return k.getModifierState(key) | 0}
    var
     Keyboard=
      [0,
       Location,
       key,
       code,
       location,
       repeat$0,
       is_composing$0,
       alt_key,
       ctrl_key,
       shift_key,
       meta_key,
       get_modifier_state];
    function related_target$0(m)
     {return find_map(function(_oh_){return _oh_},m,cst_relatedTarget$0)}
    function offset_x(m){return caml_call2(Float[2],m,cst_offsetX)}
    function offset_y(m){return caml_call2(Float[2],m,cst_offsetY)}
    function client_x(m){return caml_call2(Float[2],m,cst_clientX)}
    function client_y(m){return caml_call2(Float[2],m,cst_clientY)}
    function page_x(m){return caml_call2(Float[2],m,cst_pageX)}
    function page_y(m){return caml_call2(Float[2],m,cst_pageY)}
    function screen_x(m){return caml_call2(Float[2],m,cst_screenX)}
    function screen_y(m){return caml_call2(Float[2],m,cst_screenY)}
    function movement_x(m){return caml_call2(Float[2],m,cst_movementX)}
    function movement_y(m){return caml_call2(Float[2],m,cst_movementY)}
    function button(m){return caml_call2(Int[2],m,cst_button)}
    function buttons(m){return caml_call2(Int[2],m,cst_buttons)}
    function alt_key$0(m){return caml_call2(Bool[2],m,cst_altKey$0)}
    function ctrl_key$0(m){return caml_call2(Bool[2],m,cst_ctrlKey$0)}
    function shift_key$0(m){return caml_call2(Bool[2],m,cst_shiftKey$0)}
    function meta_key$0(m){return caml_call2(Bool[2],m,cst_metaKey$0)}
    function get_modifier_state$0(m,key){return m.getModifierState(key) | 0}
    var
     Mouse=
      [0,
       related_target$0,
       offset_x,
       offset_y,
       client_x,
       client_y,
       page_x,
       page_y,
       screen_x,
       screen_y,
       movement_x,
       movement_y,
       button,
       buttons,
       alt_key$0,
       ctrl_key$0,
       shift_key$0,
       meta_key$0,
       get_modifier_state$0];
    function data_transfer$0(d)
     {return find_map(function(_og_){return _og_},d,cst_dataTransfer$0)}
    var Drag=[0,data_transfer$0];
    function id(p){return caml_call2(Int[2],p,cst_pointerId)}
    function width(p){return caml_call2(Float[2],p,cst_width)}
    function height(p){return caml_call2(Float[2],p,cst_height)}
    function pressure(p){return caml_call2(Float[2],p,cst_pressure)}
    function tangential_pressure(p)
     {return caml_call2(Float[2],p,cst_tangentialPressure)}
    function tilt_x(p){return caml_call2(Int[2],p,cst_tiltX)}
    function tilt_y(p){return caml_call2(Int[2],p,cst_tiltY)}
    function twist(p){return caml_call2(Int[2],p,cst_twist)}
    function altitude_angle(p)
     {return caml_call2(Float[2],p,cst_altitudeAngle)}
    function azimuth_angle(p){return caml_call2(Float[2],p,cst_azimuthAngle)}
    function type$1(p){return caml_call2(_d_[2],p,cst_pointerType)}
    function is_primary(p){return caml_call2(Bool[2],p,cst_isPrimary)}
    function get_coalesced_events(p)
     {var _oe_=p.getCoalescedEvents();
      return to_list(function(_of_){return _of_},_oe_)}
    function get_predicted_events(p)
     {var _oc_=p.getPredictedEvents();
      return to_list(function(_od_){return _od_},_oc_)}
    var
     Pointer=
      [0,
       id,
       width,
       height,
       pressure,
       tangential_pressure,
       tilt_x,
       tilt_y,
       twist,
       altitude_angle,
       azimuth_angle,
       type$1,
       is_primary,
       get_coalesced_events,
       get_predicted_events],
     Delta_mode=[0,0,1,2];
    function delta_x(w){return caml_call2(Float[2],w,cst_deltaX)}
    function delta_y(w){return caml_call2(Float[2],w,cst_deltaY)}
    function delta_z(w){return caml_call2(Float[2],w,cst_deltaZ)}
    function delta_mode(w){return caml_call2(Int[2],w,cst_deltaMode)}
    var
     Wheel=[0,Delta_mode,delta_x,delta_y,delta_z,delta_mode],
     abort="abort",
     activate="activate",
     auxclick="dblclick",
     beforeinput="beforeinput",
     blur="blur",
     canplay="canplay",
     canplaythrough="canplaythrough",
     change="change",
     click="click",
     clipboardchange="clipboardchange",
     close="close",
     compositionend="compositionend",
     compositionstart="compositionstart",
     compositionudpate="compositionupdate",
     controllerchange="controllerchange",
     copy$0="copy",
     cut="cut",
     dblclick="dblclick",
     dom_content_loaded="DOMContentLoaded",
     drag="drag",
     dragend="dragend",
     dragenter="dragenter",
     dragexit="dragexit",
     dragleave="dragleave",
     dragover="dragover",
     dragstart="dragstart",
     drop="drop",
     durationchange="durationchange",
     emptied="emptied",
     ended="ended",
     error$1="error",
     focus="focus",
     focusin="focusin",
     focusout="focusout",
     fullscreenchange="fullscreenchange",
     fullscreenerror="fullscreenerror",
     gotpointercapture="gotpointercapture",
     hashchange="hashchange",
     input="input",
     install="install",
     keydown="keydown",
     keyup="keyup",
     languagechange="languagechange",
     load="load",
     loadeddata="loadeddata",
     loadedmetadata="loadedmetadata",
     loadstart="loadstart",
     lostpointercapture="lostpointercapture",
     mousedown="mousedown",
     mouseenter="mouseenter",
     mouseleave="mouseleave",
     mousemove="mousemove",
     mouseout="mouseout",
     mouseover="mouseover",
     mouseup="mouseup",
     open="open",
     paste="paste",
     pause="pause",
     play="play",
     playing="playing",
     pointercancel="pointercancel",
     pointerdown="pointerdown",
     pointerenter="pointerenter",
     pointerleave="pointerleave",
     pointerlockchange="pointerlockchange",
     pointerlockerror="pointerlockerror",
     pointermove="pointermove",
     pointerout="pointerout",
     pointerover="pointerover",
     pointerrawupdate="pointerrawupdate",
     pointerup="pointerup",
     progress="progress",
     ratechange="ratechange",
     reset="reset",
     resize="resize",
     scroll="scroll",
     seeked="seeked",
     seeking="seeking",
     select="select",
     stalled="stalled",
     statechange="statechange",
     suspend="suspend",
     timeupdate="timeupdate",
     unload="unload",
     updatefound="updatefound",
     visibilitychange="visibilitychange",
     volumechange="volumechange",
     waiting="waiting",
     wheel="wheel",
     array_buffer=target.ArrayBuffer;
    function create$3(n){return new array_buffer(n)}
    function byte_length(a){return caml_call2(Int[2],a,cst_byteLength)}
    function slice$0(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=byte_length(a);
      return a.slice(start,stop$1)}
    function buffer(o){return o.buffer}
    function byte_offset(o){return caml_call2(Int[2],o,cst_byteOffset)}
    function byte_length$0(o){return caml_call2(Int[2],o,cst_byteLength$0)}
    var dataview=target.DataView;
    function of_buffer(opt,byte_length$0,b)
     {if(opt)var sth=opt[1],byte_offset=sth;else var byte_offset=0;
      if(byte_length$0)
       var l=byte_length$0[1],byte_length$1=l;
      else
       var byte_length$1=byte_length(b);
      return new dataview(b,byte_offset,byte_length$1)}
    function get_int8(b,i){return b.getInt8(i)}
    function get_int16_be(b,i){return b.getInt16(i)}
    function get_int16_le(b,i){return b.getInt16(i,true$0)}
    function get_int32_be(b,i){return b.getInt32(i)}
    function get_int32_le(b,i){return b.getInt32(i,true$0)}
    function get_uint8(b,i){return b.getUint8(i)}
    function get_uint16_be(b,i){return b.getUint16(i)}
    function get_uint16_le(b,i){return b.getUint16(i,true$0)}
    function get_uint32_be(b,i){return b.getUint32(i)}
    function get_uint32_le(b,i){return b.getUint32(i,true$0)}
    function get_float32_be(b,i){return b.getFloat32(i)}
    function get_float32_le(b,i){return b.getFloat32(i,true$0)}
    function get_float64_be(b,i){return b.getFloat64(i)}
    function get_float64_le(b,i){return b.getFloat64(i,true$0)}
    function set_int8(b,i,v){b.setInt8(i,v);return 0}
    function set_int16_be(b,i,v){b.setInt16(i,v);return 0}
    function set_int16_le(b,i,v){b.setInt16(i,v,true$0);return 0}
    function set_int32_be(b,i,v){b.setInt32(i,v);return 0}
    function set_int32_le(b,i,v){b.setInt32(i,v,true$0);return 0}
    function set_uint8(b,i,v){b.setUint8(i,v);return 0}
    function set_uint16_be(b,i,v){b.setUint16(i,v);return 0}
    function set_uint16_le(b,i,v){b.setUint16(i,v,true$0);return 0}
    function set_uint32_be(b,i,v){b.setUint32(i,v);return 0}
    function set_uint32_le(b,i,v){b.setUint32(i,v,true$0);return 0}
    function set_float32_be(b,i,v){b.setFloat32(i,v);return 0}
    function set_float32_le(b,i,v){b.setFloat32(i,v,true$0);return 0}
    function set_float64_be(b,i,v){b.setFloat64(i,v);return 0}
    function set_float64_le(b,i,v){b.setFloat64(i,v,true$0);return 0}
    function type_size_in_bytes(param)
     {switch(param)
       {case 8:return 8;
        case 1:
        case 5:return 2;
        case 0:
        case 3:
        case 4:return 1;
        default:return 4}}
    function cons_of_type(param)
     {switch(param)
       {case 0:return target.Int8Array;
        case 1:return target.Int16Array;
        case 2:return target.Int32Array;
        case 3:return target.Uint8Array;
        case 4:return target.Uint8ClampedArray;
        case 5:return target.Uint16Array;
        case 6:return target.Uint32Array;
        case 7:return target.Float32Array;
        default:return target.Float64Array}}
    function create$4(t,n){return new (cons_of_type(t))(n)}
    function of_buffer$0(t,opt,length,b)
     {if(opt)var sth=opt[1],byte_offset=sth;else var byte_offset=0;
      if(length)
       var l=length[1],args=[0,b,byte_offset,l];
      else
       var args=[0,b,byte_offset];
      return caml_js_new(cons_of_type(t),args)}
    function length$2(a){return caml_call2(Int[2],a,cst_length$0)}
    function type$2(a)
     {var
       s=
        caml_string_of_jsstring(caml_call2(_d_[2],a.constructor,cst_name));
      if(caml_string_notequal(s,cst_Float32Array))
       {if(caml_string_notequal(s,cst_Float64Array))
         {if(caml_string_notequal(s,cst_Int16Array))
           {if(caml_string_notequal(s,cst_Int32Array))
             {if(caml_string_notequal(s,cst_Int8Array))
               {if(caml_string_notequal(s,cst_Uint16Array))
                 {if(caml_string_notequal(s,cst_Uint32Array))
                   {if(caml_string_notequal(s,cst_Uint8Array))
                     {if(caml_string_notequal(s,cst_Uint8ClampedArray))
                       {var t=caml_jsstring_of_string(s);
                        return throw$0(0,"Unknown typed array: ".concat(t))}
                      return 4}
                    return 3}
                  return 6}
                return 5}
              return 0}
            return 2}
          return 1}
        return 8}
      return 7}
    function set_tarray(a,dst,b){a.set(b,dst);return 0}
    function fill(opt,stop,v,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=length$2(a);
      a.fill(v,start,stop$1);
      return 0}
    function copy_within(opt,stop,dst,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=length$2(a);
      a.copyWithin(dst,start,stop$1);
      return 0}
    function slice$1(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$0(a);
      return a.slice(start,stop$1)}
    function sub$0(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$0(a);
      return a.subArray(start,stop$1)}
    function find$5(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      var _oa_=a.find(sat$0);
      return to_option(function(_ob_){return _ob_},_oa_)}
    function find_index(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      var i=a.findIndex(sat$0);
      return -1 === i?0:[0,i]}
    function for_all(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.every(sat$0) | 0}
    function exists(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.every(sat$0) | 0}
    function filter(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.filter(sat$0)}
    function iter(f,a)
     {function f$0(v,i){return caml_call2(f,i,v)}a.forEach(f$0);return 0}
    function map$0(f,a){return a.map(f)}
    function fold_left(f,acc,a){return a.reduce(f,acc)}
    function fold_right(f,a,acc)
     {function f$0(acc,v){return caml_call2(f,v,acc)}
      return a.reduceRight(f$0,acc)}
    function reverse(a){return a.reverse()}
    function of_tarray(t,a){return new (cons_of_type(t))(a)}
    function of_int_array(t,a)
     {var _n__=of_array(function(_n$_){return _n$_},a);
      return new (cons_of_type(t))(_n__)}
    function of_float_array(t,a)
     {var _n8_=of_array(function(_n9_){return _n9_},a);
      return new (cons_of_type(t))(_n8_)}
    function to_int_jstr(opt,b)
     {if(opt)var sth=opt[1],sep=sth;else var sep=sp;return b.join(sep)}
    function to_hex_jstr(opt,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=empty;
      var
       hex="0123456789abcdef",
       d=of_buffer(0,0,a.buffer),
       s=[0,empty],
       _n4_=byte_length$0(d) - 1 | 0,
       _n3_=0;
      if(! (_n4_ < 0))
       {var i=_n3_;
        for(;;)
         {var
           b=d.getUint8(i),
           sep$0=0 === i?empty:sep,
           _n5_=get_jstr(hex,b & 15),
           _n6_=get_jstr(hex,b >>> 4 | 0);
          s[1] = s[1].concat(sep$0).concat(_n6_).concat(_n5_);
          var _n7_=i + 1 | 0;
          if(_n4_ !== i){var i=_n7_;continue}
          break}}
      return s[1]}
    function uint8_of_buffer(b){return of_buffer$0(3,0,0,b)}
    function of_jstr(s)
     {var enc=new (target.TextEncoder)();return enc.encode(s)}
    function to_jstr(a)
     {var dec=new (target.TextDecoder)("utf-8",{"fatal":true$0});
      try
       {var s=dec.decode(a)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,s]}
    function of_binary_jstr(s)
     {function code(s,i)
       {var c=s.charCodeAt(i);
        if(255 < c)
         {var _n2_=arg(0,c);
          return throw$0
                  (0,
                   arg(0,i).concat(": char code ").concat(_n2_).concat
                    ("exceeds 255"))}
        return c}
      try
       {var
         b=create$3(s.length),
         d=of_buffer(0,0,b),
         _nZ_=s.length - 1 | 0,
         _nY_=0;
        if(! (_nZ_ < 0))
         {var i=_nY_;
          for(;;)
           {set_int8(d,i,code(s,i));
            var _n1_=i + 1 | 0;
            if(_nZ_ !== i){var i=_n1_;continue}
            break}}
        var _n0_=[0,of_buffer$0(0,0,0,b)];
        return _n0_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function to_binary_jstr(a)
     {var
       d=of_buffer(0,0,a.buffer),
       s=[0,empty],
       _nW_=byte_length$0(d) - 1 | 0,
       _nV_=0;
      if(! (_nW_ < 0))
       {var i=_nV_;
        for(;;)
         {var b=d.getUint8(i),_nU_=target.String.fromCharCode(b);
          s[1] = s[1].concat(_nU_);
          var _nX_=i + 1 | 0;
          if(_nW_ !== i){var i=_nX_;continue}
          break}}
      return s[1]}
    function type_to_bigarray_kind(param)
     {switch(param)
       {case 0:return Stdlib_Bigarray[5];
        case 1:return Stdlib_Bigarray[7];
        case 2:return Stdlib_Bigarray[10];
        case 3:return Stdlib_Bigarray[6];
        case 4:return Stdlib_Bigarray[6];
        case 5:return Stdlib_Bigarray[8];
        case 6:return Stdlib_Bigarray[10];
        case 7:return Stdlib_Bigarray[1];
        default:return Stdlib_Bigarray[2]}}
    function type_of_bigarray_kind(param)
     {switch(param)
       {case 0:return _g_;
        case 1:return _h_;
        case 2:return _i_;
        case 3:return _j_;
        case 4:return _k_;
        case 5:return _l_;
        case 6:return _m_;
        default:return 0}}
    var
     transparent="transparent",
     native$0="native",
     Ending_type=[0,transparent,native$0];
    function init$0(type,endings,param)
     {var o={};
      caml_call3(_d_[4],o,cst_type$1,type);
      caml_call3(_d_[4],o,cst_endings,endings);
      return o}
    var blob=target.Blob;
    function of_jstr$0(opt,s)
     {if(opt)var sth=opt[1],init=sth;else var init=fn;return new blob(s,init)}
    function of_array_buffer(opt,b)
     {if(opt)var sth=opt[1],init=sth;else var init=fn;
      return new blob(runtime.caml_js_from_array([0,b]),init)}
    function byte_length$1(b){return caml_call2(Int[2],b,cst_size)}
    function type$3(b){return caml_call2(_d_[2],b,cst_type$2)}
    function slice$2(opt,stop,_nT_,b)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(_nT_)var sth$0=_nT_[1],type=sth$0;else var type=empty;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$1(b);
      return b.slice(start,stop$1,type)}
    function array_buffer$0(b)
     {var _nR_=b.arrayBuffer();
      return of_promise$0(function(_nS_){return _nS_},_nR_)}
    function stream(b){return b.stream}
    function text(b)
     {var _nP_=b.text();return of_promise$0(function(_nQ_){return _nQ_},_nP_)}
    function data_uri(b)
     {var
       reader=new (target.FileReader)(),
       match=create$1(0),
       set_fut=match[2],
       fut=match[1];
      function ok(e)
       {return caml_call1(set_fut,[0,caml_call2(_d_[2],reader,cst_result)])}
      function error(e){return caml_call1(set_fut,[1,reader.error])}
      listen([0,listen_opts(0,_n_,0,0)],load,ok,reader);
      listen([0,listen_opts(0,_o_,0,0)],error$1,error,reader);
      reader.readAsDataURL(b);
      return fut}
    function init$1(blob_init,last_modified_ms,param)
     {if(blob_init)var b=blob_init[1],o=b;else var o={};
      caml_call3(Int[4],o,cst_lastModified,last_modified_ms);
      return o}
    var file$0=target.File;
    function of_blob(opt,name,b)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new file$0(b,name,init)}
    function name$0(f){return caml_call2(_d_[2],f,cst_name$0)}
    function last_modified_ms(f)
     {return caml_call2(Int[2],f,cst_lastModified$0)}
    function data_utf_8_of_jstr(s){return to_binary_jstr(of_jstr(s))}
    function data_utf_8_to_jstr(d)
     {var e=of_binary_jstr(d);
      if(0 === e[0]){var t=e[1];return to_jstr(t)}
      return e}
    function data_of_binary_jstr(_nO_){return _nO_}
    function data_to_binary_jstr(_nN_){return _nN_}
    function encode(bs)
     {try
       {var v=target.btoa(bs)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function decode(s)
     {try
       {var v=target.atob(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var
     Base64=
      [0,
       data_utf_8_of_jstr,
       data_utf_8_to_jstr,
       data_of_binary_jstr,
       data_to_binary_jstr,
       encode,
       decode],
     json=target.JSON;
    function encode$0(v){return json.stringify(v)}
    function decode$0(s)
     {try
       {var v=json.parse(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var encode$1=target.encodeURI,decode$1=target.decodeURI,url=target.URL;
    function v$0(base,s)
     {if(base){var b=base[1];return new url(s,b)}return new url(s)}
    function with_uri(scheme,host,port,path,query,fragment,u)
     {var u$0=new url(u);
      function pct_enc(v){return encode$1(v)}
      try
       {set_if_some
         (u$0,cst_protocol,caml_call2(Stdlib_Option[7],pct_enc,scheme));
        set_if_some
         (u$0,cst_hostname,caml_call2(Stdlib_Option[7],pct_enc,host));
        if(port)
         {var
           p=port[1],
           _nK_=function(eta){return arg(0,eta)},
           _nL_=caml_call2(Stdlib_Option[7],_nK_,p);
          caml_call3(_d_[4],u$0,cst_port,_nL_)}
        set_if_some
         (u$0,cst_pathname,caml_call2(Stdlib_Option[7],pct_enc,path));
        set_if_some(u$0,cst_search,caml_call2(Stdlib_Option[7],pct_enc,query));
        set_if_some
         (u$0,cst_hash,caml_call2(Stdlib_Option[7],pct_enc,fragment));
        var _nM_=[0,u$0];
        return _nM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function pct_dec(v){return decode$1(v)}
    function scheme(u)
     {var p=pct_dec(u.protocol);return 0 === p.length?p:slice(0,_p_,p)}
    function host(u){return pct_dec(u.hostname)}
    function port(u)
     {var p=caml_call2(_d_[2],u,cst_port$0);return is_empty(p)?0:to_int(0,p)}
    function query(u)
     {var q=pct_dec(u.search);return is_empty(q)?q:slice(_q_,0,q)}
    function path(u){return pct_dec(u.pathname)}
    function fragment(u)
     {var f=decode$1(u.hash);return is_empty(f)?f:slice(_r_,0,f)}
    var usp=target.URLSearchParams;
    function is_empty$0(p)
     {var _nI_=p.entries(),_nJ_=caml_call1(_b_[6],_nI_);
      return caml_call1(_b_[1],_nJ_)}
    function mem(k,p){return p.has(k) | 0}
    function find$6(k,p)
     {var _nG_=p.get(k);return to_option(function(_nH_){return _nH_},_nG_)}
    function find_all(k,p){return caml_list_of_js_array(p.getAll(k))}
    function fold$0(f,p,acc)
     {function key(_nF_){return _nF_}
      function value(_nE_){return _nE_}
      var _nD_=p.entries();
      return caml_call5(_b_[8],key,value,f,_nD_,acc)}
    function of_jstr$1(s){return new usp(s)}
    function to_jstr$0(p){return p.toString()}
    function of_assoc(l)
     {var p=of_jstr$1(empty);
      function _nC_(param){var v=param[2],k=param[1];p.append(k,v);return 0}
      caml_call2(Stdlib_List[17],_nC_,l);
      return p}
    function to_assoc(p)
     {var
       _nA_=0,
       _nB_=fold$0(function(k,v,acc){return [0,[0,k,v],acc]},p,_nA_);
      return caml_call1(Stdlib_List[9],_nB_)}
    function of_obj(o){return new usp(o)}
    function code$0(f,s)
     {try
       {var v=f(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var
     encode_component=target.encodeURIComponent,
     _s_=target.decodeURIComponent;
    function encode$2(s){return code$0(encode$1,s)}
    function decode$2(s){return code$0(decode$1,s)}
    function encode_component$0(s){return code$0(encode_component,s)}
    function decode_component(s){return code$0(_s_,s)}
    function to_jstr$1(u){return u.toString()}
    function of_jstr$2(base,s)
     {try
       {var v=v$0(base,s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function v$1(n,v){return [0,n,v]}
    function true$1(n){return [0,n,empty]}
    function int$0(n,i){return [0,n,arg(0,i)]}
    function add_if(b,at,l){return b?[0,at,l]:l}
    function add_if_some(name,o,l)
     {if(o){var a=o[1];return [0,[0,name,a],l]}return l}
    function to_pair(_nz_){return _nz_}
    var
     accesskey="accesskey",
     autofocus="autofocus",
     charset="charset",
     checked="checked",
     class$0="class",
     content="content",
     contenteditable="contenteditable",
     cols="cols",
     defer="defer",
     disabled="disabled",
     dir="dir",
     draggable="draggable",
     for$0="for",
     height$0="height",
     hidden="hidden",
     href="href",
     id$0="id",
     lang="lang",
     media="media",
     name$1="name",
     placeholder="placeholder",
     rel="rel",
     required="required",
     rows="rows",
     src="src",
     spellcheck="spellcheck",
     tabindex="tabindex",
     title="title",
     type$4="type",
     value="value",
     width$0="width",
     wrap="wrap";
    function accesskey$0(s){return [0,accesskey,s]}
    var autofocus$0=true$1(autofocus);
    function charset$0(_ny_){return [0,charset,_ny_]}
    var checked$0=true$1(checked);
    function class$1(s){return [0,class$0,s]}
    function cols$0(i){return int$0(cols,i)}
    function content$0(s){return [0,content,s]}
    function contenteditable$0(s){return true$1(contenteditable)}
    var defer$0=true$1(defer),disabled$0=true$1(disabled);
    function dir$0(s){return [0,dir,s]}
    function draggable$0(s){return true$1(draggable)}
    function for$1(s){return [0,for$0,s]}
    function height$1(i){return int$0(height$0,i)}
    var hidden$0=true$1(hidden);
    function href$0(s){return [0,href,s]}
    function id$1(s){return [0,id$0,s]}
    function lang$0(s){return [0,lang,s]}
    function media$0(s){return [0,media,s]}
    function name$2(s){return [0,name$1,s]}
    function placeholder$0(s){return [0,placeholder,s]}
    function rel$0(s){return [0,rel,s]}
    var required$0=true$1(required);
    function rows$0(i){return int$0(rows,i)}
    function src$0(s){return [0,src,s]}
    function spellcheck$0(_nx_){return [0,spellcheck,_nx_]}
    function tabindex$0(i){return int$0(tabindex,i)}
    function title$0(s){return [0,title,s]}
    function type$5(s){return [0,type$4,s]}
    function value$0(s){return [0,value,s]}
    function width$1(i){return int$0(width$0,i)}
    function wrap$0(s){return [0,value,s]}
    var document=target.document;
    function document$0(e){return e.ownerDocument}
    var global_root=document.documentElement;
    function el_list_of_node_list(nl)
     {var acc=[0,0],len=caml_call2(Int[2],nl,cst_length$1),_nv_=len - 1 | 0;
      if(! (_nv_ < 0))
       {var i=_nv_;
        for(;;)
         {acc[1] = [0,nl[i],acc[1]];
          var _nw_=i - 1 | 0;
          if(0 !== i){var i=_nw_;continue}
          break}}
      return acc[1]}
    function _t_(e,n){e.appendChild(n);return 0}
    function v$2(opt,_nr_,name,cs)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      if(_nr_)var sth$0=_nr_[1],at=sth$0;else var at=0;
      var e=d.createElement(name);
      function _ns_(param)
       {var v=param[2],a=param[1],match=caml_equal(a,class$0);
        return match
                ?is_empty(v)?0:(e.classList.add(v),0)
                :(e.setAttribute(a,v),0)}
      caml_call2(Stdlib_List[17],_ns_,at);
      function _nt_(_nu_){return _t_(e,_nu_)}
      caml_call2(Stdlib_List[17],_nt_,cs);
      return e}
    function txt(opt,s)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      return d.createTextNode(s)}
    function txt$0(opt,s)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      return d.createTextNode(caml_jsstring_of_string(s))}
    function sp$0(opt,param){return txt(0," ")}
    function nbsp(opt,param){return txt(0,caml_jsstring_of_string(cst))}
    function is_txt(e){return 3 === caml_call2(Int[2],e,cst_nodeType)?1:0}
    function is_el(e){return 1 === caml_call2(Int[2],e,cst_nodeType$0)?1:0}
    function tag_name(e)
     {return caml_call2(_d_[2],e,cst_nodeName).toLowerCase()}
    function has_tag_name(n,e){return caml_equal(n,tag_name(e))}
    function txt_text(txt)
     {var match=is_txt(txt);
      return match?caml_call2(_d_[2],txt,cst_nodeValue):empty}
    function find_by_class(opt,c)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      return el_list_of_node_list(root.getElementsByClassName(c))}
    function find_by_tag_name(opt,n)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      return el_list_of_node_list(root.getElementsByTagName(n))}
    function find_first_by_selector(opt,sel)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      var _np_=root.querySelector(sel);
      return to_option(function(_nq_){return _nq_},_np_)}
    function fold_find_by_selector(opt,f,sel,acc)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      var
       nl=root.querySelectorAll(sel),
       acc$0=[0,acc],
       _nn_=caml_call2(Int[2],nl,cst_length$2) - 1 | 0,
       _nm_=0;
      if(! (_nn_ < 0))
       {var i=_nm_;
        for(;;)
         {acc$0[1] = caml_call2(f,nl[i],acc$0[1]);
          var _no_=i + 1 | 0;
          if(_nn_ !== i){var i=_no_;continue}
          break}}
      return acc$0[1]}
    function parent(e)
     {var match=find(e,cst_parentNode);
      if(match){var e$0=match[1];if(is_el(e$0))return [0,e$0]}
      return 0}
    function children(opt,e)
     {if(opt)var sth=opt[1],only_els=sth;else var only_els=0;
      return only_els
              ?el_list_of_node_list(e.children)
              :el_list_of_node_list(e.childNodes)}
    function set_children(e,l)
     {for(;;)
       {if(is_null(e.firstChild))
         {var _nk_=function(_nl_){return _t_(e,_nl_)};
          return caml_call2(Stdlib_List[17],_nk_,l)}
        e.removeChild(e.firstChild);
        continue}}
    function prepend_children(e,l)
     {caml_js_meth_call(e,cst_prepend,caml_call1(Stdlib_Array[12],l));
      return 0}
    function append_children(e,l)
     {caml_js_meth_call(e,cst_append,caml_call1(Stdlib_Array[12],l));return 0}
    function insert_siblings(loc,e,l)
     {if(-126259180 === loc)
       caml_js_meth_call(e,cst_replaceWith,caml_call1(Stdlib_Array[12],l));
      else
       if(818927100 <= loc)
        caml_js_meth_call(e,cst_after,caml_call1(Stdlib_Array[12],l));
       else
        caml_js_meth_call(e,cst_before,caml_call1(Stdlib_Array[12],l));
      return 0}
    function remove$0(e){e.remove(e);return 0}
    function at(a,e)
     {var _ni_=e.getAttribute(a);
      return to_option(function(_nj_){return _nj_},_ni_)}
    function set_at(a,v,e)
     {if(v){var v$0=v[1];e.setAttribute(a,v$0);return 0}
      e.removeAttribute(a);
      return 0}
    function jv_to_bool(b){return is_undefined(b)?0:b | 0}
    function jv_to_int(i){return is_undefined(i)?0:i}
    function jv_to_float(f){return is_undefined(f)?0.:f}
    function jv_to_jstr(s){return is_undefined(s)?empty:s}
    function bool(n){return [0,n,jv_to_bool,caml_js_from_bool]}
    function int$1(n){return [0,n,jv_to_int,function(_nh_){return _nh_}]}
    function float$0(n){return [0,n,jv_to_float,function(_ng_){return _ng_}]}
    function jstr(n){return [0,n,jv_to_jstr,function(_nf_){return _nf_}]}
    var
     checked$1=bool("checked"),
     height$2=int$1("height"),
     id$2=jstr("id"),
     name$3=jstr("name"),
     title$1=jstr("title"),
     value$1=jstr("value"),
     width$2=int$1("width");
    function prop(p,e){return caml_call1(p[2],e[p[1]])}
    function set_prop(p,v,e)
     {var _ne_=caml_call1(p[3],v);e[p[1]] = _ne_;return 0}
    function class$2(c,e){return e.classList.contains(c) | 0}
    function set_class(c,b,e)
     {return b?(e.classList.add(c),0):(e.classList.remove(c),0)}
    var
     background_color="background-color",
     color="color",
     cursor="cursor",
     display="display",
     height$3="height",
     visibility="visibility",
     width$3="width",
     Style=
      [0,background_color,color,cursor,display,height$3,visibility,width$3];
    function computed_style(opt,p,e)
     {if(opt)var sth=opt[1],w=sth;else var w=target.window;
      var style=w.getComputedStyle(e),v=style[p];
      return is_none(v)?empty:v}
    function inline_style(p,e)
     {var style=e.style;
      if(is_none(style))return empty;
      var v=style[p];
      return is_none(v)?empty:v}
    function set_inline_style(opt,p,v,e)
     {if(opt)var sth=opt[1],important=sth;else var important=0;
      var priority=important?"important":empty,style=e.style;
      return is_none(style)?0:(style.setProperty(p,v,priority),0)}
    function inner_x(e){return caml_call2(Float[2],e,cst_clientLeft)}
    function inner_y(e){return caml_call2(Float[2],e,cst_clientTop)}
    function inner_w(e){return caml_call2(Float[2],e,cst_clientWidth)}
    function inner_h(e){return caml_call2(Float[2],e,cst_clientHeight)}
    function bound_x(e)
     {var _nd_=e.getBoundingClientRect();
      return caml_call2(Float[2],_nd_,cst_x)}
    function bound_y(e)
     {var _nc_=e.getBoundingClientRect();
      return caml_call2(Float[2],_nc_,cst_y)}
    function bound_w(e)
     {var _nb_=e.getBoundingClientRect();
      return caml_call2(Float[2],_nb_,cst_width$0)}
    function bound_h(e)
     {var _na_=e.getBoundingClientRect();
      return caml_call2(Float[2],_na_,cst_height$0)}
    function scroll_x(e){return caml_call2(Float[2],e,cst_scrollLeft)}
    function scroll_y(e){return caml_call2(Float[2],e,cst_scrollTop)}
    function scroll_w(e){return caml_call2(Float[2],e,cst_scrollWidth)}
    function scroll_h(e){return caml_call2(Float[2],e,cst_scrollHeight)}
    function scroll_into_view(opt,e)
     {if(opt)var sth=opt[1],align_v=sth;else var align_v=389604418;
      var align=389604418 <= align_v?0:1;
      e.scrollIntoView(! ! align);
      return 0}
    function has_focus(e)
     {var
       _m__=e.ownerDocument.activeElement,
       match=to_option(function(_m$_){return _m$_},_m__);
      if(match){var e$0=match[1];return e === e$0?1:0}
      return 0}
    function set_has_focus(b,e){if(b)e.focus();else e.blur();return 0}
    function is_locking_pointer(e)
     {var
       _m8_=e.ownerDocument.pointerLockElement,
       match=to_option(function(_m9_){return _m9_},_m8_);
      if(match){var e$0=match[1];return e === e$0?1:0}
      return 0}
    function request_pointer_lock(e)
     {var
       match=create$1(0),
       set=match[2],
       fut=match[1],
       d=e.ownerDocument,
       opts=listen_opts(0,_u_,0,0);
      function unlisten$0(param)
       {unlisten([0,opts],pointerlockchange,locked,d);
        return unlisten([0,opts],pointerlockerror,error,d)}
      function locked(ev){caml_call1(set,_v_);return unlisten$0(0)}
      function error(ev)
       {var err=caml_call2(_c_[1],0,"Could not lock pointer");
        caml_call1(set,[1,err]);
        return unlisten$0(0)}
      listen([0,opts],pointerlockchange,locked,d);
      listen([0,opts],pointerlockerror,error,d);
      e.requestPointerLock();
      return fut}
    function click$0(e){e.click();return 0}
    function select_text(e){e.select();return 0}
    var auto="auto",hide="hide",show="show",Navigation_ui=[0,auto,hide,show];
    function fullscreen_opts(navigation_ui,param)
     {var o={};caml_call3(_d_[4],o,cst_navigationUI,navigation_ui);return o}
    function request_fullscreen(opt,e)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      var _m6_=e.requestFullscreen(opts);
      return of_promise$0(function(_m7_){return 0},_m6_)}
    function files(e)
     {var match=find(e,cst_files);
      if(match)
       {var files=match[1];return to_list(function(_m5_){return _m5_},files)}
      return 0}
    var
     Input$0=[0,files],
     a="a",
     abbr="abbr",
     address="address",
     area="area",
     article="article",
     aside="aside",
     audio="audio",
     b="b",
     base="base",
     bdi="bdi",
     bdo="bdo",
     blockquote="blockquote",
     body="body",
     br="br",
     button$0="button",
     canvas="canvas",
     caption="caption",
     cite="cite",
     code$1="code",
     col="col",
     colgroup="colgroup",
     command="command",
     datalist="datalist",
     dd="dd",
     del="del",
     details="details",
     dfn="dfn",
     div="div",
     dl="dl",
     dt="dt",
     em="em",
     embed="embed",
     fieldset="fieldset",
     figcaption="figcaption",
     figure="figure",
     footer="footer",
     form="form",
     h1="h1",
     h2="h2",
     h3="h3",
     h4="h4",
     h5="h5",
     h6="h6",
     head="head",
     header="header",
     hgroup="hgroup",
     hr="hr",
     html="html",
     i="i",
     iframe="iframe",
     img="img",
     input$0="input",
     ins="ins",
     kbd="kbd",
     keygen="keygen",
     label="label",
     legend="legend",
     li="li",
     link$0="link",
     map$1="map",
     mark="mark",
     menu="menu",
     meta="meta",
     meter="meter",
     nav="nav",
     noscript="noscript",
     object="object",
     ol="ol",
     optgroup="optgroup",
     option="option",
     output="output",
     p="p",
     param="param",
     pre="pre",
     progress$0="progress",
     q="q",
     rp="rp",
     rt="rt",
     ruby="ruby",
     s="s",
     samp="samp",
     script="script",
     section="section",
     select$0="select",
     small="small",
     source="source",
     span="span",
     strong="strong",
     style="style",
     sub$1="sub",
     summary="summary",
     sup="sup",
     table="table",
     tbody="tbody",
     td="td",
     textarea="textarea",
     tfoot="tfoot",
     th="th",
     thead="thead",
     time="time",
     title$2="title",
     tr="tr",
     track="track",
     u="u",
     ul="ul",
     var$0="var",
     video="video",
     wbr="wbr",
     Name=
      [0,
       a,
       abbr,
       address,
       area,
       article,
       aside,
       audio,
       b,
       base,
       bdi,
       bdo,
       blockquote,
       body,
       br,
       button$0,
       canvas,
       caption,
       cite,
       code$1,
       col,
       colgroup,
       command,
       datalist,
       dd,
       del,
       details,
       dfn,
       div,
       dl,
       dt,
       em,
       embed,
       fieldset,
       figcaption,
       figure,
       footer,
       form,
       h1,
       h2,
       h3,
       h4,
       h5,
       h6,
       head,
       header,
       hgroup,
       hr,
       html,
       i,
       iframe,
       img,
       input$0,
       ins,
       kbd,
       keygen,
       label,
       legend,
       li,
       link$0,
       map$1,
       mark,
       menu,
       meta,
       meter,
       nav,
       noscript,
       object,
       ol,
       optgroup,
       option,
       output,
       p,
       param,
       pre,
       progress$0,
       q,
       rp,
       rt,
       ruby,
       s,
       samp,
       script,
       section,
       select$0,
       small,
       source,
       span,
       strong,
       style,
       sub$1,
       summary,
       sup,
       table,
       tbody,
       td,
       textarea,
       tfoot,
       th,
       thead,
       time,
       title$2,
       tr,
       track,
       u,
       ul,
       var$0,
       video,
       wbr];
    function cons(name,d,at,cs){return v$2(d,at,name,cs)}
    function void_cons(name,d,at,param){return v$2(d,at,name,0)}
    var _w_=Name[1];
    function a$0(_m2_,_m3_,_m4_){return cons(_w_,_m2_,_m3_,_m4_)}
    var _x_=Name[2];
    function abbr$0(_mZ_,_m0_,_m1_){return cons(_x_,_mZ_,_m0_,_m1_)}
    var _y_=Name[3];
    function address$0(_mW_,_mX_,_mY_){return cons(_y_,_mW_,_mX_,_mY_)}
    var _z_=Name[4];
    function area$0(_mT_,_mU_,_mV_){return void_cons(_z_,_mT_,_mU_,_mV_)}
    var _A_=Name[5];
    function article$0(_mQ_,_mR_,_mS_){return cons(_A_,_mQ_,_mR_,_mS_)}
    var _B_=Name[6];
    function aside$0(_mN_,_mO_,_mP_){return cons(_B_,_mN_,_mO_,_mP_)}
    var _C_=Name[7];
    function audio$0(_mK_,_mL_,_mM_){return cons(_C_,_mK_,_mL_,_mM_)}
    var _D_=Name[8];
    function b$0(_mH_,_mI_,_mJ_){return cons(_D_,_mH_,_mI_,_mJ_)}
    var _E_=Name[9];
    function base$0(_mE_,_mF_,_mG_){return void_cons(_E_,_mE_,_mF_,_mG_)}
    var _F_=Name[10];
    function bdi$0(_mB_,_mC_,_mD_){return cons(_F_,_mB_,_mC_,_mD_)}
    var _G_=Name[11];
    function bdo$0(_my_,_mz_,_mA_){return cons(_G_,_my_,_mz_,_mA_)}
    var _H_=Name[12];
    function blockquote$0(_mv_,_mw_,_mx_){return cons(_H_,_mv_,_mw_,_mx_)}
    var _I_=Name[13];
    function body$0(_ms_,_mt_,_mu_){return cons(_I_,_ms_,_mt_,_mu_)}
    var _J_=Name[14];
    function br$0(_mp_,_mq_,_mr_){return void_cons(_J_,_mp_,_mq_,_mr_)}
    var _K_=Name[15];
    function button$1(_mm_,_mn_,_mo_){return cons(_K_,_mm_,_mn_,_mo_)}
    var _L_=Name[16];
    function canvas$0(_mj_,_mk_,_ml_){return cons(_L_,_mj_,_mk_,_ml_)}
    var _M_=Name[17];
    function caption$0(_mg_,_mh_,_mi_){return cons(_M_,_mg_,_mh_,_mi_)}
    var _N_=Name[18];
    function cite$0(_md_,_me_,_mf_){return cons(_N_,_md_,_me_,_mf_)}
    var _O_=Name[19];
    function code$2(_ma_,_mb_,_mc_){return cons(_O_,_ma_,_mb_,_mc_)}
    var _P_=Name[20];
    function col$0(_l9_,_l__,_l$_){return void_cons(_P_,_l9_,_l__,_l$_)}
    var _Q_=Name[21];
    function colgroup$0(_l6_,_l7_,_l8_){return cons(_Q_,_l6_,_l7_,_l8_)}
    var _R_=Name[22];
    function command$0(_l3_,_l4_,_l5_){return cons(_R_,_l3_,_l4_,_l5_)}
    var _S_=Name[23];
    function datalist$0(_l0_,_l1_,_l2_){return cons(_S_,_l0_,_l1_,_l2_)}
    var _T_=Name[24];
    function dd$0(_lX_,_lY_,_lZ_){return cons(_T_,_lX_,_lY_,_lZ_)}
    var _U_=Name[25];
    function del$0(_lU_,_lV_,_lW_){return cons(_U_,_lU_,_lV_,_lW_)}
    var _V_=Name[26];
    function details$0(_lR_,_lS_,_lT_){return cons(_V_,_lR_,_lS_,_lT_)}
    var _W_=Name[27];
    function dfn$0(_lO_,_lP_,_lQ_){return cons(_W_,_lO_,_lP_,_lQ_)}
    var _X_=Name[28];
    function div$0(_lL_,_lM_,_lN_){return cons(_X_,_lL_,_lM_,_lN_)}
    var _Y_=Name[29];
    function dl$0(_lI_,_lJ_,_lK_){return cons(_Y_,_lI_,_lJ_,_lK_)}
    var _Z_=Name[30];
    function dt$0(_lF_,_lG_,_lH_){return cons(_Z_,_lF_,_lG_,_lH_)}
    var ___=Name[31];
    function em$0(_lC_,_lD_,_lE_){return cons(___,_lC_,_lD_,_lE_)}
    var _$_=Name[32];
    function embed$0(_lz_,_lA_,_lB_){return void_cons(_$_,_lz_,_lA_,_lB_)}
    var _aa_=Name[33];
    function fieldset$0(_lw_,_lx_,_ly_){return cons(_aa_,_lw_,_lx_,_ly_)}
    var _ab_=Name[34];
    function figcaption$0(_lt_,_lu_,_lv_){return cons(_ab_,_lt_,_lu_,_lv_)}
    var _ac_=Name[35];
    function figure$0(_lq_,_lr_,_ls_){return cons(_ac_,_lq_,_lr_,_ls_)}
    var _ad_=Name[36];
    function footer$0(_ln_,_lo_,_lp_){return cons(_ad_,_ln_,_lo_,_lp_)}
    var _ae_=Name[37];
    function form$0(_lk_,_ll_,_lm_){return cons(_ae_,_lk_,_ll_,_lm_)}
    var _af_=Name[38];
    function h1$0(_lh_,_li_,_lj_){return cons(_af_,_lh_,_li_,_lj_)}
    var _ag_=Name[39];
    function h2$0(_le_,_lf_,_lg_){return cons(_ag_,_le_,_lf_,_lg_)}
    var _ah_=Name[40];
    function h3$0(_lb_,_lc_,_ld_){return cons(_ah_,_lb_,_lc_,_ld_)}
    var _ai_=Name[41];
    function h4$0(_k__,_k$_,_la_){return cons(_ai_,_k__,_k$_,_la_)}
    var _aj_=Name[42];
    function h5$0(_k7_,_k8_,_k9_){return cons(_aj_,_k7_,_k8_,_k9_)}
    var _ak_=Name[43];
    function h6$0(_k4_,_k5_,_k6_){return cons(_ak_,_k4_,_k5_,_k6_)}
    var _al_=Name[44];
    function head$0(_k1_,_k2_,_k3_){return cons(_al_,_k1_,_k2_,_k3_)}
    var _am_=Name[45];
    function header$0(_kY_,_kZ_,_k0_){return cons(_am_,_kY_,_kZ_,_k0_)}
    var _an_=Name[46];
    function hgroup$0(_kV_,_kW_,_kX_){return cons(_an_,_kV_,_kW_,_kX_)}
    var _ao_=Name[47];
    function hr$0(_kS_,_kT_,_kU_){return void_cons(_ao_,_kS_,_kT_,_kU_)}
    var _ap_=Name[48];
    function html$0(_kP_,_kQ_,_kR_){return cons(_ap_,_kP_,_kQ_,_kR_)}
    var _aq_=Name[49];
    function i$0(_kM_,_kN_,_kO_){return cons(_aq_,_kM_,_kN_,_kO_)}
    var _ar_=Name[50];
    function iframe$0(_kJ_,_kK_,_kL_){return cons(_ar_,_kJ_,_kK_,_kL_)}
    var _as_=Name[51];
    function img$0(_kG_,_kH_,_kI_){return void_cons(_as_,_kG_,_kH_,_kI_)}
    var _at_=Name[52];
    function input$1(_kD_,_kE_,_kF_){return void_cons(_at_,_kD_,_kE_,_kF_)}
    var _au_=Name[53];
    function ins$0(_kA_,_kB_,_kC_){return cons(_au_,_kA_,_kB_,_kC_)}
    var _av_=Name[54];
    function kbd$0(_kx_,_ky_,_kz_){return cons(_av_,_kx_,_ky_,_kz_)}
    var _aw_=Name[55];
    function keygen$0(_ku_,_kv_,_kw_){return cons(_aw_,_ku_,_kv_,_kw_)}
    var _ax_=Name[56];
    function label$0(_kr_,_ks_,_kt_){return cons(_ax_,_kr_,_ks_,_kt_)}
    var _ay_=Name[57];
    function legend$0(_ko_,_kp_,_kq_){return cons(_ay_,_ko_,_kp_,_kq_)}
    var _az_=Name[58];
    function li$0(_kl_,_km_,_kn_){return cons(_az_,_kl_,_km_,_kn_)}
    var _aA_=Name[59];
    function link$1(_ki_,_kj_,_kk_){return void_cons(_aA_,_ki_,_kj_,_kk_)}
    var _aB_=Name[60];
    function map$2(_kf_,_kg_,_kh_){return cons(_aB_,_kf_,_kg_,_kh_)}
    var _aC_=Name[61];
    function mark$0(_kc_,_kd_,_ke_){return cons(_aC_,_kc_,_kd_,_ke_)}
    var _aD_=Name[62];
    function menu$0(_j$_,_ka_,_kb_){return cons(_aD_,_j$_,_ka_,_kb_)}
    var _aE_=Name[63];
    function meta$0(_j8_,_j9_,_j__){return void_cons(_aE_,_j8_,_j9_,_j__)}
    var _aF_=Name[64];
    function meter$0(_j5_,_j6_,_j7_){return cons(_aF_,_j5_,_j6_,_j7_)}
    var _aG_=Name[65];
    function nav$0(_j2_,_j3_,_j4_){return cons(_aG_,_j2_,_j3_,_j4_)}
    var _aH_=Name[66];
    function noscript$0(_jZ_,_j0_,_j1_){return cons(_aH_,_jZ_,_j0_,_j1_)}
    var _aI_=Name[67];
    function object$0(_jW_,_jX_,_jY_){return cons(_aI_,_jW_,_jX_,_jY_)}
    var _aJ_=Name[68];
    function ol$0(_jT_,_jU_,_jV_){return cons(_aJ_,_jT_,_jU_,_jV_)}
    var _aK_=Name[69];
    function optgroup$0(_jQ_,_jR_,_jS_){return cons(_aK_,_jQ_,_jR_,_jS_)}
    var _aL_=Name[70];
    function option$0(_jN_,_jO_,_jP_){return cons(_aL_,_jN_,_jO_,_jP_)}
    var _aM_=Name[71];
    function output$0(_jK_,_jL_,_jM_){return cons(_aM_,_jK_,_jL_,_jM_)}
    var _aN_=Name[72];
    function p$0(_jH_,_jI_,_jJ_){return cons(_aN_,_jH_,_jI_,_jJ_)}
    var _aO_=Name[73];
    function param$0(_jE_,_jF_,_jG_){return void_cons(_aO_,_jE_,_jF_,_jG_)}
    var _aP_=Name[74];
    function pre$0(_jB_,_jC_,_jD_){return cons(_aP_,_jB_,_jC_,_jD_)}
    var _aQ_=Name[75];
    function progress$1(_jy_,_jz_,_jA_){return cons(_aQ_,_jy_,_jz_,_jA_)}
    var _aR_=Name[76];
    function q$0(_jv_,_jw_,_jx_){return cons(_aR_,_jv_,_jw_,_jx_)}
    var _aS_=Name[77];
    function rp$0(_js_,_jt_,_ju_){return cons(_aS_,_js_,_jt_,_ju_)}
    var _aT_=Name[78];
    function rt$0(_jp_,_jq_,_jr_){return cons(_aT_,_jp_,_jq_,_jr_)}
    var _aU_=Name[79];
    function ruby$0(_jm_,_jn_,_jo_){return cons(_aU_,_jm_,_jn_,_jo_)}
    var _aV_=Name[80];
    function s$0(_jj_,_jk_,_jl_){return cons(_aV_,_jj_,_jk_,_jl_)}
    var _aW_=Name[81];
    function samp$0(_jg_,_jh_,_ji_){return cons(_aW_,_jg_,_jh_,_ji_)}
    var _aX_=Name[82];
    function script$0(_jd_,_je_,_jf_){return cons(_aX_,_jd_,_je_,_jf_)}
    var _aY_=Name[83];
    function section$0(_ja_,_jb_,_jc_){return cons(_aY_,_ja_,_jb_,_jc_)}
    var _aZ_=Name[84];
    function select$1(_i9_,_i__,_i$_){return cons(_aZ_,_i9_,_i__,_i$_)}
    var _a0_=Name[85];
    function small$0(_i6_,_i7_,_i8_){return cons(_a0_,_i6_,_i7_,_i8_)}
    var _a1_=Name[86];
    function source$0(_i3_,_i4_,_i5_){return void_cons(_a1_,_i3_,_i4_,_i5_)}
    var _a2_=Name[87];
    function span$0(_i0_,_i1_,_i2_){return cons(_a2_,_i0_,_i1_,_i2_)}
    var _a3_=Name[88];
    function strong$0(_iX_,_iY_,_iZ_){return cons(_a3_,_iX_,_iY_,_iZ_)}
    var _a4_=Name[89];
    function style$0(_iU_,_iV_,_iW_){return cons(_a4_,_iU_,_iV_,_iW_)}
    var _a5_=Name[90];
    function sub$2(_iR_,_iS_,_iT_){return cons(_a5_,_iR_,_iS_,_iT_)}
    var _a6_=Name[91];
    function summary$0(_iO_,_iP_,_iQ_){return cons(_a6_,_iO_,_iP_,_iQ_)}
    var _a7_=Name[92];
    function sup$0(_iL_,_iM_,_iN_){return cons(_a7_,_iL_,_iM_,_iN_)}
    var _a8_=Name[93];
    function table$0(_iI_,_iJ_,_iK_){return cons(_a8_,_iI_,_iJ_,_iK_)}
    var _a9_=Name[94];
    function tbody$0(_iF_,_iG_,_iH_){return cons(_a9_,_iF_,_iG_,_iH_)}
    var _a__=Name[95];
    function td$0(_iC_,_iD_,_iE_){return cons(_a__,_iC_,_iD_,_iE_)}
    var _a$_=Name[96];
    function textarea$0(_iz_,_iA_,_iB_){return cons(_a$_,_iz_,_iA_,_iB_)}
    var _ba_=Name[97];
    function tfoot$0(_iw_,_ix_,_iy_){return cons(_ba_,_iw_,_ix_,_iy_)}
    var _bb_=Name[98];
    function th$0(_it_,_iu_,_iv_){return cons(_bb_,_it_,_iu_,_iv_)}
    var _bc_=Name[99];
    function thead$0(_iq_,_ir_,_is_){return cons(_bc_,_iq_,_ir_,_is_)}
    var _bd_=Name[100];
    function time$0(_in_,_io_,_ip_){return cons(_bd_,_in_,_io_,_ip_)}
    var _be_=Name[101];
    function title$3(_ik_,_il_,_im_){return cons(_be_,_ik_,_il_,_im_)}
    var _bf_=Name[102];
    function tr$0(_ih_,_ii_,_ij_){return cons(_bf_,_ih_,_ii_,_ij_)}
    var _bg_=Name[103];
    function track$0(_ie_,_if_,_ig_){return void_cons(_bg_,_ie_,_if_,_ig_)}
    var _bh_=Name[104];
    function u$0(_ib_,_ic_,_id_){return cons(_bh_,_ib_,_ic_,_id_)}
    var _bi_=Name[105];
    function ul$0(_h__,_h$_,_ia_){return cons(_bi_,_h__,_h$_,_ia_)}
    var _bj_=Name[106];
    function var$1(_h7_,_h8_,_h9_){return cons(_bj_,_h7_,_h8_,_h9_)}
    var _bk_=Name[107];
    function video$0(_h4_,_h5_,_h6_){return cons(_bk_,_h4_,_h5_,_h6_)}
    var _bl_=Name[108];
    function wbr$0(_h1_,_h2_,_h3_){return void_cons(_bl_,_h1_,_h2_,_h3_)}
    function as_target(d){return d}
    function root(d){return d.documentElement}
    function body$1(d)
     {var b=d.body;
      return is_some(b)
              ?b
              :throw$0
                (0,
                 "Document body is null. Try to defer your script execution.")}
    function head$1(d){return d.head}
    function active_el(d)
     {var _hZ_=d.activeElement;
      return to_option(function(_h0_){return _h0_},_hZ_)}
    function find_el_by_id(d,id)
     {var _hX_=d.getElementById(id);
      return to_option(function(_hY_){return _hY_},_hX_)}
    function find_els_by_name(d,n)
     {return el_list_of_node_list(d.getElementsByName(n))}
    function referrer(d){return caml_call2(_d_[2],d,cst_referrer)}
    function title$4(d){return caml_call2(_d_[2],d,cst_title)}
    function set_title(d,t){return caml_call3(_d_[3],d,cst_title$0,t)}
    var
     hidden$1="hidden",
     visible="visible",
     Visibility_state=[0,hidden$1,visible];
    function visibility_state(d)
     {return caml_call2(_d_[2],d,cst_visibilityState)}
    function pointer_lock_element(d)
     {var _hV_=d.pointerLockElement;
      return to_option(function(_hW_){return _hW_},_hV_)}
    function exit_pointer_lock(d)
     {var fut=next$0(0,pointerlockchange,d);d.exitPointerLock();return fut}
    function fullscreen_available(d)
     {return caml_call2(Bool[2],d,cst_fullscreenEnabled)}
    function fullscreen_element(d)
     {var _hT_=d.fullscreenElement;
      return to_option(function(_hU_){return _hU_},_hT_)}
    function exit_fullscreen(d)
     {var _hR_=d.exitFullscreen();
      return of_promise$0(function(_hS_){return 0},_hR_)}
    function aborted(s){return caml_call2(Bool[2],s,cst_aborted)}
    var abort$0="abort",Signal=[0,aborted,abort$0];
    function controller(param){return new (target.AbortController)()}
    function signal(c){return c.signal}
    function abort$1(c){c.abort();return 0}
    var Abort=[0,Signal,controller,signal,abort$1];
    function call$0(c,meth,args){caml_js_meth_call(c,meth,args);return 0}
    var c=[0,target.console];
    function get$4(param){return c[1]}
    function set$3(n){c[1] = n;return 0}
    function clear$0(param){return call$0(c[1],cst_clear,[0])}
    function msg(v){return [0,v,0]}
    function str(v)
     {return is_null(v)?"null":is_undefined(v)?"undefined":v.toString()}
    function msg_to_jv_array(msg)
     {var a=caml_call1(Jarray[1],0),i=0,param=msg;
      for(;;)
       {if(param)
         {var vs=param[2],v=param[1];
          a[i] = v;
          var i$0=i + 1 | 0,i=i$0,param=vs;
          continue}
        return runtime.caml_js_to_array(a)}}
    function log(msg)
     {var _hQ_=msg_to_jv_array(msg);return call$0(c[1],cst_log,_hQ_)}
    function trace(msg)
     {var _hP_=msg_to_jv_array(msg);return call$0(c[1],cst_trace,_hP_)}
    function error$2(msg)
     {var _hO_=msg_to_jv_array(msg);return call$0(c[1],cst_error,_hO_)}
    function warn(msg)
     {var _hN_=msg_to_jv_array(msg);return call$0(c[1],cst_warn,_hN_)}
    function info(msg)
     {var _hM_=msg_to_jv_array(msg);return call$0(c[1],cst_info,_hM_)}
    function debug(msg)
     {var _hL_=msg_to_jv_array(msg);return call$0(c[1],cst_debug,_hL_)}
    function assert(b,msg)
     {var _hK_=msg_to_jv_array([0,! ! b,msg]);
      return call$0(c[1],cst_assert,_hK_)}
    function dir$1(o){return call$0(c[1],cst_dir,[0,o])}
    function table$1(cols,v)
     {if(cols)
       var l=cols[1],msg=[0,v,caml_list_to_js_array(l)];
      else
       var msg=[0,v];
      return call$0(c[1],cst_table,msg)}
    function group_end(param){return call$0(c[1],cst_groupEnd,[0])}
    function group(opt,msg)
     {if(opt)var sth=opt[1],closed=sth;else var closed=0;
      if(closed)
       {var _hI_=msg_to_jv_array(msg);
        return call$0(c[1],cst_groupCollapsed,_hI_)}
      var _hJ_=msg_to_jv_array(msg);
      return call$0(c[1],cst_group,_hJ_)}
    function count(label){return call$0(c[1],cst_count,[0,label])}
    function count_reset(label){return call$0(c[1],cst_countReset,[0,label])}
    function time$1(label){return call$0(c[1],cst_time,[0,label])}
    function time_log(label,msg)
     {var _hH_=msg_to_jv_array([0,label,msg]);
      return call$0(c[1],cst_timeLog,_hH_)}
    function time_end(label){return call$0(c[1],cst_timeEnd,[0,label])}
    function profile(label){return call$0(c[1],cst_profile,[0,label])}
    function profile_end(label){return call$0(c[1],cst_profileEnd,[0,label])}
    function time_stamp(label){return call$0(c[1],cst_timeStamp$0,[0,label])}
    function log_result(opt,_hG_,r)
     {if(opt)var sth=opt[1],ok=sth;else var ok=function(v){return [0,v,0]};
      if(_hG_)
       var sth$0=_hG_[1],err=sth$0;
      else
       var err=function(e){return [0,str(e),0]};
      if(0 === r[0])
       {var v=r[1];log(caml_call1(ok,v))}
      else
       {var e=r[1];error$2(caml_call1(err,e))}
      return r}
    function log_if_error(opt,_hF_,use,param)
     {if(opt)var sth=opt[1],l=sth;else var l=error$2;
      if(_hF_)
       var sth$0=_hF_[1],error_msg=sth$0;
      else
       var error_msg=function(e){return [0,str(e),0]};
      if(0 === param[0]){var v=param[1];return v}
      var e=param[1];
      caml_call1(l,caml_call1(error_msg,e));
      return use}
    function log_if_error$0(l,error_msg,use,r)
     {return [0,log_if_error(l,error_msg,use,r)]}
    function as_target$0(w){return w}
    function closed(w){return caml_call2(Bool[2],w,cst_closed)}
    function scroll_x$0(w){return caml_call2(Float[2],w,cst_scrollX)}
    function scroll_y$0(w){return caml_call2(Float[2],w,cst_scrollY)}
    function device_pixel_ratio(w)
     {return caml_call2(Float[2],w,cst_devicePixelRatio)}
    function matches_media(w,s)
     {var o=w.matchMedia(s);return caml_call2(Bool[2],o,cst_matches)}
    function prefers_dark_color_scheme(w)
     {return matches_media(w,"(prefers-color-scheme: dark)")}
    function open$0(opt,_hC_,w,u)
     {if(opt)var sth=opt[1],features=sth;else var features=empty;
      if(_hC_)var sth$0=_hC_[1],name=sth$0;else var name=empty;
      var _hD_=w.open(u,name,features);
      return to_option(function(_hE_){return _hE_},_hD_)}
    function close$0(w){w.close();return 0}
    function print(w){w.print();return 0}
    function reload(w){w.location.reload();return 0}
    function location$0(w){return new url(w.location)}
    function set_location(w,u){return w.location = u}
    var auto$0="auto",manual="manual",Scroll_restoration=[0,auto$0,manual];
    function length$3(h){return caml_call2(Int[2],h,cst_length$3)}
    function scroll_restoration(h)
     {return caml_call2(_d_[2],h,cst_scrollRestoration)}
    function set_scroll_restoration(h,r)
     {return caml_call3(_d_[3],h,cst_scrollRestoration$0,r)}
    function back(h){h.back();return 0}
    function forward(h){h.forward();return 0}
    function go(h,d){h.go(d);return 0}
    function state(h){return h.state}
    function push_state(opt,_hB_,_hA_,h)
     {if(opt)var sth=opt[1],state=sth;else var state=null$0;
      if(_hB_)var sth$0=_hB_[1],title=sth$0;else var title=empty;
      if(_hA_)var sth$1=_hA_[1],uri=sth$1;else var uri=null$0;
      h.pushState(state,title,uri);
      return 0}
    function replace_state(opt,_hz_,_hy_,h)
     {if(opt)var sth=opt[1],state=sth;else var state=null$0;
      if(_hz_)var sth$0=_hz_[1],title=sth$0;else var title=empty;
      if(_hy_)var sth$1=_hy_[1],uri=sth$1;else var uri=null$0;
      h.replaceState(state,title,uri);
      return 0}
    function state$0(e){return e.state}
    var
     Popstate=[0,state$0],
     popstate="popstate",
     Ev=[0,Popstate,popstate],
     History=
      [0,
       Scroll_restoration,
       length$3,
       scroll_restoration,
       set_scroll_restoration,
       back,
       forward,
       go,
       state,
       push_state,
       replace_state,
       Ev];
    function history(w){return w.history}
    var
     Window=
      [0,
       as_target$0,
       closed,
       scroll_x$0,
       scroll_y$0,
       device_pixel_ratio,
       matches_media,
       prefers_dark_color_scheme,
       open$0,
       close$0,
       print,
       reload,
       location$0,
       set_location,
       History,
       history];
    function languages(n)
     {var match=find(n,cst_languages);
      if(match){var a=match[1];return caml_list_of_js_array(a)}
      var match$0=caml_call2(_d_[1],n,cst_language);
      if(match$0){var v=match$0[1];return [0,v,0]}
      return 0}
    function max_touch_points(n){var t=n.maxTouchPoints;return is_none(t)?0:t}
    function online(n){return caml_call2(Bool[2],n,cst_onLine)}
    var
     Navigator=[0,languages,max_touch_points,online],
     frame="frame",
     navigation="navigation",
     resource="resource",
     mark$1="mark",
     measure="measure",
     paint="paint",
     longtask="longtask",
     Type$0=[0,frame,navigation,resource,mark$1,measure,paint,longtask];
    function name$4(e){return caml_call2(_d_[2],e,cst_name$1)}
    function type$6(e){return caml_call2(_d_[2],e,cst_entryType)}
    function start_time(e){return caml_call2(Float[2],e,cst_startTime)}
    function end_time(e){return caml_call2(Float[2],e,cst_endTime)}
    function duration(e){return caml_call2(Float[2],e,cst_duration)}
    function to_json(e){return e.toJSON()}
    function as_entry(_hx_){return _hx_}
    function initiator_type(e){return caml_call2(_d_[2],e,cst_initiatorType)}
    function next_hop_protocol(e)
     {return caml_call2(_d_[2],e,cst_nextHopProtocol)}
    function worker_start(e){return caml_call2(Float[2],e,cst_workerStart)}
    function redirect_start(e)
     {return caml_call2(Float[2],e,cst_redirectStart)}
    function redirect_end(e){return caml_call2(Float[2],e,cst_redirectEnd)}
    function fetch_start(e){return caml_call2(Float[2],e,cst_fetchStart)}
    function domain_lookup_start(e)
     {return caml_call2(Float[2],e,cst_domainLookupStart)}
    function domain_lookup_end(e)
     {return caml_call2(Float[2],e,cst_domainLookupEnd)}
    function connect_start(e){return caml_call2(Float[2],e,cst_connectStart)}
    function connect_end(e){return caml_call2(Float[2],e,cst_connectEnd)}
    function secure_connection_start(e)
     {return caml_call2(Float[2],e,cst_secureConnectionStart)}
    function request_start(e){return caml_call2(Float[2],e,cst_requestStart)}
    function response_start(e)
     {return caml_call2(Float[2],e,cst_responseStart)}
    function response_end(e){return caml_call2(Float[2],e,cst_responseEnd)}
    function transfer_size(e){return caml_call2(Int[2],e,cst_transferSize)}
    function encoded_body_size(e)
     {return caml_call2(Int[2],e,cst_encodedBodySize)}
    function decoded_body_size(e)
     {return caml_call2(Int[2],e,cst_decodedBodySize)}
    var
     Resource_timing=
      [0,
       as_entry,
       initiator_type,
       next_hop_protocol,
       worker_start,
       redirect_start,
       redirect_end,
       fetch_start,
       domain_lookup_start,
       domain_lookup_end,
       connect_start,
       connect_end,
       secure_connection_start,
       request_start,
       response_start,
       response_end,
       transfer_size,
       encoded_body_size,
       decoded_body_size],
     navigate="navigate",
     reload$0="reload",
     back_forward="back_forward",
     prerender="prerender",
     Type$1=[0,navigate,reload$0,back_forward,prerender];
    function as_resource_timing(_hw_){return _hw_}
    function as_entry$0(_hv_){return _hv_}
    function unload_event_start(e)
     {return caml_call2(Float[2],e,cst_unloadEventStart)}
    function unload_event_end(e)
     {return caml_call2(Float[2],e,cst_unloadEventEnd)}
    function dom_interactive(e)
     {return caml_call2(Float[2],e,cst_domInteractive)}
    function dom_content_loaded_event_start(e)
     {return caml_call2(Float[2],e,cst_domContentLoadedEventStart)}
    function dom_content_loaded_event_end(e)
     {return caml_call2(Float[2],e,cst_domContentLoadedEventEnd)}
    function dom_complete(e){return caml_call2(Float[2],e,cst_domComplete)}
    function load_event_start(e)
     {return caml_call2(Float[2],e,cst_loadEventStart)}
    function load_event_end(e){return caml_call2(Float[2],e,cst_loadEventEnd)}
    function type$7(e){return caml_call2(_d_[2],e,cst_type$3)}
    function redirect_count(e){return caml_call2(Int[2],e,cst_redirectCount)}
    function as_resource_timing$0(_hu_){return _hu_}
    function as_navigation_timing(_ht_){return _ht_}
    function time_origin_ms(p){return caml_call2(Float[2],p,cst_timeOrigin)}
    function clear_marks(p,n)
     {if(n)var n$0=n[1],args=[0,n$0];else var args=[0];
      caml_js_meth_call(p,cst_clearMarks,args);
      return 0}
    function clear_measures(p,n)
     {if(n)var n$0=n[1],args=[0,n$0];else var args=[0];
      caml_js_meth_call(p,cst_clearMeasures,args);
      return 0}
    function clear_resource_timings(p){p.clearResourceTimings();return 0}
    function get_entries(type,name,p)
     {if(name)
       {var _hk_=name[1];
        if(type)
         {var t=type[1],_hl_=p.getEntriesByName(_hk_,t);
          return to_list(function(_hs_){return _hs_},_hl_)}
        var _hm_=p.getEntriesByName(_hk_);
        return to_list(function(_hr_){return _hr_},_hm_)}
      if(type)
       {var t$0=type[1],_hn_=p.getEntriesByType(t$0);
        return to_list(function(_hq_){return _hq_},_hn_)}
      var _ho_=p.getEntries();
      return to_list(function(_hp_){return _hp_},_ho_)}
    function mark$2(p,n){p.mark(n);return 0}
    function measure$0(start,stop,p,n)
     {if(start)
       {var _hj_=start[1];
        if(stop){var e=stop[1];p.measure(_hj_,e);return 0}
        p.measure(_hj_);
        return 0}
      if(stop){var e$0=stop[1];p.measure(fn,e$0);return 0}
      p.measure();
      return 0}
    function now_ms(p){return p.now()}
    function to_json$0(p){return p.toJSON()}
    var
     console=target.console,
     navigator=target.navigator,
     performance=target.performance,
     window=target.window,
     is_secure_context=caml_call2(Bool[2],target,cst_isSecureContext);
    function set_timeout(ms,f){return target.setTimeout(f,ms)}
    function set_interval(ms,f){return target.setInterval(f,ms)}
    function stop_timer(tid){target.clearTimeout(tid);return 0}
    function request_animation_frame(f)
     {return target.requestAnimationFrame(f)}
    function cancel_animation_frame(fid)
     {target.cancelAnimationFrame(fid);return 0}
    var
     _bm_=
      [0,
       console,
       document,
       navigator,
       performance,
       window,
       target,
       is_secure_context,
       set_timeout,
       set_interval,
       stop_timer,
       request_animation_frame,
       cancel_animation_frame],
     _bn_=
      [0,
       v$2,
       txt,
       txt$0,
       sp$0,
       nbsp,
       is_txt,
       is_el,
       tag_name,
       has_tag_name,
       txt_text,
       document$0,
       find_by_class,
       find_by_tag_name,
       find_first_by_selector,
       fold_find_by_selector,
       parent,
       children,
       set_children,
       prepend_children,
       append_children,
       insert_siblings,
       remove$0,
       at,
       set_at,
       [0,
        bool,
        int$1,
        float$0,
        jstr,
        checked$1,
        height$2,
        id$2,
        name$3,
        title$1,
        value$1,
        width$2],
       prop,
       set_prop,
       class$2,
       set_class,
       Style,
       computed_style,
       inline_style,
       set_inline_style,
       inner_x,
       inner_y,
       inner_w,
       inner_h,
       bound_x,
       bound_y,
       bound_w,
       bound_h,
       scroll_x,
       scroll_y,
       scroll_w,
       scroll_h,
       scroll_into_view,
       has_focus,
       set_has_focus,
       is_locking_pointer,
       request_pointer_lock,
       Navigation_ui,
       fullscreen_opts,
       request_fullscreen,
       click$0,
       select_text,
       Input$0,
       Name,
       a$0,
       abbr$0,
       address$0,
       area$0,
       article$0,
       aside$0,
       audio$0,
       b$0,
       base$0,
       bdi$0,
       bdo$0,
       blockquote$0,
       body$0,
       br$0,
       button$1,
       canvas$0,
       caption$0,
       cite$0,
       code$2,
       col$0,
       colgroup$0,
       command$0,
       datalist$0,
       dd$0,
       del$0,
       details$0,
       dfn$0,
       div$0,
       dl$0,
       dt$0,
       em$0,
       embed$0,
       fieldset$0,
       figcaption$0,
       figure$0,
       footer$0,
       form$0,
       h1$0,
       h2$0,
       h3$0,
       h4$0,
       h5$0,
       h6$0,
       head$0,
       header$0,
       hgroup$0,
       hr$0,
       html$0,
       i$0,
       iframe$0,
       img$0,
       input$1,
       ins$0,
       kbd$0,
       keygen$0,
       label$0,
       legend$0,
       li$0,
       link$1,
       map$2,
       mark$0,
       menu$0,
       meta$0,
       meter$0,
       nav$0,
       noscript$0,
       object$0,
       ol$0,
       optgroup$0,
       option$0,
       output$0,
       p$0,
       param$0,
       pre$0,
       progress$1,
       q$0,
       rp$0,
       rt$0,
       ruby$0,
       s$0,
       samp$0,
       script$0,
       section$0,
       select$1,
       small$0,
       source$0,
       span$0,
       strong$0,
       style$0,
       sub$2,
       summary$0,
       sup$0,
       table$0,
       tbody$0,
       td$0,
       textarea$0,
       tfoot$0,
       th$0,
       thead$0,
       time$0,
       title$3,
       tr$0,
       track$0,
       u$0,
       ul$0,
       var$1,
       video$0,
       wbr$0],
     _bo_=
      [0,
       v$0,
       scheme,
       host,
       port,
       path,
       query,
       fragment,
       with_uri,
       [0,
        is_empty$0,
        mem,
        find$6,
        find_all,
        fold$0,
        of_obj,
        of_jstr$1,
        to_jstr$0,
        of_assoc,
        to_assoc],
       encode$2,
       decode$2,
       encode_component$0,
       decode_component,
       of_jstr$2,
       to_jstr$1],
     _bp_=[0,init$1,of_blob,name$0,last_modified_ms],
     Brr=
      [0,
       [0,
        [0,create$3,byte_length,slice$0],
        [0,
         of_buffer,
         buffer,
         byte_offset,
         byte_length$0,
         get_int8,
         get_int16_be,
         get_int16_le,
         get_int32_be,
         get_int32_le,
         get_uint8,
         get_uint16_be,
         get_uint16_le,
         get_uint32_be,
         get_uint32_le,
         get_float32_be,
         get_float32_le,
         get_float64_be,
         get_float64_le,
         set_int8,
         set_int16_be,
         set_int16_le,
         set_int32_be,
         set_int32_le,
         set_uint8,
         set_uint16_be,
         set_uint16_le,
         set_uint32_be,
         set_uint32_le,
         set_float32_be,
         set_float32_le,
         set_float64_be,
         set_float64_le],
        type_size_in_bytes,
        create$4,
        of_buffer$0,
        buffer,
        byte_offset,
        byte_length$0,
        length$2,
        type$2,
        set_tarray,
        fill,
        copy_within,
        slice$1,
        sub$0,
        find$5,
        find_index,
        for_all,
        exists,
        filter,
        iter,
        map$0,
        fold_left,
        fold_right,
        reverse,
        of_tarray,
        uint8_of_buffer,
        of_int_array,
        of_float_array,
        of_jstr,
        to_jstr,
        of_binary_jstr,
        to_binary_jstr,
        to_int_jstr,
        to_hex_jstr,
        type_to_bigarray_kind,
        type_of_bigarray_kind],
       [0,
        Ending_type,
        init$0,
        of_jstr$0,
        of_array_buffer,
        byte_length$1,
        type$3,
        slice$2,
        array_buffer$0,
        stream,
        text,
        data_uri],
       _bp_,
       Base64,
       [0,encode$0,decode$0],
       _bo_,
       [0,
        Type,
        init,
        create$2,
        type,
        target$0,
        current_target,
        composed_path,
        event_phase,
        bubbles,
        stop_propagation,
        stop_immediate_propagation,
        cancelable,
        prevent_default,
        default_prevented,
        composed,
        is_trusted,
        timestamp_ms,
        dispatch,
        listen_opts,
        listen,
        unlisten,
        next$0,
        [0,
         Effect,
         Item,
         [0,length$1,add_jstr,add_file,remove,clear,caml_js_get,items],
         drop_effect,
         set_drop_effect,
         effect_allowed,
         set_effect_allowed,
         items$0],
        Clipboard,
        Composition,
        Error$0,
        Extendable,
        Focus,
        Hash_change,
        Input,
        Keyboard,
        Mouse,
        Drag,
        Pointer,
        Wheel,
        abort,
        activate,
        auxclick,
        beforeinput,
        blur,
        canplay,
        canplaythrough,
        change,
        click,
        clipboardchange,
        close,
        compositionend,
        compositionstart,
        compositionudpate,
        controllerchange,
        copy$0,
        cut,
        dblclick,
        dom_content_loaded,
        drag,
        dragend,
        dragenter,
        dragexit,
        dragleave,
        dragover,
        dragstart,
        drop,
        durationchange,
        emptied,
        ended,
        error$1,
        focus,
        focusin,
        focusout,
        fullscreenchange,
        fullscreenerror,
        gotpointercapture,
        hashchange,
        input,
        install,
        keydown,
        keyup,
        languagechange,
        load,
        loadeddata,
        loadedmetadata,
        loadstart,
        lostpointercapture,
        mousedown,
        mouseenter,
        mouseleave,
        mousemove,
        mouseout,
        mouseover,
        mouseup,
        open,
        paste,
        pause,
        play,
        playing,
        pointercancel,
        pointerdown,
        pointerenter,
        pointerleave,
        pointerlockchange,
        pointerlockerror,
        pointermove,
        pointerout,
        pointerover,
        pointerrawupdate,
        pointerup,
        progress,
        ratechange,
        reset,
        resize,
        scroll,
        seeked,
        seeking,
        select,
        statechange,
        stalled,
        suspend,
        timeupdate,
        unload,
        updatefound,
        visibilitychange,
        volumechange,
        waiting,
        wheel],
       [0,
        v$1,
        true$1,
        int$0,
        add_if,
        add_if_some,
        to_pair,
        [0,
         autofocus,
         charset,
         checked,
         class$0,
         content,
         defer,
         disabled,
         for$0,
         height$0,
         href,
         id$0,
         lang,
         media,
         name$1,
         placeholder,
         rel,
         required,
         src,
         tabindex,
         title,
         type$4,
         value,
         wrap,
         width$0],
        accesskey$0,
        autofocus$0,
        charset$0,
        checked$0,
        class$1,
        content$0,
        contenteditable$0,
        cols$0,
        defer$0,
        disabled$0,
        dir$0,
        draggable$0,
        for$1,
        height$1,
        href$0,
        hidden$0,
        id$1,
        lang$0,
        media$0,
        name$2,
        placeholder$0,
        rel$0,
        required$0,
        rows$0,
        spellcheck$0,
        src$0,
        tabindex$0,
        title$0,
        type$5,
        value$0,
        wrap$0,
        width$1],
       _bn_,
       [0,
        as_target,
        find_el_by_id,
        find_els_by_name,
        root,
        body$1,
        head$1,
        active_el,
        referrer,
        title$4,
        set_title,
        Visibility_state,
        visibility_state,
        pointer_lock_element,
        exit_pointer_lock,
        fullscreen_available,
        fullscreen_element,
        exit_fullscreen],
       Abort,
       [0,
        get$4,
        set$3,
        clear$0,
        msg,
        str,
        log_result,
        log_if_error,
        log_if_error$0,
        log,
        trace,
        error$2,
        warn,
        info,
        debug,
        assert,
        dir$1,
        table$1,
        group,
        group_end,
        count,
        count_reset,
        time$1,
        time_log,
        time_end,
        profile,
        profile_end,
        time_stamp],
       Window,
       Navigator,
       [0,
        [0,
         Type$0,
         name$4,
         type$6,
         start_time,
         end_time,
         duration,
         to_json,
         Resource_timing,
         [0,
          Type$1,
          as_entry$0,
          as_resource_timing,
          unload_event_start,
          unload_event_end,
          dom_interactive,
          dom_content_loaded_event_start,
          dom_content_loaded_event_end,
          dom_complete,
          load_event_start,
          load_event_end,
          type$7,
          redirect_count],
         as_resource_timing$0,
         as_navigation_timing],
        time_origin_ms,
        clear_marks,
        clear_measures,
        clear_resource_timings,
        get_entries,
        mark$2,
        measure$0,
        now_ms,
        to_json$0],
       _bm_];
    caml_register_global(2933,Brr,"Brr");
    var
     unspecified="unspecified",
     inline="inline",
     attachment="attachement",
     Presentation_style=[0,unspecified,inline,attachment];
    function opts(presentation_style,param)
     {var o={};
      caml_call3(_d_[4],o,cst_presentationStyle,presentation_style);
      return o}
    var item=target.ClipboardItem;
    function create$5(opts,vs)
     {var o={};
      function add_v(param){var b=param[2],t=param[1];return o[t] = b}
      caml_call2(Stdlib_List[17],add_v,vs);
      return new item(o)}
    function presentation_style(i)
     {return caml_call2(_d_[2],i,cst_presentationStyle$0)}
    function last_modified_ms$0(i)
     {return caml_call2(Int[2],i,cst_lastModified$1)}
    function delayed(i){return caml_call2(Bool[2],i,cst_delayed)}
    function types(i){return caml_list_of_js_array(i.types)}
    function get_type(i,t)
     {var _hh_=i.getType(i,t);
      return of_promise$0(function(_hi_){return _hi_},_hh_)}
    function of_navigator(n){return n.clipboard}
    function as_target$1(_hg_){return _hg_}
    function read(c)
     {function _hd_(_hf_){return _hf_}
      function ok(_he_){return to_list(_hd_,_he_)}
      return of_promise$0(ok,c.read())}
    function read_text(c)
     {var _hb_=c.readText();
      return of_promise$0(function(_hc_){return _hc_},_hb_)}
    function write(c,data)
     {var _g__=c.write(of_list(function(_ha_){return _ha_},data));
      return of_promise$0(function(_g$_){return 0},_g__)}
    function write_text(c,data)
     {var _g8_=c.writeText(data);
      return of_promise$0(function(_g9_){return 0},_g8_)}
    function of_el(e)
     {return caml_call2(_bn_[9],_bn_[57][37],e)
              ?e
              :throw$0
                (0,
                 "Expected form element but found: ".concat
                  (caml_call1(_bn_[8],e)))}
    function to_el(e){return e}
    function name$5(f){return caml_call2(_d_[2],f,cst_name$2)}
    function method(f){return caml_call2(_d_[2],f,cst_method)}
    function target$1(f){return caml_call2(_d_[2],f,cst_target)}
    function action(f){return caml_call2(_d_[2],f,cst_action)}
    function enctype(f){return caml_call2(_d_[2],f,cst_enctype)}
    function accept_charset(f){return caml_call2(_d_[2],f,cst_acceptCharset)}
    function autocomplete(f){return caml_call2(_d_[2],f,cst_autocomplete)}
    function no_validate(f){return caml_call2(Bool[2],f,cst_noValidate)}
    function check_validity(f){return f.checkValidity() | 0}
    function report_validity(f){return f.reportValidity() | 0}
    function request_submit(f,el)
     {if(el)var e=el[1],args=[0,e];else var args=[0];
      caml_js_meth_call(f,cst_requestSubmit,args);
      return 0}
    function reset$0(f){f.reset();return 0}
    function submit(f){f.submit();return 0}
    var formdata=target.FormData;
    function create$6(param){return new formdata()}
    function of_form(f){return new formdata(f)}
    function is_empty$1(d)
     {var _g6_=d.entries(),_g7_=caml_call1(_b_[6],_g6_);
      return caml_call1(_b_[1],_g7_)}
    function mem$0(d,k){return d.has(k) | 0}
    function has_file_entry(d)
     {var it=d.entries();
      for(;;)
       {var r=caml_call1(_b_[6],it);
        if(caml_call1(_b_[1],r))return 0;
        var v=caml_call1(_b_[3],r)[1];
        if(v instanceof target.File)return 1;
        continue}}
    function value$2(v)
     {var match=v instanceof target.File?1:0;
      return match?[0,781515420,v]:[0,-976970511,v]}
    function find$7(d,k){return to_option(value$2,d.get(k))}
    function find_all$0(d,k){return to_list(value$2,d.getAll(k))}
    function fold$1(f,d,acc)
     {function key(_g5_){return _g5_}
      var _g4_=d.entries();
      return caml_call5(_b_[8],key,value$2,f,_g4_,acc)}
    function set$4(d,k,v){d.set(k,v);return 0}
    function set_blob(fn$0,d,k,b)
     {if(fn$0)var f=fn$0[1],fn$1=f;else var fn$1=fn;d.set(k,b,fn$1);return 0}
    function append(d,k,v){d.append(k,v);return 0}
    function append_blob(fn$0,d,k,b)
     {if(fn$0)var f=fn$0[1],fn$1=f;else var fn$1=fn;
      d.append(k,b,fn$1);
      return 0}
    function delete$0(d,k){d.delete(k);return 0}
    function of_assoc$0(l)
     {var d=create$6(0);
      function _g3_(param)
       {var v=param[2],k=param[1];
        if(781515420 <= v[1])
         var f=v[2],fn$0=caml_call1(_bp_[3],f),v$0=f;
        else
         var s=v[2],fn$0=fn,v$0=s;
        d.append(k,v$0,fn$0);
        return 0}
      caml_call2(Stdlib_List[17],_g3_,l);
      return d}
    function to_assoc$0(p)
     {var
       _g1_=0,
       _g2_=fold$1(function(k,v,acc){return [0,[0,k,v],acc]},p,_g1_);
      return caml_call1(Stdlib_List[9],_g2_)}
    function of_uri_params(p)
     {function add(k,v,d){append(d,k,v);return d}
      var _g0_=create$6(0);
      return caml_call3(_bo_[9][5],add,p,_g0_)}
    function to_uri_params(p)
     {var usp=target.URLSearchParams;return new usp(p)}
    function form_data(e){return e.formData}
    var Data=[0,form_data],formdata$0="formdata";
    function submitter(e)
     {var _gY_=e.submitter;return to_option(function(_gZ_){return _gZ_},_gY_)}
    var
     Submit=[0,submitter],
     submit$0="submit",
     Ev$0=[0,Data,formdata$0,Submit,submit$0];
    function of_jstr$3(_gX_){return _gX_}
    function of_uri_params$0(_gW_){return _gW_}
    function of_form_data(_gV_){return _gV_}
    function of_blob$0(_gU_){return _gU_}
    function of_array_buffer$0(_gT_){return _gT_}
    function body_used(r){return caml_call2(Bool[2],r,cst_bodyUsed)}
    function body$2(r)
     {var _gR_=r.body;return to_option(function(_gS_){return _gS_},_gR_)}
    function array_buffer$1(r)
     {var _gP_=r.arrayBuffer();
      return of_promise$0(function(_gQ_){return _gQ_},_gP_)}
    function blob$0(r)
     {var _gN_=r.blob();return of_promise$0(function(_gO_){return _gO_},_gN_)}
    function form_data$0(r)
     {var _gL_=r.formData();
      return of_promise$0(function(_gM_){return _gM_},_gL_)}
    function json$0(r)
     {var _gJ_=r.json();return of_promise$0(function(_gK_){return _gK_},_gJ_)}
    function text$0(r)
     {var _gH_=r.text();return of_promise$0(function(_gI_){return _gI_},_gH_)}
    var
     Body=
      [0,
       of_jstr$3,
       of_uri_params$0,
       of_form_data,
       of_blob$0,
       of_array_buffer$0,
       body_used,
       body$2,
       array_buffer$1,
       blob$0,
       form_data$0,
       json$0,
       text$0],
     headers=target.Headers;
    function mem$1(h,hs){return hs.has(h) | 0}
    function find$8(h,hs)
     {var _gF_=hs.get(h);return to_option(function(_gG_){return _gG_},_gF_)}
    function fold$2(f,p,acc)
     {function key(_gE_){return _gE_}
      function value(_gD_){return _gD_}
      var _gC_=p.entries();
      return caml_call5(_b_[8],key,value,f,_gC_,acc)}
    function of_obj$0(o){return new headers(o)}
    function of_assoc$1(init,l)
     {if(init)var h=init[1],args=[0,h];else var args=[0];
      var hs=caml_js_new(headers,args);
      function _gB_(param){var v=param[2],k=param[1];hs.append(k,v);return 0}
      caml_call2(Stdlib_List[17],_gB_,l);
      return hs}
    function to_assoc$1(p)
     {var
       _gz_=0,
       _gA_=fold$2(function(k,v,acc){return [0,[0,k,v],acc]},p,_gz_);
      return caml_call1(Stdlib_List[9],_gA_)}
    var
     default$0="default",
     force_cache="force-cache",
     no_cache="no-cache",
     no_store="no-store",
     only_if_cached="only-if-cached",
     reload$1="reload",
     Cache=[0,default$0,force_cache,no_cache,no_store,only_if_cached,reload$1],
     include="include",
     omit="omit",
     same_origin="same-origin",
     Credentials=[0,include,omit,same_origin],
     audio$1="audio",
     audioworklet="audioworklet",
     document$1="document",
     embed$1="embed",
     font="font",
     frame$0="frame",
     iframe$1="iframe",
     image="image",
     manifest="manifest",
     object$1="object'",
     paintworklet="paintworklet",
     report="report",
     script$1="script",
     sharedworker="sharedworker",
     style$1="style",
     track$1="track",
     video$1="video",
     worker="worker",
     xslt="xslt",
     Destination=
      [0,
       audio$1,
       audioworklet,
       document$1,
       embed$1,
       font,
       frame$0,
       iframe$1,
       image,
       manifest,
       object$1,
       paintworklet,
       report,
       script$1,
       sharedworker,
       style$1,
       track$1,
       video$1,
       worker,
       xslt],
     cors="cors",
     navigate$0="navigate",
     no_cors="no-cors",
     same_origin$0="same-origin",
     Mode=[0,cors,navigate$0,no_cors,same_origin$0],
     error$3="error",
     follow="follow",
     manual$0="manual",
     Redirect=[0,error$3,follow,manual$0];
    function init$2
     (body,
      cache,
      credentials,
      headers,
      integrity,
      keepalive,
      method,
      mode,
      redirect,
      referrer,
      referrer_policy,
      signal,
      param)
     {var o={};
      o.body = of_option(fn,function(_gy_){return _gy_},body);
      caml_call3(_d_[4],o,cst_cache,cache);
      caml_call3(_d_[4],o,cst_credentials,credentials);
      function _gv_(_gx_){return _gx_}
      set_if_some(o,cst_headers,caml_call2(Stdlib_Option[7],_gv_,headers));
      caml_call3(_d_[4],o,cst_integrity,integrity);
      caml_call3(Bool[4],o,cst_keepalive,keepalive);
      caml_call3(_d_[4],o,cst_method$0,method);
      caml_call3(_d_[4],o,cst_mode,mode);
      caml_call3(_d_[4],o,cst_redirect,redirect);
      caml_call3(_d_[4],o,cst_referrer$0,referrer);
      caml_call3(_d_[4],o,cst_referrerPolicy,referrer_policy);
      o.signal = of_option(fn,function(_gw_){return _gw_},signal);
      return o}
    var request=target.Request;
    function v$3(opt,url)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new request(url,init)}
    function of_request(init,r)
     {if(init){var init$0=init[1];return new request(r,init$0)}
      return r.clone()}
    function cache(r){return caml_call2(_d_[2],r,cst_cache$0)}
    function credentials(r){return caml_call2(_d_[2],r,cst_credentials$0)}
    function destination(r){return caml_call2(_d_[2],r,cst_destination)}
    function headers$0(r){return r.headers}
    function integrity(r){return caml_call2(_d_[2],r,cst_integrity$0)}
    function is_history_navigation(r)
     {return caml_call2(Bool[2],r,cst_isHistoryNavigation)}
    function is_reload_navigation(r)
     {return caml_call2(Bool[2],r,cst_isReloadNavigation)}
    function keepalive(r){return caml_call2(Bool[2],r,cst_keepalive$0)}
    function method$0(r){return caml_call2(_d_[2],r,cst_method$1)}
    function mode(r){return caml_call2(_d_[2],r,cst_mode$0)}
    function redirect(r){return caml_call2(_d_[2],r,cst_redirect$0)}
    function referrer$0(r){return caml_call2(_d_[2],r,cst_referrer$1)}
    function referrer_policy(r)
     {return caml_call2(_d_[2],r,cst_referrerPolicy$0)}
    function signal$0(r)
     {var _gt_=r.signal;return to_option(function(_gu_){return _gu_},_gt_)}
    function url$0(r){return caml_call2(_d_[2],r,cst_url)}
    var
     basic="basic",
     cors$0="cors",
     default$1="default",
     error$4="error",
     opaque="opaque",
     opaqueredirect="opaqueredirect",
     Type$2=[0,basic,cors$0,default$1,error$4,opaque,opaqueredirect];
    function init$3(headers,status,status_text,param)
     {var o={};
      function _gr_(_gs_){return _gs_}
      set_if_some(o,cst_headers$0,caml_call2(Stdlib_Option[7],_gr_,headers));
      caml_call3(Int[4],o,cst_status,status);
      caml_call3(_d_[4],o,cst_statusText,status_text);
      return o}
    var response=target.Response;
    function v$4(opt,body,param)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      var body$0=of_option(null$0,function(_gq_){return _gq_},body);
      return new response(body$0,init)}
    function of_response(r){return r.clone()}
    function error$5(param){return response.error()}
    function redirect$0(status,url)
     {if(status)
       var status$0=status[1],args=[0,url,status$0];
      else
       var args=[0,url];
      return caml_js_meth_call(response,cst_redirect$1,args)}
    function headers$1(r){return r.headers}
    function ok$0(r){return caml_call2(Bool[2],r,cst_ok)}
    function redirected(r){return caml_call2(Bool[2],r,cst_redirected)}
    function status(r){return caml_call2(Int[2],r,cst_status$0)}
    function status_text(r){return caml_call2(_d_[2],r,cst_statusText$0)}
    function url$1(r){return caml_call2(_d_[2],r,cst_url$0)}
    function query_opts
     (ignore_search,ignore_method,ignore_vary,cache_name,param)
     {var o={};
      caml_call3(Bool[4],o,cst_ignoreSearch,ignore_search);
      caml_call3(Bool[4],o,cst_ignoreMethod,ignore_method);
      caml_call3(Bool[4],o,cst_ignoreVary,ignore_vary);
      caml_call3(_d_[4],o,cst_cacheName,cache_name);
      return o}
    function match(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _gn_(_gp_){return _gp_}
      function ok(_go_){return to_option(_gn_,_go_)}
      return of_promise$0(ok,c.match(req,query_opts))}
    function match_all(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _gk_(_gm_){return _gm_}
      function ok(_gl_){return to_list(_gk_,_gl_)}
      return of_promise$0(ok,c.matchAll(req,query_opts))}
    function add(c,req)
     {var _gi_=c.add(req);return of_promise$0(function(_gj_){return 0},_gi_)}
    function add_all(c,reqs)
     {var _gf_=c.addAll(of_list(function(_gh_){return _gh_},reqs));
      return of_promise$0(function(_gg_){return 0},_gf_)}
    function put(c,req,resp)
     {var _gd_=c.put(req,resp);
      return of_promise$0(function(_ge_){return 0},_gd_)}
    function delete$1(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      return of_promise$0(caml_js_to_bool,c.delete(req,query_opts))}
    function keys(opt,_f__,c)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      if(_f__)var sth$0=_f__[1],req=sth$0;else var req=fn;
      var _f$_=c.keys(req,query_opts);
      function _ga_(_gc_){return _gc_}
      return of_promise$0(function(_gb_){return to_list(_ga_,_gb_)},_f$_)}
    function match$0(opt,s,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _f7_(_f9_){return _f9_}
      function ok(_f8_){return to_option(_f7_,_f8_)}
      return of_promise$0(ok,s.match(req,query_opts))}
    function has$0(s,n){return of_promise$0(caml_js_to_bool,s.has(n))}
    function open$1(s,n)
     {var _f5_=s.open(n);
      return of_promise$0(function(_f6_){return _f6_},_f5_)}
    function delete$2(s,n){return of_promise$0(caml_js_to_bool,s.delete(n))}
    function keys$0(s){return of_promise$0(caml_list_of_js_array,s.keys())}
    var
     Storage=[0,match$0,has$0,open$1,delete$2,keys$0],
     Cache$0=
      [0,query_opts,match,match_all,add,add_all,put,delete$1,keys,Storage],
     fetch="fetch";
    function as_extendable(_f4_){return _f4_}
    function request$0(e){return e.request}
    function preload_response(e)
     {function _f1_(_f3_){return _f3_}
      function ok(_f2_){return to_option(_f1_,_f2_)}
      return of_promise$0(ok,e.preloadReponse)}
    function client_id(e){return caml_call2(_d_[2],e,cst_clientId)}
    function resulting_client_id(e)
     {return caml_call2(_d_[2],e,cst_resultingClientId)}
    function replaces_client_id(e)
     {return caml_call2(_d_[2],e,cst_replacesClientId)}
    function handled(e)
     {var _fZ_=e.handled;return of_promise$0(function(_f0_){return 0},_fZ_)}
    function respond_with(e,fut)
     {e.respondWith(to_promise$0(function(_fY_){return _fY_},fut));return 0}
    var
     Ev$1=
      [0,
       fetch,
       as_extendable,
       request$0,
       preload_response,
       client_id,
       resulting_client_id,
       replaces_client_id,
       handled,
       respond_with],
     fetch$0=target.fetch;
    function url$2(opt,url)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      var _fW_=fetch$0(url,init);
      return of_promise$0(function(_fX_){return _fX_},_fW_)}
    function request$1(r)
     {var _fU_=fetch$0(r);
      return of_promise$0(function(_fV_){return _fV_},_fU_)}
    var
     caches=target.caches,
     permission_denied=1,
     position_unavailable=2,
     timeout=3;
    function code$3(e){return caml_call2(Int[2],e,cst_code$0)}
    function message$1(e){return caml_call2(_d_[2],e,cst_message$0)}
    var
     Error$1=
      [0,permission_denied,position_unavailable,timeout,code$3,message$1];
    function latitude(p){return caml_call2(Float[2],p.coords,cst_latitude)}
    function longitude(p){return caml_call2(Float[2],p.coords,cst_longitude)}
    function altitude(p){return caml_call2(Float[1],p.coords,cst_altitude)}
    function accuracy(p){return caml_call2(Float[2],p.coords,cst_accuracy)}
    function altitude_accuracy(p)
     {return caml_call2(Float[1],p.coords,cst_altitudeAccuracy)}
    function heading(p){return caml_call2(Float[1],p.coords,cst_heading)}
    function speed(p){return caml_call2(Float[1],p.coords,cst_speed)}
    function timestamp_ms$0(p){return caml_call2(Float[2],p,cst_timestamp)}
    function of_navigator$0(n){return n.geolocation}
    function opts$0(high_accuracy,timeout_ms,maximum_age_ms,param)
     {var o={};
      caml_call3(Bool[4],o,cst_enableHighAccuracy,high_accuracy);
      caml_call3(Int[4],o,cst_timeout,timeout_ms);
      caml_call3(Int[4],o,cst_maximumAge,maximum_age_ms);
      return o}
    function get$5(opts,l)
     {var match=create$1(0),set_fut=match[2],fut=match[1];
      function pos(p){return caml_call1(set_fut,[0,p])}
      function error(e){return caml_call1(set_fut,[1,e])}
      var opts$0=of_option(fn,function(_fT_){return _fT_},opts);
      l.getCurrentPosition(pos,error,opts$0);
      return fut}
    function watch(opts,l,f)
     {function pos(p){return caml_call1(f,[0,p])}
      function error(e){return caml_call1(f,[1,e])}
      var opts$0=of_option(fn,function(_fS_){return _fS_},opts);
      return l.watchPosition(pos,error,opts$0)}
    function unwatch(l,id){l.clearWatch(id);return 0}
    function v$5(exact,ideal,param)
     {var o={};
      caml_call3(Bool[4],o,cst_exact,exact);
      caml_call3(Bool[4],o,cst_ideal,ideal);
      return o}
    var Constraint=[0,v$5],Bool$0=[0,Constraint];
    function v$6(min,max,param)
     {var o={};
      caml_call3(Int[4],o,cst_min,min);
      caml_call3(Int[4],o,cst_max,max);
      return o}
    function min(r){return caml_call2(Int[1],r,cst_min$0)}
    function max(r){return caml_call2(Int[1],r,cst_max$0)}
    var Range=[0,v$6,min,max];
    function v$7(min,max,exact,ideal,param)
     {var o={};
      caml_call3(Int[4],o,cst_min$1,min);
      caml_call3(Int[4],o,cst_max$1,max);
      caml_call3(Int[4],o,cst_exact$0,exact);
      caml_call3(Int[4],o,cst_ideal$0,ideal);
      return o}
    var Constraint$0=[0,v$7],Int$0=[0,Range,Constraint$0];
    function v$8(min,max,param)
     {var o={};
      caml_call3(Float[4],o,cst_min$2,min);
      caml_call3(Float[4],o,cst_max$2,max);
      return o}
    function min$0(r){return caml_call2(Float[1],r,cst_min$3)}
    function max$0(r){return caml_call2(Float[1],r,cst_max$3)}
    var Range$0=[0,v$8,min$0,max$0];
    function v$9(min,max,exact,ideal,param)
     {var o={};
      caml_call3(Float[4],o,cst_min$4,min);
      caml_call3(Float[4],o,cst_max$4,max);
      caml_call3(Float[4],o,cst_exact$1,exact);
      caml_call3(Float[4],o,cst_ideal$1,ideal);
      return o}
    var Constraint$1=[0,v$9],Float$0=[0,Range$0,Constraint$1];
    function v$10(exact,ideal,param)
     {var o={};
      set_if_some
       (o,
        cst_exact$2,
        caml_call2(Stdlib_Option[7],caml_list_to_js_array,exact));
      set_if_some
       (o,
        cst_ideal$2,
        caml_call2(Stdlib_Option[7],caml_list_to_js_array,ideal));
      return o}
    var Constraint$2=[0,v$10],Jstr$0=[0,Constraint$2];
    function v$11(name,param,_fR_,_fQ_)
     {var
       constr_of_jv=_fQ_[2],
       constr_to_jv=_fQ_[1],
       cap_of_jv=_fR_[2],
       cap_to_jv=_fR_[1],
       value_of_jv=param[2],
       value_to_jv=param[1];
      return [0,
              name,
              value_to_jv,
              value_of_jv,
              cap_to_jv,
              cap_of_jv,
              constr_to_jv,
              constr_of_jv]}
    function name$6(p){return p[1]}
    function value_to_jv(p){return p[2]}
    function value_of_jv(p){return p[3]}
    function cap_to_jv(p){return p[4]}
    function cap_of_jv(p){return p[5]}
    function constr_to_jv(p){return p[6]}
    function constr_of_jv(p){return p[7]}
    function bool$0(name)
     {var
       value_conv=[0,caml_js_from_bool,caml_js_to_bool],
       _fI_=caml_js_to_bool;
      function _fJ_(_fP_){return to_list(_fI_,_fP_)}
      var
       _fK_=caml_js_from_bool,
       cap_conv=[0,function(_fO_){return of_list(_fK_,_fO_)},_fJ_];
      function _fL_(_fN_){return _fN_}
      var constr_conv=[0,function(_fM_){return _fM_},_fL_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function int$2(name)
     {function _fz_(_fH_){return _fH_}
      var value_conv=[0,function(_fG_){return _fG_},_fz_];
      function _fA_(_fF_){return _fF_}
      var cap_conv=[0,function(_fE_){return _fE_},_fA_];
      function _fB_(_fD_){return _fD_}
      var constr_conv=[0,function(_fC_){return _fC_},_fB_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function float$1(name)
     {function _fq_(_fy_){return _fy_}
      var value_conv=[0,function(_fx_){return _fx_},_fq_];
      function _fr_(_fw_){return _fw_}
      var cap_conv=[0,function(_fv_){return _fv_},_fr_];
      function _fs_(_fu_){return _fu_}
      var constr_conv=[0,function(_ft_){return _ft_},_fs_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function jstr$0(name)
     {function _fk_(_fp_){return _fp_}
      var value_conv=[0,function(_fo_){return _fo_},_fk_];
      function _fl_(_fn_){return _fn_}
      var constr_conv=[0,function(_fm_){return _fm_},_fl_];
      return v$11(name,value_conv,value_conv,constr_conv)}
    function jstr_enum(name)
     {function _fe_(_fj_){return _fj_}
      var
       value_conv=[0,function(_fi_){return _fi_},_fe_],
       cap_conv=[0,caml_list_to_js_array,caml_list_of_js_array];
      function _ff_(_fh_){return _fh_}
      var constr_conv=[0,function(_fg_){return _fg_},_ff_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function mem$2(p,cs){var mem=cs[p[1]];return is_none(mem)?0:mem | 0}
    function names(cs){return caml_list_of_js_array(target.Object.keys(cs))}
    var Supported_constraints=[0,mem$2,names];
    function empty$0(param){return {}}
    function find$9(p,c){return find_map$0(p[7],c,p[1])}
    function set$5(p,v,c){var _fd_=caml_call1(p[6],v);return c[p[1]] = _fd_}
    function delete$3(p,c){return delete c[p[1]]}
    var Constraints=[0,empty$0,find$9,set$5,delete$3];
    function find$10(p,s){return find_map$0(p[5],s,p[1])}
    function set$6(p,v,s){var _fc_=caml_call1(p[4],v);return s[p[1]] = _fc_}
    function delete$4(p,s){return delete s[p[1]]}
    var Capabilities=[0,find$10,set$6,delete$4];
    function get$6(p,s){return caml_call1(p[3],s[p[1]])}
    function find$11(p,s){return find_map$0(p[3],s,p[1])}
    var
     Settings=[0,get$6,find$11],
     aspect_ratio=float$1("aspectRatio"),
     auto_gain_control=bool$0("autoGainControl"),
     channel_count=int$2("channelCount"),
     cursor$0=jstr_enum("cursor"),
     device_id=jstr$0("deviceId"),
     display_surface=jstr_enum("displaySurface"),
     echo_cancellation=bool$0("echoCancellation"),
     facing_mode=jstr_enum("facingMode"),
     frame_rate=float$1("frameRate"),
     group_id=jstr$0("groupId"),
     height$4=int$2("height"),
     latency=float$1("latency"),
     logical_surface=bool$0("logicalSurface"),
     noise_suppresion=bool$0("noiseSuppresion"),
     resize_mode=jstr_enum("resizeMode"),
     sample_rate=int$2("sampleRate"),
     sample_size=int$2("sampleSize"),
     width$4=int$2("width"),
     Prop=
      [0,
       aspect_ratio,
       auto_gain_control,
       channel_count,
       cursor$0,
       device_id,
       display_surface,
       echo_cancellation,
       facing_mode,
       frame_rate,
       group_id,
       height$4,
       latency,
       logical_surface,
       noise_suppresion,
       resize_mode,
       sample_rate,
       sample_size,
       width$4],
     live="live",
     ended$0="ended",
     State=[0,live,ended$0],
     audio$2="audio",
     video$2="video",
     Kind$0=[0,audio$2,video$2];
    function id$3(t){return caml_call2(_d_[2],t,cst_id)}
    function isolated(t){return caml_call2(Bool[2],t,cst_isolated)}
    function kind$0(t){return caml_call2(_d_[2],t,cst_kind$0)}
    function label$1(t){return caml_call2(_d_[2],t,cst_label)}
    function muted(t){return caml_call2(Bool[2],t,cst_muted)}
    function ready_state(t){return caml_call2(_d_[2],t,cst_readyState)}
    function enabled(t){return caml_call2(Bool[2],t,cst_enabled)}
    function set_enabled(t,b){return caml_call3(Bool[3],t,cst_enabled$0,b)}
    function get_capabilities(t){return t.getCapabilities()}
    function get_constraints(t){return t.getConstraints()}
    function apply_constraints(t,c)
     {if(c)var c$0=c[1],a=[0,c$0];else var a=[0];
      var _fb_=caml_js_meth_call(t,cst_applyConstraints,a);
      return of_promise$0(caml_call1(Stdlib_Fun[1],0),_fb_)}
    function get_settings(t){return t.getSettings()}
    function stop(t){t.stop();return 0}
    function clone(t){return t.clone()}
    var
     ended$1="ended",
     isolationchange="isolationchange",
     mute="mute",
     unmute="unmute";
    function track$2(p){return p.track}
    function v$12(opt,_e$_,param)
     {if(opt)var sth=opt[1],audio=sth;else var audio=17505;
      if(_e$_)var sth$0=_e$_[1],video=sth$0;else var video=17505;
      var o={};
      function set_track(o,n,param)
       {if(typeof param === "number")return caml_call3(Bool[3],o,n,0);
        var _fa_=param[2];
        if(_fa_){var c=_fa_[1];return o[n] = c}
        return caml_call3(Bool[3],o,n,1)}
      set_track(o,cst_audio,audio);
      set_track(o,cst_video,video);
      return o}
    function av(param){return v$12(_br_,_bq_,0)}
    var Constraints$0=[0,v$12,av],stream$0=target.MediaStream;
    function create$7(param){return new stream$0()}
    function of_stream(s){return new stream$0(s)}
    function of_tracks(ts)
     {return new stream$0(of_list(function(_e__){return _e__},ts))}
    function id$4(s){return caml_call2(_d_[2],s,cst_id$0)}
    function active(s){return caml_call2(Bool[2],s,cst_active)}
    function get_audio_tracks(s)
     {var _e8_=s.getAudioTracks();
      return to_list(function(_e9_){return _e9_},_e8_)}
    function get_video_tracks(s)
     {var _e6_=s.getVideoTracks();
      return to_list(function(_e7_){return _e7_},_e6_)}
    function get_tracks(s)
     {var _e4_=s.getTracks();return to_list(function(_e5_){return _e5_},_e4_)}
    function get_track_by_id(s,id)
     {var _e2_=s.getTrackById(id);
      return to_option(function(_e3_){return _e3_},_e2_)}
    function add_track(s,t){s.addTrack(t);return 0}
    function remove_track(s,t){s.removeTrack(t);return 0}
    function clone$0(s){return s.clone()}
    var
     addtrack="addtrack",
     removetrack="removetrack",
     Ev$2=[0,addtrack,removetrack],
     cbr="cbr",
     vbr="vbr",
     Bitrate_mode=[0,cbr,vbr],
     inactive="inactive",
     recording="recording",
     paused="paused",
     Recording_state=[0,inactive,recording,paused];
    function init$4(type,audio_bps,video_bps,bps,audio_bitrate_mode,param)
     {var o={};
      caml_call3(_d_[4],o,cst_mimeType,type);
      caml_call3(Int[4],o,cst_audioBitsPerSecond,audio_bps);
      caml_call3(Int[4],o,cst_videoBitsPerSecond,video_bps);
      caml_call3(Int[4],o,cst_bitsPerSecond,bps);
      caml_call3(_d_[4],o,cst_audioBitrateMode,audio_bitrate_mode);
      return o}
    var recorder=target.MediaRecorder;
    function is_type_supported(t){return recorder.isTypeSupported(t) | 0}
    function create$8(opt,s)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new recorder(s,init)}
    function stream$1(r){return r.stream}
    function type$8(r){return caml_call2(_d_[2],r,cst_mimeType$0)}
    function state$1(r){return caml_call2(_d_[2],r,cst_state)}
    function video_bps(r)
     {return caml_call2(Int[2],r,cst_videoBitsPerSecond$0)}
    function audio_bps(r)
     {return caml_call2(Int[2],r,cst_audioBitsPerSecond$0)}
    function audio_bitrate_mode(r)
     {return caml_call2(_d_[2],r,cst_audioBitrateMode$0)}
    function start(r,ts)
     {if(ts)var ms=ts[1],args=[0,ms];else var args=[0];
      try
       {caml_js_meth_call(r,cst_start,args);return _bs_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function stop$0(r){r.stop();return 0}
    function pause$0(r){r.pause();return 0}
    function resume(r){r.resume();return 0}
    function request_data(r){r.requestData();return 0}
    function data$2(e){return e.data}
    function timecode(e){return caml_call2(Float[2],e,cst_timecode)}
    var Blob=[0,data$2,timecode];
    function error$6(e){return e.error}
    var
     Error$2=[0,error$6],
     start$0="start",
     stop$1="stop",
     dataavailable="dataavailable",
     pause$1="pause",
     resume$0="resume",
     error$7="error",
     Ev$3=
      [0,Blob,Error$2,start$0,stop$1,dataavailable,pause$1,resume$0,error$7],
     audioinput="audioinput",
     audiooutput="audiooutput",
     videoinput="videoinput",
     Kind$1=[0,audioinput,audiooutput,videoinput];
    function device_id$0(d){return caml_call2(_d_[2],d,cst_deviceId)}
    function kind$1(d){return caml_call2(_d_[2],d,cst_kind$1)}
    function label$2(d){return caml_call2(_d_[2],d,cst_label$0)}
    function group_id$0(d){return caml_call2(_d_[2],d,cst_groupId)}
    function to_json$1(d){return d.toJSON()}
    var
     Info=[0,device_id$0,kind$1,label$2,group_id$0,to_json$1],
     Device=[0,Kind$1,Info];
    function of_navigator$1(n){return n.mediaDevices}
    function enumerate(m)
     {function _eZ_(_e1_){return _e1_}
      function ok(_e0_){return to_list(_eZ_,_e0_)}
      return of_promise$0(ok,m.enumerateDevices())}
    function get_supported_constraints(m){return m.getSupportedConstraints()}
    function get_user_media(m,c)
     {function ok(_eY_){return _eY_}return of_promise$0(ok,m.getUserMedia(c))}
    function get_display_media(m,c)
     {function ok(_eX_){return _eX_}
      return of_promise$0(ok,m.getDisplayMedia(c))}
    var
     devicechange="devicechange",
     Ev$4=[0,devicechange],
     Devices=
      [0,
       of_navigator$1,
       enumerate,
       get_supported_constraints,
       get_user_media,
       get_display_media,
       Ev$4],
     aborted$0=1,
     network=2,
     decode$3=3,
     src_not_supported=4;
    function code$4(e){return caml_call2(Int[2],e,cst_code$1)}
    function message$2(e){return caml_call2(_d_[2],e,cst_message$1)}
    var
     Error$3=[0,aborted$0,network,decode$3,src_not_supported,code$4,message$2],
     maybe="maybe",
     probably="probably",
     Can_play=[0,maybe,probably],
     Have=[0,0,1,2,3,4],
     Network=[0,0,1,2,3],
     anonymous="anonymous",
     use_credentials="use-credentials",
     Cors=[0,anonymous,use_credentials];
    function of_media_stream(_eW_){return _eW_}
    function of_blob$1(_eV_){return _eV_}
    function of_media_source(_eU_){return _eU_}
    var
     Provider=[0,of_media_stream,of_blob$1,of_media_source],
     List=[0],
     Audio_track=[0,List],
     List$0=[0],
     Video_track=[0,List$0],
     Kind$2=[0],
     List$1=[0],
     Text_track=[0,Kind$2,List$1];
    function length$4(r){return caml_call2(Int[2],r,cst_length$4)}
    function start$1(r,i){return r.start(i)}
    function end(r,i){return r.end(i)}
    var Time_ranges=[0,length$4,start$1,end];
    function of_el$0(e)
     {return caml_call2(_bn_[9],_bn_[57][107],e)
              ?e
              :caml_call2(_bn_[9],_bn_[57][7],e)
                ?e
                :throw$0
                  (0,
                   "Expected audio or video element but found: ".concat
                    (caml_call1(_bn_[8],e)))}
    function to_el$0(_eT_){return _eT_}
    function error$8(m)
     {var _eR_=m.error;return to_option(function(_eS_){return _eS_},_eR_)}
    function src$1(m){return caml_call2(_d_[2],m,cst_src)}
    function set_src(m,s){return caml_call3(_d_[3],m,cst_src$0,s)}
    function src_object(m)
     {var _eP_=m.srcObject;return to_option(function(_eQ_){return _eQ_},_eP_)}
    function set_src_object(m,o)
     {return m.srcObject = of_option(null$0,function(_eO_){return _eO_},o)}
    function current_src(m){return caml_call2(_d_[2],m,cst_currentSrc)}
    function cross_origin(m){return caml_call2(_d_[2],m,cst_crossOrigin)}
    function set_cross_origin(m,c)
     {return caml_call3(_d_[3],m,cst_crossOrigin$0,c)}
    function network_state(m){return caml_call2(Int[2],m,cst_networkState)}
    function preload(m){return caml_call2(_d_[2],m,cst_preload)}
    function set_preload(m,p){return caml_call3(_d_[3],m,cst_preload$0,p)}
    function buffered(m){return m.buffered}
    function load$0(m){m.load();return 0}
    function can_play_type(m,t){return m.canPlayType(t)}
    function ready_state$0(m){return caml_call2(Int[2],m,cst_readyState$0)}
    function seeking$0(m){return caml_call2(Bool[2],m,cst_seeking)}
    function current_time_s(m){return caml_call2(Float[2],m,cst_currentTime)}
    function set_current_time_s(m,t)
     {return caml_call3(Float[3],m,cst_currentTime$0,t)}
    function fast_seek_s(m,t){m.fastSeek(t);return 0}
    function duration_s(m){return caml_call2(Float[2],m,cst_duration$0)}
    function paused$0(m){return caml_call2(Bool[2],m,cst_paused)}
    function default_playback_rate(m)
     {return caml_call2(Float[2],m,cst_defaultPlaybackRate)}
    function set_default_playback_rate(m,r)
     {return caml_call3(Float[3],m,cst_defaultPlaybackRate$0,r)}
    function playback_rate(m){return caml_call2(Float[2],m,cst_playbackRate)}
    function set_playback_rate(m,r)
     {return caml_call3(Float[3],m,cst_playbackRate$0,r)}
    function played(m){return m.played}
    function seekable(m){return m.seekable}
    function ended$2(m){return caml_call2(Bool[2],m,cst_ended)}
    function autoplay(m){return caml_call2(Bool[2],m,cst_autoplay)}
    function set_auto_play(m,b){return caml_call3(Bool[3],m,cst_autoplay$0,b)}
    function loop(m){return caml_call2(Bool[2],m,cst_loop)}
    function set_loop(m,b){return caml_call3(Bool[3],m,cst_loop$0,b)}
    function play$0(m)
     {var _eM_=m.play();return of_promise$0(function(_eN_){return 0},_eM_)}
    function pause$2(m){m.pause();return 0}
    function controls(m){return caml_call2(Bool[2],m,cst_controls)}
    function set_controls(m,b){return caml_call3(Bool[3],m,cst_controls$0,b)}
    function volume(m){return caml_call2(Float[2],m,cst_volume)}
    function set_volume(m,f){return caml_call3(Float[3],m,cst_volume$0,f)}
    function muted$0(m){return caml_call2(Bool[2],m,cst_muted$0)}
    function set_muted(m,b){return caml_call3(Bool[3],m,cst_muted$1,b)}
    function default_muted(m){return caml_call2(Bool[2],m,cst_defaultMuted)}
    function set_default_muted(m,b)
     {return caml_call3(Bool[3],m,cst_defaultMuted$0,b)}
    function audio_track_list(m){return m.audioTracks}
    function video_track_list(m){return m.videoTracks}
    function text_track_list(m){return m.textTracks}
    function capture_stream(m){return m.captureStream()}
    var
     El=
      [0,
       Error$3,
       Can_play,
       Have,
       Network,
       Cors,
       Provider,
       Audio_track,
       Video_track,
       Text_track,
       Time_ranges,
       of_el$0,
       to_el$0,
       error$8,
       src$1,
       set_src,
       src_object,
       set_src_object,
       current_src,
       cross_origin,
       set_cross_origin,
       network_state,
       preload,
       set_preload,
       buffered,
       load$0,
       can_play_type,
       ready_state$0,
       seeking$0,
       current_time_s,
       set_current_time_s,
       fast_seek_s,
       duration_s,
       paused$0,
       default_playback_rate,
       set_default_playback_rate,
       playback_rate,
       set_playback_rate,
       played,
       seekable,
       ended$2,
       autoplay,
       set_auto_play,
       loop,
       set_loop,
       play$0,
       pause$2,
       controls,
       set_controls,
       volume,
       set_volume,
       muted$0,
       set_muted,
       default_muted,
       set_default_muted,
       audio_track_list,
       video_track_list,
       text_track_list,
       capture_stream];
    function transfer(_eL_){return _eL_}
    function opts$1(target_origin,transfer,param)
     {var o={};
      caml_call3(_d_[4],o,cst_targetOrigin,target_origin);
      set_if_some
       (o,
        cst_transfer,
        caml_call2(Stdlib_Option[7],caml_list_to_js_array,transfer));
      return o}
    function start$2(p){p.start();return 0}
    function close$1(p){p.close();return 0}
    function post(opt,p,v)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      p.postMessage(v,opts);
      return 0}
    var Port=[0,start$2,close$1,post],channel=target.MessageChannel;
    function create$9(param){return new channel()}
    function port1(c){return c.port1}
    function port2(c){return c.port2}
    var broadcast=target.BroadcastChannel;
    function create$10(n){return new broadcast(n)}
    function name$7(b){return caml_call2(_d_[2],b,cst_name$3)}
    function close$2(b){b.close();return 0}
    function post$0(b,v){b.postMessage(v);return 0}
    function window_post(opt,w,v)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      w.postMessage(v,opts);
      return 0}
    var message$3="message",messageerror="messageerror";
    function as_extendable$0(_eK_){return _eK_}
    function data$3(e){return e.data}
    function origin(e){return caml_call2(_d_[2],e,cst_origin)}
    function last_event_id(e){return caml_call2(_d_[2],e,cst_lastEventId)}
    function source$1(e)
     {var _eI_=e.source;return to_option(function(_eJ_){return _eJ_},_eI_)}
    function ports(e)
     {var _eG_=e.ports;return to_list(function(_eH_){return _eH_},_eG_)}
    var
     default$2="default",
     denied="denied",
     granted="granted",
     Permission=[0,default$2,denied,granted],
     notification=target.Notification;
    function permission(param)
     {return caml_call2(_d_[2],notification,cst_permission)}
    function request_permission(param)
     {var _eE_=notification.requestPermission();
      return of_promise$0(function(_eF_){return _eF_},_eE_)}
    var auto$1="auto",ltr="ltr",rtl="rtl",Direction=[0,auto$1,ltr,rtl];
    function max$1(param)
     {return caml_call2(Int[2],notification,cst_maxActions)}
    function v$13(icon,action,title,param)
     {var o={};
      caml_call3(_d_[3],o,cst_action$0,action);
      caml_call3(_d_[3],o,cst_title$1,title);
      caml_call3(_d_[4],o,cst_icon,icon);
      return o}
    function action$0(a){return caml_call2(_d_[2],a,cst_action$1)}
    function title$5(a){return caml_call2(_d_[2],a,cst_title$2)}
    function icon(a){return caml_call2(_d_[1],a,cst_icon$0)}
    var Action=[0,max$1,v$13,action$0,title$5,icon];
    function opts$2
     (dir,
      lang,
      body,
      tag,
      image,
      icon,
      badge,
      timestamp_ms,
      renotify,
      silent,
      require_interaction,
      data,
      opt,
      param)
     {if(opt)var sth=opt[1],actions=sth;else var actions=0;
      var o={};
      caml_call3(_d_[4],o,cst_dir$0,dir);
      caml_call3(_d_[4],o,cst_lang,lang);
      caml_call3(_d_[4],o,cst_body,body);
      caml_call3(_d_[4],o,cst_image,image);
      caml_call3(_d_[4],o,cst_icon$1,icon);
      caml_call3(_d_[4],o,cst_badge,badge);
      caml_call3(Int[4],o,cst_timestamp$0,timestamp_ms);
      caml_call3(Bool[4],o,cst_renotify,renotify);
      caml_call3(Bool[4],o,cst_silent,silent);
      caml_call3(Bool[4],o,cst_requireInteraction,require_interaction);
      function _eB_(_eD_){return _eD_}
      set_if_some(o,cst_data$1,caml_call2(Stdlib_Option[7],_eB_,data));
      o.actions = of_list(function(_eC_){return _eC_},actions);
      return o}
    function create$11(opt,title)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new notification(title,opts)}
    function close$3(n){n.close();return 0}
    function actions(n)
     {var _ez_=n.actions;return to_list(function(_eA_){return _eA_},_ez_)}
    function badge(n){return caml_call2(_d_[2],n,cst_badge$0)}
    function body$3(n){return caml_call2(_d_[2],n,cst_body$0)}
    function data$4(n){return n.data}
    function dir$2(n){return caml_call2(_d_[2],n,cst_dir$1)}
    function lang$1(n){return caml_call2(_d_[2],n,cst_lang$0)}
    function tag(n){return caml_call2(_d_[2],n,cst_tag)}
    function icon$0(n){return caml_call2(_d_[2],n,cst_icon$2)}
    function image$0(n){return caml_call2(_d_[2],n,cst_image$0)}
    function renotify(n){return caml_call2(Bool[2],n,cst_renotify$0)}
    function require_interaction(n)
     {return caml_call2(Bool[2],n,cst_requireInteraction$0)}
    function silent(n){return caml_call2(Bool[2],n,cst_silent$0)}
    function timestamp_ms$1(n){return caml_call2(Int[2],n,cst_timestamp$1)}
    function title$6(n){return caml_call2(_d_[2],n,cst_title$3)}
    var
     notificationclick="notificationclick",
     notificationclose="notificationclose";
    function as_extendable$1(_ey_){return _ey_}
    function notification$0(e){return e.notification}
    function action$1(e){return caml_call2(_d_[2],e,cst_action$2)}
    function local(w){return w.localStorage}
    function session(w){return w.sessionStorage}
    function length$5(s){return caml_call2(Int[2],s,cst_length$5)}
    function key$0(s,i)
     {var _ew_=s.key(i);return to_option(function(_ex_){return _ex_},_ew_)}
    function get_item(s,k)
     {var _eu_=s.getItem(k);
      return to_option(function(_ev_){return _ev_},_eu_)}
    function set_item(s,k,v)
     {try
       {s.setItem(k,v);return _bt_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function remove_item(s,k){s.removeItem(k);return 0}
    function clear$1(s){s.clear();return 0}
    var storage="storage";
    function key$1(e){return caml_call2(_d_[1],e,cst_key$0)}
    function old_value(e){return caml_call2(_d_[1],e,cst_oldValue)}
    function new_value(e){return caml_call2(_d_[1],e,cst_newValue)}
    function url$3(e){return caml_call2(_d_[2],e,cst_url$1)}
    function storage_area(e){return find(e,cst_storageArea)}
    var
     blob$1="blob",
     arraybuffer="arraybuffer",
     Binary_type=[0,blob$1,arraybuffer],
     Ready_state=[0,0,1,2,3],
     websocket=target.WebSocket;
    function create$12(protocols,url)
     {if(protocols)
       var ps=protocols[1],protocols$0=caml_list_to_js_array(ps);
      else
       var protocols$0=fn;
      return new websocket(url,protocols$0)}
    function binary_type(s){return caml_call2(_d_[2],s,cst_binaryType)}
    function set_binary_type(s,t)
     {return caml_call3(_d_[3],s,cst_binaryType$0,t)}
    function close$4(code,r,s)
     {if(code)var c=code[1],code$0=c;else var code$0=fn;
      if(r)var s$0=r[1],reason=s$0;else var reason=fn;
      s.close(code$0,reason);
      return 0}
    function url$4(s){return caml_call2(_d_[2],s,cst_url$2)}
    function ready_state$1(s){return caml_call2(Int[2],s,cst_readyState$1)}
    function buffered_amount(s)
     {return caml_call2(Int[2],s,cst_bufferedAmount)}
    function extensions(s){return caml_call2(_d_[2],s,cst_extensions)}
    function protocol(s){return caml_call2(_d_[2],s,cst_protocol$0)}
    function send_string(s,d){s.send(d);return 0}
    function send_blob(s,d){s.send(d);return 0}
    function send_tarray(s,d){s.send(d);return 0}
    function send_array_buffer(s,d){s.send(d);return 0}
    function was_clean(e){return caml_call2(Bool[2],e,cst_wasClean)}
    function code$5(e){return caml_call2(Int[2],e,cst_code$2)}
    function reason(e){return caml_call2(_d_[2],e,cst_reason)}
    var
     Close=[0,was_clean,code$5,reason],
     close$5="close",
     Ev$5=[0,Close,close$5],
     Brr_io=
      [0,
       [0,
        [0,
         Presentation_style,
         opts,
         create$5,
         presentation_style,
         last_modified_ms$0,
         delayed,
         types,
         get_type],
        of_navigator,
        as_target$1,
        read,
        read_text,
        write,
        write_text],
       [0,
        of_el,
        to_el,
        name$5,
        method,
        target$1,
        action,
        enctype,
        accept_charset,
        autocomplete,
        no_validate,
        check_validity,
        report_validity,
        request_submit,
        reset$0,
        submit,
        [0,
         create$6,
         of_form,
         is_empty$1,
         has_file_entry,
         mem$0,
         find$7,
         find_all$0,
         fold$1,
         set$4,
         set_blob,
         append,
         append_blob,
         delete$0,
         of_assoc$0,
         to_assoc$0,
         of_uri_params,
         to_uri_params],
        Ev$0],
       [0,
        Body,
        [0,mem$1,find$8,fold$2,of_obj$0,of_assoc$1,to_assoc$1],
        [0,
         Cache,
         Credentials,
         Destination,
         Mode,
         Redirect,
         init$2,
         v$3,
         of_request,
         cache,
         credentials,
         destination,
         headers$0,
         integrity,
         is_history_navigation,
         is_reload_navigation,
         keepalive,
         method$0,
         mode,
         redirect,
         referrer$0,
         referrer_policy,
         signal$0,
         url$0],
        [0,
         Type$2,
         init$3,
         v$4,
         of_response,
         error$5,
         redirect$0,
         headers$1,
         ok$0,
         redirected,
         status,
         status_text,
         url$1],
        Cache$0,
        Ev$1,
        url$2,
        request$1,
        caches],
       [0,
        Error$1,
        [0,
         latitude,
         longitude,
         accuracy,
         altitude,
         altitude_accuracy,
         heading,
         speed,
         timestamp_ms$0],
        opts$0,
        of_navigator$0,
        get$5,
        watch,
        unwatch],
       [0,
        [0,
         Bool$0,
         Int$0,
         Float$0,
         Jstr$0,
         bool$0,
         int$2,
         float$1,
         jstr$0,
         jstr_enum,
         v$11,
         name$6,
         value_of_jv,
         value_to_jv,
         cap_of_jv,
         cap_to_jv,
         constr_of_jv,
         constr_to_jv],
        Supported_constraints,
        Constraints,
        Capabilities,
        Settings,
        [0,
         State,
         Kind$0,
         Prop,
         id$3,
         isolated,
         kind$0,
         label$1,
         muted,
         ready_state,
         enabled,
         set_enabled,
         get_capabilities,
         get_constraints,
         apply_constraints,
         get_settings,
         stop,
         clone,
         [0,track$2,ended$1,isolationchange,mute,unmute]],
        [0,
         Constraints$0,
         create$7,
         of_stream,
         of_tracks,
         id$4,
         active,
         get_audio_tracks,
         get_video_tracks,
         get_tracks,
         get_track_by_id,
         add_track,
         remove_track,
         clone$0,
         Ev$2],
        [0,
         Bitrate_mode,
         Recording_state,
         is_type_supported,
         init$4,
         create$8,
         stream$1,
         type$8,
         state$1,
         video_bps,
         audio_bps,
         audio_bitrate_mode,
         start,
         stop$0,
         pause$0,
         resume,
         request_data,
         Ev$3],
        Device,
        Devices,
        El],
       [0,
        transfer,
        opts$1,
        Port,
        [0,create$9,port1,port2],
        [0,create$10,name$7,close$2,post$0],
        window_post,
        [0,
         as_extendable$0,
         data$3,
         origin,
         last_event_id,
         source$1,
         ports,
         message$3,
         messageerror]],
       [0,
        Permission,
        permission,
        request_permission,
        Direction,
        Action,
        opts$2,
        create$11,
        close$3,
        actions,
        badge,
        body$3,
        data$4,
        dir$2,
        lang$1,
        tag,
        icon$0,
        image$0,
        renotify,
        require_interaction,
        silent,
        timestamp_ms$1,
        title$6,
        [0,
         as_extendable$1,
         notification$0,
         action$1,
         notificationclick,
         notificationclose]],
       [0,
        local,
        session,
        length$5,
        key$0,
        get_item,
        set_item,
        remove_item,
        clear$1,
        [0,key$1,old_value,new_value,url$3,storage_area,storage]],
       [0,
        Binary_type,
        Ready_state,
        create$12,
        binary_type,
        set_binary_type,
        close$4,
        url$4,
        ready_state$1,
        buffered_amount,
        extensions,
        protocol,
        send_string,
        send_blob,
        send_array_buffer,
        send_tarray,
        Ev$5]];
    caml_register_global(2935,Brr_io,"Brr_io");
    function is_2d(m){return caml_call2(Bool[2],m,cst_is2D)}
    function is_identity(m){return caml_call2(Bool[2],m,cst_isIdentity)}
    function inverse(m){return m.inverse()}
    function multiply(m$0,m){return m$0.multiply(m)}
    function m11(m){return caml_call2(Float[2],m,cst_m11)}
    function m12(m){return caml_call2(Float[2],m,cst_m12)}
    function m13(m){return caml_call2(Float[2],m,cst_m13)}
    function m14(m){return caml_call2(Float[2],m,cst_m14)}
    function m21(m){return caml_call2(Float[2],m,cst_m21)}
    function m22(m){return caml_call2(Float[2],m,cst_m22)}
    function m23(m){return caml_call2(Float[2],m,cst_m23)}
    function m24(m){return caml_call2(Float[2],m,cst_m24)}
    function m31(m){return caml_call2(Float[2],m,cst_m31)}
    function m32(m){return caml_call2(Float[2],m,cst_m32)}
    function m33(m){return caml_call2(Float[2],m,cst_m33)}
    function m34(m){return caml_call2(Float[2],m,cst_m34)}
    function m41(m){return caml_call2(Float[2],m,cst_m41)}
    function m42(m){return caml_call2(Float[2],m,cst_m42)}
    function m43(m){return caml_call2(Float[2],m,cst_m43)}
    function m44(m){return caml_call2(Float[2],m,cst_m44)}
    function a$1(m){return caml_call2(Float[2],m,cst_a)}
    function b$1(m){return caml_call2(Float[2],m,cst_b)}
    function c$0(m){return caml_call2(Float[2],m,cst_c)}
    function d(m){return caml_call2(Float[2],m,cst_d)}
    function e(m){return caml_call2(Float[2],m,cst_e)}
    function f(m){return caml_call2(Float[2],m,cst_f)}
    var dommatrixro=target.DOMMatrixReadOnly;
    function to_float32_array(m){return m.toFloat32Array()}
    function of_float32_array(a){return dommatrixro.fromFloat32Array(a)}
    function to_float64_array(m){return m.toFloat64Array()}
    function of_float64_array(a){return dommatrixro.fromFloat64Array(a)}
    var v4=target.DOMPointReadOnly;
    function v$14(x,y,z,w){return new v4(x,y,z,w)}
    function tr$1(m,v){return v.matrixTransform(m)}
    function to_json$2(v){return v.toJSON()}
    function x(v){return caml_call2(Float[2],v,cst_x$0)}
    function y(v){return caml_call2(Float[2],v,cst_y$0)}
    function z(v){return caml_call2(Float[2],v,cst_z)}
    function w(v){return caml_call2(Float[2],v,cst_w)}
    function create$13(d,at,opt,_et_,cs)
     {if(opt)var sth=opt[1],w=sth;else var w=0;
      if(_et_)var sth$0=_et_[1],h=sth$0;else var h=0;
      var c=caml_call3(_bn_[73],d,at,cs);
      caml_call3(Int[3],c,cst_width$1,w);
      caml_call3(Int[3],c,cst_height$1,h);
      return c}
    function of_el$1(e)
     {return caml_call2(_bn_[9],_bn_[57][16],e)
              ?e
              :throw$0
                (0,
                 "Expected canvas element but found: ".concat
                  (caml_call1(_bn_[8],e)))}
    function to_el$1(_es_){return _es_}
    function w$0(c){return caml_call2(Int[2],c,cst_width$2)}
    function h(c){return caml_call2(Int[2],c,cst_height$2)}
    function set_w(c,w){return caml_call3(Int[3],c,cst_width$3,w)}
    function set_h(c,h){return caml_call3(Int[3],c,cst_height$3,h)}
    function set_size_to_layout_size(opt,c)
     {if(opt)var sth=opt[1],hidpi=sth;else var hidpi=1;
      var
       dpr=hidpi?caml_call1(Window[5],_bm_[5]):1.,
       cw=Math.ceil(dpr * caml_call1(_bn_[36],c)) | 0,
       ch=Math.ceil(dpr * caml_call1(_bn_[37],c)) | 0,
       _eq_=w$0(c) !== cw?1:0,
       _er_=_eq_ || (h(c) !== ch?1:0);
      return _er_?(set_w(c,cw),set_h(c,ch)):_er_}
    function image_encode(opt,quality,param)
     {if(opt)var sth=opt[1],type=sth;else var type="image/png";
      var o={};
      caml_call3(_d_[3],o,cst_type$4,type);
      caml_call3(Float[4],o,cst_quality,quality);
      return o}
    function enc(encode,c,meth,arg)
     {if(encode)
       var e=encode[1],encode$0=e;
      else
       var encode$0=image_encode(0,0,0);
      var t=encode$0.type,q=find(encode$0,cst_quality$0);
      if(arg)
       {var a=arg[1];
        if(q)var q$0=q[1],_ep_=[0,a,t,q$0];else var _ep_=[0,a,t];
        var args=_ep_}
      else
       if(q)var q$1=q[1],args=[0,t,q$1];else var args=[0,t];
      return caml_js_meth_call(c,meth,args)}
    function to_data_url(encode,c)
     {try
       {var v=enc(0,c,cst_toDataURL,0)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function to_blob(encode,c)
     {var match=create$1(0),set=match[2],fut=match[1];
      function cb(blob)
       {return caml_call1(set,[0,to_option(function(_eo_){return _eo_},blob)])}
      try
       {enc(0,c,cst_toBlob,[0,cb]);return fut}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];caml_call1(set,[1,e]);return fut}
        throw exn}}
    function capture_stream$0(hz,c)
     {if(hz)var hz$0=hz[1],args=[0,hz$0];else var args=[0];
      return caml_js_meth_call(c,cst_captureStrseam,args)}
    var
     nonzero="nonzero",
     evenodd="evenodd",
     Fill_rule=[0,nonzero,evenodd],
     low="low",
     medium="medium",
     high="high",
     Image_smoothing_quality=[0,low,medium,high],
     butt="butt",
     round="round",
     square="square",
     Line_cap=[0,butt,round,square],
     round$0="round",
     bevel="bevel",
     miter="miter",
     Line_join=[0,round$0,bevel,miter],
     start$3="start",
     end$0="end",
     left="left",
     right="right",
     center="center",
     Text_align=[0,start$3,end$0,left,right,center],
     top="top",
     hanging="hanging",
     middle="middle",
     alphabetic="alphabetic",
     ideographic="ideographic",
     bottom="bottom",
     Text_baseline=[0,top,hanging,middle,alphabetic,ideographic,bottom],
     ltr$0="ltr",
     rtl$0="rtl",
     inherit="inherit",
     Text_direction=[0,ltr$0,rtl$0,inherit],
     normal="normal",
     multiply$0="multiply",
     screen="screen",
     overlay="overlay",
     darken="darken",
     lighten="lighten",
     color_dodge="color-dodge",
     color_burn="color-burn",
     hard_light="hard-light",
     soft_light="soft-light",
     difference="difference",
     exclusion="exclusion",
     hue="hue",
     saturation="saturation",
     color$0="color",
     luminosity="luminosity",
     clear$2="clear",
     copy$1="copy",
     source_over="source-over",
     destination_over="destination-over",
     source_in="source-in",
     destination_in="destination-in",
     source_out="source-out",
     destination_out="destination-out",
     source_atop="source-atop",
     destination_atop="destination-atop",
     xor="xor",
     lighter="lighter",
     plus_darker="plus-darker",
     plus_lighter="plus-lighter",
     Composite_op=
      [0,
       normal,
       multiply$0,
       screen,
       overlay,
       darken,
       lighten,
       color_dodge,
       color_burn,
       hard_light,
       soft_light,
       difference,
       exclusion,
       hue,
       saturation,
       color$0,
       luminosity,
       clear$2,
       copy$1,
       source_over,
       destination_over,
       source_in,
       destination_in,
       source_out,
       destination_out,
       source_atop,
       destination_atop,
       xor,
       lighter,
       plus_darker,
       plus_lighter],
     xy="repeat",
     x$0="repeat-x",
     y$0="repeat-y",
     no="no-repeat",
     Repeat=[0,xy,x$0,y$0,no],
     path$0=target.Path2D;
    function create$14(param){return new path$0()}
    function of_svg(svg){return new path$0(svg)}
    function of_path(p){return new path$0(p)}
    function add$0(tr,p$0,p)
     {if(tr)var t=tr[1],_en_=[0,p,t];else var _en_=[0,p];
      caml_js_meth_call(p$0,cst_addPath,_en_);
      return 0}
    function close$6(p){p.closePath();return 0}
    function move_to(p,x,y){p.moveTo(x,y);return 0}
    function line_to(p,x,y){p.lineTo(x,y);return 0}
    function qcurve_to(p,cx,cy,x,y){p.quadraticCurveTo(cx,cy,x,y);return 0}
    function ccurve_to(p,cx$0,cy$0,cx,cy,x,y)
     {p.bezierCurveTo(cx$0,cy$0,cx,cy,x,y);return 0}
    function arc_to(p,cx$0,cy$0,cx,cy,r){p.arcTo(cx$0,cy$0,cx,cy,r);return 0}
    function arc(opt,p,cx,cy,r,start,stop)
     {if(opt)var sth=opt[1],anticlockwise=sth;else var anticlockwise=0;
      p.arc(cx,cy,r,start,stop,! ! anticlockwise);
      return 0}
    function rect(p,x,y,w,h){p.rect(x,y,w,h);return 0}
    function ellipse(opt,p,cx,cy,rx,ry,rot,start,stop)
     {if(opt)var sth=opt[1],anticlockwise=sth;else var anticlockwise=0;
      p.ellipse(cx,cy,rx,ry,rot,start,stop,! ! anticlockwise);
      return 0}
    function image_src_of_el(_em_){return _em_}
    function image_src_of_jv(_el_){return _el_}
    function attrs_alpha(o){return caml_call2(Bool[2],o,cst_alpha)}
    function attrs_desynchronized(o)
     {return caml_call2(Bool[2],o,cst_desynchronized)}
    function create$15(opt,cnv)
     {if(opt)var sth=opt[1],attrs=sth;else var attrs=fn;
      return cnv.getContext("2d",attrs)}
    function canvas$1(c)
     {return find_map(function(_ek_){return _ek_},c,cst_canvas)}
    function attrs(c){return c.getContextAttributes()}
    function save(c){c.save();return 0}
    function restore(c){c.restore();return 0}
    function image_smoothing_enabled(c)
     {return caml_call2(Bool[2],c,cst_imageSmoothingEnabled)}
    function set_image_smoothing_enabled(c,b)
     {return caml_call3(Bool[3],c,cst_imageSmoothingEnabled$0,b)}
    function image_smoothing_quality(c)
     {return caml_call2(_d_[2],c,cst_imageSmoothingQuality)}
    function set_image_smoothing_quality(c,v)
     {return caml_call3(_d_[3],c,cst_imageSmoothingQuality$0,v)}
    function global_alpha(c){return caml_call2(Float[2],c,cst_globalAlpha)}
    function set_global_alpha(c,a)
     {return caml_call3(Float[3],c,cst_globalAlpha$0,a)}
    function global_composite_op(c)
     {return caml_call2(_d_[2],c,cst_globalCompositeOperation)}
    function set_global_composite_op(c,o)
     {return caml_call3(_d_[3],c,cst_globalCompositeOperation$0,o)}
    function filter$0(c){return caml_call2(_d_[2],c,cst_filter)}
    function set_filter(c,f){return caml_call3(_d_[3],c,cst_filter$0,f)}
    function get_transform(c){return c.getTransform()}
    function set_transform(c,m){c.setTransform(m);return 0}
    function reset_transform(c){c.resetTransform();return 0}
    function transform(c,m)
     {var _ef_=f(m),_eg_=e(m),_eh_=d(m),_ei_=c$0(m),_ej_=b$1(m);
      c.resetTransform(a$1(m),_ej_,_ei_,_eh_,_eg_,_ef_);
      return 0}
    function translate(c,x,y){c.translate(x,y);return 0}
    function rotate(c,r){c.rotate(r);return 0}
    function scale(c,sx,sy){c.scale(sx,sy);return 0}
    function set_stroke_style(c,s){return c.strokeStyle = s}
    function set_fill_style(c,s){return c.fillStyle = s}
    function color$1(_ee_){return _ee_}
    function gradient_style(_ed_){return _ed_}
    function make_stops(g,stops)
     {function _ec_(param)
       {var c=param[2],off=param[1];g.addColorStop(off,c);return 0}
      return caml_call2(Stdlib_List[17],_ec_,stops)}
    function linear_gradient(c,x0,y0,x1,y1,stops)
     {var g=c.createLinearGradient(x0,y0,x1,y1);make_stops(g,stops);return g}
    function radial_gradient(c,x0,y0,r0,x1,y1,r1,stops)
     {var g=c.createRadialGradient(x0,y0,r0,x1,y1,r1);
      make_stops(g,stops);
      return g}
    function pattern(c,img,r,tr)
     {var p=c.createPattern(img,r);
      if(tr){var t=tr[1];p.setTransform(t);return p}
      return p}
    function pattern_style(_eb_){return _eb_}
    function line_width(c){return caml_call2(Float[2],c,cst_lineWidth)}
    function set_line_width(c,w)
     {return caml_call3(Float[3],c,cst_lineWidth$0,w)}
    function line_cap(c){return caml_call2(_d_[2],c,cst_lineCap)}
    function set_line_cap(c,cap)
     {return caml_call3(_d_[3],c,cst_lineCap$0,cap)}
    function line_join(c){return caml_call2(_d_[2],c,cst_lineJoin)}
    function set_line_join(c,join)
     {return caml_call3(_d_[3],c,cst_lineJoin$0,join)}
    function miter_limit(c){return caml_call2(Float[2],c,cst_miterLimit)}
    function set_miter_limit(c,l)
     {return caml_call3(Float[3],c,cst_miterLimit$0,l)}
    function line_dash(c)
     {var _d$_=c.getLineDash();
      return to_list(function(_ea_){return _ea_},_d$_)}
    function set_line_dash(c,ds)
     {c.setLineDash(of_list(function(_d__){return _d__},ds));return 0}
    function line_dash_offset(c)
     {return caml_call2(Float[2],c,cst_lineDashOffset)}
    function set_line_dash_offset(c,o)
     {return caml_call3(Float[3],c,cst_lineDashOffset$0,o)}
    function shadow_blur(c){return caml_call2(Float[2],c,cst_shadowBlur)}
    function set_shadow_blur(c,b)
     {return caml_call3(Float[3],c,cst_shadowBlur$0,b)}
    function shadow_offset_x(c)
     {return caml_call2(Float[2],c,cst_shadowOffsetX)}
    function set_shadow_offset_x(c,o)
     {return caml_call3(Float[3],c,cst_shadowOffsetX$0,o)}
    function shadow_offset_y(c)
     {return caml_call2(Float[2],c,cst_shadowOffsetY)}
    function set_shadow_offset_y(c,o)
     {return caml_call3(Float[3],c,cst_shadowOffsetY$0,o)}
    function shadow_color(c){return caml_call2(_d_[2],c,cst_shadowColor)}
    function set_shadow_color(c,col)
     {return caml_call3(_d_[3],c,cst_shadowColor$0,col)}
    function font$0(c){return caml_call2(_d_[2],c,cst_font)}
    function set_font(c,f){return caml_call3(_d_[3],c,cst_font$0,f)}
    function text_align(c){return caml_call2(_d_[2],c,cst_textAlign)}
    function set_text_align(c,a)
     {return caml_call3(_d_[3],c,cst_textAlign$0,a)}
    function text_baseline(c){return caml_call2(_d_[2],c,cst_textBaseline)}
    function set_text_baseline(c,b)
     {return caml_call3(_d_[3],c,cst_textBaseline$0,b)}
    function text_direction(c){return caml_call2(_d_[2],c,cst_direction)}
    function set_text_direction(c,d)
     {return caml_call3(_d_[3],c,cst_direction$0,d)}
    function clear_rect(c,x,y,w,h){c.clearRect(x,y,w,h);return 0}
    function fill_rect(c,x,y,w,h){c.fillRect(x,y,w,h);return 0}
    function stroke_rect(c,x,y,w,h){c.strokeRect(x,y,w,h);return 0}
    function fill$0(opt,c,p)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      c.fill(p,fill_rule);
      return 0}
    function stroke(c,p){c.stroke(p);return 0}
    function clip(opt,c,p)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      c.clip(p,fill_rule);
      return 0}
    function draw_focus_if_needed(c,p,e){c.drawFocusIfNeeded(p,e);return 0}
    function scroll_path_into_view(c,p){c.scrollPathIntoView(p);return 0}
    function is_point_in_fill(opt,c,p,x,y)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      return c.isPointInPath(p,x,y,fill_rule) | 0}
    function is_point_in_stroke(c,p,x,y){return c.isPointInStroke(p,x,y) | 0}
    function call_text(c,meth,max_width,txt,x,y)
     {if(max_width)
       var m=max_width[1],args=[0,txt,x,y,m];
      else
       var args=[0,txt,x,y];
      caml_js_meth_call(c,meth,args);
      return 0}
    function fill_text(max_width,c,txt,x,y)
     {return call_text(c,cst_fillText,max_width,txt,x,y)}
    function stroke_text(max_width,c,txt,x,y)
     {return call_text(c,cst_strokeText,max_width,txt,x,y)}
    function width$5(m){return caml_call2(Float[2],m,cst_width$4)}
    function actual_bounding_box_left(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxLeft)}
    function actual_bounding_box_right(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxRight)}
    function font_bounding_box_ascent(m)
     {return caml_call2(Float[2],m,cst_fontBoundingBoxAscent)}
    function font_bounding_box_descent(m)
     {return caml_call2(Float[2],m,cst_fontBoundingBoxDescent)}
    function actual_bounding_box_ascent(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxAscent)}
    function actual_bounding_box_descent(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxDescent)}
    function em_height_ascent(m)
     {return caml_call2(Float[2],m,cst_emHeightAscent)}
    function em_height_descent(m)
     {return caml_call2(Float[2],m,cst_emHeightDescent)}
    function hanging_baseline(m)
     {return caml_call2(Float[2],m,cst_hangingBaseline)}
    function alphabetic_baseline(m)
     {return caml_call2(Float[2],m,cst_alphabeticBaseline)}
    function ideographic_baseline(m)
     {return caml_call2(Float[2],m,cst_ideographicBaseline)}
    var
     Text_metrics=
      [0,
       width$5,
       actual_bounding_box_left,
       actual_bounding_box_right,
       font_bounding_box_ascent,
       font_bounding_box_descent,
       actual_bounding_box_ascent,
       actual_bounding_box_descent,
       em_height_ascent,
       em_height_descent,
       hanging_baseline,
       alphabetic_baseline,
       ideographic_baseline];
    function measure_text(c,txt){return c.measureText(txt)}
    function draw_image(c,i,x,y){c.drawImage(i,x,y);return 0}
    function draw_image_in_rect(c,i,x,y,w,h){c.drawImage(i,x,y,w,h);return 0}
    function draw_sub_image_in_rect(c,i,sx,sy,sw,sh,x,y,w,h)
     {c.drawImage(i,sx,sy,sw,sh,x,y,w,h);return 0}
    var image_data=target.ImageData;
    function create$16(data,w,h,param)
     {if(data)var data$0=data[1],args=[0,data$0,w,h];else var args=[0,w,h];
      return caml_js_new(image_data,args)}
    function w$1(d){return caml_call2(Int[2],d,cst_width$5)}
    function h$0(d){return caml_call2(Int[2],d,cst_height$4)}
    function data$5(d){return d.data}
    function create_image_data(c,w,h){return c.createImageData(w,h)}
    function get_image_data(c,x,y,w,h){return c.getImageData(x,y,w,h)}
    function put_image_data(c,d,x,y){c.putImageData(d,x,y);return 0}
    function put_sub_image_data(c,d,sx,sy,sw,sh,x,y)
     {c.putImageData(d,x,y,sx,sy,sw,sh);return 0}
    var
     default$3="default",
     high_performance="high-performance",
     low_power="low-power",
     Power_preference=[0,default$3,high_performance,low_power];
    function v$15
     (alpha,
      depth,
      stencil,
      antialias,
      premultiplied_alpha,
      preserve_drawing_buffer,
      power_preference,
      fail_if_major_performance_cave,
      desynchronized,
      param)
     {var o={};
      caml_call3(Bool[4],o,cst_alpha$0,alpha);
      caml_call3(Bool[4],o,cst_depth,depth);
      caml_call3(Bool[4],o,cst_stencil,stencil);
      caml_call3(Bool[4],o,cst_antialias,antialias);
      caml_call3(Bool[4],o,cst_premultipliedApha,premultiplied_alpha);
      caml_call3(Bool[4],o,cst_preserveDrawingBuffer,preserve_drawing_buffer);
      caml_call3(_d_[4],o,cst_powerPreference,power_preference);
      caml_call3
       (Bool[4],
        o,
        cst_failIfMajorPerformanceCave,
        fail_if_major_performance_cave);
      caml_call3(Bool[4],o,cst_desynchronized$0,desynchronized);
      return o}
    function alpha(a){return caml_call2(Bool[2],a,cst_alpha$1)}
    function depth(a){return caml_call2(Bool[2],a,cst_depth$0)}
    function stencil(a){return caml_call2(Bool[2],a,cst_stencil$0)}
    function antialias(a){return caml_call2(Bool[2],a,cst_antialias$0)}
    function premultiplied_alpha(a)
     {return caml_call2(Bool[2],a,cst_premultipliedApha$0)}
    function preserve_drawing_buffer(a)
     {return caml_call2(Bool[2],a,cst_preserveDrawingBuffer$0)}
    function power_preference(a)
     {return caml_call2(_d_[2],a,cst_powerPreference$0)}
    function desynchronized(a)
     {return caml_call2(Bool[2],a,cst_desynchronized$1)}
    function create$17(opt,_d6_,cnv)
     {if(opt)var sth=opt[1],attrs=sth;else var attrs=fn;
      if(_d6_)var sth$0=_d6_[1],v1=sth$0;else var v1=0;
      var
       _d7_=v1?cst_webgl:cst_webgl2,
       webgl=caml_jsstring_of_string(_d7_),
       _d8_=cnv.getContext(webgl,attrs);
      return to_option(function(_d9_){return _d9_},_d8_)}
    function canvas$2(c)
     {return find_map(function(_d5_){return _d5_},c,cst_canvas$0)}
    function attrs$0(c){return c.getContextAttributes()}
    function drawing_buffer_width(c)
     {return caml_call2(Int[2],c,cst_drawingBufferWidth)}
    function drawing_buffer_height(c)
     {return caml_call2(Int[2],c,cst_drawingBufferHeight)}
    function is_context_lost(c)
     {return caml_call2(Bool[2],c,cst_isContextLost)}
    function get_supported_extensions(c)
     {return caml_list_of_js_array(c.getSupportedExtensions())}
    function get_extension(c,ext){return c.getExtension(ext)}
    function size(i){return caml_call2(Int[2],i,cst_size$0)}
    function type$9(i){return caml_call2(Int[2],i,cst_type$5)}
    function name$8(i){return caml_call2(_d_[2],i,cst_name$4)}
    var Active_info=[0,size,type$9,name$8];
    function range_min(f){return caml_call2(Int[2],f,cst_rangeMin)}
    function range_max(f){return caml_call2(Int[2],f,cst_rangeMax)}
    function precision(f){return caml_call2(Int[2],f,cst_precision)}
    var Shader_precision_format=[0,range_min,range_max,precision];
    function of_image_data(_d4_){return _d4_}
    function of_img_el(_d3_){return _d3_}
    function of_canvas_el(_d2_){return _d2_}
    function of_video_el(_d1_){return _d1_}
    function of_offscreen_canvas(_d0_){return _d0_}
    var
     Tex_image_source=
      [0,of_image_data,of_img_el,of_canvas_el,of_video_el,of_offscreen_canvas];
    function active_texture(c,texture){c.activeTexture(texture);return 0}
    function attach_shader(c,program,shader)
     {c.attachShader(program,shader);return 0}
    function begin_query(c,target,query){c.beginQuery(target,query);return 0}
    function begin_transform_feedback(c,primitiveMode)
     {c.beginTransformFeedback(primitiveMode);return 0}
    function bind_attrib_location(c,program,index,name)
     {c.bindAttribLocation(program,index,name);return 0}
    function bind_buffer(c,target,buffer)
     {c.bindBuffer
       (target,of_option(null$0,function(_dZ_){return _dZ_},buffer));
      return 0}
    function bind_buffer_base(c,target,index,buffer)
     {c.bindBufferBase(target,index,buffer);return 0}
    function bind_buffer_range(c,target,index,buffer,offset,size)
     {c.bindBufferRange(target,index,buffer,offset,size);return 0}
    function bind_framebuffer(c,target,framebuffer)
     {c.bindFramebuffer
       (target,of_option(null$0,function(_dY_){return _dY_},framebuffer));
      return 0}
    function bind_renderbuffer(c,target,renderbuffer)
     {c.bindRenderbuffer
       (target,of_option(null$0,function(_dX_){return _dX_},renderbuffer));
      return 0}
    function bind_sampler(c,unit,sampler)
     {c.bindSampler
       (unit,of_option(null$0,function(_dW_){return _dW_},sampler));
      return 0}
    function bind_texture(c,target,texture)
     {c.bindTexture
       (target,of_option(null$0,function(_dV_){return _dV_},texture));
      return 0}
    function bind_transform_feedback(c,target,tf)
     {c.bindTransformFeedback
       (target,of_option(null$0,function(_dU_){return _dU_},tf));
      return 0}
    function bind_vertex_array(c,array)
     {c.bindVertexArray(of_option(null$0,function(_dT_){return _dT_},array));
      return 0}
    function blend_color(c,red,green,blue,alpha)
     {c.blendColor(red,green,blue,alpha);return 0}
    function blend_equation(c,mode){c.blendEquation(mode);return 0}
    function blend_equation_separate(c,modeRGB,modeAlpha)
     {c.blendEquationSeparate(modeRGB,modeAlpha);return 0}
    function blend_func(c,sfactor,dfactor)
     {c.blendFunc(sfactor,dfactor);return 0}
    function blend_func_separate(c,srcRGB,dstRGB,srcAlpha,dstAlpha)
     {c.blendFuncSeparate(srcRGB,dstRGB,srcAlpha,dstAlpha);return 0}
    function blit_framebuffer
     (c,srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter)
     {c.blitFramebuffer
       (srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter);
      return 0}
    function buffer_data(c,target,srcData,usage)
     {c.bufferData(target,srcData,usage);return 0}
    function buffer_data_size(c,target,size,usage)
     {c.bufferData(target,size,usage);return 0}
    function buffer_sub_data(c,target,dstByteOffset,srcData)
     {c.bufferSubData(target,dstByteOffset,srcData);return 0}
    function check_framebuffer_status(c,target)
     {return c.checkFramebufferStatus(target)}
    function clear$3(c,mask){c.clear(mask);return 0}
    function clear_bufferfi(c,buffer,drawbuffer,depth,stencil)
     {c.clearBufferfi(buffer,drawbuffer,depth,stencil);return 0}
    function clear_bufferfv(c,buffer,drawbuffer,values)
     {c.clearBufferfv(buffer,drawbuffer,values);return 0}
    function clear_bufferiv(c,buffer,drawbuffer,values)
     {c.clearBufferiv(buffer,drawbuffer,values);return 0}
    function clear_bufferuiv(c,buffer,drawbuffer,values)
     {c.clearBufferuiv(buffer,drawbuffer,values);return 0}
    function clear_color(c,red,green,blue,alpha)
     {c.clearColor(red,green,blue,alpha);return 0}
    function clear_depth(c,depth){c.clearDepth(depth);return 0}
    function clear_stencil(c,s){c.clearStencil(s);return 0}
    function client_wait_sync(c,sync,flags,timeout)
     {return c.clientWaitSync(sync,flags,timeout)}
    function color_mask(c,red,green,blue,alpha)
     {c.colorMask(! ! red,! ! green,! ! blue,! ! alpha);return 0}
    function compile_shader(c,shader){c.compileShader(shader);return 0}
    function compressed_tex_image2d
     (c,target,level,internalformat,width,height,border,srcData)
     {c.compressedTexImage2D
       (target,level,internalformat,width,height,border,srcData);
      return 0}
    function compressed_tex_image2d_size
     (c,target,level,internalformat,width,height,border,imageSize,offset)
     {c.compressedTexImage2D
       (target,level,internalformat,width,height,border,imageSize,offset);
      return 0}
    function compressed_tex_image3d
     (c,target,level,internalformat,width,height,depth,border,srcData)
     {c.compressedTexImage3D
       (target,level,internalformat,width,height,depth,border,srcData);
      return 0}
    function compressed_tex_image3d_size
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      imageSize,
      offset)
     {c.compressedTexImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        imageSize,
        offset);
      return 0}
    function compressed_tex_sub_image2d
     (c,target,level,xoffset,yoffset,width,height,format,srcData)
     {c.compressedTexSubImage2D
       (target,level,xoffset,yoffset,width,height,format,srcData);
      return 0}
    function compressed_tex_sub_image2d_siz
     (c,target,level,xoffset,yoffset,width,height,format,imageSize,offset)
     {c.compressedTexSubImage2D
       (target,level,xoffset,yoffset,width,height,format,imageSize,offset);
      return 0}
    function compressed_tex_sub_image3d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      srcData)
     {c.compressedTexSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        srcData);
      return 0}
    function compressed_tex_sub_image3d_siz
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      imageSize,
      offset)
     {c.compressedTexSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        imageSize,
        offset);
      return 0}
    function copy_buffer_sub_data
     (c,readTarget,writeTarget,readOffset,writeOffset,size)
     {c.copyBufferSubData(readTarget,writeTarget,readOffset,writeOffset,size);
      return 0}
    function copy_tex_image2d
     (c,target,level,internalformat,x,y,width,height,border)
     {c.copyTexImage2D(target,level,internalformat,x,y,width,height,border);
      return 0}
    function copy_tex_sub_image2d
     (c,target,level,xoffset,yoffset,x,y,width,height)
     {c.copyTexSubImage2D(target,level,xoffset,yoffset,x,y,width,height);
      return 0}
    function copy_tex_sub_image3d
     (c,target,level,xoffset,yoffset,zoffset,x,y,width,height)
     {c.copyTexSubImage3D
       (target,level,xoffset,yoffset,zoffset,x,y,width,height);
      return 0}
    function create_buffer(c){return c.createBuffer()}
    function create_framebuffer(c){return c.createFramebuffer()}
    function create_program(c){return c.createProgram()}
    function create_query(c){return c.createQuery()}
    function create_renderbuffer(c){return c.createRenderbuffer()}
    function create_sampler(c){return c.createSampler()}
    function create_shader(c,type){return c.createShader(type)}
    function create_texture(c){return c.createTexture()}
    function create_transform_feedback(c){return c.createTransformFeedback()}
    function create_vertex_array(c){return c.createVertexArray()}
    function cull_face(c,mode){c.cullFace(mode);return 0}
    function delete_buffer(c,buffer){c.deleteBuffer(buffer);return 0}
    function delete_framebuffer(c,framebuffer)
     {c.deleteFramebuffer(framebuffer);return 0}
    function delete_program(c,program){c.deleteProgram(program);return 0}
    function delete_query(c,query){c.deleteQuery(query);return 0}
    function delete_renderbuffer(c,renderbuffer)
     {c.deleteRenderbuffer(renderbuffer);return 0}
    function delete_sampler(c,sampler){c.deleteSampler(sampler);return 0}
    function delete_shader(c,shader){c.deleteShader(shader);return 0}
    function delete_sync(c,sync){c.deleteSync(sync);return 0}
    function delete_texture(c,texture){c.deleteTexture(texture);return 0}
    function delete_transform_feedback(c,tf)
     {c.deleteTransformFeedback(tf);return 0}
    function delete_vertex_array(c,vertexArray)
     {c.deleteVertexArray(vertexArray);return 0}
    function depth_func(c,func){c.depthFunc(func);return 0}
    function depth_mask(c,flag){c.depthMask(! ! flag);return 0}
    function detach_shader(c,program,shader)
     {c.detachShader(program,shader);return 0}
    function disable(c,cap){c.disable(cap);return 0}
    function disable_vertex_attrib_array(c,index)
     {c.disableVertexAttribArray(index);return 0}
    function draw_arrays(c,mode,first,count)
     {c.drawArrays(mode,first,count);return 0}
    function draw_arrays_instanced(c,mode,first,count,instanceCount)
     {c.drawArraysInstanced(mode,first,count,instanceCount);return 0}
    function draw_buffers(c,buffers)
     {c.drawBuffers(of_list(function(_dS_){return _dS_},buffers));return 0}
    function draw_elements(c,mode,count,type,offset)
     {c.drawElements(mode,count,type,offset);return 0}
    function draw_elements_instanced(c,mode,count,type,offset,instanceCount)
     {c.drawElementsInstanced(mode,count,type,offset,instanceCount);return 0}
    function draw_range_elements(c,mode,start,end,count,type,offset)
     {c.drawRangeElements(mode,start,end,count,type,offset);return 0}
    function enable(c,cap){c.enable(cap);return 0}
    function enable_vertex_attrib_array(c,index)
     {c.enableVertexAttribArray(index);return 0}
    function end_query(c,target){c.endQuery(target);return 0}
    function end_transform_feedback(c){c.endTransformFeedback();return 0}
    function fence_sync(c,condition,flags)
     {return c.fenceSync(condition,flags)}
    function finish(c){c.finish();return 0}
    function flush(c){c.flush();return 0}
    function framebuffer_renderbuffer
     (c,target,attachment,renderbuffertarget,renderbuffer)
     {c.framebufferRenderbuffer
       (target,attachment,renderbuffertarget,renderbuffer);
      return 0}
    function framebuffer_texture2d
     (c,target,attachment,textarget,texture,level)
     {c.framebufferTexture2D(target,attachment,textarget,texture,level);
      return 0}
    function framebuffer_texture_layer
     (c,target,attachment,texture,level,layer)
     {c.framebufferTextureLayer(target,attachment,texture,level,layer);
      return 0}
    function front_face(c,mode){c.frontFace(mode);return 0}
    function generate_mipmap(c,target){c.generateMipmap(target);return 0}
    function get_active_attrib(c,program,index)
     {return c.getActiveAttrib(program,index)}
    function get_active_uniform(c,program,index)
     {return c.getActiveUniform(program,index)}
    function get_active_uniform_block_name(c,program,uniformBlockIndex)
     {return c.getActiveUniformBlockName(program,uniformBlockIndex)}
    function get_active_uniform_block_param(c,program,uniformBlockIndex,pname)
     {return c.getActiveUniformBlockParameter(program,uniformBlockIndex,pname)}
    function get_active_uniforms(c,program,uniformIndices,pname)
     {return c.getActiveUniforms
              (program,
               of_list(function(_dR_){return _dR_},uniformIndices),
               pname)}
    function get_attached_shaders(c,program)
     {return caml_list_of_js_array(c.getAttachedShaders(program))}
    function get_attrib_location(c,program,name)
     {return c.getAttribLocation(program,name)}
    function get_buffer_parameter(c,target,pname)
     {return c.getBufferParameter(target,pname)}
    function get_buffer_sub_data(c,target,srcByteOffset,dstBuffer)
     {c.getBufferSubData(target,srcByteOffset,dstBuffer);return 0}
    function get_error(c){return c.getError()}
    function get_frag_data_location(c,program,name)
     {return c.getFragDataLocation(program,name)}
    function get_framebuffer_attachment_par(c,target,attachment,pname)
     {return c.getFramebufferAttachmentParameter(target,attachment,pname)}
    function get_indexed_parameter(c,target,index)
     {return c.getIndexedParameter(target,index)}
    function get_internalformat_parameter(c,target,internalformat,pname)
     {return c.getInternalformatParameter(target,internalformat,pname)}
    function get_parameter(c,pname){return c.getParameter(pname)}
    function get_program_info_log(c,program)
     {return c.getProgramInfoLog(program)}
    function get_program_parameter(c,program,pname)
     {return c.getProgramParameter(program,pname)}
    function get_query(c,target,pname){return c.getQuery(target,pname)}
    function get_query_parameter(c,query,pname)
     {return c.getQueryParameter(query,pname)}
    function get_renderbuffer_parameter(c,target,pname)
     {return c.getRenderbufferParameter(target,pname)}
    function get_sampler_parameter(c,sampler,pname)
     {return c.getSamplerParameter(sampler,pname)}
    function get_shader_info_log(c,shader){return c.getShaderInfoLog(shader)}
    function get_shader_parameter(c,shader,pname)
     {return c.getShaderParameter(shader,pname)}
    function get_shader_precision_format(c,shadertype,precisiontype)
     {return c.getShaderPrecisionFormat(shadertype,precisiontype)}
    function get_shader_source(c,shader){return c.getShaderSource(shader)}
    function get_sync_parameter(c,sync,pname)
     {return c.getSyncParameter(sync,pname)}
    function get_tex_parameter(c,target,pname)
     {return c.getTexParameter(target,pname)}
    function get_transform_feedback_varying(c,program,index)
     {return c.getTransformFeedbackVarying(program,index)}
    function get_uniform(c,program,location)
     {return c.getUniform(program,location)}
    function get_uniform_block_index(c,program,uniformBlockName)
     {return c.getUniformBlockIndex(program,uniformBlockName)}
    function get_uniform_indices(c,program,uniformNames)
     {var
       _dP_=
        c.getUniformIndices(program,caml_list_to_js_array(uniformNames));
      return to_list(function(_dQ_){return _dQ_},_dP_)}
    function get_uniform_location(c,program,name)
     {return c.getUniformLocation(program,name)}
    function get_vertex_attrib(c,index,pname)
     {return c.getVertexAttrib(index,pname)}
    function get_vertex_attrib_offset(c,index,pname)
     {return c.getVertexAttribOffset(index,pname)}
    function hint(c,target,mode){c.hint(target,mode);return 0}
    function invalidate_framebuffer(c,target,attachments)
     {c.invalidateFramebuffer
       (target,of_list(function(_dO_){return _dO_},attachments));
      return 0}
    function invalidate_sub_framebuffer(c,target,attachments,x,y,width,height)
     {c.invalidateSubFramebuffer
       (target,
        of_list(function(_dN_){return _dN_},attachments),
        x,
        y,
        width,
        height);
      return 0}
    function is_buffer(c,buffer){return c.isBuffer(buffer) | 0}
    function is_enabled(c,cap){return c.isEnabled(cap) | 0}
    function is_framebuffer(c,framebuffer)
     {return c.isFramebuffer(framebuffer) | 0}
    function is_program(c,program){return c.isProgram(program) | 0}
    function is_query(c,query){return c.isQuery(query) | 0}
    function is_renderbuffer(c,renderbuffer)
     {return c.isRenderbuffer(renderbuffer) | 0}
    function is_sampler(c,sampler){return c.isSampler(sampler) | 0}
    function is_shader(c,shader){return c.isShader(shader) | 0}
    function is_texture(c,texture){return c.isTexture(texture) | 0}
    function is_transform_feedback(c,tf){return c.isTransformFeedback(tf) | 0}
    function is_vertex_array(c,vertexArray)
     {return c.isVertexArray(vertexArray) | 0}
    function line_width$0(c,width){c.lineWidth(width);return 0}
    function link_program(c,program){c.linkProgram(program);return 0}
    function pause_transform_feedback(c){c.pauseTransformFeedback();return 0}
    function pixel_storei(c,pname,param){c.pixelStorei(pname,param);return 0}
    function polygon_offset(c,factor,units)
     {c.polygonOffset(factor,units);return 0}
    function read_buffer(c,src){c.readBuffer(src);return 0}
    function read_pixels_to_pixel_pack(c,x,y,width,height,format,type,offset)
     {c.readPixels(x,y,width,height,format,type,offset);return 0}
    function read_pixels(c,x,y,width,height,format,type,dstData)
     {c.readPixels(x,y,width,height,format,type,dstData);return 0}
    function renderbuffer_storage(c,target,internalformat,width,height)
     {c.renderbufferStorage(target,internalformat,width,height);return 0}
    function renderbuffer_storage_multisamp
     (c,target,samples,internalformat,width,height)
     {c.renderbufferStorageMultisample
       (target,samples,internalformat,width,height);
      return 0}
    function resume_transform_feedback(c)
     {c.resumeTransformFeedback();return 0}
    function sample_coverage(c,value,invert)
     {c.sampleCoverage(value,! ! invert);return 0}
    function sampler_parameterf(c,sampler,pname,param)
     {c.samplerParameterf(sampler,pname,param);return 0}
    function sampler_parameteri(c,sampler,pname,param)
     {c.samplerParameteri(sampler,pname,param);return 0}
    function scissor(c,x,y,width,height){c.scissor(x,y,width,height);return 0}
    function shader_source(c,shader,source)
     {c.shaderSource(shader,source);return 0}
    function stencil_func(c,func,ref,mask)
     {c.stencilFunc(func,ref,mask);return 0}
    function stencil_func_separate(c,face,func,ref,mask)
     {c.stencilFuncSeparate(face,func,ref,mask);return 0}
    function stencil_mask(c,mask){c.stencilMask(mask);return 0}
    function stencil_mask_separate(c,face,mask)
     {c.stencilMaskSeparate(face,mask);return 0}
    function stencil_op(c,fail,zfail,zpass)
     {c.stencilOp(fail,zfail,zpass);return 0}
    function stencil_op_separate(c,face,fail,zfail,zpass)
     {c.stencilOpSeparate(face,fail,zfail,zpass);return 0}
    function tex_image2d
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      border,
      format,
      type,
      srcData,
      srcOffset)
     {c.texImage2D
       (target,
        level,
        internalformat,
        width,
        height,
        border,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_image2d_of_source
     (c,target,level,internalformat,width,height,border,format,type,source)
     {c.texImage2D
       (target,level,internalformat,width,height,border,format,type,source);
      return 0}
    function tex_image2d_of_pixel_unpack
     (c,target,level,internalformat,width,height,border,format,type,pboOffset)
     {c.texImage2D
       (target,level,internalformat,width,height,border,format,type,pboOffset);
      return 0}
    function tex_image3d
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      srcData,
      srcOffset)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_image3d_of_source
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      source)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        source);
      return 0}
    function tex_image3d_of_pixel_unpack
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      pboOffset)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        pboOffset);
      return 0}
    function tex_parameterf(c,target,pname,param)
     {c.texParameterf(target,pname,param);return 0}
    function tex_parameteri(c,target,pname,param)
     {c.texParameteri(target,pname,param);return 0}
    function tex_storage2d(c,target,levels,internalformat,width,height)
     {c.texStorage2D(target,levels,internalformat,width,height);return 0}
    function tex_storage3d(c,target,levels,internalformat,width,height,depth)
     {c.texStorage3D(target,levels,internalformat,width,height,depth);
      return 0}
    function tex_sub_image2d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      width,
      height,
      format,
      type,
      srcData,
      srcOffset)
     {c.texSubImage2D
       (target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_sub_image2d_of_source
     (c,target,level,xoffset,yoffset,width,height,format,type,source)
     {c.texSubImage2D
       (target,level,xoffset,yoffset,width,height,format,type,source);
      return 0}
    function tex_sub_image2d_of_pixel_unpac
     (c,target,level,xoffset,yoffset,width,height,format,type,pboOffset)
     {c.texSubImage2D
       (target,level,xoffset,yoffset,width,height,format,type,pboOffset);
      return 0}
    function tex_sub_image3d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      srcData)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        srcData);
      return 0}
    function tex_sub_image3d_of_source
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      source)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        source);
      return 0}
    function tex_sub_image3d_of_pixel_unpac
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      pboOffset)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        pboOffset);
      return 0}
    function transform_feedback_varyings(c,program,varyings,bufferMode)
     {c.transformFeedbackVaryings
       (program,caml_list_to_js_array(varyings),bufferMode);
      return 0}
    function uniform1f(c,location,x){c.uniform1f(location,x);return 0}
    function uniform1fv(c,location,data){c.uniform1fv(location,data);return 0}
    function uniform1i(c,location,x){c.uniform1i(location,x);return 0}
    function uniform1iv(c,location,data){c.uniform1iv(location,data);return 0}
    function uniform1ui(c,location,v0){c.uniform1ui(location,v0);return 0}
    function uniform1uiv(c,location,data)
     {c.uniform1uiv(location,data);return 0}
    function uniform2f(c,location,x,y){c.uniform2f(location,x,y);return 0}
    function uniform2fv(c,location,data){c.uniform2fv(location,data);return 0}
    function uniform2i(c,location,x,y){c.uniform2i(location,x,y);return 0}
    function uniform2iv(c,location,data){c.uniform2iv(location,data);return 0}
    function uniform2ui(c,location,v0,v1)
     {c.uniform2ui(location,v0,v1);return 0}
    function uniform2uiv(c,location,data)
     {c.uniform2uiv(location,data);return 0}
    function uniform3f(c,location,x,y,z){c.uniform3f(location,x,y,z);return 0}
    function uniform3fv(c,location,data){c.uniform3fv(location,data);return 0}
    function uniform3i(c,location,x,y,z){c.uniform3i(location,x,y,z);return 0}
    function uniform3iv(c,location,data){c.uniform3iv(location,data);return 0}
    function uniform3ui(c,location,v0,v1,v2)
     {c.uniform3ui(location,v0,v1,v2);return 0}
    function uniform3uiv(c,location,data)
     {c.uniform3uiv(location,data);return 0}
    function uniform4f(c,location,x,y,z,w)
     {c.uniform4f(location,x,y,z,w);return 0}
    function uniform4fv(c,location,data){c.uniform4fv(location,data);return 0}
    function uniform4i(c,location,x,y,z,w)
     {c.uniform4i(location,x,y,z,w);return 0}
    function uniform4iv(c,location,data){c.uniform4iv(location,data);return 0}
    function uniform4ui(c,location,v0,v1,v2,v3)
     {c.uniform4ui(location,v0,v1,v2,v3);return 0}
    function uniform4uiv(c,location,data)
     {c.uniform4uiv(location,data);return 0}
    function uniform_block_binding
     (c,program,uniformBlockIndex,uniformBlockBinding)
     {c.uniformBlockBinding(program,uniformBlockIndex,uniformBlockBinding);
      return 0}
    function uniform_matrix2fv(c,location,transpose,data)
     {c.uniformMatrix2fv(location,! ! transpose,data);return 0}
    function uniform_matrix2x3fv(c,location,transpose,data)
     {c.uniformMatrix2x3fv(location,! ! transpose,data);return 0}
    function uniform_matrix2x4fv(c,location,transpose,data)
     {c.uniformMatrix2x4fv(location,! ! transpose,data);return 0}
    function uniform_matrix3fv(c,location,transpose,data)
     {c.uniformMatrix3fv(location,! ! transpose,data);return 0}
    function uniform_matrix3x2fv(c,location,transpose,data)
     {c.uniformMatrix3x2fv(location,! ! transpose,data);return 0}
    function uniform_matrix3x4fv(c,location,transpose,data)
     {c.uniformMatrix3x4fv(location,! ! transpose,data);return 0}
    function uniform_matrix4fv(c,location,transpose,data)
     {c.uniformMatrix4fv(location,! ! transpose,data);return 0}
    function uniform_matrix4x2fv(c,location,transpose,data)
     {c.uniformMatrix4x2fv(location,! ! transpose,data);return 0}
    function uniform_matrix4x3fv(c,location,transpose,data)
     {c.uniformMatrix4x3fv(location,! ! transpose,data);return 0}
    function use_program(c,program){c.useProgram(program);return 0}
    function validate_program(c,program){c.validateProgram(program);return 0}
    function vertex_attrib1f(c,index,x){c.vertexAttrib1f(index,x);return 0}
    function vertex_attrib1fv(c,index,values)
     {c.vertexAttrib1fv(index,values);return 0}
    function vertex_attrib2f(c,index,x,y)
     {c.vertexAttrib2f(index,x,y);return 0}
    function vertex_attrib2fv(c,index,values)
     {c.vertexAttrib2fv(index,values);return 0}
    function vertex_attrib3f(c,index,x,y,z)
     {c.vertexAttrib3f(index,x,y,z);return 0}
    function vertex_attrib3fv(c,index,values)
     {c.vertexAttrib3fv(index,values);return 0}
    function vertex_attrib4f(c,index,x,y,z,w)
     {c.vertexAttrib4f(index,x,y,z,w);return 0}
    function vertex_attrib4fv(c,index,values)
     {c.vertexAttrib4fv(index,values);return 0}
    function vertex_attrib_divisor(c,index,divisor)
     {c.vertexAttribDivisor(index,divisor);return 0}
    function vertex_attrib_i4i(c,index,x,y,z,w)
     {c.vertexAttribI4i(index,x,y,z,w);return 0}
    function vertex_attrib_i4iv(c,index,values)
     {c.vertexAttribI4iv(index,values);return 0}
    function vertex_attrib_i4ui(c,index,x,y,z,w)
     {c.vertexAttribI4ui(index,x,y,z,w);return 0}
    function vertex_attrib_i4uiv(c,index,values)
     {c.vertexAttribI4uiv(index,values);return 0}
    function vertex_attrib_ipointer(c,index,size,type,stride,offset)
     {c.vertexAttribIPointer(index,size,type,stride,offset);return 0}
    function vertex_attrib_pointer(c,index,size,type,normalized,stride,offset)
     {c.vertexAttribPointer(index,size,type,! ! normalized,stride,offset);
      return 0}
    function viewport(c,x,y,width,height)
     {c.viewport(x,y,width,height);return 0}
    function wait_sync(c,sync,flags,timeout)
     {c.waitSync(sync,flags,timeout);return 0}
    var
     gl1ctx=target.WebGLRenderingContext,
     depth_buffer_bit=caml_call2(Int[2],gl1ctx,cst_DEPTH_BUFFER_BIT),
     stencil_buffer_bit=caml_call2(Int[2],gl1ctx,cst_STENCIL_BUFFER_BIT),
     color_buffer_bit=caml_call2(Int[2],gl1ctx,cst_COLOR_BUFFER_BIT),
     points=caml_call2(Int[2],gl1ctx,cst_POINTS),
     lines=caml_call2(Int[2],gl1ctx,cst_LINES),
     line_loop=caml_call2(Int[2],gl1ctx,cst_LINE_LOOP),
     line_strip=caml_call2(Int[2],gl1ctx,cst_LINE_STRIP),
     triangles=caml_call2(Int[2],gl1ctx,cst_TRIANGLES),
     triangle_strip=caml_call2(Int[2],gl1ctx,cst_TRIANGLE_STRIP),
     triangle_fan=caml_call2(Int[2],gl1ctx,cst_TRIANGLE_FAN),
     zero=caml_call2(Int[2],gl1ctx,cst_ZERO),
     one=caml_call2(Int[2],gl1ctx,cst_ONE),
     src_color=caml_call2(Int[2],gl1ctx,cst_SRC_COLOR),
     one_minus_src_color=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_SRC_COLOR),
     src_alpha=caml_call2(Int[2],gl1ctx,cst_SRC_ALPHA),
     one_minus_src_alpha=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_SRC_ALPHA),
     dst_alpha=caml_call2(Int[2],gl1ctx,cst_DST_ALPHA),
     one_minus_dst_alpha=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_DST_ALPHA),
     dst_color=caml_call2(Int[2],gl1ctx,cst_DST_COLOR),
     one_minus_dst_color=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_DST_COLOR),
     src_alpha_saturate=caml_call2(Int[2],gl1ctx,cst_SRC_ALPHA_SATURATE),
     func_add=caml_call2(Int[2],gl1ctx,cst_FUNC_ADD),
     blend_equation$0=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION),
     blend_equation_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION_RGB),
     blend_equation_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION_ALPHA),
     func_subtract=caml_call2(Int[2],gl1ctx,cst_FUNC_SUBTRACT),
     func_reverse_subtract=caml_call2(Int[2],gl1ctx,cst_FUNC_REVERSE_SUBTRACT),
     blend_dst_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_DST_RGB),
     blend_src_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_SRC_RGB),
     blend_dst_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_DST_ALPHA),
     blend_src_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_SRC_ALPHA),
     constant_color=caml_call2(Int[2],gl1ctx,cst_CONSTANT_COLOR),
     one_minus_constant_color=
      caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_CONSTANT_COLOR),
     constant_alpha=caml_call2(Int[2],gl1ctx,cst_CONSTANT_ALPHA),
     one_minus_constant_alpha=
      caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_CONSTANT_ALPHA),
     blend_color$0=caml_call2(Int[2],gl1ctx,cst_BLEND_COLOR),
     array_buffer$2=caml_call2(Int[2],gl1ctx,cst_ARRAY_BUFFER),
     element_array_buffer=caml_call2(Int[2],gl1ctx,cst_ELEMENT_ARRAY_BUFFER),
     array_buffer_binding=caml_call2(Int[2],gl1ctx,cst_ARRAY_BUFFER_BINDING),
     element_array_buffer_binding=
      caml_call2(Int[2],gl1ctx,cst_ELEMENT_ARRAY_BUFFER_BINDI),
     stream_draw=caml_call2(Int[2],gl1ctx,cst_STREAM_DRAW),
     static_draw=caml_call2(Int[2],gl1ctx,cst_STATIC_DRAW),
     dynamic_draw=caml_call2(Int[2],gl1ctx,cst_DYNAMIC_DRAW),
     buffer_size=caml_call2(Int[2],gl1ctx,cst_BUFFER_SIZE),
     buffer_usage=caml_call2(Int[2],gl1ctx,cst_BUFFER_USAGE),
     current_vertex_attrib=caml_call2(Int[2],gl1ctx,cst_CURRENT_VERTEX_ATTRIB),
     front=caml_call2(Int[2],gl1ctx,cst_FRONT),
     back$0=caml_call2(Int[2],gl1ctx,cst_BACK),
     front_and_back=caml_call2(Int[2],gl1ctx,cst_FRONT_AND_BACK),
     cull_face$0=caml_call2(Int[2],gl1ctx,cst_CULL_FACE),
     blend=caml_call2(Int[2],gl1ctx,cst_BLEND),
     dither=caml_call2(Int[2],gl1ctx,cst_DITHER),
     stencil_test=caml_call2(Int[2],gl1ctx,cst_STENCIL_TEST),
     depth_test=caml_call2(Int[2],gl1ctx,cst_DEPTH_TEST),
     scissor_test=caml_call2(Int[2],gl1ctx,cst_SCISSOR_TEST),
     polygon_offset_fill=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_FILL),
     sample_alpha_to_coverage=
      caml_call2(Int[2],gl1ctx,cst_SAMPLE_ALPHA_TO_COVERAGE),
     sample_coverage$0=caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE),
     no_error=caml_call2(Int[2],gl1ctx,cst_NO_ERROR),
     invalid_enum=caml_call2(Int[2],gl1ctx,cst_INVALID_ENUM),
     invalid_value=caml_call2(Int[2],gl1ctx,cst_INVALID_VALUE),
     invalid_operation=caml_call2(Int[2],gl1ctx,cst_INVALID_OPERATION),
     out_of_memory=caml_call2(Int[2],gl1ctx,cst_OUT_OF_MEMORY),
     cw=caml_call2(Int[2],gl1ctx,cst_CW),
     ccw=caml_call2(Int[2],gl1ctx,cst_CCW),
     line_width$1=caml_call2(Int[2],gl1ctx,cst_LINE_WIDTH),
     aliased_point_size_range=
      caml_call2(Int[2],gl1ctx,cst_ALIASED_POINT_SIZE_RANGE),
     aliased_line_width_range=
      caml_call2(Int[2],gl1ctx,cst_ALIASED_LINE_WIDTH_RANGE),
     cull_face_mode=caml_call2(Int[2],gl1ctx,cst_CULL_FACE_MODE),
     front_face$0=caml_call2(Int[2],gl1ctx,cst_FRONT_FACE),
     depth_range=caml_call2(Int[2],gl1ctx,cst_DEPTH_RANGE),
     depth_writemask=caml_call2(Int[2],gl1ctx,cst_DEPTH_WRITEMASK),
     depth_clear_value=caml_call2(Int[2],gl1ctx,cst_DEPTH_CLEAR_VALUE),
     depth_func$0=caml_call2(Int[2],gl1ctx,cst_DEPTH_FUNC),
     stencil_clear_value=caml_call2(Int[2],gl1ctx,cst_STENCIL_CLEAR_VALUE),
     stencil_func$0=caml_call2(Int[2],gl1ctx,cst_STENCIL_FUNC),
     stencil_fail=caml_call2(Int[2],gl1ctx,cst_STENCIL_FAIL),
     stencil_pass_depth_fail=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_PASS_DEPTH_FAIL),
     stencil_pass_depth_pass=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_PASS_DEPTH_PASS),
     stencil_ref=caml_call2(Int[2],gl1ctx,cst_STENCIL_REF),
     stencil_value_mask=caml_call2(Int[2],gl1ctx,cst_STENCIL_VALUE_MASK),
     stencil_writemask=caml_call2(Int[2],gl1ctx,cst_STENCIL_WRITEMASK),
     stencil_back_func=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_FUNC),
     stencil_back_fail=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_FAIL),
     stencil_back_pass_depth_fail=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_PASS_DEPTH_FA),
     stencil_back_pass_depth_pass=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_PASS_DEPTH_PA),
     stencil_back_ref=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_REF),
     stencil_back_value_mask=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_VALUE_MASK),
     stencil_back_writemask=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_WRITEMASK),
     viewport$0=caml_call2(Int[2],gl1ctx,cst_VIEWPORT),
     scissor_box=caml_call2(Int[2],gl1ctx,cst_SCISSOR_BOX),
     color_clear_value=caml_call2(Int[2],gl1ctx,cst_COLOR_CLEAR_VALUE),
     color_writemask=caml_call2(Int[2],gl1ctx,cst_COLOR_WRITEMASK),
     unpack_alignment=caml_call2(Int[2],gl1ctx,cst_UNPACK_ALIGNMENT),
     pack_alignment=caml_call2(Int[2],gl1ctx,cst_PACK_ALIGNMENT),
     max_texture_size=caml_call2(Int[2],gl1ctx,cst_MAX_TEXTURE_SIZE),
     max_viewport_dims=caml_call2(Int[2],gl1ctx,cst_MAX_VIEWPORT_DIMS),
     subpixel_bits=caml_call2(Int[2],gl1ctx,cst_SUBPIXEL_BITS),
     red_bits=caml_call2(Int[2],gl1ctx,cst_RED_BITS),
     green_bits=caml_call2(Int[2],gl1ctx,cst_GREEN_BITS),
     blue_bits=caml_call2(Int[2],gl1ctx,cst_BLUE_BITS),
     alpha_bits=caml_call2(Int[2],gl1ctx,cst_ALPHA_BITS),
     depth_bits=caml_call2(Int[2],gl1ctx,cst_DEPTH_BITS),
     stencil_bits=caml_call2(Int[2],gl1ctx,cst_STENCIL_BITS),
     polygon_offset_units=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_UNITS),
     polygon_offset_factor=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_FACTOR),
     texture_binding_2d=caml_call2(Int[2],gl1ctx,cst_TEXTURE_BINDING_2D),
     sample_buffers=caml_call2(Int[2],gl1ctx,cst_SAMPLE_BUFFERS),
     samples=caml_call2(Int[2],gl1ctx,cst_SAMPLES),
     sample_coverage_value=caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE_VALUE),
     sample_coverage_invert=
      caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE_INVERT),
     compressed_texture_formats=
      caml_call2(Int[2],gl1ctx,cst_COMPRESSED_TEXTURE_FORMATS),
     dont_care=caml_call2(Int[2],gl1ctx,cst_DONT_CARE),
     fastest=caml_call2(Int[2],gl1ctx,cst_FASTEST),
     nicest=caml_call2(Int[2],gl1ctx,cst_NICEST),
     generate_mipmap_hint=caml_call2(Int[2],gl1ctx,cst_GENERATE_MIPMAP_HINT),
     byte$0=caml_call2(Int[2],gl1ctx,cst_BYTE),
     unsigned_byte=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_BYTE),
     short$0=caml_call2(Int[2],gl1ctx,cst_SHORT),
     unsigned_short=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT),
     int$3=caml_call2(Int[2],gl1ctx,cst_INT),
     unsigned_int=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_INT),
     float$2=caml_call2(Int[2],gl1ctx,cst_FLOAT),
     depth_component=caml_call2(Int[2],gl1ctx,cst_DEPTH_COMPONENT),
     alpha$0=caml_call2(Int[2],gl1ctx,cst_ALPHA),
     rgb=caml_call2(Int[2],gl1ctx,cst_RGB),
     rgba=caml_call2(Int[2],gl1ctx,cst_RGBA),
     luminance=caml_call2(Int[2],gl1ctx,cst_LUMINANCE),
     luminance_alpha=caml_call2(Int[2],gl1ctx,cst_LUMINANCE_ALPHA),
     unsigned_short_4_4_4_4=
      caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_4_4_4_4),
     unsigned_short_5_5_5_1=
      caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_5_5_5_1),
     unsigned_short_5_6_5=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_5_6_5),
     fragment_shader=caml_call2(Int[2],gl1ctx,cst_FRAGMENT_SHADER),
     vertex_shader=caml_call2(Int[2],gl1ctx,cst_VERTEX_SHADER),
     max_vertex_attribs=caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_ATTRIBS),
     max_vertex_uniform_vectors=
      caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_UNIFORM_VECTORS),
     max_varying_vectors=caml_call2(Int[2],gl1ctx,cst_MAX_VARYING_VECTORS),
     max_combined_texture_image_uni=
      caml_call2(Int[2],gl1ctx,cst_MAX_COMBINED_TEXTURE_IMAGE),
     max_vertex_texture_image_units=
      caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_TEXTURE_IMAGE_U),
     max_texture_image_units=
      caml_call2(Int[2],gl1ctx,cst_MAX_TEXTURE_IMAGE_UNITS),
     max_fragment_uniform_vectors=
      caml_call2(Int[2],gl1ctx,cst_MAX_FRAGMENT_UNIFORM_VECTO),
     shader_type=caml_call2(Int[2],gl1ctx,cst_SHADER_TYPE),
     delete_status=caml_call2(Int[2],gl1ctx,cst_DELETE_STATUS),
     link_status=caml_call2(Int[2],gl1ctx,cst_LINK_STATUS),
     validate_status=caml_call2(Int[2],gl1ctx,cst_VALIDATE_STATUS),
     attached_shaders=caml_call2(Int[2],gl1ctx,cst_ATTACHED_SHADERS),
     active_uniforms=caml_call2(Int[2],gl1ctx,cst_ACTIVE_UNIFORMS),
     active_attributes=caml_call2(Int[2],gl1ctx,cst_ACTIVE_ATTRIBUTES),
     shading_language_version=
      caml_call2(Int[2],gl1ctx,cst_SHADING_LANGUAGE_VERSION),
     current_program=caml_call2(Int[2],gl1ctx,cst_CURRENT_PROGRAM),
     never=caml_call2(Int[2],gl1ctx,cst_NEVER),
     less=caml_call2(Int[2],gl1ctx,cst_LESS),
     equal$0=caml_call2(Int[2],gl1ctx,cst_EQUAL),
     lequal=caml_call2(Int[2],gl1ctx,cst_LEQUAL),
     greater=caml_call2(Int[2],gl1ctx,cst_GREATER),
     notequal=caml_call2(Int[2],gl1ctx,cst_NOTEQUAL),
     gequal=caml_call2(Int[2],gl1ctx,cst_GEQUAL),
     always=caml_call2(Int[2],gl1ctx,cst_ALWAYS),
     keep=caml_call2(Int[2],gl1ctx,cst_KEEP),
     replace=caml_call2(Int[2],gl1ctx,cst_REPLACE),
     incr=caml_call2(Int[2],gl1ctx,cst_INCR),
     decr=caml_call2(Int[2],gl1ctx,cst_DECR),
     invert=caml_call2(Int[2],gl1ctx,cst_INVERT),
     incr_wrap=caml_call2(Int[2],gl1ctx,cst_INCR_WRAP),
     decr_wrap=caml_call2(Int[2],gl1ctx,cst_DECR_WRAP),
     vendor=caml_call2(Int[2],gl1ctx,cst_VENDOR),
     renderer=caml_call2(Int[2],gl1ctx,cst_RENDERER),
     version=caml_call2(Int[2],gl1ctx,cst_VERSION),
     nearest=caml_call2(Int[2],gl1ctx,cst_NEAREST),
     linear=caml_call2(Int[2],gl1ctx,cst_LINEAR),
     nearest_mipmap_nearest=
      caml_call2(Int[2],gl1ctx,cst_NEAREST_MIPMAP_NEAREST),
     linear_mipmap_nearest=caml_call2(Int[2],gl1ctx,cst_LINEAR_MIPMAP_NEAREST),
     nearest_mipmap_linear=caml_call2(Int[2],gl1ctx,cst_NEAREST_MIPMAP_LINEAR),
     linear_mipmap_linear=caml_call2(Int[2],gl1ctx,cst_LINEAR_MIPMAP_LINEAR),
     texture_mag_filter=caml_call2(Int[2],gl1ctx,cst_TEXTURE_MAG_FILTER),
     texture_min_filter=caml_call2(Int[2],gl1ctx,cst_TEXTURE_MIN_FILTER),
     texture_wrap_s=caml_call2(Int[2],gl1ctx,cst_TEXTURE_WRAP_S),
     texture_wrap_t=caml_call2(Int[2],gl1ctx,cst_TEXTURE_WRAP_T),
     texture_2d=caml_call2(Int[2],gl1ctx,cst_TEXTURE_2D),
     texture=caml_call2(Int[2],gl1ctx,cst_TEXTURE),
     texture_cube_map=caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP),
     texture_binding_cube_map=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_BINDING_CUBE_MAP),
     texture_cube_map_positive_x=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_),
     texture_cube_map_negative_x=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_),
     texture_cube_map_positive_y=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_$0),
     texture_cube_map_negative_y=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_$0),
     texture_cube_map_positive_z=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_$1),
     texture_cube_map_negative_z=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_$1),
     max_cube_map_texture_size=
      caml_call2(Int[2],gl1ctx,cst_MAX_CUBE_MAP_TEXTURE_SIZE),
     texture0=caml_call2(Int[2],gl1ctx,cst_TEXTURE0),
     texture1=caml_call2(Int[2],gl1ctx,cst_TEXTURE1),
     texture2=caml_call2(Int[2],gl1ctx,cst_TEXTURE2),
     texture3=caml_call2(Int[2],gl1ctx,cst_TEXTURE3),
     texture4=caml_call2(Int[2],gl1ctx,cst_TEXTURE4),
     texture5=caml_call2(Int[2],gl1ctx,cst_TEXTURE5),
     texture6=caml_call2(Int[2],gl1ctx,cst_TEXTURE6),
     texture7=caml_call2(Int[2],gl1ctx,cst_TEXTURE7),
     texture8=caml_call2(Int[2],gl1ctx,cst_TEXTURE8),
     texture9=caml_call2(Int[2],gl1ctx,cst_TEXTURE9),
     texture10=caml_call2(Int[2],gl1ctx,cst_TEXTURE10),
     texture11=caml_call2(Int[2],gl1ctx,cst_TEXTURE11),
     texture12=caml_call2(Int[2],gl1ctx,cst_TEXTURE12),
     texture13=caml_call2(Int[2],gl1ctx,cst_TEXTURE13),
     texture14=caml_call2(Int[2],gl1ctx,cst_TEXTURE14),
     texture15=caml_call2(Int[2],gl1ctx,cst_TEXTURE15),
     texture16=caml_call2(Int[2],gl1ctx,cst_TEXTURE16),
     texture17=caml_call2(Int[2],gl1ctx,cst_TEXTURE17),
     texture18=caml_call2(Int[2],gl1ctx,cst_TEXTURE18),
     texture19=caml_call2(Int[2],gl1ctx,cst_TEXTURE19),
     texture20=caml_call2(Int[2],gl1ctx,cst_TEXTURE20),
     texture21=caml_call2(Int[2],gl1ctx,cst_TEXTURE21),
     texture22=caml_call2(Int[2],gl1ctx,cst_TEXTURE22),
     texture23=caml_call2(Int[2],gl1ctx,cst_TEXTURE23),
     texture24=caml_call2(Int[2],gl1ctx,cst_TEXTURE24),
     texture25=caml_call2(Int[2],gl1ctx,cst_TEXTURE25),
     texture26=caml_call2(Int[2],gl1ctx,cst_TEXTURE26),
     texture27=caml_call2(Int[2],gl1ctx,cst_TEXTURE27),
     texture28=caml_call2(Int[2],gl1ctx,cst_TEXTURE28),
     texture29=caml_call2(Int[2],gl1ctx,cst_TEXTURE29),
     texture30=caml_call2(Int[2],gl1ctx,cst_TEXTURE30),
     texture31=caml_call2(Int[2],gl1ctx,cst_TEXTURE31),
     active_texture$0=caml_call2(Int[2],gl1ctx,cst_ACTIVE_TEXTURE),
     repeat$1=caml_call2(Int[2],gl1ctx,cst_REPEAT),
     clamp_to_edge=caml_call2(Int[2],gl1ctx,cst_CLAMP_TO_EDGE),
     mirrored_repeat=caml_call2(Int[2],gl1ctx,cst_MIRRORED_REPEAT),
     float_vec2=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC2),
     float_vec3=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC3),
     float_vec4=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC4),
     int_vec2=caml_call2(Int[2],gl1ctx,cst_INT_VEC2),
     int_vec3=caml_call2(Int[2],gl1ctx,cst_INT_VEC3),
     int_vec4=caml_call2(Int[2],gl1ctx,cst_INT_VEC4),
     bool$1=caml_call2(Int[2],gl1ctx,cst_BOOL),
     bool_vec2=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC2),
     bool_vec3=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC3),
     bool_vec4=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC4),
     float_mat2=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT2),
     float_mat3=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT3),
     float_mat4=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT4),
     sampler_2d=caml_call2(Int[2],gl1ctx,cst_SAMPLER_2D),
     sampler_cube=caml_call2(Int[2],gl1ctx,cst_SAMPLER_CUBE),
     vertex_attrib_array_enabled=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_ENABLE),
     vertex_attrib_array_size=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_SIZE),
     vertex_attrib_array_stride=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_STRIDE),
     vertex_attrib_array_type=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_TYPE),
     vertex_attrib_array_normalized=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_NORMAL),
     vertex_attrib_array_pointer=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_POINTE),
     vertex_attrib_array_buffer_bin=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_BUFFER),
     implementation_color_read_type=
      caml_call2(Int[2],gl1ctx,cst_IMPLEMENTATION_COLOR_READ_),
     implementation_color_read_form=
      caml_call2(Int[2],gl1ctx,cst_IMPLEMENTATION_COLOR_READ_$0),
     compile_status=caml_call2(Int[2],gl1ctx,cst_COMPILE_STATUS),
     low_float=caml_call2(Int[2],gl1ctx,cst_LOW_FLOAT),
     medium_float=caml_call2(Int[2],gl1ctx,cst_MEDIUM_FLOAT),
     high_float=caml_call2(Int[2],gl1ctx,cst_HIGH_FLOAT),
     low_int=caml_call2(Int[2],gl1ctx,cst_LOW_INT),
     medium_int=caml_call2(Int[2],gl1ctx,cst_MEDIUM_INT),
     high_int=caml_call2(Int[2],gl1ctx,cst_HIGH_INT),
     framebuffer=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER),
     renderbuffer=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER),
     rgba4=caml_call2(Int[2],gl1ctx,cst_RGBA4),
     rgb5_a1=caml_call2(Int[2],gl1ctx,cst_RGB5_A1),
     rgb565=caml_call2(Int[2],gl1ctx,cst_RGB565),
     depth_component16=caml_call2(Int[2],gl1ctx,cst_DEPTH_COMPONENT16),
     stencil_index8=caml_call2(Int[2],gl1ctx,cst_STENCIL_INDEX8),
     depth_stencil=caml_call2(Int[2],gl1ctx,cst_DEPTH_STENCIL),
     renderbuffer_width=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_WIDTH),
     renderbuffer_height=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_HEIGHT),
     renderbuffer_internal_format=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_INTERNAL_FORM),
     renderbuffer_red_size=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_RED_SIZE),
     renderbuffer_green_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_GREEN_SIZE),
     renderbuffer_blue_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_BLUE_SIZE),
     renderbuffer_alpha_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_ALPHA_SIZE),
     renderbuffer_depth_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_DEPTH_SIZE),
     renderbuffer_stencil_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_STENCIL_SIZE),
     framebuffer_attachment_object_=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_OBJ),
     framebuffer_attachment_object_$0=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_OBJ$0),
     framebuffer_attachment_texture=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX),
     framebuffer_attachment_texture$0=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX$0),
     color_attachment0=caml_call2(Int[2],gl1ctx,cst_COLOR_ATTACHMENT0),
     depth_attachment=caml_call2(Int[2],gl1ctx,cst_DEPTH_ATTACHMENT),
     stencil_attachment=caml_call2(Int[2],gl1ctx,cst_STENCIL_ATTACHMENT),
     depth_stencil_attachment=
      caml_call2(Int[2],gl1ctx,cst_DEPTH_STENCIL_ATTACHMENT),
     none$0=caml_call2(Int[2],gl1ctx,cst_NONE),
     framebuffer_complete=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_COMPLETE),
     framebuffer_incomplete_attachm=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_ATT),
     framebuffer_incomplete_missing=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_MIS),
     framebuffer_incomplete_dimensi=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_DIM),
     framebuffer_unsupported=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_UNSUPPORTED),
     framebuffer_binding=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_BINDING),
     renderbuffer_binding=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_BINDING),
     max_renderbuffer_size=caml_call2(Int[2],gl1ctx,cst_MAX_RENDERBUFFER_SIZE),
     invalid_framebuffer_operation=
      caml_call2(Int[2],gl1ctx,cst_INVALID_FRAMEBUFFER_OPERAT),
     unpack_flip_y_webgl=caml_call2(Int[2],gl1ctx,cst_UNPACK_FLIP_Y_WEBGL),
     unpack_premultiply_alpha_webgl=
      caml_call2(Int[2],gl1ctx,cst_UNPACK_PREMULTIPLY_ALPHA_W),
     context_lost_webgl=caml_call2(Int[2],gl1ctx,cst_CONTEXT_LOST_WEBGL),
     unpack_colorspace_conversion_w=
      caml_call2(Int[2],gl1ctx,cst_UNPACK_COLORSPACE_CONVERSI),
     browser_default_webgl=caml_call2(Int[2],gl1ctx,cst_BROWSER_DEFAULT_WEBGL),
     gl2ctx=target.WebGL2RenderingContext,
     _bu_=is_none(gl2ctx)?function(param,_dM_){return 0}:Int[2],
     read_buffer$0=caml_call2(_bu_,gl2ctx,cst_READ_BUFFER),
     unpack_row_length=caml_call2(_bu_,gl2ctx,cst_UNPACK_ROW_LENGTH),
     unpack_skip_rows=caml_call2(_bu_,gl2ctx,cst_UNPACK_SKIP_ROWS),
     unpack_skip_pixels=caml_call2(_bu_,gl2ctx,cst_UNPACK_SKIP_PIXELS),
     pack_row_length=caml_call2(_bu_,gl2ctx,cst_PACK_ROW_LENGTH),
     pack_skip_rows=caml_call2(_bu_,gl2ctx,cst_PACK_SKIP_ROWS),
     pack_skip_pixels=caml_call2(_bu_,gl2ctx,cst_PACK_SKIP_PIXELS),
     color$2=caml_call2(_bu_,gl2ctx,cst_COLOR),
     depth$0=caml_call2(_bu_,gl2ctx,cst_DEPTH),
     stencil$0=caml_call2(_bu_,gl2ctx,cst_STENCIL),
     red=caml_call2(_bu_,gl2ctx,cst_RED),
     rgb8=caml_call2(_bu_,gl2ctx,cst_RGB8),
     rgba8=caml_call2(_bu_,gl2ctx,cst_RGBA8),
     rgb10_a2=caml_call2(_bu_,gl2ctx,cst_RGB10_A2),
     texture_binding_3d=caml_call2(_bu_,gl2ctx,cst_TEXTURE_BINDING_3D),
     unpack_skip_images=caml_call2(_bu_,gl2ctx,cst_UNPACK_SKIP_IMAGES),
     unpack_image_height=caml_call2(_bu_,gl2ctx,cst_UNPACK_IMAGE_HEIGHT),
     texture_3d=caml_call2(_bu_,gl2ctx,cst_TEXTURE_3D),
     texture_wrap_r=caml_call2(_bu_,gl2ctx,cst_TEXTURE_WRAP_R),
     max_3d_texture_size=caml_call2(_bu_,gl2ctx,cst_MAX_3D_TEXTURE_SIZE),
     unsigned_int_2_10_10_10_rev=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_2_10_10_10_RE),
     max_elements_vertices=caml_call2(_bu_,gl2ctx,cst_MAX_ELEMENTS_VERTICES),
     max_elements_indices=caml_call2(_bu_,gl2ctx,cst_MAX_ELEMENTS_INDICES),
     texture_min_lod=caml_call2(_bu_,gl2ctx,cst_TEXTURE_MIN_LOD),
     texture_max_lod=caml_call2(_bu_,gl2ctx,cst_TEXTURE_MAX_LOD),
     texture_base_level=caml_call2(_bu_,gl2ctx,cst_TEXTURE_BASE_LEVEL),
     texture_max_level=caml_call2(_bu_,gl2ctx,cst_TEXTURE_MAX_LEVEL),
     min$1=caml_call2(_bu_,gl2ctx,cst_MIN),
     max$2=caml_call2(_bu_,gl2ctx,cst_MAX),
     depth_component24=caml_call2(_bu_,gl2ctx,cst_DEPTH_COMPONENT24),
     max_texture_lod_bias=caml_call2(_bu_,gl2ctx,cst_MAX_TEXTURE_LOD_BIAS),
     texture_compare_mode=caml_call2(_bu_,gl2ctx,cst_TEXTURE_COMPARE_MODE),
     texture_compare_func=caml_call2(_bu_,gl2ctx,cst_TEXTURE_COMPARE_FUNC),
     current_query=caml_call2(_bu_,gl2ctx,cst_CURRENT_QUERY),
     query_result=caml_call2(_bu_,gl2ctx,cst_QUERY_RESULT),
     query_result_available=caml_call2(_bu_,gl2ctx,cst_QUERY_RESULT_AVAILABLE),
     stream_read=caml_call2(_bu_,gl2ctx,cst_STREAM_READ),
     stream_copy=caml_call2(_bu_,gl2ctx,cst_STREAM_COPY),
     static_read=caml_call2(_bu_,gl2ctx,cst_STATIC_READ),
     static_copy=caml_call2(_bu_,gl2ctx,cst_STATIC_COPY),
     dynamic_read=caml_call2(_bu_,gl2ctx,cst_DYNAMIC_READ),
     dynamic_copy=caml_call2(_bu_,gl2ctx,cst_DYNAMIC_COPY),
     max_draw_buffers=caml_call2(_bu_,gl2ctx,cst_MAX_DRAW_BUFFERS),
     draw_buffer0=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER0),
     draw_buffer1=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER1),
     draw_buffer2=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER2),
     draw_buffer3=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER3),
     draw_buffer4=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER4),
     draw_buffer5=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER5),
     draw_buffer6=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER6),
     draw_buffer7=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER7),
     draw_buffer8=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER8),
     draw_buffer9=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER9),
     draw_buffer10=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER10),
     draw_buffer11=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER11),
     draw_buffer12=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER12),
     draw_buffer13=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER13),
     draw_buffer14=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER14),
     draw_buffer15=caml_call2(_bu_,gl2ctx,cst_DRAW_BUFFER15),
     max_fragment_uniform_component=
      caml_call2(_bu_,gl2ctx,cst_MAX_FRAGMENT_UNIFORM_COMPO),
     max_vertex_uniform_components=
      caml_call2(_bu_,gl2ctx,cst_MAX_VERTEX_UNIFORM_COMPONE),
     sampler_3d=caml_call2(_bu_,gl2ctx,cst_SAMPLER_3D),
     sampler_2d_shadow=caml_call2(_bu_,gl2ctx,cst_SAMPLER_2D_SHADOW),
     fragment_shader_derivative_hin=
      caml_call2(_bu_,gl2ctx,cst_FRAGMENT_SHADER_DERIVATIVE),
     pixel_pack_buffer=caml_call2(_bu_,gl2ctx,cst_PIXEL_PACK_BUFFER),
     pixel_unpack_buffer=caml_call2(_bu_,gl2ctx,cst_PIXEL_UNPACK_BUFFER),
     pixel_pack_buffer_binding=
      caml_call2(_bu_,gl2ctx,cst_PIXEL_PACK_BUFFER_BINDING),
     pixel_unpack_buffer_binding=
      caml_call2(_bu_,gl2ctx,cst_PIXEL_UNPACK_BUFFER_BINDIN),
     float_mat2x3=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT2x3),
     float_mat2x4=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT2x4),
     float_mat3x2=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT3x2),
     float_mat3x4=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT3x4),
     float_mat4x2=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT4x2),
     float_mat4x3=caml_call2(_bu_,gl2ctx,cst_FLOAT_MAT4x3),
     srgb=caml_call2(_bu_,gl2ctx,cst_SRGB),
     srgb8=caml_call2(_bu_,gl2ctx,cst_SRGB8),
     srgb8_alpha8=caml_call2(_bu_,gl2ctx,cst_SRGB8_ALPHA8),
     compare_ref_to_texture=caml_call2(_bu_,gl2ctx,cst_COMPARE_REF_TO_TEXTURE),
     rgba32f=caml_call2(_bu_,gl2ctx,cst_RGBA32F),
     rgb32f=caml_call2(_bu_,gl2ctx,cst_RGB32F),
     rgba16f=caml_call2(_bu_,gl2ctx,cst_RGBA16F),
     rgb16f=caml_call2(_bu_,gl2ctx,cst_RGB16F),
     vertex_attrib_array_integer=
      caml_call2(_bu_,gl2ctx,cst_VERTEX_ATTRIB_ARRAY_INTEGE),
     max_array_texture_layers=
      caml_call2(_bu_,gl2ctx,cst_MAX_ARRAY_TEXTURE_LAYERS),
     min_program_texel_offset=
      caml_call2(_bu_,gl2ctx,cst_MIN_PROGRAM_TEXEL_OFFSET),
     max_program_texel_offset=
      caml_call2(_bu_,gl2ctx,cst_MAX_PROGRAM_TEXEL_OFFSET),
     max_varying_components=caml_call2(_bu_,gl2ctx,cst_MAX_VARYING_COMPONENTS),
     texture_2d_array=caml_call2(_bu_,gl2ctx,cst_TEXTURE_2D_ARRAY),
     texture_binding_2d_array=
      caml_call2(_bu_,gl2ctx,cst_TEXTURE_BINDING_2D_ARRAY),
     r11f_g11f_b10f=caml_call2(_bu_,gl2ctx,cst_R11F_G11F_B10F),
     unsigned_int_10f_11f_11f_rev=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_10F_11F_11F_R),
     rgb9_e5=caml_call2(_bu_,gl2ctx,cst_RGB9_E5),
     unsigned_int_5_9_9_9_rev=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_5_9_9_9_REV),
     transform_feedback_buffer_mode=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_),
     max_transform_feedback_separat=
      caml_call2(_bu_,gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_SEP),
     transform_feedback_varyings$0=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_VARYING),
     transform_feedback_buffer_star=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$0),
     transform_feedback_buffer_size=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$1),
     transform_feedback_primitives_=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_PRIMITI),
     rasterizer_discard=caml_call2(_bu_,gl2ctx,cst_RASTERIZER_DISCARD),
     max_transform_feedback_interle=
      caml_call2(_bu_,gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_INT),
     max_transform_feedback_separat$0=
      caml_call2(_bu_,gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_SEP$0),
     interleaved_attribs=caml_call2(_bu_,gl2ctx,cst_INTERLEAVED_ATTRIBS),
     separate_attribs=caml_call2(_bu_,gl2ctx,cst_SEPARATE_ATTRIBS),
     transform_feedback_buffer=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER),
     transform_feedback_buffer_bind=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$2),
     rgba32ui=caml_call2(_bu_,gl2ctx,cst_RGBA32UI),
     rgb32ui=caml_call2(_bu_,gl2ctx,cst_RGB32UI),
     rgba16ui=caml_call2(_bu_,gl2ctx,cst_RGBA16UI),
     rgb16ui=caml_call2(_bu_,gl2ctx,cst_RGB16UI),
     rgba8ui=caml_call2(_bu_,gl2ctx,cst_RGBA8UI),
     rgb8ui=caml_call2(_bu_,gl2ctx,cst_RGB8UI),
     rgba32i=caml_call2(_bu_,gl2ctx,cst_RGBA32I),
     rgb32i=caml_call2(_bu_,gl2ctx,cst_RGB32I),
     rgba16i=caml_call2(_bu_,gl2ctx,cst_RGBA16I),
     rgb16i=caml_call2(_bu_,gl2ctx,cst_RGB16I),
     rgba8i=caml_call2(_bu_,gl2ctx,cst_RGBA8I),
     rgb8i=caml_call2(_bu_,gl2ctx,cst_RGB8I),
     red_integer=caml_call2(_bu_,gl2ctx,cst_RED_INTEGER),
     rgb_integer=caml_call2(_bu_,gl2ctx,cst_RGB_INTEGER),
     rgba_integer=caml_call2(_bu_,gl2ctx,cst_RGBA_INTEGER),
     sampler_2d_array=caml_call2(_bu_,gl2ctx,cst_SAMPLER_2D_ARRAY),
     sampler_2d_array_shadow=
      caml_call2(_bu_,gl2ctx,cst_SAMPLER_2D_ARRAY_SHADOW),
     sampler_cube_shadow=caml_call2(_bu_,gl2ctx,cst_SAMPLER_CUBE_SHADOW),
     unsigned_int_vec2=caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_VEC2),
     unsigned_int_vec3=caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_VEC3),
     unsigned_int_vec4=caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_VEC4),
     int_sampler_2d=caml_call2(_bu_,gl2ctx,cst_INT_SAMPLER_2D),
     int_sampler_3d=caml_call2(_bu_,gl2ctx,cst_INT_SAMPLER_3D),
     int_sampler_cube=caml_call2(_bu_,gl2ctx,cst_INT_SAMPLER_CUBE),
     int_sampler_2d_array=caml_call2(_bu_,gl2ctx,cst_INT_SAMPLER_2D_ARRAY),
     unsigned_int_sampler_2d=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_SAMPLER_2D),
     unsigned_int_sampler_3d=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_SAMPLER_3D),
     unsigned_int_sampler_cube=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_SAMPLER_CUBE),
     unsigned_int_sampler_2d_array=
      caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_SAMPLER_2D_AR),
     depth_component32f=caml_call2(_bu_,gl2ctx,cst_DEPTH_COMPONENT32F),
     depth32f_stencil8=caml_call2(_bu_,gl2ctx,cst_DEPTH32F_STENCIL8),
     float_32_unsigned_int_24_8_rev=
      caml_call2(_bu_,gl2ctx,cst_FLOAT_32_UNSIGNED_INT_24_8),
     framebuffer_attachment_color_e=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_COL),
     framebuffer_attachment_compone=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_COM),
     framebuffer_attachment_red_siz=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_RED),
     framebuffer_attachment_green_s=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_GRE),
     framebuffer_attachment_blue_si=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_BLU),
     framebuffer_attachment_alpha_s=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_ALP),
     framebuffer_attachment_depth_s=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_DEP),
     framebuffer_attachment_stencil=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_STE),
     framebuffer_default=caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_DEFAULT),
     unsigned_int_24_8=caml_call2(_bu_,gl2ctx,cst_UNSIGNED_INT_24_8),
     depth24_stencil8=caml_call2(_bu_,gl2ctx,cst_DEPTH24_STENCIL8),
     unsigned_normalized=caml_call2(_bu_,gl2ctx,cst_UNSIGNED_NORMALIZED),
     draw_framebuffer_binding=
      caml_call2(_bu_,gl2ctx,cst_DRAW_FRAMEBUFFER_BINDING),
     read_framebuffer=caml_call2(_bu_,gl2ctx,cst_READ_FRAMEBUFFER),
     draw_framebuffer=caml_call2(_bu_,gl2ctx,cst_DRAW_FRAMEBUFFER),
     read_framebuffer_binding=
      caml_call2(_bu_,gl2ctx,cst_READ_FRAMEBUFFER_BINDING),
     renderbuffer_samples=caml_call2(_bu_,gl2ctx,cst_RENDERBUFFER_SAMPLES),
     framebuffer_attachment_texture$1=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX$1),
     max_color_attachments=caml_call2(_bu_,gl2ctx,cst_MAX_COLOR_ATTACHMENTS),
     color_attachment1=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT1),
     color_attachment2=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT2),
     color_attachment3=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT3),
     color_attachment4=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT4),
     color_attachment5=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT5),
     color_attachment6=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT6),
     color_attachment7=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT7),
     color_attachment8=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT8),
     color_attachment9=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT9),
     color_attachment10=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT10),
     color_attachment11=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT11),
     color_attachment12=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT12),
     color_attachment13=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT13),
     color_attachment14=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT14),
     color_attachment15=caml_call2(_bu_,gl2ctx,cst_COLOR_ATTACHMENT15),
     framebuffer_incomplete_multisa=
      caml_call2(_bu_,gl2ctx,cst_FRAMEBUFFER_INCOMPLETE_MUL),
     max_samples=caml_call2(_bu_,gl2ctx,cst_MAX_SAMPLES),
     half_float=caml_call2(_bu_,gl2ctx,cst_HALF_FLOAT),
     rg=caml_call2(_bu_,gl2ctx,cst_RG),
     rg_integer=caml_call2(_bu_,gl2ctx,cst_RG_INTEGER),
     r8=caml_call2(_bu_,gl2ctx,cst_R8),
     rg8=caml_call2(_bu_,gl2ctx,cst_RG8),
     r16f=caml_call2(_bu_,gl2ctx,cst_R16F),
     r32f=caml_call2(_bu_,gl2ctx,cst_R32F),
     rg16f=caml_call2(_bu_,gl2ctx,cst_RG16F),
     rg32f=caml_call2(_bu_,gl2ctx,cst_RG32F),
     r8i=caml_call2(_bu_,gl2ctx,cst_R8I),
     r8ui=caml_call2(_bu_,gl2ctx,cst_R8UI),
     r16i=caml_call2(_bu_,gl2ctx,cst_R16I),
     r16ui=caml_call2(_bu_,gl2ctx,cst_R16UI),
     r32i=caml_call2(_bu_,gl2ctx,cst_R32I),
     r32ui=caml_call2(_bu_,gl2ctx,cst_R32UI),
     rg8i=caml_call2(_bu_,gl2ctx,cst_RG8I),
     rg8ui=caml_call2(_bu_,gl2ctx,cst_RG8UI),
     rg16i=caml_call2(_bu_,gl2ctx,cst_RG16I),
     rg16ui=caml_call2(_bu_,gl2ctx,cst_RG16UI),
     rg32i=caml_call2(_bu_,gl2ctx,cst_RG32I),
     rg32ui=caml_call2(_bu_,gl2ctx,cst_RG32UI),
     vertex_array_binding=caml_call2(_bu_,gl2ctx,cst_VERTEX_ARRAY_BINDING),
     r8_snorm=caml_call2(_bu_,gl2ctx,cst_R8_SNORM),
     rg8_snorm=caml_call2(_bu_,gl2ctx,cst_RG8_SNORM),
     rgb8_snorm=caml_call2(_bu_,gl2ctx,cst_RGB8_SNORM),
     rgba8_snorm=caml_call2(_bu_,gl2ctx,cst_RGBA8_SNORM),
     signed_normalized=caml_call2(_bu_,gl2ctx,cst_SIGNED_NORMALIZED),
     copy_read_buffer=caml_call2(_bu_,gl2ctx,cst_COPY_READ_BUFFER),
     copy_write_buffer=caml_call2(_bu_,gl2ctx,cst_COPY_WRITE_BUFFER),
     copy_read_buffer_binding=
      caml_call2(_bu_,gl2ctx,cst_COPY_READ_BUFFER_BINDING),
     copy_write_buffer_binding=
      caml_call2(_bu_,gl2ctx,cst_COPY_WRITE_BUFFER_BINDING),
     uniform_buffer=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BUFFER),
     uniform_buffer_binding=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BUFFER_BINDING),
     uniform_buffer_start=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BUFFER_START),
     uniform_buffer_size=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BUFFER_SIZE),
     max_vertex_uniform_blocks=
      caml_call2(_bu_,gl2ctx,cst_MAX_VERTEX_UNIFORM_BLOCKS),
     max_fragment_uniform_blocks=
      caml_call2(_bu_,gl2ctx,cst_MAX_FRAGMENT_UNIFORM_BLOCK),
     max_combined_uniform_blocks=
      caml_call2(_bu_,gl2ctx,cst_MAX_COMBINED_UNIFORM_BLOCK),
     max_uniform_buffer_bindings=
      caml_call2(_bu_,gl2ctx,cst_MAX_UNIFORM_BUFFER_BINDING),
     max_uniform_block_size=caml_call2(_bu_,gl2ctx,cst_MAX_UNIFORM_BLOCK_SIZE),
     max_combined_vertex_uniform_co=
      caml_call2(_bu_,gl2ctx,cst_MAX_COMBINED_VERTEX_UNIFOR),
     max_combined_fragment_uniform_=
      caml_call2(_bu_,gl2ctx,cst_MAX_COMBINED_FRAGMENT_UNIF),
     uniform_buffer_offset_alignmen=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BUFFER_OFFSET_ALIG),
     active_uniform_blocks=caml_call2(_bu_,gl2ctx,cst_ACTIVE_UNIFORM_BLOCKS),
     uniform_type=caml_call2(_bu_,gl2ctx,cst_UNIFORM_TYPE),
     uniform_size=caml_call2(_bu_,gl2ctx,cst_UNIFORM_SIZE),
     uniform_block_index=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_INDEX),
     uniform_offset=caml_call2(_bu_,gl2ctx,cst_UNIFORM_OFFSET),
     uniform_array_stride=caml_call2(_bu_,gl2ctx,cst_UNIFORM_ARRAY_STRIDE),
     uniform_matrix_stride=caml_call2(_bu_,gl2ctx,cst_UNIFORM_MATRIX_STRIDE),
     uniform_is_row_major=caml_call2(_bu_,gl2ctx,cst_UNIFORM_IS_ROW_MAJOR),
     uniform_block_binding$0=caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_BINDING),
     uniform_block_data_size=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_DATA_SIZE),
     uniform_block_active_uniforms=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_ACTIVE_UNIFO),
     uniform_block_active_uniform_i=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_ACTIVE_UNIFO$0),
     uniform_block_referenced_by_ve=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_REFERENCED_B),
     uniform_block_referenced_by_fr=
      caml_call2(_bu_,gl2ctx,cst_UNIFORM_BLOCK_REFERENCED_B$0),
     invalid_index=caml_call2(_bu_,gl2ctx,cst_INVALID_INDEX),
     max_vertex_output_components=
      caml_call2(_bu_,gl2ctx,cst_MAX_VERTEX_OUTPUT_COMPONEN),
     max_fragment_input_components=
      caml_call2(_bu_,gl2ctx,cst_MAX_FRAGMENT_INPUT_COMPONE),
     max_server_wait_timeout=
      caml_call2(_bu_,gl2ctx,cst_MAX_SERVER_WAIT_TIMEOUT),
     object_type=caml_call2(_bu_,gl2ctx,cst_OBJECT_TYPE),
     sync_condition=caml_call2(_bu_,gl2ctx,cst_SYNC_CONDITION),
     sync_status=caml_call2(_bu_,gl2ctx,cst_SYNC_STATUS),
     sync_flags=caml_call2(_bu_,gl2ctx,cst_SYNC_FLAGS),
     sync_fence=caml_call2(_bu_,gl2ctx,cst_SYNC_FENCE),
     sync_gpu_commands_complete=
      caml_call2(_bu_,gl2ctx,cst_SYNC_GPU_COMMANDS_COMPLETE),
     unsignaled=caml_call2(_bu_,gl2ctx,cst_UNSIGNALED),
     signaled=caml_call2(_bu_,gl2ctx,cst_SIGNALED),
     already_signaled=caml_call2(_bu_,gl2ctx,cst_ALREADY_SIGNALED),
     timeout_expired=caml_call2(_bu_,gl2ctx,cst_TIMEOUT_EXPIRED),
     condition_satisfied=caml_call2(_bu_,gl2ctx,cst_CONDITION_SATISFIED),
     wait_failed=caml_call2(_bu_,gl2ctx,cst_WAIT_FAILED),
     sync_flush_commands_bit=
      caml_call2(_bu_,gl2ctx,cst_SYNC_FLUSH_COMMANDS_BIT),
     vertex_attrib_array_divisor=
      caml_call2(_bu_,gl2ctx,cst_VERTEX_ATTRIB_ARRAY_DIVISO),
     any_samples_passed=caml_call2(_bu_,gl2ctx,cst_ANY_SAMPLES_PASSED),
     any_samples_passed_conservativ=
      caml_call2(_bu_,gl2ctx,cst_ANY_SAMPLES_PASSED_CONSERV),
     sampler_binding=caml_call2(_bu_,gl2ctx,cst_SAMPLER_BINDING),
     rgb10_a2ui=caml_call2(_bu_,gl2ctx,cst_RGB10_A2UI),
     int_2_10_10_10_rev=caml_call2(_bu_,gl2ctx,cst_INT_2_10_10_10_REV),
     transform_feedback=caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK),
     transform_feedback_paused=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_PAUSED),
     transform_feedback_active=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_ACTIVE),
     transform_feedback_binding=
      caml_call2(_bu_,gl2ctx,cst_TRANSFORM_FEEDBACK_BINDING),
     texture_immutable_format=
      caml_call2(_bu_,gl2ctx,cst_TEXTURE_IMMUTABLE_FORMAT),
     max_element_index=caml_call2(_bu_,gl2ctx,cst_MAX_ELEMENT_INDEX),
     texture_immutable_levels=
      caml_call2(_bu_,gl2ctx,cst_TEXTURE_IMMUTABLE_LEVELS),
     timeout_ignored=caml_call2(_bu_,gl2ctx,cst_TIMEOUT_IGNORED),
     max_client_wait_timeout_webgl=
      caml_call2(_bu_,gl2ctx,cst_MAX_CLIENT_WAIT_TIMEOUT_WE),
     Brr_canvas=
      [0,
       [0,
        is_2d,
        is_identity,
        inverse,
        multiply,
        m11,
        m12,
        m13,
        m14,
        m21,
        m22,
        m23,
        m24,
        m31,
        m32,
        m33,
        m34,
        m41,
        m42,
        m43,
        m44,
        a$1,
        b$1,
        c$0,
        d,
        e,
        f,
        to_float32_array,
        of_float32_array,
        to_float64_array,
        of_float64_array],
       [0,v$14,tr$1,to_json$2,x,y,z,w],
       [0,
        create$13,
        of_el$1,
        to_el$1,
        w$0,
        h,
        set_w,
        set_h,
        set_size_to_layout_size,
        image_encode,
        to_data_url,
        to_blob,
        capture_stream$0],
       [0,
        Fill_rule,
        Image_smoothing_quality,
        Line_cap,
        Line_join,
        Text_align,
        Text_baseline,
        Text_direction,
        Composite_op,
        Repeat,
        [0,
         create$14,
         of_svg,
         of_path,
         add$0,
         close$6,
         move_to,
         line_to,
         qcurve_to,
         ccurve_to,
         arc_to,
         arc,
         rect,
         ellipse],
        image_src_of_el,
        image_src_of_jv,
        attrs_alpha,
        attrs_desynchronized,
        create$15,
        canvas$1,
        attrs,
        save,
        restore,
        image_smoothing_enabled,
        set_image_smoothing_enabled,
        image_smoothing_quality,
        set_image_smoothing_quality,
        global_alpha,
        set_global_alpha,
        global_composite_op,
        set_global_composite_op,
        filter$0,
        set_filter,
        get_transform,
        set_transform,
        reset_transform,
        transform,
        translate,
        rotate,
        scale,
        set_stroke_style,
        set_fill_style,
        color$1,
        gradient_style,
        linear_gradient,
        radial_gradient,
        pattern_style,
        pattern,
        line_width,
        set_line_width,
        line_cap,
        set_line_cap,
        line_join,
        set_line_join,
        miter_limit,
        set_miter_limit,
        line_dash,
        set_line_dash,
        line_dash_offset,
        set_line_dash_offset,
        shadow_blur,
        set_shadow_blur,
        shadow_offset_x,
        set_shadow_offset_x,
        shadow_offset_y,
        set_shadow_offset_y,
        shadow_color,
        set_shadow_color,
        font$0,
        set_font,
        text_align,
        set_text_align,
        text_baseline,
        set_text_baseline,
        text_direction,
        set_text_direction,
        clear_rect,
        fill_rect,
        stroke_rect,
        fill$0,
        stroke,
        clip,
        draw_focus_if_needed,
        scroll_path_into_view,
        is_point_in_fill,
        is_point_in_stroke,
        fill_text,
        stroke_text,
        Text_metrics,
        measure_text,
        draw_image,
        draw_image_in_rect,
        draw_sub_image_in_rect,
        [0,create$16,w$1,h$0,data$5],
        create_image_data,
        get_image_data,
        put_image_data,
        put_sub_image_data],
       [0,
        [0,
         Power_preference,
         v$15,
         alpha,
         depth,
         stencil,
         antialias,
         premultiplied_alpha,
         preserve_drawing_buffer,
         power_preference,
         desynchronized],
        create$17,
        canvas$2,
        drawing_buffer_width,
        drawing_buffer_height,
        attrs$0,
        is_context_lost,
        get_supported_extensions,
        get_extension,
        Active_info,
        Shader_precision_format,
        Tex_image_source,
        active_texture,
        attach_shader,
        begin_query,
        begin_transform_feedback,
        bind_attrib_location,
        bind_buffer,
        bind_buffer_base,
        bind_buffer_range,
        bind_framebuffer,
        bind_renderbuffer,
        bind_sampler,
        bind_texture,
        bind_transform_feedback,
        bind_vertex_array,
        blend_color,
        blend_equation,
        blend_equation_separate,
        blend_func,
        blend_func_separate,
        blit_framebuffer,
        buffer_data,
        buffer_data_size,
        buffer_sub_data,
        check_framebuffer_status,
        clear$3,
        clear_bufferfi,
        clear_bufferfv,
        clear_bufferiv,
        clear_bufferuiv,
        clear_color,
        clear_depth,
        clear_stencil,
        client_wait_sync,
        color_mask,
        compile_shader,
        compressed_tex_image2d,
        compressed_tex_image2d_size,
        compressed_tex_image3d,
        compressed_tex_image3d_size,
        compressed_tex_sub_image2d,
        compressed_tex_sub_image2d_siz,
        compressed_tex_sub_image3d,
        compressed_tex_sub_image3d_siz,
        copy_buffer_sub_data,
        copy_tex_image2d,
        copy_tex_sub_image2d,
        copy_tex_sub_image3d,
        create_buffer,
        create_framebuffer,
        create_program,
        create_query,
        create_renderbuffer,
        create_sampler,
        create_shader,
        create_texture,
        create_transform_feedback,
        create_vertex_array,
        cull_face,
        delete_buffer,
        delete_framebuffer,
        delete_program,
        delete_query,
        delete_renderbuffer,
        delete_sampler,
        delete_shader,
        delete_sync,
        delete_texture,
        delete_transform_feedback,
        delete_vertex_array,
        depth_func,
        depth_mask,
        detach_shader,
        disable,
        disable_vertex_attrib_array,
        draw_arrays,
        draw_arrays_instanced,
        draw_buffers,
        draw_elements,
        draw_elements_instanced,
        draw_range_elements,
        enable,
        enable_vertex_attrib_array,
        end_query,
        end_transform_feedback,
        fence_sync,
        finish,
        flush,
        framebuffer_renderbuffer,
        framebuffer_texture2d,
        framebuffer_texture_layer,
        front_face,
        generate_mipmap,
        get_active_attrib,
        get_active_uniform,
        get_active_uniform_block_name,
        get_active_uniform_block_param,
        get_active_uniforms,
        get_attached_shaders,
        get_attrib_location,
        get_buffer_parameter,
        get_buffer_sub_data,
        get_error,
        get_frag_data_location,
        get_framebuffer_attachment_par,
        get_indexed_parameter,
        get_internalformat_parameter,
        get_parameter,
        get_program_info_log,
        get_program_parameter,
        get_query,
        get_query_parameter,
        get_renderbuffer_parameter,
        get_sampler_parameter,
        get_shader_info_log,
        get_shader_parameter,
        get_shader_precision_format,
        get_shader_source,
        get_sync_parameter,
        get_tex_parameter,
        get_transform_feedback_varying,
        get_uniform,
        get_uniform_block_index,
        get_uniform_indices,
        get_uniform_location,
        get_vertex_attrib,
        get_vertex_attrib_offset,
        hint,
        invalidate_framebuffer,
        invalidate_sub_framebuffer,
        is_buffer,
        is_enabled,
        is_framebuffer,
        is_program,
        is_query,
        is_renderbuffer,
        is_sampler,
        is_shader,
        is_texture,
        is_transform_feedback,
        is_vertex_array,
        line_width$0,
        link_program,
        pause_transform_feedback,
        pixel_storei,
        polygon_offset,
        read_buffer,
        read_pixels_to_pixel_pack,
        read_pixels,
        renderbuffer_storage,
        renderbuffer_storage_multisamp,
        resume_transform_feedback,
        sample_coverage,
        sampler_parameterf,
        sampler_parameteri,
        scissor,
        shader_source,
        stencil_func,
        stencil_func_separate,
        stencil_mask,
        stencil_mask_separate,
        stencil_op,
        stencil_op_separate,
        tex_image2d,
        tex_image2d_of_source,
        tex_image2d_of_pixel_unpack,
        tex_image3d,
        tex_image3d_of_source,
        tex_image3d_of_pixel_unpack,
        tex_parameterf,
        tex_parameteri,
        tex_storage2d,
        tex_storage3d,
        tex_sub_image2d,
        tex_sub_image2d_of_source,
        tex_sub_image2d_of_pixel_unpac,
        tex_sub_image3d,
        tex_sub_image3d_of_source,
        tex_sub_image3d_of_pixel_unpac,
        transform_feedback_varyings,
        uniform1f,
        uniform1fv,
        uniform1i,
        uniform1iv,
        uniform1ui,
        uniform1uiv,
        uniform2f,
        uniform2fv,
        uniform2i,
        uniform2iv,
        uniform2ui,
        uniform2uiv,
        uniform3f,
        uniform3fv,
        uniform3i,
        uniform3iv,
        uniform3ui,
        uniform3uiv,
        uniform4f,
        uniform4fv,
        uniform4i,
        uniform4iv,
        uniform4ui,
        uniform4uiv,
        uniform_block_binding,
        uniform_matrix2fv,
        uniform_matrix2x3fv,
        uniform_matrix2x4fv,
        uniform_matrix3fv,
        uniform_matrix3x2fv,
        uniform_matrix3x4fv,
        uniform_matrix4fv,
        uniform_matrix4x2fv,
        uniform_matrix4x3fv,
        use_program,
        validate_program,
        vertex_attrib1f,
        vertex_attrib1fv,
        vertex_attrib2f,
        vertex_attrib2fv,
        vertex_attrib3f,
        vertex_attrib3fv,
        vertex_attrib4f,
        vertex_attrib4fv,
        vertex_attrib_divisor,
        vertex_attrib_i4i,
        vertex_attrib_i4iv,
        vertex_attrib_i4ui,
        vertex_attrib_i4uiv,
        vertex_attrib_ipointer,
        vertex_attrib_pointer,
        viewport,
        wait_sync,
        active_attributes,
        active_texture$0,
        active_uniform_blocks,
        active_uniforms,
        aliased_line_width_range,
        aliased_point_size_range,
        alpha$0,
        alpha_bits,
        already_signaled,
        always,
        any_samples_passed,
        any_samples_passed_conservativ,
        array_buffer$2,
        array_buffer_binding,
        attached_shaders,
        back$0,
        blend,
        blend_color$0,
        blend_dst_alpha,
        blend_dst_rgb,
        blend_equation$0,
        blend_equation_alpha,
        blend_equation_rgb,
        blend_src_alpha,
        blend_src_rgb,
        blue_bits,
        bool$1,
        bool_vec2,
        bool_vec3,
        bool_vec4,
        browser_default_webgl,
        buffer_size,
        buffer_usage,
        byte$0,
        ccw,
        clamp_to_edge,
        color$2,
        color_attachment0,
        color_attachment1,
        color_attachment10,
        color_attachment11,
        color_attachment12,
        color_attachment13,
        color_attachment14,
        color_attachment15,
        color_attachment2,
        color_attachment3,
        color_attachment4,
        color_attachment5,
        color_attachment6,
        color_attachment7,
        color_attachment8,
        color_attachment9,
        color_buffer_bit,
        color_clear_value,
        color_writemask,
        compare_ref_to_texture,
        compile_status,
        compressed_texture_formats,
        condition_satisfied,
        constant_alpha,
        constant_color,
        context_lost_webgl,
        copy_read_buffer,
        copy_read_buffer_binding,
        copy_write_buffer,
        copy_write_buffer_binding,
        cull_face$0,
        cull_face_mode,
        current_program,
        current_query,
        current_vertex_attrib,
        cw,
        decr,
        decr_wrap,
        delete_status,
        depth$0,
        depth24_stencil8,
        depth32f_stencil8,
        depth_attachment,
        depth_bits,
        depth_buffer_bit,
        depth_clear_value,
        depth_component,
        depth_component16,
        depth_component24,
        depth_component32f,
        depth_func$0,
        depth_range,
        depth_stencil,
        depth_stencil_attachment,
        depth_test,
        depth_writemask,
        dither,
        dont_care,
        draw_buffer0,
        draw_buffer1,
        draw_buffer10,
        draw_buffer11,
        draw_buffer12,
        draw_buffer13,
        draw_buffer14,
        draw_buffer15,
        draw_buffer2,
        draw_buffer3,
        draw_buffer4,
        draw_buffer5,
        draw_buffer6,
        draw_buffer7,
        draw_buffer8,
        draw_buffer9,
        draw_framebuffer,
        draw_framebuffer_binding,
        dst_alpha,
        dst_color,
        dynamic_copy,
        dynamic_draw,
        dynamic_read,
        element_array_buffer,
        element_array_buffer_binding,
        equal$0,
        fastest,
        float$2,
        float_32_unsigned_int_24_8_rev,
        float_mat2,
        float_mat2x3,
        float_mat2x4,
        float_mat3,
        float_mat3x2,
        float_mat3x4,
        float_mat4,
        float_mat4x2,
        float_mat4x3,
        float_vec2,
        float_vec3,
        float_vec4,
        fragment_shader,
        fragment_shader_derivative_hin,
        framebuffer,
        framebuffer_attachment_alpha_s,
        framebuffer_attachment_blue_si,
        framebuffer_attachment_color_e,
        framebuffer_attachment_compone,
        framebuffer_attachment_depth_s,
        framebuffer_attachment_green_s,
        framebuffer_attachment_object_$0,
        framebuffer_attachment_object_,
        framebuffer_attachment_red_siz,
        framebuffer_attachment_stencil,
        framebuffer_attachment_texture$0,
        framebuffer_attachment_texture$1,
        framebuffer_attachment_texture,
        framebuffer_binding,
        framebuffer_complete,
        framebuffer_default,
        framebuffer_incomplete_attachm,
        framebuffer_incomplete_dimensi,
        framebuffer_incomplete_missing,
        framebuffer_incomplete_multisa,
        framebuffer_unsupported,
        front,
        front_and_back,
        front_face$0,
        func_add,
        func_reverse_subtract,
        func_subtract,
        generate_mipmap_hint,
        gequal,
        greater,
        green_bits,
        half_float,
        high_float,
        high_int,
        implementation_color_read_form,
        implementation_color_read_type,
        incr,
        incr_wrap,
        int$3,
        int_2_10_10_10_rev,
        int_sampler_2d,
        int_sampler_2d_array,
        int_sampler_3d,
        int_sampler_cube,
        int_vec2,
        int_vec3,
        int_vec4,
        interleaved_attribs,
        invalid_enum,
        invalid_framebuffer_operation,
        invalid_index,
        invalid_operation,
        invalid_value,
        invert,
        keep,
        lequal,
        less,
        line_loop,
        line_strip,
        line_width$1,
        linear,
        linear_mipmap_linear,
        linear_mipmap_nearest,
        lines,
        link_status,
        low_float,
        low_int,
        luminance,
        luminance_alpha,
        max$2,
        max_3d_texture_size,
        max_array_texture_layers,
        max_client_wait_timeout_webgl,
        max_color_attachments,
        max_combined_fragment_uniform_,
        max_combined_texture_image_uni,
        max_combined_uniform_blocks,
        max_combined_vertex_uniform_co,
        max_cube_map_texture_size,
        max_draw_buffers,
        max_element_index,
        max_elements_indices,
        max_elements_vertices,
        max_fragment_input_components,
        max_fragment_uniform_blocks,
        max_fragment_uniform_component,
        max_fragment_uniform_vectors,
        max_program_texel_offset,
        max_renderbuffer_size,
        max_samples,
        max_server_wait_timeout,
        max_texture_image_units,
        max_texture_lod_bias,
        max_texture_size,
        max_transform_feedback_interle,
        max_transform_feedback_separat$0,
        max_transform_feedback_separat,
        max_uniform_block_size,
        max_uniform_buffer_bindings,
        max_varying_components,
        max_varying_vectors,
        max_vertex_attribs,
        max_vertex_output_components,
        max_vertex_texture_image_units,
        max_vertex_uniform_blocks,
        max_vertex_uniform_components,
        max_vertex_uniform_vectors,
        max_viewport_dims,
        medium_float,
        medium_int,
        min$1,
        min_program_texel_offset,
        mirrored_repeat,
        nearest,
        nearest_mipmap_linear,
        nearest_mipmap_nearest,
        never,
        nicest,
        no_error,
        none$0,
        notequal,
        object_type,
        one,
        one_minus_constant_alpha,
        one_minus_constant_color,
        one_minus_dst_alpha,
        one_minus_dst_color,
        one_minus_src_alpha,
        one_minus_src_color,
        out_of_memory,
        pack_alignment,
        pack_row_length,
        pack_skip_pixels,
        pack_skip_rows,
        pixel_pack_buffer,
        pixel_pack_buffer_binding,
        pixel_unpack_buffer,
        pixel_unpack_buffer_binding,
        points,
        polygon_offset_factor,
        polygon_offset_fill,
        polygon_offset_units,
        query_result,
        query_result_available,
        r11f_g11f_b10f,
        r16f,
        r16i,
        r16ui,
        r32f,
        r32i,
        r32ui,
        r8,
        r8_snorm,
        r8i,
        r8ui,
        rasterizer_discard,
        read_buffer$0,
        read_framebuffer,
        read_framebuffer_binding,
        red,
        red_bits,
        red_integer,
        renderbuffer,
        renderbuffer_alpha_size,
        renderbuffer_binding,
        renderbuffer_blue_size,
        renderbuffer_depth_size,
        renderbuffer_green_size,
        renderbuffer_height,
        renderbuffer_internal_format,
        renderbuffer_red_size,
        renderbuffer_samples,
        renderbuffer_stencil_size,
        renderbuffer_width,
        renderer,
        repeat$1,
        replace,
        rg,
        rg16f,
        rg16i,
        rg16ui,
        rg32f,
        rg32i,
        rg32ui,
        rg8,
        rg8_snorm,
        rg8i,
        rg8ui,
        rg_integer,
        rgb,
        rgb10_a2,
        rgb10_a2ui,
        rgb16f,
        rgb16i,
        rgb16ui,
        rgb32f,
        rgb32i,
        rgb32ui,
        rgb565,
        rgb5_a1,
        rgb8,
        rgb8_snorm,
        rgb8i,
        rgb8ui,
        rgb9_e5,
        rgb_integer,
        rgba,
        rgba16f,
        rgba16i,
        rgba16ui,
        rgba32f,
        rgba32i,
        rgba32ui,
        rgba4,
        rgba8,
        rgba8_snorm,
        rgba8i,
        rgba8ui,
        rgba_integer,
        sample_alpha_to_coverage,
        sample_buffers,
        sample_coverage$0,
        sample_coverage_invert,
        sample_coverage_value,
        sampler_2d,
        sampler_2d_array,
        sampler_2d_array_shadow,
        sampler_2d_shadow,
        sampler_3d,
        sampler_binding,
        sampler_cube,
        sampler_cube_shadow,
        samples,
        scissor_box,
        scissor_test,
        separate_attribs,
        shader_type,
        shading_language_version,
        short$0,
        signaled,
        signed_normalized,
        src_alpha,
        src_alpha_saturate,
        src_color,
        srgb,
        srgb8,
        srgb8_alpha8,
        static_copy,
        static_draw,
        static_read,
        stencil$0,
        stencil_attachment,
        stencil_back_fail,
        stencil_back_func,
        stencil_back_pass_depth_fail,
        stencil_back_pass_depth_pass,
        stencil_back_ref,
        stencil_back_value_mask,
        stencil_back_writemask,
        stencil_bits,
        stencil_buffer_bit,
        stencil_clear_value,
        stencil_fail,
        stencil_func$0,
        stencil_index8,
        stencil_pass_depth_fail,
        stencil_pass_depth_pass,
        stencil_ref,
        stencil_test,
        stencil_value_mask,
        stencil_writemask,
        stream_copy,
        stream_draw,
        stream_read,
        subpixel_bits,
        sync_condition,
        sync_fence,
        sync_flags,
        sync_flush_commands_bit,
        sync_gpu_commands_complete,
        sync_status,
        texture,
        texture0,
        texture1,
        texture10,
        texture11,
        texture12,
        texture13,
        texture14,
        texture15,
        texture16,
        texture17,
        texture18,
        texture19,
        texture2,
        texture20,
        texture21,
        texture22,
        texture23,
        texture24,
        texture25,
        texture26,
        texture27,
        texture28,
        texture29,
        texture3,
        texture30,
        texture31,
        texture4,
        texture5,
        texture6,
        texture7,
        texture8,
        texture9,
        texture_2d,
        texture_2d_array,
        texture_3d,
        texture_base_level,
        texture_binding_2d,
        texture_binding_2d_array,
        texture_binding_3d,
        texture_binding_cube_map,
        texture_compare_func,
        texture_compare_mode,
        texture_cube_map,
        texture_cube_map_negative_x,
        texture_cube_map_negative_y,
        texture_cube_map_negative_z,
        texture_cube_map_positive_x,
        texture_cube_map_positive_y,
        texture_cube_map_positive_z,
        texture_immutable_format,
        texture_immutable_levels,
        texture_mag_filter,
        texture_max_level,
        texture_max_lod,
        texture_min_filter,
        texture_min_lod,
        texture_wrap_r,
        texture_wrap_s,
        texture_wrap_t,
        timeout_expired,
        timeout_ignored,
        transform_feedback,
        transform_feedback_active,
        transform_feedback_binding,
        transform_feedback_buffer,
        transform_feedback_buffer_bind,
        transform_feedback_buffer_mode,
        transform_feedback_buffer_size,
        transform_feedback_buffer_star,
        transform_feedback_paused,
        transform_feedback_primitives_,
        transform_feedback_varyings$0,
        triangle_fan,
        triangle_strip,
        triangles,
        uniform_array_stride,
        uniform_block_active_uniform_i,
        uniform_block_active_uniforms,
        uniform_block_binding$0,
        uniform_block_data_size,
        uniform_block_index,
        uniform_block_referenced_by_fr,
        uniform_block_referenced_by_ve,
        uniform_buffer,
        uniform_buffer_binding,
        uniform_buffer_offset_alignmen,
        uniform_buffer_size,
        uniform_buffer_start,
        uniform_is_row_major,
        uniform_matrix_stride,
        uniform_offset,
        uniform_size,
        uniform_type,
        unpack_alignment,
        unpack_colorspace_conversion_w,
        unpack_flip_y_webgl,
        unpack_image_height,
        unpack_premultiply_alpha_webgl,
        unpack_row_length,
        unpack_skip_images,
        unpack_skip_pixels,
        unpack_skip_rows,
        unsignaled,
        unsigned_byte,
        unsigned_int,
        unsigned_int_10f_11f_11f_rev,
        unsigned_int_24_8,
        unsigned_int_2_10_10_10_rev,
        unsigned_int_5_9_9_9_rev,
        unsigned_int_sampler_2d,
        unsigned_int_sampler_2d_array,
        unsigned_int_sampler_3d,
        unsigned_int_sampler_cube,
        unsigned_int_vec2,
        unsigned_int_vec3,
        unsigned_int_vec4,
        unsigned_normalized,
        unsigned_short,
        unsigned_short_4_4_4_4,
        unsigned_short_5_5_5_1,
        unsigned_short_5_6_5,
        validate_status,
        vendor,
        version,
        vertex_array_binding,
        vertex_attrib_array_buffer_bin,
        vertex_attrib_array_divisor,
        vertex_attrib_array_enabled,
        vertex_attrib_array_integer,
        vertex_attrib_array_normalized,
        vertex_attrib_array_pointer,
        vertex_attrib_array_size,
        vertex_attrib_array_stride,
        vertex_attrib_array_type,
        vertex_shader,
        viewport$0,
        wait_failed,
        zero]];
    caml_register_global(2936,Brr_canvas,"Brr_canvas");
    var a_rate="a-rate",k_rate="k-rate",Automation_rate=[0,a_rate,k_rate];
    function descriptor(automation_rate,min_value,max_value,default_value,n)
     {var o={};
      o.name = n;
      caml_call3(_d_[4],o,cst_automationRate,automation_rate);
      caml_call3(Float[4],o,cst_minValue,min_value);
      caml_call3(Float[4],o,cst_maxValue,max_value);
      caml_call3(Float[4],o,cst_defaultValue,max_value);
      return o}
    function value$3(p){return caml_call2(Float[2],p,cst_value)}
    function set_value(p,v){return caml_call3(Float[3],p,cst_value$0,v)}
    function automation_rate(p)
     {return caml_call2(_d_[2],p,cst_automationRate$0)}
    function set_automation_rate(p,v)
     {return caml_call3(_d_[3],p,cst_automationRate$1,v)}
    function default_value(p)
     {return caml_call2(Float[2],p,cst_defaultValue$0)}
    function min_value(p){return caml_call2(Float[2],p,cst_minValue$0)}
    function max_value(p){return caml_call2(Float[2],p,cst_maxValue$0)}
    function set_value_at_time(p,v,t){p.setValueAtTime(v,t);return 0}
    function linear_ramp_to_value_at_time(p,v,t)
     {p.linearRampToValueAtTime(v,t);return 0}
    function exponential_ramp_to_value_at_t(p,v,t)
     {p.exponentialRampToValueAtTime(v,t);return 0}
    function set_target_at_time(p,v,t,r){p.setTargetAtTime(v,t,r);return 0}
    function set_value_curve_at_time(p,vs,t,d)
     {p.setValueCurveAtTime(vs,t,d);return 0}
    function cancel_scheduled_values(p,t){p.cancelScheduledValues(t);return 0}
    function cancel_and_hold_at_time(p,t){p.cancelAndHoldAtTime(t);return 0}
    var
     Param=
      [0,
       Automation_rate,
       descriptor,
       value$3,
       set_value,
       automation_rate,
       set_automation_rate,
       default_value,
       min_value,
       max_value,
       set_value_at_time,
       linear_ramp_to_value_at_time,
       exponential_ramp_to_value_at_t,
       set_target_at_time,
       set_value_curve_at_time,
       cancel_scheduled_values,
       cancel_and_hold_at_time];
    function position_x(l){return l.positionX()}
    function position_y(l){return l.positionY()}
    function position_z(l){return l.positionZ()}
    function forward_x(l){return l.forwardX()}
    function forward_y(l){return l.forwardY()}
    function forward_z(l){return l.forwardZ()}
    function up_x(l){return l.upX()}
    function up_y(l){return l.upY()}
    function up_z(l){return l.upZ()}
    var
     Listener=
      [0,
       position_x,
       position_y,
       position_z,
       forward_x,
       forward_y,
       forward_z,
       up_x,
       up_y,
       up_z];
    function add_module(w,url)
     {var _dK_=w.addModule(url);
      return of_promise$0(function(_dL_){return 0},_dK_)}
    function register_processor(n,c){target.registerProcessor(n,c);return 0}
    function current_frame(param)
     {return caml_call2(Int[2],target,cst_currentFrame)}
    function current_time(param)
     {return caml_call2(Float[2],target,cst_currentTime$1)}
    function sample_rate$0(param)
     {return caml_call2(Float[2],target,cst_sampleRate)}
    var G=[0,register_processor,current_frame,current_time,sample_rate$0];
    function port$0(p){return p.port}
    var Processor=[0,port$0],Worklet=[0,add_module,G,Processor];
    function opts$3(cc,l,r,param)
     {return {"numberOfChannels":cc,"length":l,"sampleRate":r}}
    function create$18(opts){return new (target.AudioBuffer)(opts)}
    function sample_rate$1(b){return caml_call2(Float[2],b,cst_sampleRate$0)}
    function length$6(b){return caml_call2(Int[2],b,cst_length$6)}
    function duration_s$0(b){return caml_call2(Float[2],b,cst_length$7)}
    function channel_count$0(b)
     {return caml_call2(Int[2],b,cst_numberOfChannels)}
    function get_channel_data(b,channel){return b.getChannelData(channel)}
    function copy_from_channel(opt,b,c,dst)
     {if(opt)var sth=opt[1],dst_start=sth;else var dst_start=0;
      b.copyFromChannel(dst,c,dst_start);
      return 0}
    function copy_to_channel(opt,b,src,c)
     {if(opt)var sth=opt[1],dst_start=sth;else var dst_start=0;
      b.copyToChannel(src,c,dst_start);
      return 0}
    var
     Buffer=
      [0,
       opts$3,
       create$18,
       sample_rate$1,
       length$6,
       duration_s$0,
       channel_count$0,
       get_channel_data,
       copy_from_channel,
       copy_to_channel],
     max$3="max",
     clamped_max="clamped-max",
     explicit="explicit",
     Channel_count_mode=[0,max$3,clamped_max,explicit],
     speakers="speakers",
     discrete="discrete",
     Channel_interpretation=[0,speakers,discrete];
    function context(n){return n.context}
    function input_count(n){return caml_call2(Int[2],n,cst_numberOfInputs)}
    function output_count(n){return caml_call2(Int[2],n,cst_numberOfOutputs)}
    function channel_count$1(n){return caml_call2(Int[2],n,cst_channelCount)}
    function set_channel_count(n,c)
     {return caml_call3(Int[3],n,cst_channelCount$0,c)}
    function channel_count_mode(n)
     {return caml_call2(_d_[2],n,cst_channelCountMode)}
    function set_channel_count_mode(n,m)
     {return caml_call3(_d_[3],n,cst_channelCountMode$0,m)}
    function channel_interpretation(n)
     {return caml_call2(_d_[2],n,cst_channelInterpretation)}
    function set_channel_interpretation(n,i)
     {return caml_call3(_d_[3],n,cst_channelInterpretation$0,i)}
    function connect_node(opt,_dJ_,n,dst)
     {if(opt)var sth=opt[1],output=sth;else var output=0;
      if(_dJ_)var sth$0=_dJ_[1],input=sth$0;else var input=0;
      n.connect(dst,output,input);
      return 0}
    function connect_param(opt,n,dst)
     {if(opt)var sth=opt[1],output=sth;else var output=0;
      n.connect(dst,output);
      return 0}
    function disconnect(n){n.disconnect();return 0}
    function disconnect_node(output,input,n,dst)
     {var
       output$0=of_option(fn,function(_dI_){return _dI_},output),
       input$0=of_option(fn,function(_dH_){return _dH_},input);
      n.disconnect(dst,output$0,input$0);
      return 0}
    function disconnect_param(output,n,dst)
     {var output$0=of_option(fn,function(_dG_){return _dG_},output);
      n.disconnect(dst,output$0);
      return 0}
    function opts$4
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      fft_size,
      max_decibels,
      min_decibels,
      smoothing_time_constant,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$1,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$1,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$1,channel_interpretation);
      caml_call3(Int[4],o,cst_fftSize,fft_size);
      caml_call3(Float[4],o,cst_minDecibels,min_decibels);
      caml_call3(Float[4],o,cst_maxDecibels,max_decibels);
      caml_call3(Float[4],o,cst_smoothingTimeConstant,smoothing_time_constant);
      return o}
    function create$19(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AnalyserNode)(c,opts)}
    function get_float_frequency_data(n,a)
     {n.getFloatFrequencyData(a);return 0}
    function get_byte_frequency_data(n,a){n.getByteFrequencyData(a);return 0}
    function get_float_time_domain_data(n,a)
     {n.getFloatTimeDomainData(a);return 0}
    function get_byte_time_domain_data(n,a)
     {n.getByteTimeDomainData(a);return 0}
    function fft_size(n){return caml_call2(Int[2],n,cst_fftSize$0)}
    function set_fft_size(n,v){return caml_call3(Int[3],n,cst_fftSize$1,v)}
    function frequency_bin_count(n)
     {return caml_call2(Int[2],n,cst_frequencyBinCount)}
    function min_decibels(n){return caml_call2(Float[2],n,cst_minDecibels$0)}
    function set_min_decibels(n,v)
     {return caml_call3(Float[3],n,cst_minDecibels$1,v)}
    function max_decibels(n){return caml_call2(Float[2],n,cst_maxDecibels$0)}
    function set_max_decibels(n,v)
     {return caml_call3(Float[3],n,cst_maxDecibels$1,v)}
    function smoothing_time_constant(n)
     {return caml_call2(Float[2],n,cst_smoothingTimeConstant$0)}
    function set_smoothing_time_constant(n,v)
     {return caml_call3(Float[3],n,cst_smoothingTimeConstant$1,v)}
    var
     Analyser=
      [0,
       opts$4,
       create$19,
       get_float_frequency_data,
       get_byte_frequency_data,
       get_float_time_domain_data,
       get_byte_time_domain_data,
       fft_size,
       set_fft_size,
       frequency_bin_count,
       min_decibels,
       set_min_decibels,
       max_decibels,
       set_max_decibels,
       smoothing_time_constant,
       set_smoothing_time_constant],
     lowpass="lowpass",
     highpass="highpass",
     bandpass="bandpass",
     lowshelf="lowshelf",
     highshelf="highshelf",
     peaking="peaking",
     notch="notch",
     allpass="allpass",
     Type$3=
      [0,lowpass,highpass,bandpass,lowshelf,highshelf,peaking,notch,allpass];
    function opts$5
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      type,
      q,
      detune,
      frequency,
      gain,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$2,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$2,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$2,channel_interpretation);
      caml_call3(_d_[4],o,cst_type$6,type);
      caml_call3(Float[4],o,cst_Q,q);
      caml_call3(Float[4],o,cst_detune,detune);
      caml_call3(Float[4],o,cst_frequency,frequency);
      caml_call3(Float[4],o,cst_gain,gain);
      return o}
    function create$20(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.BiquadFilterNode)(c,opts)}
    function type$10(n){return caml_call2(_d_[2],n,cst_type$7)}
    function set_type(n,v){return caml_call3(_d_[3],n,cst_type$8,v)}
    function detune(n){return n.detune()}
    function frequency(n){return n.frequency()}
    function q$1(n){return n.Q()}
    function gain(n){return n.gain()}
    function get_frequency_response(n,f,m,p)
     {n.getFrequencyResponse(f,m,p);return 0}
    var
     Biquad_filter=
      [0,
       Type$3,
       opts$5,
       create$20,
       type$10,
       set_type,
       detune,
       frequency,
       q$1,
       gain,
       get_frequency_response];
    function opts$6
     (buffer,detune,loop,loop_start,loop_end,playback_rate,param)
     {var o={};
      set_if_some(o,cst_buffer,buffer);
      caml_call3(Float[4],o,cst_detune$0,detune);
      caml_call3(Bool[4],o,cst_loop$1,loop);
      caml_call3(Float[4],o,cst_loop_start,loop_start);
      caml_call3(Float[4],o,cst_loop_end,loop_end);
      caml_call3(Float[4],o,cst_playbackRate$1,playback_rate);
      return o}
    function create$21(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioBufferSourceNode)(c,opts)}
    function buffer$0(n)
     {return find_map(function(_dF_){return _dF_},n,cst_buffer$0)}
    function set_buffer(n,v)
     {return n.buffer = of_option(null$0,function(_dE_){return _dE_},v)}
    function playback_rate$0(n){return n.playbackRate}
    function detune$0(n){return n.detune}
    function loop$0(n){return caml_call2(Bool[2],n,cst_loop$2)}
    function set_loop$0(n,b){return caml_call3(Bool[3],n,cst_loop$3,b)}
    function loop_start(n){return caml_call2(Float[2],n,cst_loopStart)}
    function set_loop_start(n,v)
     {return caml_call3(Float[3],n,cst_loopStart$0,v)}
    function loop_end(n){return caml_call2(Float[2],n,cst_loopEnd)}
    function set_loop_end(n,v){return caml_call3(Float[3],n,cst_loopEnd$0,v)}
    function start$4(t,o,d,n)
     {var
       t$0=of_option(fn,function(_dD_){return _dD_},t),
       o$0=of_option(fn,function(_dC_){return _dC_},o),
       d$0=of_option(fn,function(_dB_){return _dB_},d);
      n.start(t$0,o$0,d$0);
      return 0}
    function stop$2(t,n)
     {var t$0=of_option(fn,function(_dA_){return _dA_},t);
      n.stop(t$0);
      return 0}
    var
     Buffer_source=
      [0,
       opts$6,
       create$21,
       buffer$0,
       set_buffer,
       playback_rate$0,
       detune$0,
       loop$0,
       set_loop$0,
       loop_start,
       set_loop_start,
       loop_end,
       set_loop_end,
       start$4,
       stop$2];
    function opts$7
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      input_count,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$3,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$3,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$3,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfInputs$0,input_count);
      return o}
    function create$22(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ChannelMergerNode)(c,opts)}
    var Channel_merger=[0,opts$7,create$22];
    function opts$8
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      output_count,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$4,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$4,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$4,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfOutput,output_count);
      return o}
    function create$23(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ChannelSplitterNode)(c,opts)}
    var Channel_splitter=[0,opts$8,create$23];
    function opts$9(offset,param)
     {var o={};caml_call3(Float[4],o,cst_offset,offset);return o}
    function create$24(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ConstantSourceNode)(c,opts)}
    function offset(n){return n.offset}
    function start$5(t,n)
     {var t$0=of_option(fn,function(_dz_){return _dz_},t);
      n.start(t$0);
      return 0}
    function stop$3(t,n)
     {var t$0=of_option(fn,function(_dy_){return _dy_},t);
      n.stop(t$0);
      return 0}
    var Constant_source=[0,opts$9,create$24,offset,start$5,stop$3];
    function opts$10
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      buffer,
      disable_normalization,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$5,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$5,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$5,channel_interpretation);
      set_if_some(o,cst_buffer$1,buffer);
      caml_call3(Bool[4],o,cst_disableNormalization,disable_normalization);
      return o}
    function create$25(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ConvolverNode)(c,opts)}
    function buffer$1(n)
     {return find_map(function(_dx_){return _dx_},n,cst_buffer$2)}
    function set_buffer$0(n,v)
     {return n.buffer = of_option(null$0,function(_dw_){return _dw_},v)}
    function normalize(n){return caml_call2(Bool[2],n,cst_normalize)}
    function set_normalize(n,b)
     {return caml_call3(Bool[3],n,cst_normalize$0,b)}
    var
     Convolver=
      [0,opts$10,create$25,buffer$1,set_buffer$0,normalize,set_normalize];
    function opts$11
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      delay_time,
      max_delay_time,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$6,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$6,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$6,channel_interpretation);
      caml_call3(Float[4],o,cst_delayTime,delay_time);
      caml_call3(Float[4],o,cst_maxDelayTime,max_delay_time);
      return o}
    function create$26(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.DelayNode)(c,opts)}
    function delay_time(n){return n.delayTime}
    var Delay=[0,opts$11,create$26,delay_time];
    function max_channel_count(n)
     {return caml_call2(Int[2],n,cst_maxChannelCount)}
    var Destination$0=[0,max_channel_count];
    function opts$12
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      attack,
      knee,
      ratio,
      release,
      threshold,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$7,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$7,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$7,channel_interpretation);
      caml_call3(Float[4],o,cst_attack,attack);
      caml_call3(Float[4],o,cst_knee,knee);
      caml_call3(Float[4],o,cst_ratio,ratio);
      caml_call3(Float[4],o,cst_release,release);
      caml_call3(Float[4],o,cst_threshold,threshold);
      return o}
    function create$27(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.DynamicsCompressorNode)(c,opts)}
    function attack(n){return n.attack}
    function knee(n){return n.knee}
    function ratio(n){return n.ratio}
    function reduction(n){return caml_call2(Float[2],n,cst_reduction)}
    function release(n){return n.release}
    function threshold(n){return n.threshold}
    var
     Dynamics_compressor=
      [0,opts$12,create$27,attack,knee,ratio,reduction,release,threshold];
    function opts$13
     (channel_count,channel_count_mode,channel_interpretation,gain,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$8,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$8,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$8,channel_interpretation);
      caml_call3(Float[4],o,cst_gain$0,gain);
      return o}
    function create$28(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.GainNode)(c,opts)}
    function gain$0(n){return n.gain}
    var Gain=[0,opts$13,create$28,gain$0];
    function opts$14
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      feedforward,
      feedback,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$9,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$9,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$9,channel_interpretation);
      o.feedforward = feedforward;
      o.feedback = feedback;
      return o}
    function create$29(c,opts){return new (target.IIRFilterNode)(c,opts)}
    function get_frequency_response$0(n,f,m,p)
     {n.getFrequencyResponse(f,m,p);return 0}
    var Iir_filter=[0,opts$14,create$29,get_frequency_response$0];
    function opts$15(el,param){var o={};o.mediaElement = el;return o}
    function create$30(c,opts)
     {return new
              (target[caml_string_of_jsbytes("MediaElementAudioSourceNode ")])
              (c,opts)}
    function media_element(n){return n.mediaElement}
    var Media_element_source=[0,opts$15,create$30,media_element];
    function opts$16
     (channel_count,channel_count_mode,channel_interpretation,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$10,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$10,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$10,channel_interpretation);
      return o}
    function create$31(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.MediaStreamAudioDestinationNode)(c,opts)}
    function stream$2(n){return n.stream}
    var Media_stream_destination=[0,opts$16,create$31,stream$2];
    function opts$17(stream,param){var o={};o.mediaStream = stream;return o}
    function create$32(c,opts)
     {return new (target.MediaStreamAudioSourceNode)(c,opts)}
    function media_stream(n){return n.mediaStream}
    var Media_stream_source=[0,opts$17,create$32,media_stream];
    function opts$18(stream,param)
     {var o={};o.mediaStreamTrack = stream;return o}
    function create$33(c,opts)
     {return new
              (target
                [caml_string_of_jsbytes("MediaStreamTrackAudioSourceNode ")])
              (c,opts)}
    var Media_stream_track_source=[0,opts$18,create$33];
    function opts$19(disable_normalization,real,imag,param)
     {var o={};
      caml_call3(Bool[4],o,cst_disableNormalization$0,disable_normalization);
      o.real = of_option(fn,function(_dv_){return _dv_},real);
      o.imag = of_option(fn,function(_du_){return _du_},imag);
      return o}
    function create$34(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.PeriodicWave)(c,opts)}
    var
     Periodic_wave=[0,opts$19,create$34],
     sine="sine",
     square$0="square",
     sawtooth="sawtooth",
     triangle="triangle",
     custom="custom",
     Type$4=[0,sine,square$0,sawtooth,triangle,custom];
    function opts$20
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      type,
      frequency,
      detune,
      periodic_wave,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$11,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$11,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$11,channel_interpretation);
      caml_call3(_d_[4],o,cst_type$9,type);
      caml_call3(Float[4],o,cst_frequency$0,frequency);
      caml_call3(Float[4],o,cst_detune$1,detune);
      set_if_some(o,cst_periodicWave,periodic_wave);
      return o}
    function create$35(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.OscillatorNode)(c,opts)}
    function type$11(n){return caml_call2(_d_[2],n,cst_type$10)}
    function set_type$0(n,v){return caml_call3(_d_[3],n,cst_type$11,v)}
    function detune$1(n){return n.detune()}
    function frequency$0(n){return n.frequency()}
    function set_periodic_wave(n,w){n.setPeriodicWave(w);return 0}
    function start$6(t,n)
     {var t$0=of_option(fn,function(_dt_){return _dt_},t);
      n.start(t$0);
      return 0}
    function stop$4(t,n)
     {var t$0=of_option(fn,function(_ds_){return _ds_},t);
      n.stop(t$0);
      return 0}
    var
     Oscillator=
      [0,
       Periodic_wave,
       Type$4,
       opts$20,
       create$35,
       type$11,
       set_type$0,
       detune$1,
       frequency$0,
       set_periodic_wave,
       start$6,
       stop$4],
     equalpower="equalpower",
     hrtf="HRTF",
     Panning_model=[0,equalpower,hrtf],
     linear$0="linear",
     inverse$0="inverse",
     exponential="exponential",
     Distance_model=[0,linear$0,inverse$0,exponential];
    function opts$21
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      panning_model,
      distance_model,
      position_x,
      position_y,
      position_z,
      orientation_x,
      orientation_y,
      orientation_z,
      ref_distance,
      max_distance,
      rolloff_factor,
      cone_inner_angle,
      cone_outer_angle,
      cone_outer_gain,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$12,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$12,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$12,channel_interpretation);
      caml_call3(_d_[4],o,cst_panningModel,panning_model);
      caml_call3(_d_[4],o,cst_distanceModel,distance_model);
      caml_call3(Float[4],o,cst_positionX,position_x);
      caml_call3(Float[4],o,cst_positionY,position_y);
      caml_call3(Float[4],o,cst_positionZ,position_z);
      caml_call3(Float[4],o,cst_orientationX,orientation_x);
      caml_call3(Float[4],o,cst_orientationY,orientation_y);
      caml_call3(Float[4],o,cst_orientationZ,orientation_z);
      caml_call3(Float[4],o,cst_refDistance,ref_distance);
      caml_call3(Float[4],o,cst_maxDistance,max_distance);
      caml_call3(Float[4],o,cst_rolloff_factor,rolloff_factor);
      caml_call3(Float[4],o,cst_cone_inner_angle,cone_inner_angle);
      caml_call3(Float[4],o,cst_cone_outer_angle,cone_outer_angle);
      caml_call3(Float[4],o,cst_cone_outer_gain,cone_outer_gain);
      return o}
    function create$36(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.PannerNode)(c,opts)}
    function panning_model(n){return caml_call2(_d_[2],n,cst_panningModel$0)}
    function set_panning_model(n,v)
     {return caml_call3(_d_[3],n,cst_panningModel$1,v)}
    function distance_model(n)
     {return caml_call2(_d_[2],n,cst_distanceModel$0)}
    function set_distance_model(n,v)
     {return caml_call3(_d_[3],n,cst_distanceModel$1,v)}
    function position_x$0(n){return n.positionX}
    function position_y$0(n){return n.positionY}
    function position_z$0(n){return n.positionZ}
    function orientation_x(n){return n.orientationX}
    function orientation_y(n){return n.orientationY}
    function orientation_z(n){return n.orientationZ}
    function ref_distance(n){return caml_call2(Float[2],n,cst_refDistance$0)}
    function set_ref_distance(n,v)
     {return caml_call3(Float[3],n,cst_refDistance$1,v)}
    function max_distance(n){return caml_call2(Float[2],n,cst_maxDistance$0)}
    function set_max_distance(n,v)
     {return caml_call3(Float[3],n,cst_maxDistance$1,v)}
    function cone_inner_angle(n)
     {return caml_call2(Float[2],n,cst_coneInnerAngle)}
    function set_cone_inner_angle(n,v)
     {return caml_call3(Float[3],n,cst_coneInnerAngle$0,v)}
    function cone_outer_angle(n)
     {return caml_call2(Float[2],n,cst_coneOuterAngle)}
    function set_cone_outer_angle(n,v)
     {return caml_call3(Float[3],n,cst_coneOuterAngle$0,v)}
    function cone_outer_gain(n)
     {return caml_call2(Float[2],n,cst_coneOuterGain)}
    function set_cone_outer_gain(n,v)
     {return caml_call3(Float[3],n,cst_coneOuterGain$0,v)}
    var
     Panner=
      [0,
       Panning_model,
       Distance_model,
       opts$21,
       create$36,
       panning_model,
       set_panning_model,
       distance_model,
       set_distance_model,
       position_x$0,
       position_y$0,
       position_z$0,
       orientation_x,
       orientation_y,
       orientation_z,
       ref_distance,
       set_ref_distance,
       max_distance,
       set_max_distance,
       cone_inner_angle,
       set_cone_inner_angle,
       cone_outer_angle,
       set_cone_outer_angle,
       cone_outer_gain,
       set_cone_outer_gain];
    function opts$22
     (channel_count,channel_count_mode,channel_interpretation,pan,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$13,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$13,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$13,channel_interpretation);
      caml_call3(Float[4],o,cst_pan,pan);
      return o}
    function create$37(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.StereoPannerNode)(c,opts)}
    function pan(n){return n.pan}
    var
     Stereo_panner=[0,opts$22,create$37,pan],
     none$1="none",
     mul_2x="2x",
     mul_4x="4x",
     Oversample=[0,none$1,mul_2x,mul_4x];
    function opts$23
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      curve,
      oversample,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$14,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$14,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$14,channel_interpretation);
      o.curve = of_option(fn,function(_dr_){return _dr_},curve);
      caml_call3(_d_[4],o,cst_oversample,oversample);
      return o}
    function create$38(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.WaveShaperNode)(c,opts)}
    function curve(n)
     {var _dp_=n.curve;return to_option(function(_dq_){return _dq_},_dp_)}
    function set_curve(n,v)
     {return n.curve = of_option(null$0,function(_do_){return _do_},v)}
    function oversample(n){return caml_call2(_d_[2],n,cst_oversample$0)}
    function set_oversample(n,v)
     {return caml_call3(_d_[3],n,cst_oversample$1,v)}
    var
     Wave_shaper=
      [0,
       Oversample,
       opts$23,
       create$38,
       curve,
       set_curve,
       oversample,
       set_oversample];
    function opts$24
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      input_count,
      output_count,
      output_channel_count,
      parameters,
      processor_options,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$15,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$15,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$15,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfInputs$1,input_count);
      caml_call3(Int[4],o,cst_numberOfOutputs$0,output_count);
      function _dk_(_dn_){return _dn_}
      function _dl_(_dm_){return of_list(_dk_,_dm_)}
      set_if_some
       (o,
        cst_outputChannelCount,
        caml_call2(Stdlib_Option[7],_dl_,output_channel_count));
      set_if_some(o,cst_parameterData,parameters);
      set_if_some(o,cst_processorOptions,processor_options);
      return o}
    function create$39(opt,c,name)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioWorkletNode)(c,name,opts)}
    function parameter(n,k)
     {var p=n.parameters.get(k);
      return is_none(p)?throw$0(0,"no parameter named ".concat(k)):p}
    function port$1(n){return n.port}
    var
     Worklet$0=[0,opts$24,create$39,parameter,port$1],
     Node=
      [0,
       Channel_count_mode,
       Channel_interpretation,
       context,
       input_count,
       output_count,
       channel_count$1,
       set_channel_count,
       channel_count_mode,
       set_channel_count_mode,
       channel_interpretation,
       set_channel_interpretation,
       connect_node,
       connect_param,
       disconnect,
       disconnect_node,
       disconnect_param,
       Analyser,
       Biquad_filter,
       Buffer_source,
       Channel_merger,
       Channel_splitter,
       Constant_source,
       Convolver,
       Delay,
       Destination$0,
       Dynamics_compressor,
       Gain,
       Iir_filter,
       Media_element_source,
       Media_stream_destination,
       Media_stream_source,
       Media_stream_track_source,
       Oscillator,
       Panner,
       Stereo_panner,
       Wave_shaper,
       Worklet$0];
    function context_time(t){return caml_call2(Float[2],t,cst_contextTime)}
    function performance_time(t)
     {return caml_call2(Float[2],t,cst_performanceTime)}
    var
     Timestamp=[0,context_time,performance_time],
     suspended="suspended",
     running="running",
     closed$0="closed",
     State$0=[0,suspended,running,closed$0];
    function decode_audio_data(c,b)
     {var _di_=c.decodeAudioData(b);
      return of_promise$0(function(_dj_){return _dj_},_di_)}
    function destination$0(c){return c.destination}
    function sample_rate$2(c){return caml_call2(Float[2],c,cst_sampleRate$1)}
    function current_time$0(c)
     {return caml_call2(Float[2],c,cst_currentTime$2)}
    function listener(c){return c.listener}
    function state$2(c){return caml_call2(_d_[2],c,cst_state$0)}
    function audio_worklet(c){return c.audioWorklet}
    var
     Base=
      [0,
       decode_audio_data,
       destination$0,
       sample_rate$2,
       current_time$0,
       listener,
       state$2,
       audio_worklet],
     balanced="balanced",
     interactive="interactive",
     playback="playback",
     Latency_category=[0,balanced,interactive,playback];
    function opts$25(latency_hint,sample_rate_hz,param)
     {var o={};
      if(latency_hint)
       {var _dg_=latency_hint[1];
        if(925478882 <= _dg_[1])
         var s=_dg_[2],_dh_=[0,s];
        else
         var c=_dg_[2],_dh_=[0,c];
        var latency_hint$0=_dh_}
      else
       var latency_hint$0=0;
      set_if_some(o,cst_latencyHint,latency_hint$0);
      caml_call3(Float[4],o,cst_sampleRate$2,sample_rate_hz);
      return o}
    function create$40(opt,param)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioContext)(opts)}
    function base_latency(c){return caml_call2(Float[2],c,cst_baseLatency)}
    function output_latency(c)
     {return caml_call2(Float[2],c,cst_outputLatency)}
    function get_output_timestamp(c){return c.getOutputTimestamp()}
    function resume$1(c)
     {var _de_=c.resume();return of_promise$0(function(_df_){return 0},_de_)}
    function suspend$0(c)
     {var _dc_=c.suspend();return of_promise$0(function(_dd_){return 0},_dc_)}
    function close$7(c)
     {var _da_=c.close();return of_promise$0(function(_db_){return 0},_da_)}
    function opts$26(cc,l,r,param)
     {return {"numberOfChannels":cc,"length":l,"sampleRate":r}}
    function length$7(c){return caml_call2(Int[2],c,cst_length$8)}
    function create$41(opts){return new (target.OfflineAudioContext)(opts)}
    function start_rendering(c)
     {var _c__=c.startRenderig();
      return of_promise$0(function(_c$_){return _c$_},_c__)}
    function suspend$1(c,secs)
     {var _c8_=c.suspend(secs);
      return of_promise$0(function(_c9_){return 0},_c8_)}
    function resume$2(c)
     {var _c6_=c.resume();return of_promise$0(function(_c7_){return 0},_c6_)}
    var
     Brr_webaudio=
      [0,
       [0,
        Param,
        Listener,
        Worklet,
        Buffer,
        Node,
        Timestamp,
        [0,
         State$0,
         Base,
         Latency_category,
         opts$25,
         create$40,
         base_latency,
         output_latency,
         get_output_timestamp,
         resume$1,
         suspend$0,
         close$7,
         [0,opts$26,create$41,length$7,start_rendering,suspend$1,resume$2]]]];
    caml_register_global(2937,Brr_webaudio,"Brr_webaudio");
    var
     public$0="public",
     private$0="private",
     secret="secret",
     Type$5=[0,public$0,private$0,secret],
     encrypt="encrypt",
     decrypt="decrypt",
     sign="sign",
     verify="verify",
     derive_key="deriveKey",
     derive_bits="deriveBits",
     wrap_key="wrapKey",
     unwrap_key="unwrapKey",
     Usage=
      [0,
       encrypt,
       decrypt,
       sign,
       verify,
       derive_key,
       derive_bits,
       wrap_key,
       unwrap_key],
     raw="raw",
     pkcs8="pkcs8",
     spki="spki",
     jwk="jwk",
     Format=[0,raw,pkcs8,spki,jwk];
    function type$12(k){return caml_call2(_d_[2],k,cst_type$12)}
    function extractable(k){return caml_call2(Bool[2],k,cst_extractable)}
    function algorithm(k){return k.algorithm}
    function usages(k){return caml_list_of_js_array(k.usages)}
    function public$1(p){return p.publicKey}
    function private$1(p){return p.privateKey}
    var
     Crypto_key=
      [0,
       Type$5,
       Usage,
       Format,
       type$12,
       extractable,
       algorithm,
       usages,
       public$1,
       private$1];
    function v$16(n){return {"name":n}}
    function name$9(a){return caml_call2(_d_[2],a,cst_name$5)}
    var rsassa_pkcs1_v1_5="RSASSA-PKCS1-v1_5";
    function v$17(name,modulus_length,public_exponent,hash,param)
     {return {"name":name,
              "modulusLength":modulus_length,
              "publicExponent":public_exponent,
              "hash":hash}}
    function of_algo(_c5_){return _c5_}
    function name$10(a){return caml_call2(_d_[2],a,cst_name$6)}
    function modulus_length(a){return caml_call2(Int[2],a,cst_modulusLength)}
    function public_exponent(a){return a.publicExponent}
    function hash(a){return caml_call2(_d_[2],a,cst_hash$0)}
    var
     Rsa_hashed_key_gen_params=
      [0,v$17,of_algo,name$10,modulus_length,public_exponent,hash];
    function v$18(name,hash,param){return {"name":name,"hash":hash}}
    function of_algo$0(_c4_){return _c4_}
    function name$11(a){return caml_call2(_d_[2],a,cst_name$7)}
    function hash$0(a){return caml_call2(_d_[2],a,cst_hash$1)}
    var
     Rsa_hashed_import_params=[0,v$18,of_algo$0,name$11,hash$0],
     rsa_pss="RSA-PSS";
    function v$19(opt,salt_length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=rsa_pss;
      return {"name":name,"saltLength":salt_length}}
    function of_algo$1(_c3_){return _c3_}
    function name$12(a){return caml_call2(_d_[2],a,cst_name$8)}
    function salt_length(a){return caml_call2(Int[2],a,cst_saltLength)}
    var
     Rsa_pss_params=[0,v$19,of_algo$1,name$12,salt_length],
     rsa_oaep="RSA-OAEP";
    function v$20(opt,label,param)
     {if(opt)var sth=opt[1],name=sth;else var name=rsa_oaep;
      if(label)var l=label[1],label$0=l;else var label$0=fn;
      return {"name":name,"label":label$0}}
    function of_algo$2(_c2_){return _c2_}
    function name$13(a){return caml_call2(_d_[2],a,cst_name$9)}
    function label$3(a)
     {var _c0_=a.label;return to_option(function(_c1_){return _c1_},_c0_)}
    var Rsa_oaep_params=[0,v$20,of_algo$2,name$13,label$3],ecdsa="ECDSA";
    function v$21(name,named_curve,param)
     {return {"name":name,"namedCurve":named_curve}}
    function of_algo$3(_cZ_){return _cZ_}
    function name$14(a){return caml_call2(_d_[2],a,cst_name$10)}
    function named_curve(a){return caml_call2(_d_[2],a,cst_namedCurve)}
    var Ec_key_gen_params=[0,v$21,of_algo$3,name$14,named_curve];
    function v$22(name,named_curve,param)
     {return {"name":name,"namedCurve":named_curve}}
    function of_algo$4(_cY_){return _cY_}
    function name$15(a){return caml_call2(_d_[2],a,cst_name$11)}
    function named_curve$0(a){return caml_call2(_d_[2],a,cst_namedCurve$0)}
    var Ec_key_import_params=[0,v$22,of_algo$4,name$15,named_curve$0];
    function v$23(name,hash,param){return {"name":name,"hash":hash}}
    function of_algo$5(_cX_){return _cX_}
    function name$16(a){return caml_call2(_d_[2],a,cst_name$12)}
    function hash$1(a){return caml_call2(_d_[2],a,cst_hash$2)}
    var Ecdsa_params=[0,v$23,of_algo$5,name$16,hash$1],ecdh="ECDH";
    function v$24(name,public$0,param){return {"name":name,"public":public$0}}
    function of_algo$6(_cW_){return _cW_}
    function name$17(a){return caml_call2(_d_[2],a,cst_name$13)}
    function public$2(a){return a[caml_string_of_jsbytes("public")]}
    var
     Ecdh_key_derive_params=[0,v$24,of_algo$6,name$17,public$2],
     aes_ctr="AES-CTR";
    function v$25(name,length,param){return {"name":name,"length":length}}
    function of_algo$7(_cV_){return _cV_}
    function name$18(a){return caml_call2(_d_[2],a,cst_name$14)}
    function length$8(a){return caml_call2(Int[2],a,cst_length$9)}
    var Aes_key_gen_params=[0,v$25,of_algo$7,name$18,length$8];
    function v$26(opt,counter,length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_ctr;
      return {"name":name,"counter":counter,"length":length}}
    function of_algo$8(_cU_){return _cU_}
    function name$19(a){return caml_call2(_d_[2],a,cst_name$15)}
    function counter(a){return a.counter}
    function length$9(a){return caml_call2(Int[2],a,cst_length$10)}
    var
     Aes_ctr_params=[0,v$26,of_algo$8,name$19,counter,length$9],
     aes_cbc="AES-CBC";
    function v$27(opt,iv,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_cbc;
      return {"name":name,"iv":iv}}
    function of_algo$9(_cT_){return _cT_}
    function name$20(a){return caml_call2(_d_[2],a,cst_name$16)}
    function iv(a){return a.iv}
    var Aes_cbc_params=[0,v$27,of_algo$9,name$20,iv],aes_gcm="AES-GCM";
    function v$28(opt,iv,additional_data,tag_length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_cbc;
      if(additional_data)var a=additional_data[1],add=a;else var add=fn;
      if(tag_length)var l=tag_length[1],tlen=l;else var tlen=fn;
      return {"name":name,"iv":iv,"additionalData":add,"tagLength":tlen}}
    function of_algo$10(_cS_){return _cS_}
    function name$21(a){return caml_call2(_d_[2],a,cst_name$17)}
    function iv$0(a){return a.iv}
    function additional_data(a)
     {return find_map(function(_cR_){return _cR_},a,cst_additionalData)}
    function tag_length(a)
     {return find_map(function(_cQ_){return _cQ_},a,cst_tagLength)}
    var
     Aes_gcm_params=
      [0,v$28,of_algo$10,name$21,iv$0,additional_data,tag_length],
     aes_kw="AES-KW",
     hmac="HMAC";
    function v$29(opt,length,hash,param)
     {if(opt)var sth=opt[1],name=sth;else var name=hmac;
      if(length)var l=length[1],l$0=l;else var l$0=fn;
      return {"name":name,"hash":hash,"length":l$0}}
    function of_algo$11(_cP_){return _cP_}
    function name$22(a){return caml_call2(_d_[2],a,cst_name$18)}
    function hash$2(a){return caml_call2(_d_[2],a,cst_hash$3)}
    function length$10(a)
     {return find_map(function(_cO_){return _cO_},a,cst_length$11)}
    var
     Hmac_key_gen_params=[0,v$29,of_algo$11,name$22,hash$2,length$10],
     sha_1="SHA-1",
     sha_256="SHA-256",
     sha_384="SHA-384",
     sha_512="SHA-512",
     hkdf="HKDF";
    function v$30(opt,hash,salt,info,param)
     {if(opt)var sth=opt[1],name=sth;else var name=hkdf;
      return {"name":name,"hash":hash,"salt":salt,"info":info}}
    function of_algo$12(_cN_){return _cN_}
    function name$23(a){return caml_call2(_d_[2],a,cst_name$19)}
    function hash$3(a){return caml_call2(_d_[2],a,cst_hash$4)}
    function salt(a){return a.salt}
    function info$0(a){return a.info}
    var
     Hkdf_params=[0,v$30,of_algo$12,name$23,hash$3,salt,info$0],
     pbkdf2="PBKDF2";
    function v$31(opt,hash,salt,iterations,param)
     {if(opt)var sth=opt[1],name=sth;else var name=pbkdf2;
      return {"name":name,"hash":hash,"salt":salt,"iterations":iterations}}
    function of_algo$13(_cM_){return _cM_}
    function name$24(a){return caml_call2(_d_[2],a,cst_name$20)}
    function hash$4(a){return caml_call2(_d_[2],a,cst_hash$5)}
    function salt$0(a){return a.salt}
    function iterations(a){return caml_call2(Int[2],a,cst_iterations)}
    var Pbkdf2_params=[0,v$31,of_algo$13,name$24,hash$4,salt$0,iterations];
    function encrypt$0(s,a,k,d)
     {var _cK_=s.encrypt(a,k,d);
      return of_promise$0(function(_cL_){return _cL_},_cK_)}
    function decrypt$0(s,a,k,d)
     {var _cI_=s.decrypt(a,k,d);
      return of_promise$0(function(_cJ_){return _cJ_},_cI_)}
    function digest(s,a,d)
     {var _cG_=s.digest(a,d);
      return of_promise$0(function(_cH_){return _cH_},_cG_)}
    function sign$0(s,a,k,d)
     {var _cE_=s.sign(a,k,d);
      return of_promise$0(function(_cF_){return _cF_},_cE_)}
    function verify$0(s,a,k,sig,d)
     {return of_promise$0(caml_js_to_bool,s.verify(a,k,sig,d))}
    function generate_key(s,a,extractable,usages)
     {var _cC_=s.generateKey(a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cD_){return _cD_},_cC_)}
    function generate_key_pair(s,a,extractable,usages)
     {var _cA_=s.generateKey(a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cB_){return _cB_},_cA_)}
    function derive_bits$0(s,a,k,l)
     {var _cy_=s.deriveBits(a,k,l);
      return of_promise$0(function(_cz_){return _cz_},_cy_)}
    function derive_key$0(s,a,k,derived,extractable,usages)
     {var
       _cw_=
        s.deriveKey(a,k,derived,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cx_){return _cx_},_cw_)}
    function import_key(s,f,k,a,extractable,usages)
     {if(98868477 <= k[1])var k$0=k[2],k$1=k$0;else var b=k[2],k$1=b;
      var
       _cu_=
        s.importKey(f,k$1,a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cv_){return _cv_},_cu_)}
    function export_key(s,f,k)
     {var
       match=caml_equal(Crypto_key[3][4],f),
       ok=
        match
         ?function(v){return [0,98868477,v]}
         :function(v){return [0,86585632,v]};
      return of_promise$0(ok,s.exportKey(f,k))}
    function wrap_key$0(s,f,k,wrap_key,wrapper)
     {var _cs_=s.wrapKey(f,k,wrap_key,wrapper);
      return of_promise$0(function(_ct_){return _ct_},_cs_)}
    function unwrap_key$0(s,f,k,wrap_key,wrapper,unwrapped,extractable,usages)
     {var
       _cq_=
        s.unwrapKey
         (f,
          k,
          wrap_key,
          wrapper,
          unwrapped,
          ! ! extractable,
          caml_list_to_js_array(usages));
      return of_promise$0(function(_cr_){return _cr_},_cq_)}
    var crypto=target.crypto;
    function subtle(c){return c.subtle}
    function set_random_values(c,a){c.getRandomValues(a);return 0}
    var
     Crypto=[0,crypto,subtle,set_random_values],
     Brr_webcrypto=
      [0,
       Crypto_key,
       [0,
        v$16,
        name$9,
        rsassa_pkcs1_v1_5,
        Rsa_hashed_key_gen_params,
        Rsa_hashed_import_params,
        rsa_pss,
        Rsa_pss_params,
        rsa_oaep,
        Rsa_oaep_params,
        ecdsa,
        Ec_key_gen_params,
        Ec_key_import_params,
        Ecdsa_params,
        ecdh,
        Ecdh_key_derive_params,
        aes_ctr,
        Aes_key_gen_params,
        Aes_ctr_params,
        aes_cbc,
        Aes_cbc_params,
        aes_gcm,
        Aes_gcm_params,
        aes_kw,
        hmac,
        Hmac_key_gen_params,
        Hmac_key_gen_params,
        sha_1,
        sha_256,
        sha_384,
        sha_512,
        hkdf,
        Hkdf_params,
        pbkdf2,
        Pbkdf2_params],
       [0,
        encrypt$0,
        decrypt$0,
        digest,
        sign$0,
        verify$0,
        generate_key,
        generate_key_pair,
        derive_bits$0,
        derive_key$0,
        export_key,
        import_key,
        wrap_key$0,
        unwrap_key$0],
       Crypto];
    caml_register_global(2938,Brr_webcrypto,"Brr_webcrypto");
    var classic="classic",module="module",Type$6=[0,classic,module];
    function opts$27(type,credentials,name,param)
     {var o=obj([0]);
      caml_call3(_d_[4],o,cst_type$13,type);
      caml_call3(_d_[4],o,cst_credentials$1,credentials);
      caml_call3(_d_[4],o,cst_name$21,name);
      return o}
    var worker$0=target.Worker;
    function create$42(opt,uri)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new worker$0(uri,opts)}
    function terminate(w){w.terminate();return 0}
    function post$1(opts,w,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      w.postMessage(v,opts$0);
      return 0}
    var shared=target.SharedWorker;
    function create$43(opt,uri)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new shared(uri,opts)}
    function port$2(w){return w.port}
    function ami(param){return has(cst_WorkerGlobalScope,target)}
    function import_scripts(uris)
     {target.importScripts(caml_list_to_js_array(uris));return 0}
    function post$2(opts,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      target.postMessage(v,opts$0);
      return 0}
    function close$8(param){target.close();return 0}
    var
     G$0=[0,import_scripts,post$2,close$8],
     imports="imports",
     all$1="all",
     none$2="none",
     Update_via_cache=[0,imports,all$1,none$2],
     parsed="parsed",
     installing="installing",
     installed="installed",
     activating="activating",
     activated="activated",
     redundant="redundant",
     State$1=[0,parsed,installing,installed,activating,activated,redundant];
    function script_url(w){return w.scriptURL()}
    function state$3(w){return w.state()}
    function enable$0(p)
     {var _co_=p.enable();return of_promise$0(function(_cp_){return 0},_co_)}
    function disable$0(p)
     {var _cm_=p.disable();return of_promise$0(function(_cn_){return 0},_cm_)}
    function set_header_value(p,v)
     {var _ck_=p.setHeaderValue(v);
      return of_promise$0(function(_cl_){return 0},_ck_)}
    function get_state(p)
     {function extract(s)
       {var _cj_=caml_call2(_d_[2],s,cst_headerValue);
        return [0,caml_call2(Bool[2],s,cst_enabled$1),_cj_]}
      return of_promise$0(extract,p.getState())}
    var
     Navigation_preload_manager=
      [0,enable$0,disable$0,set_header_value,get_state];
    function installing$0(r)
     {var _ch_=r.installing;
      return to_option(function(_ci_){return _ci_},_ch_)}
    function waiting$0(r)
     {var _cf_=r.waiting;return to_option(function(_cg_){return _cg_},_cf_)}
    function active$0(r)
     {var _cd_=r.active;return to_option(function(_ce_){return _ce_},_cd_)}
    function navigation_preload(r){return r.navigationPreload}
    function scope(r){return caml_call2(_d_[2],r,cst_scope)}
    function update_via_cache(r)
     {return caml_call2(_d_[2],r,cst_updateViaCache)}
    function update(r)
     {var _cb_=r.update();return of_promise$0(function(_cc_){return 0},_cb_)}
    function unregister(r)
     {return of_promise$0(caml_js_to_bool,r.unregister())}
    function show_notification(opts,r,title)
     {var
       opts$0=of_option(fn,function(_ca_){return _ca_},opts),
       _b__=r.showNotification(title,opts$0);
      return of_promise$0(function(_b$_){return 0},_b__)}
    function get_notifications(tag,r)
     {if(tag)var tag$0=tag[1],opts={"tag":tag$0};else var opts=fn;
      var _b6_=r.getNotifications(opts);
      function _b7_(_b9_){return _b9_}
      return of_promise$0(function(_b8_){return to_list(_b7_,_b8_)},_b6_)}
    function of_navigator$2(n){return n.serviceWorker}
    function controller$0(c)
     {var _b4_=c.controller;
      return to_option(function(_b5_){return _b5_},_b4_)}
    function ready(c)
     {var _b2_=c.ready;return of_promise$0(function(_b3_){return _b3_},_b2_)}
    function register_opts(scope,type,update_via_cache,param)
     {var o={};
      caml_call3(_d_[4],o,cst_scope$0,scope);
      caml_call3(_d_[4],o,cst_type$14,type);
      caml_call3(_d_[4],o,cst_updateViaCache$0,update_via_cache);
      return o}
    function register(opt,c,uri)
     {if(opt)var sth=opt[1],register_opts=sth;else var register_opts=fn;
      var _b0_=c.register(uri,register_opts);
      return of_promise$0(function(_b1_){return _b1_},_b0_)}
    function get_registration(c,uri)
     {var
       uri$0=of_option(fn,function(_bZ_){return _bZ_},uri),
       _bV_=c.getRegistration(uri$0);
      function _bW_(_bY_){return _bY_}
      return of_promise$0(function(_bX_){return to_option(_bW_,_bX_)},_bV_)}
    function get_registrations(c)
     {var _bR_=c.getRegistrations();
      function _bS_(_bU_){return _bU_}
      return of_promise$0(function(_bT_){return to_list(_bS_,_bT_)},_bR_)}
    function start_messages(c){c.startMessages();return 0}
    var
     Container=
      [0,
       of_navigator$2,
       controller$0,
       ready,
       register_opts,
       register,
       get_registration,
       get_registrations,
       start_messages],
     hidden$2="hidden",
     visible$0="visible",
     Visibility_state$0=[0,hidden$2,visible$0],
     window$0="window",
     worker$1="worker",
     sharedworker$0="sharedworker",
     all$2="all",
     Type$7=[0,window$0,worker$1,sharedworker$0,all$2],
     auxiliary="auxiliary",
     top_level="top-level",
     nested="nested",
     none$3="none",
     Frame_type=[0,auxiliary,top_level,nested,none$3];
    function url$5(c){return caml_call2(_d_[2],c,cst_url$3)}
    function frame_type(c){return caml_call2(_d_[2],c,cst_frameType)}
    function id$5(c){return caml_call2(_d_[2],c,cst_id$1)}
    function type$13(c){return caml_call2(_d_[2],c,cst_type$15)}
    function post$3(opts,c,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      c.postMessage(v,opts$0);
      return 0}
    function visibility_state$0(w)
     {return caml_call2(_d_[2],w,cst_visibilityState$0)}
    function focused(w){return caml_call2(Bool[2],w,cst_focused)}
    function ancestor_origins(w)
     {var _bP_=w.ancestorOrigins;
      return to_list(function(_bQ_){return _bQ_},_bP_)}
    function focus$0(w)
     {var _bN_=w.focus();
      return of_promise$0(function(_bO_){return _bO_},_bN_)}
    function navigate$1(w,url)
     {var _bL_=w.focus(url);
      return of_promise$0(function(_bM_){return _bM_},_bL_)}
    var
     Window$0=
      [0,visibility_state$0,focused,ancestor_origins,focus$0,navigate$1],
     Client=
      [0,
       Visibility_state$0,
       Type$7,
       Frame_type,
       url$5,
       frame_type,
       id$5,
       type$13,
       post$3,
       Window$0];
    function query_opts$0(include_uncontrolled,type,param)
     {var o={};
      caml_call3(Bool[4],o,cst_includeUncontrolled,include_uncontrolled);
      caml_call3(_d_[4],o,cst_type$16,type);
      return o}
    function get$7(cs,id)
     {var _bH_=cs.get(id);
      function _bI_(_bK_){return _bK_}
      return of_promise$0(function(_bJ_){return to_option(_bI_,_bJ_)},_bH_)}
    function match_all$0(opt,cs)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      var _bD_=cs.matchAll(query_opts);
      function _bE_(_bG_){return _bG_}
      return of_promise$0(function(_bF_){return to_list(_bE_,_bF_)},_bD_)}
    function open_window(cs,url)
     {var _bz_=cs.openWindow(url);
      function _bA_(_bC_){return _bC_}
      return of_promise$0(function(_bB_){return to_option(_bA_,_bB_)},_bz_)}
    function claim(cs)
     {var _bx_=cs.claim();return of_promise$0(function(_by_){return 0},_bx_)}
    var
     Clients=[0,query_opts$0,get$7,match_all$0,open_window,claim],
     clients=target.clients,
     registration=target.registration,
     service_worker=target.serviceWorker;
    function skip_waiting(param)
     {var _bv_=target.skipWaiting();
      return of_promise$0(function(_bw_){return 0},_bv_)}
    var
     G$1=[0,clients,registration,service_worker,skip_waiting],
     Brr_webworkers=
      [0,
       [0,
        Type$6,
        opts$27,
        create$42,
        terminate,
        post$1,
        [0,create$43,port$2],
        ami,
        G$0],
       [0,
        Update_via_cache,
        State$1,
        script_url,
        state$3,
        Navigation_preload_manager,
        [0,
         update,
         unregister,
         show_notification,
         get_notifications,
         installing$0,
         waiting$0,
         active$0,
         navigation_preload,
         scope,
         update_via_cache],
        Container,
        Client,
        Clients,
        G$1]];
    caml_register_global(2939,Brr_webworkers,"Brr_webworkers");
    return}
  (function(){return this}()));


//# 1 "../../.js/bigarray-compat/bigarray_compat.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Stdlib_Bigarray=global_data.Stdlib__Bigarray,
     float32=Stdlib_Bigarray[1],
     float64=Stdlib_Bigarray[2],
     complex32=Stdlib_Bigarray[3],
     complex64=Stdlib_Bigarray[4],
     int8_signed=Stdlib_Bigarray[5],
     int8_unsigned=Stdlib_Bigarray[6],
     int16_signed=Stdlib_Bigarray[7],
     int16_unsigned=Stdlib_Bigarray[8],
     int$0=Stdlib_Bigarray[9],
     int32=Stdlib_Bigarray[10],
     int64=Stdlib_Bigarray[11],
     nativeint=Stdlib_Bigarray[12],
     char$0=Stdlib_Bigarray[13],
     kind_size_in_bytes=Stdlib_Bigarray[14],
     c_layout=Stdlib_Bigarray[15],
     fortran_layout=Stdlib_Bigarray[16],
     Genarray=Stdlib_Bigarray[17],
     Array0=Stdlib_Bigarray[18],
     Array1=Stdlib_Bigarray[19],
     Array2=Stdlib_Bigarray[20],
     Array3=Stdlib_Bigarray[21],
     array0_of_genarray=Stdlib_Bigarray[22],
     array1_of_genarray=Stdlib_Bigarray[23],
     array2_of_genarray=Stdlib_Bigarray[24],
     array3_of_genarray=Stdlib_Bigarray[25],
     reshape=Stdlib_Bigarray[26],
     reshape_0=Stdlib_Bigarray[27],
     reshape_1=Stdlib_Bigarray[28],
     reshape_2=Stdlib_Bigarray[29],
     reshape_3=Stdlib_Bigarray[30],
     Bigarray_compat=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       Array0,
       Array1,
       Array2,
       Array3,
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    runtime.caml_register_global(1,Bigarray_compat,"Bigarray_compat");
    return}
  (function(){return this}()));


//# 1 "../../.js/bigstringaf/bigstringaf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_uint8_get16=runtime.caml_ba_uint8_get16,
     caml_ba_uint8_get32=runtime.caml_ba_uint8_get32,
     caml_ba_uint8_get64=runtime.caml_ba_uint8_get64,
     caml_ba_uint8_set16=runtime.caml_ba_uint8_set16,
     caml_ba_uint8_set32=runtime.caml_ba_uint8_set32,
     caml_ba_uint8_set64=runtime.caml_ba_uint8_set64,
     caml_bswap16=runtime.caml_bswap16,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_memchr=caml_string_of_jsbytes("memchr"),
     cst_memchr$0=caml_string_of_jsbytes("memchr"),
     cst_memcmp_string=caml_string_of_jsbytes("memcmp_string"),
     cst_memcmp_string$0=caml_string_of_jsbytes("memcmp_string"),
     cst_memcmp_string$1=caml_string_of_jsbytes("memcmp_string"),
     cst_memcmp=caml_string_of_jsbytes("memcmp"),
     cst_memcmp$0=caml_string_of_jsbytes("memcmp"),
     cst_memcmp$1=caml_string_of_jsbytes("memcmp"),
     cst_blit_to_bytes=caml_string_of_jsbytes("blit_to_bytes"),
     cst_blit_to_bytes$0=caml_string_of_jsbytes("blit_to_bytes"),
     cst_blit_to_bytes$1=caml_string_of_jsbytes("blit_to_bytes"),
     cst_blit_from_bytes=caml_string_of_jsbytes("blit_from_bytes"),
     cst_blit_from_bytes$0=caml_string_of_jsbytes("blit_from_bytes"),
     cst_blit_from_bytes$1=caml_string_of_jsbytes("blit_from_bytes"),
     cst_blit_from_string=caml_string_of_jsbytes("blit_from_string"),
     cst_blit_from_string$0=caml_string_of_jsbytes("blit_from_string"),
     cst_blit_from_string$1=caml_string_of_jsbytes("blit_from_string"),
     cst_blit=caml_string_of_jsbytes("blit"),
     cst_blit$0=caml_string_of_jsbytes("blit"),
     cst_blit$1=caml_string_of_jsbytes("blit"),
     cst_of_string=caml_string_of_jsbytes("of_string"),
     cst_substring=caml_string_of_jsbytes("substring"),
     cst_copy=caml_string_of_jsbytes("copy"),
     partial=
      [11,
       caml_string_of_jsbytes(", len: "),
       [4,0,0,0,[11,caml_string_of_jsbytes(" }"),0]]],
     partial$0=
      [11,
       caml_string_of_jsbytes(", len: "),
       [4,0,0,0,[11,caml_string_of_jsbytes(" }"),0]]],
     Stdlib_Sys=global_data.Stdlib__Sys,
     Stdlib_Bytes=global_data.Stdlib__Bytes,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib=global_data.Stdlib,
     Bigarray_compat=global_data.Bigarray_compat,
     _c_=
      [0,
       [11,
        caml_string_of_jsbytes("Bigstringaf."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" invalid range: { buf1_len: "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", buf1_off: "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", buf2_len: "),
              [4,
               0,
               0,
               0,
               [11,caml_string_of_jsbytes(", buf2_off: "),[4,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("Bigstringaf.%s invalid range: { buf1_len: %d, buf1_off: %d, buf2_len: %d, buf2_off: %d, len: %d }")],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("Bigstringaf."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" invalid range: { src_len: "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", src_off: "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", dst_len: "),
              [4,
               0,
               0,
               0,
               [11,caml_string_of_jsbytes(", dst_off: "),[4,0,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes
        ("Bigstringaf.%s invalid range: { src_len: %d, src_off: %d, dst_len: %d, dst_off: %d, len: %d }")],
     _a_=
      [0,
       [11,
        caml_string_of_jsbytes("Bigstringaf."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" invalid range: { buffer_len: "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", off: "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", len: "),
              [4,0,0,0,[11,caml_string_of_jsbytes(" }"),0]]]]]]]]],
       caml_string_of_jsbytes
        ("Bigstringaf.%s invalid range: { buffer_len: %d, off: %d, len: %d }")];
    function create(size)
     {return caml_call3
              (Bigarray_compat[19][1],
               Bigarray_compat[13],
               Bigarray_compat[15],
               size)}
    var empty=create(0);
    function length(t){return caml_ba_dim_1(t)}
    function sub(t,off,len){return runtime.caml_ba_sub(t,off,len)}
    function invalid_bounds(op,buffer_len,off,len)
     {var message=caml_call5(Stdlib_Printf[4],_a_,op,buffer_len,off,len);
      throw [0,Stdlib[6],message]}
    function invalid_bounds_blit(op,src_len,src_off,dst_len,dst_off,len)
     {var
       message=
        caml_call7
         (Stdlib_Printf[4],_b_,op,src_len,src_off,dst_len,dst_off,len);
      throw [0,Stdlib[6],message]}
    function invalid_bounds_memcmp(op,buf1_len,buf1_off,buf2_len,buf2_off,len)
     {var
       message=
        caml_call7
         (Stdlib_Printf[4],_c_,op,buf1_len,buf1_off,buf2_len,buf2_off,len);
      throw [0,Stdlib[6],message]}
    function copy(t,off,len)
     {var buffer_len=caml_ba_dim_1(t),_aY_=len < 0?1:0;
      if(_aY_)
       var _aZ_=_aY_;
      else
       var _a0_=off < 0?1:0,_aZ_=_a0_ || ((buffer_len - off | 0) < len?1:0);
      if(_aZ_)invalid_bounds(cst_copy,buffer_len,off,len);
      var dst=create(len);
      runtime.bigstringaf_blit_to_bigstring(t,off,dst,0,len);
      return dst}
    function substring(t,off,len)
     {var buffer_len=caml_ba_dim_1(t),_aV_=len < 0?1:0;
      if(_aV_)
       var _aW_=_aV_;
      else
       var _aX_=off < 0?1:0,_aW_=_aX_ || ((buffer_len - off | 0) < len?1:0);
      if(_aW_)invalid_bounds(cst_substring,buffer_len,off,len);
      var b=caml_create_bytes(len);
      runtime.bigstringaf_blit_to_bytes(t,off,b,0,len);
      return caml_call1(Stdlib_Bytes[48],b)}
    function to_string(t)
     {var len=caml_ba_dim_1(t),b=caml_create_bytes(len);
      runtime.bigstringaf_blit_to_bytes(t,0,b,0,len);
      return caml_call1(Stdlib_Bytes[48],b)}
    function of_string(off,len,s)
     {var buffer_len=caml_ml_string_length(s),_aS_=len < 0?1:0;
      if(_aS_)
       var _aT_=_aS_;
      else
       var _aU_=off < 0?1:0,_aT_=_aU_ || ((buffer_len - off | 0) < len?1:0);
      if(_aT_)invalid_bounds(cst_of_string,buffer_len,off,len);
      var b=create(len);
      runtime.bigstringaf_blit_from_bytes(s,off,b,0,len);
      return b}
    function blit(src,src_off,dst,dst_off,len)
     {var src_len=caml_ba_dim_1(src),dst_len=caml_ba_dim_1(dst);
      if(len < 0)
       invalid_bounds_blit(cst_blit,src_len,src_off,dst_len,dst_off,len);
      var
       _aO_=src_off < 0?1:0,
       _aP_=_aO_ || ((src_len - src_off | 0) < len?1:0);
      if(_aP_)
       invalid_bounds_blit(cst_blit$0,src_len,src_off,dst_len,dst_off,len);
      var
       _aQ_=dst_off < 0?1:0,
       _aR_=_aQ_ || ((dst_len - dst_off | 0) < len?1:0);
      if(_aR_)
       invalid_bounds_blit(cst_blit$1,src_len,src_off,dst_len,dst_off,len);
      return runtime.bigstringaf_blit_to_bigstring
              (src,src_off,dst,dst_off,len)}
    function blit_from_string(src,src_off,dst,dst_off,len)
     {var src_len=caml_ml_string_length(src),dst_len=caml_ba_dim_1(dst);
      if(len < 0)
       invalid_bounds_blit
        (cst_blit_from_string,src_len,src_off,dst_len,dst_off,len);
      var
       _aK_=src_off < 0?1:0,
       _aL_=_aK_ || ((src_len - src_off | 0) < len?1:0);
      if(_aL_)
       invalid_bounds_blit
        (cst_blit_from_string$0,src_len,src_off,dst_len,dst_off,len);
      var
       _aM_=dst_off < 0?1:0,
       _aN_=_aM_ || ((dst_len - dst_off | 0) < len?1:0);
      if(_aN_)
       invalid_bounds_blit
        (cst_blit_from_string$1,src_len,src_off,dst_len,dst_off,len);
      return runtime.bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)}
    function blit_from_bytes(src,src_off,dst,dst_off,len)
     {var src_len=caml_ml_bytes_length(src),dst_len=caml_ba_dim_1(dst);
      if(len < 0)
       invalid_bounds_blit
        (cst_blit_from_bytes,src_len,src_off,dst_len,dst_off,len);
      var
       _aG_=src_off < 0?1:0,
       _aH_=_aG_ || ((src_len - src_off | 0) < len?1:0);
      if(_aH_)
       invalid_bounds_blit
        (cst_blit_from_bytes$0,src_len,src_off,dst_len,dst_off,len);
      var
       _aI_=dst_off < 0?1:0,
       _aJ_=_aI_ || ((dst_len - dst_off | 0) < len?1:0);
      if(_aJ_)
       invalid_bounds_blit
        (cst_blit_from_bytes$1,src_len,src_off,dst_len,dst_off,len);
      return runtime.bigstringaf_blit_from_bytes(src,src_off,dst,dst_off,len)}
    function blit_to_bytes(src,src_off,dst,dst_off,len)
     {var src_len=caml_ba_dim_1(src),dst_len=caml_ml_bytes_length(dst);
      if(len < 0)
       invalid_bounds_blit
        (cst_blit_to_bytes,src_len,src_off,dst_len,dst_off,len);
      var
       _aC_=src_off < 0?1:0,
       _aD_=_aC_ || ((src_len - src_off | 0) < len?1:0);
      if(_aD_)
       invalid_bounds_blit
        (cst_blit_to_bytes$0,src_len,src_off,dst_len,dst_off,len);
      var
       _aE_=dst_off < 0?1:0,
       _aF_=_aE_ || ((dst_len - dst_off | 0) < len?1:0);
      if(_aF_)
       invalid_bounds_blit
        (cst_blit_to_bytes$1,src_len,src_off,dst_len,dst_off,len);
      return runtime.bigstringaf_blit_to_bytes(src,src_off,dst,dst_off,len)}
    function memcmp(buf1,buf1_off,buf2,buf2_off,len)
     {var buf1_len=caml_ba_dim_1(buf1),buf2_len=caml_ba_dim_1(buf2);
      if(len < 0)
       invalid_bounds_memcmp
        (cst_memcmp,buf1_len,buf1_off,buf2_len,buf2_off,len);
      var
       _ay_=buf1_off < 0?1:0,
       _az_=_ay_ || ((buf1_len - buf1_off | 0) < len?1:0);
      if(_az_)
       invalid_bounds_memcmp
        (cst_memcmp$0,buf1_len,buf1_off,buf2_len,buf2_off,len);
      var
       _aA_=buf2_off < 0?1:0,
       _aB_=_aA_ || ((buf2_len - buf2_off | 0) < len?1:0);
      if(_aB_)
       invalid_bounds_memcmp
        (cst_memcmp$1,buf1_len,buf1_off,buf2_len,buf2_off,len);
      return runtime.bigstringaf_memcmp_bigstring
              (buf1,buf1_off,buf2,buf2_off,len)}
    function memcmp_string(buf1,buf1_off,buf2,buf2_off,len)
     {var buf1_len=caml_ba_dim_1(buf1),buf2_len=caml_ml_string_length(buf2);
      if(len < 0)
       invalid_bounds_memcmp
        (cst_memcmp_string,buf1_len,buf1_off,buf2_len,buf2_off,len);
      var
       _au_=buf1_off < 0?1:0,
       _av_=_au_ || ((buf1_len - buf1_off | 0) < len?1:0);
      if(_av_)
       invalid_bounds_memcmp
        (cst_memcmp_string$0,buf1_len,buf1_off,buf2_len,buf2_off,len);
      var
       _aw_=buf2_off < 0?1:0,
       _ax_=_aw_ || ((buf2_len - buf2_off | 0) < len?1:0);
      if(_ax_)
       invalid_bounds_memcmp
        (cst_memcmp_string$1,buf1_len,buf1_off,buf2_len,buf2_off,len);
      return runtime.bigstringaf_memcmp_string
              (buf1,buf1_off,buf2,buf2_off,len)}
    function memchr(buf,buf_off,chr,len)
     {var buf_len=caml_ba_dim_1(buf);
      if(len < 0)invalid_bounds(cst_memchr,buf_len,buf_off,len);
      var
       _as_=buf_off < 0?1:0,
       _at_=_as_ || ((buf_len - buf_off | 0) < len?1:0);
      if(_at_)invalid_bounds(cst_memchr$0,buf_len,buf_off,len);
      return runtime.bigstringaf_memchr(buf,buf_off,chr,len)}
    function caml_bigstring_set_16(bs,off,i)
     {return caml_ba_uint8_set16(bs,off,caml_bswap16(i))}
    function caml_bigstring_set_32(bs,off,i)
     {return caml_ba_uint8_set32(bs,off,caml_int32_bswap(i))}
    function caml_bigstring_set_64(bs,off,i)
     {return caml_ba_uint8_set64(bs,off,caml_int64_bswap(i))}
    function caml_bigstring_get_16(bs,off)
     {return caml_bswap16(caml_ba_uint8_get16(bs,off))}
    function caml_bigstring_get_32(bs,off)
     {return caml_int32_bswap(caml_ba_uint8_get32(bs,off))}
    function caml_bigstring_get_64(bs,off)
     {return caml_int64_bswap(caml_ba_uint8_get64(bs,off))}
    function get_int16_sign_extended(x,off)
     {var _aq_=Stdlib_Sys[10] - 16 | 0,_ar_=Stdlib_Sys[10] - 16 | 0;
      return caml_bigstring_get_16(x,off) << _ar_ >> _aq_}
    if(Stdlib_Sys[11])
     var _e_=caml_ba_uint8_set16,_d_=caml_bigstring_set_16;
    else
     var _e_=caml_bigstring_set_16,_d_=caml_ba_uint8_set16;
    if(Stdlib_Sys[11])
     var _g_=caml_ba_uint8_set32,_f_=caml_bigstring_set_32;
    else
     var _g_=caml_bigstring_set_32,_f_=caml_ba_uint8_set32;
    if(Stdlib_Sys[11])
     var _i_=caml_ba_uint8_set64,_h_=caml_bigstring_set_64;
    else
     var _i_=caml_bigstring_set_64,_h_=caml_ba_uint8_set64;
    if(Stdlib_Sys[11])
     var _k_=caml_ba_uint8_get16,_j_=caml_bigstring_get_16;
    else
     var _k_=caml_bigstring_get_16,_j_=caml_ba_uint8_get16;
    function get_int16_sign_extended_noswap(x,off)
     {var _ao_=Stdlib_Sys[10] - 16 | 0,_ap_=Stdlib_Sys[10] - 16 | 0;
      return caml_ba_uint8_get16(x,off) << _ap_ >> _ao_}
    if(Stdlib_Sys[11])
     var
      get_int16_sign_extended_noswap$0=get_int16_sign_extended_noswap,
      _l_=get_int16_sign_extended;
    else
     var
      get_int16_sign_extended_noswap$0=get_int16_sign_extended,
      _l_=get_int16_sign_extended_noswap;
    if(Stdlib_Sys[11])
     var _n_=caml_ba_uint8_get32,_m_=caml_bigstring_get_32;
    else
     var _n_=caml_bigstring_get_32,_m_=caml_ba_uint8_get32;
    if(Stdlib_Sys[11])
     var get_int64_be=caml_ba_uint8_get64,get_int64_le=caml_bigstring_get_64;
    else
     var get_int64_be=caml_bigstring_get_64,get_int64_le=caml_ba_uint8_get64;
    function caml_bigstring_unsafe_set_16(bs,off,i)
     {return caml_ba_uint8_set16(bs,off,caml_bswap16(i))}
    function caml_bigstring_unsafe_set_32(bs,off,i)
     {return caml_ba_uint8_set32(bs,off,caml_int32_bswap(i))}
    function caml_bigstring_unsafe_set_64(bs,off,i)
     {return caml_ba_uint8_set64(bs,off,caml_int64_bswap(i))}
    function caml_bigstring_unsafe_get_16(bs,off)
     {return caml_bswap16(caml_ba_uint8_get16(bs,off))}
    function caml_bigstring_unsafe_get_32(bs,off)
     {return caml_int32_bswap(caml_ba_uint8_get32(bs,off))}
    function caml_bigstring_unsafe_get_64(bs,off)
     {return caml_int64_bswap(caml_ba_uint8_get64(bs,off))}
    if(Stdlib_Sys[11])
     var _p_=caml_ba_uint8_set16,_o_=caml_bigstring_unsafe_set_16;
    else
     var _p_=caml_bigstring_unsafe_set_16,_o_=caml_ba_uint8_set16;
    if(Stdlib_Sys[11])
     var _r_=caml_ba_uint8_set32,_q_=caml_bigstring_unsafe_set_32;
    else
     var _r_=caml_bigstring_unsafe_set_32,_q_=caml_ba_uint8_set32;
    if(Stdlib_Sys[11])
     var _t_=caml_ba_uint8_set64,_s_=caml_bigstring_unsafe_set_64;
    else
     var _t_=caml_bigstring_unsafe_set_64,_s_=caml_ba_uint8_set64;
    if(Stdlib_Sys[11])
     var _v_=caml_ba_uint8_get16,_u_=caml_bigstring_unsafe_get_16;
    else
     var _v_=caml_bigstring_unsafe_get_16,_u_=caml_ba_uint8_get16;
    function unsafe_get_int16_sign_extended(x,off)
     {var _am_=Stdlib_Sys[10] - 16 | 0,_an_=Stdlib_Sys[10] - 16 | 0;
      return _u_(x,off) << _an_ >> _am_}
    function unsafe_get_int16_sign_extended$0(x,off)
     {var _ak_=Stdlib_Sys[10] - 16 | 0,_al_=Stdlib_Sys[10] - 16 | 0;
      return _v_(x,off) << _al_ >> _ak_}
    if(Stdlib_Sys[11])
     var _x_=caml_ba_uint8_get32,_w_=caml_bigstring_unsafe_get_32;
    else
     var _x_=caml_bigstring_unsafe_get_32,_w_=caml_ba_uint8_get32;
    if(Stdlib_Sys[11])
     var
      unsafe_get_int64_be=caml_ba_uint8_get64,
      unsafe_get_int64_le=caml_bigstring_unsafe_get_64;
    else
     var
      unsafe_get_int64_be=caml_bigstring_unsafe_get_64,
      unsafe_get_int64_le=caml_ba_uint8_get64;
    function _y_(_aj_,_ai_,_ah_,_ag_)
     {return runtime.bigstringaf_memchr(_aj_,_ai_,_ah_,_ag_)}
    function _z_(_af_,_ae_,_ad_,_ac_,_ab_)
     {return runtime.bigstringaf_memcmp_string(_af_,_ae_,_ad_,_ac_,_ab_)}
    function _A_(_aa_,_$_,___,_Z_,_Y_)
     {return runtime.bigstringaf_memcmp_bigstring(_aa_,_$_,___,_Z_,_Y_)}
    function _B_(_X_,_W_,_V_,_U_,_T_)
     {return runtime.bigstringaf_blit_to_bytes(_X_,_W_,_V_,_U_,_T_)}
    function _C_(_S_,_R_,_Q_,_P_,_O_)
     {return runtime.bigstringaf_blit_from_bytes(_S_,_R_,_Q_,_P_,_O_)}
    function _D_(_N_,_M_,_L_,_K_,_J_)
     {return runtime.bigstringaf_blit_from_bytes(_N_,_M_,_L_,_K_,_J_)}
    var
     Bigstringaf=
      [0,
       create,
       empty,
       of_string,
       copy,
       sub,
       length,
       substring,
       to_string,
       _j_,
       _l_,
       _d_,
       _m_,
       _f_,
       get_int64_le,
       _h_,
       _k_,
       get_int16_sign_extended_noswap$0,
       _e_,
       _n_,
       _g_,
       get_int64_be,
       _i_,
       blit,
       blit_from_string,
       blit_from_bytes,
       blit_to_bytes,
       memcmp,
       memcmp_string,
       memchr,
       _u_,
       _v_,
       unsafe_get_int16_sign_extended,
       unsafe_get_int16_sign_extended$0,
       _o_,
       _p_,
       _w_,
       _x_,
       _q_,
       _r_,
       unsafe_get_int64_le,
       unsafe_get_int64_be,
       _s_,
       _t_,
       function(_I_,_H_,_G_,_F_,_E_)
        {return runtime.bigstringaf_blit_to_bigstring(_I_,_H_,_G_,_F_,_E_)},
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_];
    runtime.caml_register_global(31,Bigstringaf,"Bigstringaf");
    return}
  (function(){return this}()));


//# 1 "../../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_exn_with_js_backtrace=runtime.caml_exn_with_js_backtrace,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_copy=caml_string_of_jsbytes("copy"),
     cst_cut=caml_string_of_jsbytes("cut"),
     cst_paste=caml_string_of_jsbytes("paste"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.11.0"),
     git_version=caml_string_of_jsbytes("25a3fa7"),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_String=global_data.Stdlib__String,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib=global_data.Stdlib,
     Stdlib_Callback=global_data.Stdlib__Callback,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Uchar=global_data.Stdlib__Uchar,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Js_of_ocaml=[0];
    caml_register_global(1632,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _f_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _g_=[0,caml_string_of_jsbytes("transparent")],
     _h_=[0,caml_string_of_jsbytes("native")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2828,58],
     _k_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2827,61],
     _j_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _n_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _m_=[0,1],
     _o_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _p_=[0,caml_string_of_jsbytes(""),0],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cm_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_String[1],
     init=Stdlib_String[2],
     empty=Stdlib_String[3],
     of_bytes=Stdlib_String[4],
     to_bytes=Stdlib_String[5],
     concat=Stdlib_String[6],
     cat=Stdlib_String[7],
     compare$0=Stdlib_String[9],
     starts_with=Stdlib_String[10],
     ends_with=Stdlib_String[11],
     contains_from=Stdlib_String[12],
     rcontains_from=Stdlib_String[13],
     contains=Stdlib_String[14],
     sub=Stdlib_String[15],
     split_on_char=Stdlib_String[16],
     map=Stdlib_String[17],
     mapi=Stdlib_String[18],
     fold_left=Stdlib_String[19],
     fold_right=Stdlib_String[20],
     for_all=Stdlib_String[21],
     exists=Stdlib_String[22],
     trim=Stdlib_String[23],
     escaped=Stdlib_String[24],
     uppercase_ascii=Stdlib_String[25],
     lowercase_ascii=Stdlib_String[26],
     capitalize_ascii=Stdlib_String[27],
     uncapitalize_ascii=Stdlib_String[28],
     iter=Stdlib_String[29],
     iteri=Stdlib_String[30],
     index_from=Stdlib_String[31],
     index_from_opt=Stdlib_String[32],
     rindex_from=Stdlib_String[33],
     rindex_from_opt=Stdlib_String[34],
     index=Stdlib_String[35],
     index_opt=Stdlib_String[36],
     rindex=Stdlib_String[37],
     rindex_opt=Stdlib_String[38],
     to_seq=Stdlib_String[39],
     to_seqi=Stdlib_String[40],
     of_seq=Stdlib_String[41],
     blit=Stdlib_String[42],
     copy=Stdlib_String[43],
     fill=Stdlib_String[44],
     uppercase=Stdlib_String[45],
     lowercase=Stdlib_String[46],
     capitalize=Stdlib_String[47],
     uncapitalize=Stdlib_String[48],
     get_uint8=Stdlib_String[49],
     get_int8=Stdlib_String[50],
     get_uint16_ne=Stdlib_String[51],
     get_uint16_be=Stdlib_String[52],
     get_uint16_le=Stdlib_String[53],
     get_int16_ne=Stdlib_String[54],
     get_int16_be=Stdlib_String[55],
     get_int16_le=Stdlib_String[56],
     get_int32_ne=Stdlib_String[57],
     get_int32_be=Stdlib_String[58],
     get_int32_le=Stdlib_String[59],
     get_int64_ne=Stdlib_String[60],
     get_int64_be=Stdlib_String[61],
     get_int64_le=Stdlib_String[62];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       compare$0,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       equal$0],
     chr=Stdlib_Char[1],
     escaped$0=Stdlib_Char[2],
     lowercase$0=Stdlib_Char[3],
     uppercase$0=Stdlib_Char[4],
     lowercase_ascii$0=Stdlib_Char[5],
     uppercase_ascii$0=Stdlib_Char[6],
     compare$1=Stdlib_Char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1635,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t39=undefined;
    function return$0(_gH_){return _gH_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gG_=1 - (x == no_handler?1:0);return _gG_?caml_call1(f,x):_gG_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gF_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gF_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gE_){return _gE_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gD_=x !== t39?1:0;return _gD_?caml_call1(f,x):_gD_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gC_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gC_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gA_(param){return caml_call1(g,x)}
      var _gB_=caml_call1(f,x);
      return caml_call2(Opt[8],_gB_,_gA_)}
    function coerce_opt(x,f,g)
     {function _gy_(param){return caml_call1(g,x)}
      var _gz_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gz_,_gy_)}
    var
     t25=true,
     t4=false,
     string_constr=Unsafe[1].String,
     t11=Unsafe[1].RegExp,
     t4$0=Unsafe[1].Object;
    function object_keys(t3){return t4$0.keys(t3)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gx_){return _gx_}
    function match_result(_gw_){return _gw_}
    var
     t121=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_Callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_Printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_Printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var
       t25=object_keys(obj),
       t24=
        caml_js_wrap_callback
         (function(key,param,_gv_){return export_js(key,obj[key])});
      return t25.forEach(t24)}
    var _c_=runtime.caml_js_error_of_exception,_d_=caml_exn_with_js_backtrace;
    function _e_(_gu_){return _gu_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gt_){return _gt_},
       t39,
       _e_,
       Opt,
       Optdef,
       t25,
       t4,
       string_constr,
       t11,
       t11,
       t11,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       _d_,
       _c_,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1639,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gs_=nodeList.item(i),match=caml_call1(Opt[10],_gs_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_List[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gp_(param)
       {function _gr_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gr_)}
      var target=caml_call2(Opt[8],e.target,_gp_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gq_=function(param){throw [0,Assert_failure,_f_]};
          return caml_call2(Opt[8],target.parentNode,_gq_)}
        return target}
      return target}
    function make$0(s){return caml_jsstring_of_string(s)}
    var Event=[0,make$0];
    function addEventListenerWithOptions(t50,t47,capture,once,passive,t48)
     {if(t50.addEventListener === t39)
       {var
         t34="on".concat(t47),
         t35=
          function(e)
           {var _gm_=[0,t48,e,[0]];
            return function(_gn_,_go_)
             {return runtime.caml_js_call(_gm_,_gn_,_go_)}};
        t50.attachEvent(t34,t35);
        return function(param){return t50.detachEvent(t34,t35)}}
      var t49={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return t49.capture = b});
      iter(once,function(b){return t49.once = b});
      iter(passive,function(b){return t49.passive = b});
      t50.addEventListener(t47,t48,t49);
      return function(param){return t50.removeEventListener(t47,t48,t49)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,t62)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var t63={};
      opt_iter(function(x){return t63.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return t63.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return t63.detail = x},detail);
      var t64=Unsafe[1].CustomEvent;
      return new t64(t62,t63)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1642,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     t11$0=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set;
    function get$1(a,i){return a[i]}
    function unsafe_get(a,i){return a[i]}
    var dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new t11$0(ab);return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1643,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var t3=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gi_=0;
      if(endings)
       var _gj_=116179762 <= endings[1]?_g_:_h_,_gk_=_gj_;
      else
       var _gk_=0;
      var
       _gl_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gk_],_gi_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gl_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_Array[12],options))
         :t39,
       t1=caml_js_from_array(a);
      return new t3(t1,options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gg_(param)
       {var _gh_=param[1];
        if(155580615 === _gh_){var s=param[2];return s}
        if(486041214 <= _gh_)
         {if(1037850489 <= _gh_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gh_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_List[19],_gg_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_Array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof t3?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gf_){return _gf_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1645,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     copy$0=caml_call1(Event[1],cst_copy),
     cut=caml_call1(Event[1],cst_cut),
     paste=caml_call1(Event[1],cst_paste),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gd_(o){return o}
      function _ge_(param)
       {var t8=loc.protocol,t7=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,t8.length,0)
          &&
          caml_call2(symbol$8,t7.length,0))
         return "";
        var t13=t8.concat("//",t7);
        if(caml_call2(symbol$9,port.length,0))
         {var t12=loc.port;return t13.concat(":",t12)}
        return t13}
      return caml_call3(Optdef[7],loc.origin,_ge_,_gd_)}
    var _i_=Unsafe[1],t22=_i_.document;
    function getElementById(id)
     {function _ga_(pnode){return pnode}
      function _gb_(param){throw Stdlib[8]}
      var t15=caml_jsstring_of_string(id),_gc_=t22.getElementById(t15);
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function getElementById_exn(id)
     {function _f8_(pnode){return pnode}
      function _f9_(param)
       {var _f$_=caml_call2(Stdlib_Printf[4],_j_,id);
        return caml_call1(Stdlib[2],_f$_)}
      var t17=caml_jsstring_of_string(id),_f__=t22.getElementById(t17);
      return caml_call3(Opt[7],_f__,_f9_,_f8_)}
    function getElementById_opt(id)
     {var t19=caml_jsstring_of_string(id),_f7_=t22.getElementById(t19);
      return caml_call1(Opt[10],_f7_)}
    function getElementById_coerce(id,coerce)
     {function _f3_(e)
       {var _f6_=caml_call1(coerce,e);return caml_call1(Opt[10],_f6_)}
      function _f4_(param){return 0}
      var t21=caml_jsstring_of_string(id),_f5_=t22.getElementById(t21);
      return caml_call3(Opt[7],_f5_,_f4_,_f3_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(t24,name)
     {var t23=caml_jsstring_of_string(name);return t24.createElement(t23)}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _fX_=createElementSyntax[1];
        if(785140586 === _fX_)
         {try
           {var
             el=t22.createElement('<input name="x">'),
             _f0_=el.tagName.toLowerCase() === "input"?1:0,
             _f1_=_f0_?el.name === "x"?1:0:_f0_,
             _fY_=_f1_}
          catch(_f2_){var _fY_=0}
          var _fZ_=_fY_?982028505:-1003883683;
          createElementSyntax[1] = _fZ_;
          continue}
        if(982028505 <= _fX_)
         {var t40=new array_length();
          t40.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t)
             {var t34=caml_js_html_escape(t);
              t40.push(' type="',t34,'"');
              return 0});
          opt_iter
           (name,
            function(n)
             {var t38=caml_js_html_escape(n);
              t40.push(' name="',t38,'"');
              return 0});
          t40.push(">");
          return doc.createElement(t40.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var t56=e.tagName,_fW_=caml_jsstring_of_string(tag);
      return t56.toLowerCase() === _fW_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fT_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fU_=function(param){throw [0,Assert_failure,_k_]};
          return caml_call2(Optdef[8],e.fromElement,_fU_)}
        function _fV_(param){throw [0,Assert_failure,_l_]}
        return caml_call2(Optdef[8],e.toElement,_fV_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fT_)}
    function eventAbsolutePosition(e)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fP_(x)
       {function _fR_(y){return [0,x,y]}
        function _fS_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fS_,_fR_)}
      function _fQ_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fQ_,_fP_)}
    function elementClientPosition(e)
     {var r=e.getBoundingClientRect(),body=t22.body,html=t22.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fN_(x){return x}
      function _fO_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fO_,_fN_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var t95=createDiv(t22);
      t95.setAttribute("onmousewheel","return;");
      if(typeof t95.onmousewheel === "function")
       {var
         _fJ_=
          handler
           (function(e)
             {function _fL_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fL_) | 0) / 40 | 0;
              function _fM_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fM_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[14],capture,once,passive,_fJ_)}
      var
       _fK_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[15],capture,once,passive,_fK_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fI_=switcher;
        if(67 <= _fI_)
         switch(_fI_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fI_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fB_=evt.keyCode;
      function _fC_(_fH_){return run_next(_fB_,try_key_code_normal,_fH_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fD_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fy_=evt.keyCode,
           _fD_=function(_fF_){return run_next(_fy_,try_key_code_left,_fF_)};
          break;
         case 1:
          var
           _fz_=evt.keyCode,
           _fD_=function(_fE_){return run_next(_fz_,try_key_code_right,_fE_)};
          break;
         default:
          var
           _fA_=evt.keyCode,
           _fD_=function(_fG_){return run_next(_fA_,try_key_code_numpad,_fG_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fD_),
               _fC_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fw_=[0,caml_call1(Stdlib_Uchar[8],value)];return _fw_}
       catch(_fx_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var t109=caml_call2(Optdef[8],evt.key,empty_string),match=t109.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(t109.charCodeAt(0) | 0):0}
    function element$1(_fv_){return _fv_}
    function tagged(e)
     {var t111=e.tagName,tag=caml_string_of_jsbytes(t111.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _ft_(e){return [0,tagged(e)]}
      function _fu_(param){return 0}
      return caml_call3(Opt[7],e,_fu_,_ft_)}
    function taggedEvent(ev)
     {function _fe_(ev){return [0,ev]}
      function _ff_(param)
       {function _fh_(ev){return [1,ev]}
        function _fi_(param)
         {function _fk_(ev){return [2,ev]}
          function _fl_(param)
           {function _fn_(ev){return [3,ev]}
            function _fo_(param)
             {function _fq_(ev){return [4,ev]}
              function _fr_(param){return [5,ev]}
              var _fs_=popStateEvent(ev);
              return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
            var _fp_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fp_,_fo_,_fn_)}
          var _fm_=wheelEvent(ev);
          return caml_call3(Opt[7],_fm_,_fl_,_fk_)}
        var _fj_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fj_,_fi_,_fh_)}
      var _fg_=mouseEvent(ev);
      return caml_call3(Opt[7],_fg_,_ff_,_fe_)}
    function opt_taggedEvent(ev)
     {function _fc_(ev){return [0,taggedEvent(ev)]}
      function _fd_(param){return 0}
      return caml_call3(Opt[7],ev,_fd_,_fc_)}
    function stopPropagation(ev)
     {function _fa_(param){return ev.stopPropagation()}
      function _fb_(param){return ev.cancelBubble = t25}
      return caml_call3(Optdef[7],ev.stopPropagation,_fb_,_fa_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _i_.requestAnimationFrame,
             [0,
              _i_.mozRequestAnimationFrame,
              [0,
               _i_.webkitRequestAnimationFrame,
               [0,
                _i_.oRequestAnimationFrame,
                [0,_i_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e9_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_List[38],_e9_,l),
             _e__=function(callback){return req(callback)};
            return _e__}
          catch(_e$_)
           {_e$_ = caml_wrap_exception(_e$_);
            if(_e$_ === Stdlib[8])
             {var
               now=function(param){var t122=new t121();return t122.getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _i_.setTimeout(callback,dt$0);
                return 0}}
            throw _e$_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_i_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var
         cb=remain == 0.?callback:function(_e8_){return loop(remain,_e8_)},
         t130=caml_js_wrap_callback(cb);
        id[1] = [0,_i_.setTimeout(t130,step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e7_=id[1];
      if(_e7_){var x=_e7_[1];id[1] = 0;return _i_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       t22,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _i_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1648,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e5_=caml_call2(symbol$9,elt.name.length,0),
       _e6_=_e5_?1 - (elt.disabled | 0):_e5_;
      return _e6_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eT_(i)
       {var t34=form.elements,_e4_=t34.item(i);
        return caml_call1(Opt[10],_e4_)}
      var
       _eU_=caml_call2(Stdlib_Array[2],length,_eT_),
       elements=caml_call1(Stdlib_Array[11],_eU_);
      function _eV_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                t20=v$0.type,
                match=caml_string_of_jsbytes(t20.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && match$1[1])
                      {var
                        _eZ_=function(t28){return list.item(t28)},
                        _e0_=caml_call2(Stdlib_Array[2],list.length,_eZ_),
                        _e1_=caml_call1(Stdlib_Array[11],_e0_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e1_)}
                     var _e2_=list.item(0),match$2=caml_call1(Opt[10],_e2_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eX_=
                   function(i)
                    {var t13=v$1.options,_e3_=t13.item(i);
                     return caml_call1(Opt[10],_e3_)},
                  options=caml_call2(Stdlib_Array[2],v$1.options.length,_eX_),
                  _eY_=caml_call1(Stdlib_Array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eY_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eW_=caml_call2(Stdlib_List[19],_eV_,elements),
       contents=caml_call1(Stdlib_List[14],_eW_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eR_=form_elt[2],_eS_=form_elt[1];
      if(781515420 <= _eR_[1])
       {var file=_eR_[2],t38=caml_jsstring_of_string(_eS_);
        return f.append(t38,file)}
      var s=_eR_[2],t35=caml_jsstring_of_string(_eS_);
      return f.append(t35,s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eO_=form_elements(0,form);
      function _eP_(_eQ_){return append(contents,_eQ_)}
      caml_call2(Stdlib_List[17],_eP_,_eO_);
      return contents}
    function get_form_contents(form)
     {var _eL_=form_elements(_m_,form);
      function _eM_(param)
       {var _eN_=param[2];
        if(typeof _eN_ !== "number" && -976970511 === _eN_[1])
         {var s=_eN_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_n_]}
      return caml_call2(Stdlib_List[19],_eM_,_eL_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1649,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1650,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var t2=Unsafe[1].Worker;
    function create(script)
     {var t1=caml_jsstring_of_string(script);return new t2(t1)}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var _eI_=caml_call1(Stdlib_Array[12],scripts);
      function _eJ_(s){return caml_jsstring_of_string(s)}
      var _eK_=caml_call2(Stdlib_Array[15],_eJ_,_eI_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eK_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(t10)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(t10)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1651,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1652,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":t25,
       "depth":t25,
       "stencil":t4,
       "antialias":t25,
       "premultipliedAlpha":t4,
       "preserveDrawingBuffer":t4,
       "preferLowPowerToHighPerformance":t4,
       "failIfMajorPerformanceCaveat":t4},
     webglcontextlost=caml_call1(Event$0[86],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[86],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[86],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(t3)
     {var ctx=t3.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:t3.getContext("experimental-webgl")}
    function getContextWithAttributes(t9,t8)
     {var ctx=t9.getContext("webgl",t8);
      return caml_call1(Opt[5],ctx)?ctx:t9.getContext("experimental-webgl",t8)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1653,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {var t0=caml_jsbytes_of_string(s);return new t11(t0,"g")}
    function regexp_case_fold(s)
     {var t3=caml_jsbytes_of_string(s);return new t11(t3,"gi")}
    function regexp_with_flag(s,f)
     {var
       t7=caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)),
       t6=caml_jsbytes_of_string(s);
      return new t11(t6,t7)}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_o_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       t11=caml_jsbytes_of_string(s),
       _eF_=r.exec(t11),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      var t15=caml_jsbytes_of_string(s);
      function _eC_(res){return [0,res.index,res]}
      var _eD_=r.exec(t15),_eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eB_)}
    var t21=new t11("[$]","g");
    function quote_repl(s)
     {var t23=caml_jsbytes_of_string(s);return t23.replace(t21,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var t27=quote_repl(s_by),t28=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t28.replace(r,t27))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       t32=r.source,
       t35=new t11(t32,flags),
       t36=quote_repl(s_by),
       t37=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t37.replace(t35,t36))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      var t42=caml_jsbytes_of_string(s);
      return list_of_js_array(t42.split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      var t47=caml_jsbytes_of_string(s);
      return list_of_js_array(t47.split(r,i))}
    var t48=regexp(cst);
    function quote(s)
     {var t50=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t50.replace(t48,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1654,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var plus_re=regexp_string(cst$0),t14=new t11("\\+","g");
    function urldecode_js_string_string(s)
     {t14.lastIndex = 0;
      return caml_string_of_jsbytes(unescape(s.replace(t14," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ez_=caml_call3(String[30],s,i,47),j=_ez_}
        catch(_eA_)
         {_eA_ = caml_wrap_exception(_eA_);
          if(_eA_ !== Stdlib[8])throw _eA_;
          var j=l}
        var word=caml_call3(String[14],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ey_=a[2];
        if(! _ey_)return 0;
        if(! caml_string_notequal(_ey_[1],cst$3) && ! _ey_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _et_(param)
       {var
         v=param[2],
         n=param[1],
         _ev_=urlencode(0,v),
         _ew_=caml_call2(Stdlib[28],cst$4,_ev_),
         _ex_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ex_,_ew_)}
      var _eu_=caml_call2(Stdlib_List[19],_et_,l);
      return caml_call2(String[6],cst$5,_eu_)}
    function decode_arguments_js_string(s)
     {var
       t0=caml_jsstring_of_string(caml_call2(String[1],1,38)),
       arr=s.split(t0),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _el_=idx$0 - 1 | 0,
             _em_=
              function(s)
               {function _er_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _es_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_es_]}
                var
                 t2=caml_jsstring_of_string(caml_call2(String[1],1,61)),
                 t5=s.indexOf(t2);
                if(caml_call2(symbol$5,t5,0))
                 var _eq_=t39;
                else
                 var
                  t7=t5 + 1 | 0,
                  _ep_=s.slice(t7),
                  _eq_=[0,s.slice(0,t5),_ep_];
                return caml_call3(Optdef[7],_eq_,interrupt,_er_)},
             _en_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_em_),acc],_el_);
            return _en_}
          catch(_eo_)
           {_eo_ = caml_wrap_exception(_eo_);
            if(_eo_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _eo_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     t19=caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0),
     t24=new t11(t19),
     t21$0=caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee),
     t26=new t11(t21$0);
    function url_of_js_string(s)
     {function _d4_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ec_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ec_)),
             _ed_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ee_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ed_)),
             _ef_=function(param){return caml_jsbytes_of_string(cst$9)},
             _eg_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ef_)),
             _eh_=path_of_path_string(path_str),
             _ei_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_ei_)),
             _ej_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ej_,
               _eh_,
               path_str,
               _eg_,
               _ee_],
             _ek_=ssl?[1,url]:[0,url];
            return [0,_ek_]}}
        throw Not_an_http_protocol}
      function _d5_(param)
       {function _d7_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d__(param){return caml_jsbytes_of_string(cst$11)}
          var _d$_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d__));
          function _ea_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _eb_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ea_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_eb_,_d$_]]]}
        function _d8_(param){return 0}
        var _d9_=t26.exec(s);
        return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
      var _d6_=t24.exec(s);
      return caml_call3(Opt[7],_d6_,_d5_,_d4_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dr_=urlencode(0,frag),_ds_=caml_call2(Stdlib[28],cst$14,_dr_);
         else
          var _ds_=cst$21;
         if(args)
          var
           _dt_=encode_arguments(args),
           _du_=caml_call2(Stdlib[28],cst$15,_dt_);
         else
          var _du_=cst$20;
         var
          _dv_=caml_call2(Stdlib[28],_du_,_ds_),
          _dw_=function(x){return urlencode(0,x)},
          _dx_=caml_call2(Stdlib_List[19],_dw_,path),
          _dy_=caml_call2(String[6],cst$16,_dx_),
          _dz_=caml_call2(Stdlib[28],_dy_,_dv_),
          _dA_=caml_call2(Stdlib[28],cst$17,_dz_);
         if(80 === port)
          var _dB_=cst$18;
         else
          var
           _dF_=caml_call1(Stdlib[33],port),
           _dB_=caml_call2(Stdlib[28],cst$19,_dF_);
         var
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_),
          _dD_=urlencode(0,host),
          _dE_=caml_call2(Stdlib[28],_dD_,_dC_);
         return caml_call2(Stdlib[28],cst_http$1,_dE_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dG_=urlencode(0,frag$0),
           _dH_=caml_call2(Stdlib[28],cst$23,_dG_);
         else
          var _dH_=cst$30;
         if(args$0)
          var
           _dI_=encode_arguments(args$0),
           _dJ_=caml_call2(Stdlib[28],cst$24,_dI_);
         else
          var _dJ_=cst$29;
         var
          _dK_=caml_call2(Stdlib[28],_dJ_,_dH_),
          _dL_=function(x){return urlencode(0,x)},
          _dM_=caml_call2(Stdlib_List[19],_dL_,path$0),
          _dN_=caml_call2(String[6],cst$25,_dM_),
          _dO_=caml_call2(Stdlib[28],_dN_,_dK_),
          _dP_=caml_call2(Stdlib[28],cst$26,_dO_);
         if(443 === port$0)
          var _dQ_=cst$27;
         else
          var
           _dU_=caml_call1(Stdlib[33],port$0),
           _dQ_=caml_call2(Stdlib[28],cst$28,_dU_);
         var
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_),
          _dS_=urlencode(0,host$0),
          _dT_=caml_call2(Stdlib[28],_dS_,_dR_);
         return caml_call2(Stdlib[28],cst_https$1,_dT_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dV_=urlencode(0,frag$1),
           _dW_=caml_call2(Stdlib[28],cst$32,_dV_);
         else
          var _dW_=cst$36;
         if(args$1)
          var
           _dX_=encode_arguments(args$1),
           _dY_=caml_call2(Stdlib[28],cst$33,_dX_);
         else
          var _dY_=cst$35;
         var
          _dZ_=caml_call2(Stdlib[28],_dY_,_dW_),
          _d0_=function(x){return urlencode(0,x)},
          _d1_=caml_call2(Stdlib_List[19],_d0_,path$1),
          _d2_=caml_call2(String[6],cst$34,_d1_),
          _d3_=caml_call2(Stdlib[28],_d2_,_dZ_);
         return caml_call2(Stdlib[28],cst_file$2,_d3_)}}
    var _q_=caml_call1(Optdef[2],_i_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_i_.location;
    else
     var
      t42=function(param,_dq_){return 0},
      t41=function(param,_dp_){return 0},
      t40=function(param){return 0},
      _r_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _dn_=[0,caml_int_of_string(caml_string_of_jsbytes(_r_.port))];
           return _dn_}
         catch(_do_)
          {_do_ = caml_wrap_exception(_do_);
           if(_do_[1] === Stdlib[7])return 0;
           throw _do_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     t49=_r_.search;
    if(t49.charAt(0) === "?")
     var t52=_r_.search,_t_=t52.slice(1);
    else
     var _t_=_r_.search;
    var arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _dk_(res){return caml_string_of_jsstring(res[1])}
      function _dl_(param){return cst$37}
      var t57=new t11("#(.*)"),t58=_r_.href,_dm_=t58.match(t57);
      return caml_call3(Opt[7],_dm_,_dl_,_dk_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1656,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1657,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    function unmount(path){return runtime.caml_unmount(path)}
    if(caml_call2(String[62],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cn_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cn_);
    var
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dj_){return runtime.caml_list_mount_point(_dj_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1658,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var t2$0=Unsafe[1].ResizeObserver;
    function is_supported$0(param){return caml_call1(Optdef[5],t2$0)}
    function observe(node,f,box,param)
     {var t1=caml_js_wrap_callback(f),t4=new t2$0(t1);
      if(box)
       {var box$0=box[1],t8={};t8.box = box$0;t4.observe(node,t8)}
      else
       t4.observe(node);
      return t4}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,t2$0,is_supported$0,observe];
    caml_register_global
     (1659,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var t2$1=Unsafe[1].MutationObserver;
    function is_supported$1(param){return caml_call1(Optdef[5],t2$1)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var t1=caml_js_wrap_callback(f),t19=new t2$1(t1),t18={};
      opt_iter(child_list,function(v){return t18.childList = v});
      opt_iter(attributes,function(v){return t18.attributes = v});
      opt_iter(character_data,function(v){return t18.characterData = v});
      opt_iter(subtree,function(v){return t18.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return t18.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return t18.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return t18.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_Array[12],l))});
      t19.observe(node,t18);
      return t19}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,t2$1,is_supported$1,observe$0];
    caml_register_global
     (1660,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var t1=Unsafe[1].Object;
    function create$0(param){return new t1()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       t10=Unsafe[1].Object,
       key_array=t10.keys(t),
       res=[0,0],
       _df_=key_array.length - 1 | 0,
       _de_=0;
      if(! (_df_ < 0))
       {var i=_de_;
        for(;;)
         {var
           _dg_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           t15=caml_call2(Optdef[8],key_array[i],_dg_),
           t14=t15.length - 1 | 0,
           _dh_=res[1];
          res[1] = [0,t15.substring(0,t14),_dh_];
          var _di_=i + 1 | 0;
          if(_df_ !== i){var i=_di_;continue}
          break}}
      return caml_call1(Stdlib_List[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1661,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var t12=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var t3$0=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(t2){return t12.parse(t2,t3$0)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function t11$1(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(t10){return t12.stringify(t10,t11$1)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1662,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _dd_=param;
      if(74 <= _dd_)
       {if(111 <= _dd_)
         switch(_dd_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_dd_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _dd_)
       switch(_dd_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_dd_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _dc_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_dc_]}
    function rgb_of_name(param)
     {var _db_=param;
      if(74 <= _db_)
       {if(111 <= _db_)
         switch(_db_)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_db_)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _db_)
       switch(_db_)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_db_)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_Printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_Printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_Printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_Printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_Printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_Printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c9_=caml_call2(symbol$5,i,0),
         _c__=_c9_ || caml_call2(symbol$9,i,255);
        if(_c__)
         {var
           _c$_=caml_call1(Stdlib[33],i),
           _da_=caml_call2(Stdlib[28],_c$_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_da_]}
        return _c__}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_Printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       t0=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d),
       t13=new t11(t0),
       t2=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0),
       t17=new t11(t2),
       t4=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d),
       t15=new t11(t4),
       t6=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0),
       t19=new t11(t6),
       t8=caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d),
       t21=new t11(t8),
       t10=caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d),
       t23=new t11(t10);
      if
       (!
        (t13.test(s) | 0)
        &&
        !
        (t15.test(s) | 0)
        &&
        !
        (t17.test(s) | 0)
        &&
        !
        (t19.test(s) | 0)
        &&
        !
        (t21.test(s) | 0)
        &&
        !
        (t23.test(s) | 0))
       {var _c6_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_List[36],_c6_,_b6_))return s;
        var
         _c7_=caml_string_of_jsstring(s),
         _c8_=caml_call2(Stdlib[28],_c7_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c8_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cT_=[0,name_of_string(s)];return _cT_}
      catch(_cU_)
       {_cU_ = caml_wrap_exception(_cU_);
        if(_cU_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c5_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c5_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c3_=caml_int_of_string(i);return _c3_}
                catch(_c4_)
                 {_c4_ = caml_wrap_exception(_c4_);
                  if(_c4_[1] === Stdlib[6])
                   var s=_c4_[2];
                  else
                   {if(_c4_[1] !== Stdlib[7])throw _c4_;var s=_c4_[2]}
                  var
                   _c0_=caml_call2(Stdlib[28],cst$39,s),
                   _c1_=caml_call2(Stdlib[28],i,_c0_),
                   _c2_=caml_call2(Stdlib[28],cst_color_conversion_error,_c1_);
                  throw [0,Stdlib[6],_c2_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cY_=caml_float_of_string(f);return _cY_}
              catch(_cZ_)
               {_cZ_ = caml_wrap_exception(_cZ_);
                if(_cZ_[1] === Stdlib[6])
                 var s=_cZ_[2];
                else
                 {if(_cZ_[1] !== Stdlib[7])throw _cZ_;var s=_cZ_[2]}
                var
                 _cV_=caml_call2(Stdlib[28],cst$40,s),
                 _cW_=caml_call2(Stdlib[28],f,_cV_),
                 _cX_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cW_);
                throw [0,Stdlib[6],_cX_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cB_=match$0[1];
              if(! caml_string_notequal(_cB_,cst_rgb))
               {if(alpha)return fail(0);
                var _cF_=i_of_s_o(blue),_cG_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cG_,_cF_]]}
              if(! caml_string_notequal(_cB_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cC_=f_of_s(a),
                   _cD_=i_of_s_o(blue),
                   _cE_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cE_,_cD_,_cC_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cH_=match$2[1];
              if(! caml_string_notequal(_cH_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cL_=i_of_s_o(blue$0),_cM_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cM_,_cL_]]}
              if(! caml_string_notequal(_cH_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cI_=f_of_s(a$0),
                   _cJ_=i_of_s_o(blue$0),
                   _cK_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cK_,_cJ_,_cI_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cN_=match$4[1];
              if(! caml_string_notequal(_cN_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cR_=i_of_s_o(blue$1),_cS_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cS_,_cR_]]}
              if(! caml_string_notequal(_cN_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cO_=f_of_s(a$1),
                   _cP_=i_of_s_o(blue$1),
                   _cQ_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cQ_,_cP_,_cO_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cU_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_Printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_Printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_Printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_Printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_Printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_Printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_Printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_Printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_Printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_Printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_Printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_Printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_Printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_Printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[62],s,cst_0$0))return 0;
      function fail(param)
       {var _cA_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cA_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cy_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cx_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cx_]}
            throw exn}
          var f$0=_cy_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cz_=match$1[1],switch$0=caml_string_compare(_cz_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cz_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cz_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cz_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cz_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cz_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cz_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cz_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cz_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cz_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cz_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cz_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cz_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cz_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_Printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_Printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_Printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_Printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cw_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cw_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _ct_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_ct_]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1];
          if(! caml_string_notequal(_cv_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cv_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cv_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cv_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1663,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cs_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cs_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1664,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     t0="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(t2,name)
     {var t1=caml_jsstring_of_string(name);
      return t2.createElementNS("http://www.w3.org/2000/svg",t1)}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$0=Unsafe[1].document;
    function getElementById$0(id)
     {function _cp_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cq_(param){throw Stdlib[8]}
      var
       t6=caml_jsstring_of_string(id),
       t7=Unsafe[1].document,
       _cr_=t7.getElementById(t6);
      return caml_call3(Opt[7],_cr_,_cq_,_cp_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var t9=e.tagName,_co_=caml_jsstring_of_string(tag);
      return t9.toLowerCase() === _co_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       t0,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$0,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1665,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1666,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1667,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1668,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$3(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$3,
       intersectionObserver_unsafe];
    caml_register_global
     (1669,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":t4,
              "numeric":t4,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":t25,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$4(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$4];
    caml_register_global(1670,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1671,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 "../../.js/result/result.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Stdlib_Result=global_data.Stdlib__Result,
     ok=Stdlib_Result[1],
     error=Stdlib_Result[2],
     value=Stdlib_Result[3],
     get_ok=Stdlib_Result[4],
     get_error=Stdlib_Result[5],
     bind=Stdlib_Result[6],
     join=Stdlib_Result[7],
     map=Stdlib_Result[8],
     map_error=Stdlib_Result[9],
     fold=Stdlib_Result[10],
     iter=Stdlib_Result[11],
     iter_error=Stdlib_Result[12],
     is_ok=Stdlib_Result[13],
     is_error=Stdlib_Result[14],
     equal=Stdlib_Result[15],
     compare=Stdlib_Result[16],
     to_option=Stdlib_Result[17],
     to_list=Stdlib_Result[18],
     to_seq=Stdlib_Result[19],
     Result=
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
    runtime.caml_register_global(1,Result,"Result");
    return}
  (function(){return this}()));


//# 1 "../../.js/lwt/lwt.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Lwt_sequence_Empty=caml_string_of_jsbytes("Lwt_sequence.Empty"),
     cst_Lwt_nchoose_split_would_re=
      caml_string_of_jsbytes
       ("Lwt.nchoose_split [] would return a promise that is pending forever"),
     cst_Lwt_npick_would_return_a_p=
      caml_string_of_jsbytes
       ("Lwt.npick [] would return a promise that is pending forever"),
     cst_Lwt_nchoose_would_return_a=
      caml_string_of_jsbytes
       ("Lwt.nchoose [] would return a promise that is pending forever"),
     cst_Lwt_pick_would_return_a_pr=
      caml_string_of_jsbytes
       ("Lwt.pick [] would return a promise that is pending forever"),
     cst_Lwt_choose_would_return_a_=
      caml_string_of_jsbytes
       ("Lwt.choose [] would return a promise that is pending forever"),
     cst_wakeup_later_exn=caml_string_of_jsbytes("wakeup_later_exn"),
     cst_wakeup_later=caml_string_of_jsbytes("wakeup_later"),
     cst_wakeup_later_result=caml_string_of_jsbytes("wakeup_later_result"),
     cst_wakeup_exn=caml_string_of_jsbytes("wakeup_exn"),
     cst_wakeup=caml_string_of_jsbytes("wakeup"),
     cst_wakeup_result=caml_string_of_jsbytes("wakeup_result"),
     cst_Fatal_error_exception=
      caml_string_of_jsbytes("Fatal error: exception "),
     cst_Lwt_Resolution_loop_Cancel=
      caml_string_of_jsbytes("Lwt.Resolution_loop.Canceled"),
     cst_Lwt_switch_Off=caml_string_of_jsbytes("Lwt_switch.Off"),
     cst$3=caml_string_of_jsbytes("    "),
     cst$4=caml_string_of_jsbytes("   "),
     cst$5=caml_string_of_jsbytes(" |"),
     cst_Lwt_stream_parse=caml_string_of_jsbytes("Lwt_stream.parse"),
     cst_Lwt_stream_create_bounded=
      caml_string_of_jsbytes("Lwt_stream.create_bounded"),
     cst_Lwt_stream_bounded_push_re=
      caml_string_of_jsbytes("Lwt_stream.bounded_push#resize"),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(""),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     cst_Lwt_stream_clone=caml_string_of_jsbytes("Lwt_stream.clone"),
     shared=
      [0,
       caml_string_of_jsbytes("size"),
       caml_string_of_jsbytes("set_reference"),
       caml_string_of_jsbytes("resize"),
       caml_string_of_jsbytes("push"),
       caml_string_of_jsbytes("count"),
       caml_string_of_jsbytes("closed"),
       caml_string_of_jsbytes("close"),
       caml_string_of_jsbytes("blocked"),
       caml_string_of_jsbytes("*dummy method*")],
     cst_Lwt_stream_Closed=caml_string_of_jsbytes("Lwt_stream.Closed"),
     cst_Lwt_stream_Full=caml_string_of_jsbytes("Lwt_stream.Full"),
     cst_Lwt_stream_Empty=caml_string_of_jsbytes("Lwt_stream.Empty"),
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_List=global_data.Stdlib__List,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Random=global_data.Stdlib__Random,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Stdlib_Map=global_data.Stdlib__Map,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     CamlinternalOO=global_data.CamlinternalOO,
     Stdlib_String=global_data.Stdlib__String,
     Stdlib_Array=global_data.Stdlib__Array,
     Empty=[248,cst_Lwt_sequence_Empty,caml_fresh_oo_id(0)],
     _O_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),2665,6],
     _P_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),2685,6],
     _U_=[0,0],
     _V_=[0,0],
     _T_=[0,0],
     _S_=[0,0],
     _R_=[0,0],
     _Q_=[0,0],
     _N_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),2639,24],
     _M_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),2620,13],
     _L_=[0,0],
     _K_=[0,0],
     _I_=[0,1],
     _J_=[0,1],
     _G_=[0,1],
     _H_=[0,1],
     _F_=[0,1],
     _E_=[0,1],
     _C_=[0,0],
     _D_=[0,1],
     _A_=[0,1],
     _B_=[0,1],
     _y_=[0,1],
     _z_=[0,1],
     _w_=[0,0],
     _x_=[0,1],
     _u_=[0,0],
     _v_=[0,1],
     _r_=[0,0],
     _s_=[0,0],
     _t_=[0,1],
     _p_=[0,0],
     _q_=[0,1],
     _n_=[0,0],
     _o_=[0,1],
     _l_=[0,0],
     _m_=[0,0],
     _k_=[0,0],
     _j_=[0,0],
     _i_=[0,0],
     _f_=
      [0,
       [11,caml_string_of_jsbytes("Lwt."),[2,0,0]],
       caml_string_of_jsbytes("Lwt.%s")],
     _g_=
      [0,
       [11,caml_string_of_jsbytes("Lwt."),[2,0,0]],
       caml_string_of_jsbytes("Lwt.%s")],
     _h_=[0,1],
     _c_=
      [0,
       [11,caml_string_of_jsbytes("Lwt."),[2,0,0]],
       caml_string_of_jsbytes("Lwt.%s")],
     _d_=
      [0,
       [11,caml_string_of_jsbytes("Lwt."),[2,0,0]],
       caml_string_of_jsbytes("Lwt.%s")],
     _e_=[0,0],
     _a_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),991,23],
     _b_=[0,caml_string_of_jsbytes("src/core/lwt.ml"),992,22],
     _ab_=[0,[4,6,[0,2,2],0,[12,32,0]],caml_string_of_jsbytes("%02x ")],
     _aa_=
      [0,
       [4,6,[0,2,8],0,[11,caml_string_of_jsbytes("|  "),0]],
       caml_string_of_jsbytes("%08x|  ")],
     _$_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Lwt_stream.iter_n: max_concurrency must be > 0, "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" given"),0]]],
       caml_string_of_jsbytes
        ("Lwt_stream.iter_n: max_concurrency must be > 0, %d given")],
     _Y_=
      [0,
       caml_string_of_jsbytes("blocked"),
       caml_string_of_jsbytes("close"),
       caml_string_of_jsbytes("push"),
       caml_string_of_jsbytes("count"),
       caml_string_of_jsbytes("size"),
       caml_string_of_jsbytes("set_reference"),
       caml_string_of_jsbytes("resize"),
       caml_string_of_jsbytes("closed")],
     _Z_=[0,caml_string_of_jsbytes("closed")],
     _ac_=[0,caml_string_of_jsbytes("src/core/lwt_result.ml"),77,14],
     _ad_=[0,caml_string_of_jsbytes("src/core/lwt_pqueue.ml"),81,15];
    function get(node){return node[3]}
    function set(node,data){node[3] = data;return 0}
    function remove(node)
     {var
       _gX_=node[4],
       _gY_=
        _gX_?(node[4] = 0,node[1][2] = node[2],node[2][1] = node[1],0):_gX_;
      return _gY_}
    function create(param)
     {var seq=[];caml_update_dummy(seq,[0,seq,seq]);return seq}
    function clear(seq){seq[1] = seq;seq[2] = seq;return 0}
    function is_empty(seq){return seq[2] === seq?1:0}
    function length(seq)
     {var curr=seq[2],len=0;
      for(;;)
       {if(curr === seq)return len;
        var len$0=len + 1 | 0,curr$0=curr[2],curr=curr$0,len=len$0;
        continue}}
    function add_l(data,seq)
     {var node=[0,seq,seq[2],data,1];
      seq[2][1] = node;
      seq[2] = node;
      return node}
    function add_r(data,seq)
     {var node=[0,seq[1],seq,data,1];
      seq[1][2] = node;
      seq[1] = node;
      return node}
    function take_l(seq)
     {if(is_empty(seq))throw Empty;
      var node=seq[2];
      remove(node);
      return node[3]}
    function take_r(seq)
     {if(is_empty(seq))throw Empty;
      var node=seq[1];
      remove(node);
      return node[3]}
    function take_opt_l(seq)
     {if(is_empty(seq))return 0;
      var node=seq[2];
      remove(node);
      return [0,node[3]]}
    function take_opt_r(seq)
     {if(is_empty(seq))return 0;
      var node=seq[1];
      remove(node);
      return [0,node[3]]}
    function transfer_l(s1,s2)
     {s2[2][1] = s1[1];
      s1[1][2] = s2[2];
      s2[2] = s1[2];
      s1[2][1] = s2;
      s1[1] = s1;
      s1[2] = s1;
      return 0}
    function transfer_r(s1,s2)
     {s2[1][2] = s1[2];
      s1[2][1] = s2[1];
      s2[1] = s1[1];
      s1[1][2] = s2;
      s1[1] = s1;
      s1[2] = s1;
      return 0}
    function iter_l(f,seq)
     {var curr=seq[2];
      for(;;)
       {var _gW_=curr !== seq?1:0;
        if(_gW_)
         {if(curr[4])caml_call1(f,curr[3]);
          var curr$0=curr[2],curr=curr$0;
          continue}
        return _gW_}}
    function iter_r(f,seq)
     {var curr=seq[1];
      for(;;)
       {var _gV_=curr !== seq?1:0;
        if(_gV_)
         {if(curr[4])caml_call1(f,curr[3]);
          var curr$0=curr[1],curr=curr$0;
          continue}
        return _gV_}}
    function iter_node_l(f,seq)
     {var curr=seq[2];
      for(;;)
       {var _gU_=curr !== seq?1:0;
        if(_gU_)
         {if(curr[4])caml_call1(f,curr);
          var curr$0=curr[2],curr=curr$0;
          continue}
        return _gU_}}
    function iter_node_r(f,seq)
     {var curr=seq[1];
      for(;;)
       {var _gT_=curr !== seq?1:0;
        if(_gT_)
         {if(curr[4])caml_call1(f,curr);
          var curr$0=curr[1],curr=curr$0;
          continue}
        return _gT_}}
    function fold_l(f,seq,acc)
     {var curr=seq[2],acc$0=acc;
      for(;;)
       {if(curr === seq)return acc$0;
        if(curr[4])
         {var
           acc$1=caml_call2(f,curr[3],acc$0),
           curr$0=curr[2],
           curr=curr$0,
           acc$0=acc$1;
          continue}
        var curr$1=curr[2],curr=curr$1;
        continue}}
    function fold_r(f,seq,acc)
     {var curr=seq[1],acc$0=acc;
      for(;;)
       {if(curr === seq)return acc$0;
        if(curr[4])
         {var
           acc$1=caml_call2(f,curr[3],acc$0),
           curr$0=curr[1],
           curr=curr$0,
           acc$0=acc$1;
          continue}
        var curr$1=curr[1],curr=curr$1;
        continue}}
    function find_node_l(f,seq)
     {var curr=seq[2];
      for(;;)
       {if(curr !== seq)
         {if(curr[4])
           {if(caml_call1(f,curr[3]))return curr;
            var curr$0=curr[2],curr=curr$0;
            continue}
          var curr$1=curr[2],curr=curr$1;
          continue}
        throw Stdlib[8]}}
    function find_node_r(f,seq)
     {var curr=seq[1];
      for(;;)
       {if(curr !== seq)
         {if(curr[4])
           {if(caml_call1(f,curr[3]))return curr;
            var curr$0=curr[1],curr=curr$0;
            continue}
          var curr$1=curr[1],curr=curr$1;
          continue}
        throw Stdlib[8]}}
    function find_node_opt_l(f,seq)
     {try
       {var _gR_=[0,find_node_l(f,seq)];return _gR_}
      catch(_gS_)
       {_gS_ = caml_wrap_exception(_gS_);
        if(_gS_ === Stdlib[8])return 0;
        throw _gS_}}
    function find_node_opt_r(f,seq)
     {try
       {var _gP_=[0,find_node_r(f,seq)];return _gP_}
      catch(_gQ_)
       {_gQ_ = caml_wrap_exception(_gQ_);
        if(_gQ_ === Stdlib[8])return 0;
        throw _gQ_}}
    var
     Lwt_sequence=
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
    caml_register_global(86,Lwt_sequence,"Lwt_sequence");
    var
     compare=runtime.caml_compare,
     Storage_map=caml_call1(Stdlib_Map[1],[0,compare]);
    function state_of_result(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}
      var exn=param[1];
      return [1,exn]}
    function underlying(p)
     {var _gO_=p[1];
      switch(_gO_[0])
       {case 0:return p;
        case 1:return p;
        case 2:return p;
        default:
         var p$0=_gO_[1],p$1=underlying(p$0);
         if(1 - (p$1 === p$0?1:0))p[1] = [3,p$1];
         return p$1}}
    function set_promise_state(p,state){p[1] = state;return p}
    var next_key_id=[0,0];
    function new_key(param)
     {var id=next_key_id[1];next_key_id[1] = id + 1 | 0;return [0,id,0]}
    var current_storage=[0,Storage_map[1]];
    function get$0(key)
     {if(caml_call2(Storage_map[3],key[1],current_storage[1]))
       {var refresh=caml_call2(Storage_map[28],key[1],current_storage[1]);
        caml_call1(refresh,0);
        var value=key[2];
        key[2] = 0;
        return value}
      return 0}
    function with_value(key,value,f)
     {if(value)
       var
        refresh=function(param){key[2] = value;return 0},
        new_storage=
         caml_call3(Storage_map[4],key[1],refresh,current_storage[1]);
      else
       var new_storage=caml_call2(Storage_map[7],key[1],current_storage[1]);
      var saved_storage=current_storage[1];
      current_storage[1] = new_storage;
      try
       {var result=caml_call1(f,0);
        current_storage[1] = saved_storage;
        return result}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        current_storage[1] = saved_storage;
        throw exn}}
    function concat_regular_callbacks(l1,l2)
     {return typeof l1 === "number"?l2:typeof l2 === "number"?l1:[0,l1,l2]}
    function clean_up_callback_cells(callbacks)
     {if(typeof callbacks !== "number")
       switch(callbacks[0])
        {case 0:
          var
           l2=callbacks[2],
           l1=callbacks[1],
           l1$0=clean_up_callback_cells(l1),
           l2$0=clean_up_callback_cells(l2);
          return concat_regular_callbacks(l1$0,l2$0);
         case 2:if(! callbacks[1][1])return 0;break
         }
      return callbacks}
    function clear_explicitly_removable_cal(cell,ps)
     {cell[1] = 0;
      function _gL_(p)
       {var _gM_=underlying(p)[1];
        switch(_gM_[0])
         {case 1:return 0;
          case 2:
           var callbacks=_gM_[1],_gN_=callbacks[1];
           if(typeof _gN_ !== "number" && 2 === _gN_[0])
            {callbacks[1] = 0;return 0}
           var cleanups_deferred=callbacks[4] + 1 | 0;
           return 42 < cleanups_deferred
                   ?(callbacks[4]
                     =
                     0,
                     callbacks[1]
                     =
                     clean_up_callback_cells(callbacks[1]),
                     0)
                   :(callbacks[4] = cleanups_deferred,0);
          default:return 0}}
      return caml_call1(caml_call1(Stdlib_List[17],_gL_),ps)}
    function add_regular_callback_list_node(callbacks,node)
     {var
       _gK_=callbacks[1],
       node$0=typeof _gK_ === "number"?node:[0,node,_gK_];
      callbacks[1] = node$0;
      return 0}
    function add_implicitly_removed_callbac(callbacks,f)
     {return add_regular_callback_list_node(callbacks,[1,f])}
    function add_explicitly_removable_callb(ps,f)
     {var
       cell=[],
       self_removing_callback_wrapper=
        function _gJ_(_gI_){return _gJ_.fun(_gI_)};
      caml_update_dummy(cell,[0,[0,self_removing_callback_wrapper]]);
      caml_update_dummy
       (self_removing_callback_wrapper,
        function(result)
         {clear_explicitly_removable_cal(cell,ps);return caml_call1(f,result)});
      var node=[2,cell];
      function _gG_(p)
       {var _gH_=underlying(p)[1];
        switch(_gH_[0])
         {case 1:throw [0,Assert_failure,_b_];
          case 2:
           var callbacks=_gH_[1];
           return add_regular_callback_list_node(callbacks,node);
          default:throw [0,Assert_failure,_a_]}}
      caml_call1(caml_call1(Stdlib_List[17],_gG_),ps);
      return cell}
    function add_explicitly_removable_callb$0(ps,f)
     {add_explicitly_removable_callb(ps,f);return 0}
    function add_cancel_callback(callbacks,f)
     {var
       node=[1,current_storage[1],f],
       node$0=typeof callbacks[2] === "number"?node:[0,node,callbacks[2]];
      callbacks[2] = node$0;
      return 0}
    var
     async_exception_hook=
      [0,
       function(exn)
        {caml_call1(Stdlib[49],cst_Fatal_error_exception);
         var _gF_=caml_call1(Stdlib_Printexc[1],exn);
         caml_call1(Stdlib[49],_gF_);
         caml_call1(Stdlib[48],10);
         caml_call1(Stdlib_Printexc[5],Stdlib[40]);
         caml_call1(Stdlib[63],Stdlib[40]);
         return caml_call1(Stdlib[99],2)}];
    function handle_with_async_exception_ho(f,v)
     {try
       {var _gE_=caml_call1(f,v);return _gE_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        return caml_call1(async_exception_hook[1],exn)}}
    var Canceled=[248,cst_Lwt_Resolution_loop_Cancel,caml_fresh_oo_id(0)];
    function run_callbacks(callbacks,result)
     {if(1 === result[0])
       var _gC_=result[1] === Canceled?1:0,is_canceled=_gC_;
      else
       var is_canceled=0;
      if(is_canceled)
       {var
         _gA_=callbacks[2],
         iter_callback_list$2=
          function(counter,fs,rest)
           {var fs$0=fs,rest$0=rest;
            for(;;)
             if(typeof fs$0 === "number")
              {if(counter < 50)
                {var counter$0=counter + 1 | 0;
                 return iter_list$0(counter$0,rest$0)}
               return caml_trampoline_return(iter_list$0,[0,rest$0])}
             else
              switch(fs$0[0])
               {case 0:
                 var
                  fs$1=fs$0[2],
                  fs$2=fs$0[1],
                  rest$1=[0,fs$1,rest$0],
                  fs$0=fs$2,
                  rest$0=rest$1;
                 continue;
                case 1:
                 var f=fs$0[2],storage=fs$0[1];
                 current_storage[1] = storage;
                 handle_with_async_exception_ho(f,0);
                 if(counter < 50)
                  {var counter$1=counter + 1 | 0;
                   return iter_list$0(counter$1,rest$0)}
                 return caml_trampoline_return(iter_list$0,[0,rest$0]);
                default:
                 var node=fs$0[1];
                 remove(node);
                 if(counter < 50)
                  {var counter$2=counter + 1 | 0;
                   return iter_list$0(counter$2,rest$0)}
                 return caml_trampoline_return(iter_list$0,[0,rest$0])}},
         iter_list$0=
          function(counter,rest)
           {if(rest)
             {var rest$0=rest[2],fs=rest[1];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return iter_callback_list$2(counter$0,fs,rest$0)}
              return caml_trampoline_return
                      (iter_callback_list$2,[0,fs,rest$0])}
            return 0},
         iter_callback_list=
          function(fs,rest)
           {return caml_trampoline(iter_callback_list$2(0,fs,rest))};
        iter_callback_list(_gA_,0)}
      var _gB_=callbacks[1];
      function iter_callback_list$1(counter,fs,rest)
       {var fs$0=fs,rest$0=rest;
        for(;;)
         if(typeof fs$0 === "number")
          {if(counter < 50)
            {var counter$0=counter + 1 | 0;return iter_list(counter$0,rest$0)}
           return caml_trampoline_return(iter_list,[0,rest$0])}
         else
          switch(fs$0[0])
           {case 0:
             var
              fs$1=fs$0[2],
              fs$2=fs$0[1],
              rest$1=[0,fs$1,rest$0],
              fs$0=fs$2,
              rest$0=rest$1;
             continue;
            case 1:
             var f=fs$0[1];
             caml_call1(f,result);
             if(counter < 50)
              {var counter$1=counter + 1 | 0;
               return iter_list(counter$1,rest$0)}
             return caml_trampoline_return(iter_list,[0,rest$0]);
            default:
             var _gD_=fs$0[1][1];
             if(_gD_)
              {var f$0=_gD_[1];
               caml_call1(f$0,result);
               if(counter < 50)
                {var counter$2=counter + 1 | 0;
                 return iter_list(counter$2,rest$0)}
               return caml_trampoline_return(iter_list,[0,rest$0])}
             if(counter < 50)
              {var counter$3=counter + 1 | 0;
               return iter_list(counter$3,rest$0)}
             return caml_trampoline_return(iter_list,[0,rest$0])}}
      function iter_list(counter,rest)
       {if(rest)
         {var rest$0=rest[2],fs=rest[1];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return iter_callback_list$1(counter$0,fs,rest$0)}
          return caml_trampoline_return(iter_callback_list$1,[0,fs,rest$0])}
        return 0}
      function iter_callback_list$0(fs,rest)
       {return caml_trampoline(iter_callback_list$1(0,fs,rest))}
      return iter_callback_list$0(_gB_,0)}
    var
     current_callback_nesting_depth=[0,0],
     deferred_callbacks=caml_call1(Stdlib_Queue[2],0),
     default_maximum_callback_nesti=42;
    function leave_resolution_loop(storage_snapshot)
     {if(1 === current_callback_nesting_depth[1])
       for(;;)
        {if(! caml_call1(Stdlib_Queue[13],deferred_callbacks))
          {var
            match=caml_call1(Stdlib_Queue[7],deferred_callbacks),
            result=match[2],
            callbacks=match[1];
           run_callbacks(callbacks,result);
           continue}
         break}
      current_callback_nesting_depth[1]
      =
      current_callback_nesting_depth[1]
      -
      1
      |
      0;
      current_storage[1] = storage_snapshot;
      return 0}
    function run_in_resolution_loop(f)
     {current_callback_nesting_depth[1]
      =
      current_callback_nesting_depth[1]
      +
      1
      |
      0;
      var storage_snapshot=current_storage[1],result=caml_call1(f,0);
      leave_resolution_loop(storage_snapshot);
      return result}
    function abandon_wakeups(param)
     {var _gz_=0 !== current_callback_nesting_depth[1]?1:0;
      return _gz_?leave_resolution_loop(Storage_map[1]):_gz_}
    function run_callbacks_or_defer_them(opt,_gy_,callbacks,result)
     {if(opt)var sth=opt[1],allow_deferring=sth;else var allow_deferring=1;
      if(_gy_)
       var sth$0=_gy_[1],maximum_callback_nesting_depth=sth$0;
      else
       var maximum_callback_nesting_depth=default_maximum_callback_nesti;
      var
       should_defer=
        allow_deferring
         ?maximum_callback_nesting_depth <= current_callback_nesting_depth[1]
           ?1
           :0
         :allow_deferring;
      return should_defer
              ?caml_call2
                (Stdlib_Queue[4],[0,callbacks,result],deferred_callbacks)
              :run_in_resolution_loop
                (function(param){return run_callbacks(callbacks,result)})}
    function resolve(allow_deferring,maximum_callback_nesting_depth,p,result)
     {var match=p[1],callbacks=match[1],p$0=set_promise_state(p,result);
      run_callbacks_or_defer_them
       (allow_deferring,maximum_callback_nesting_depth,callbacks,result);
      return p$0}
    function run_callback_or_defer_it(opt,f,if_deferred)
     {if(opt)
       var sth=opt[1],run_immediately_and_ensure_tai=sth;
      else
       var run_immediately_and_ensure_tai=0;
      if(run_immediately_and_ensure_tai)return caml_call1(f,0);
      var should_defer=42 <= current_callback_nesting_depth[1]?1:0;
      if(should_defer)
       {var
         match=caml_call1(if_deferred,0),
         deferred_result=match[3],
         deferred_callback=match[2],
         immediate_result=match[1],
         deferred_record=[0,[1,deferred_callback],0,0,0];
        caml_call2
         (Stdlib_Queue[4],
          [0,deferred_record,deferred_result],
          deferred_callbacks);
        return immediate_result}
      return run_in_resolution_loop(function(param){return caml_call1(f,0)})}
    function wakeup_general(api_function_name,p,result)
     {var p$0=underlying(p),_gx_=p$0[1];
      switch(_gx_[0])
       {case 1:
         return _gx_[1] === Canceled
                 ?0
                 :caml_call3
                   (Stdlib_Printf[10],Stdlib[1],_d_,api_function_name);
        case 2:
         var result$0=state_of_result(result);
         resolve(_e_,0,p$0,result$0);
         return 0;
        default:
         return caml_call3(Stdlib_Printf[10],Stdlib[1],_c_,api_function_name)}}
    function wakeup_result(r,result)
     {return wakeup_general(cst_wakeup_result,r,result)}
    function wakeup(r,v){return wakeup_general(cst_wakeup,r,[0,v])}
    function wakeup_exn(r,exn)
     {return wakeup_general(cst_wakeup_exn,r,[1,exn])}
    function wakeup_later_general(api_function_name,p,result)
     {var p$0=underlying(p),_gw_=p$0[1];
      switch(_gw_[0])
       {case 1:
         return _gw_[1] === Canceled
                 ?0
                 :caml_call3
                   (Stdlib_Printf[10],Stdlib[1],_g_,api_function_name);
        case 2:
         var result$0=state_of_result(result);
         resolve(0,_h_,p$0,result$0);
         return 0;
        default:
         return caml_call3(Stdlib_Printf[10],Stdlib[1],_f_,api_function_name)}}
    function wakeup_later_result(r,result)
     {return wakeup_later_general(cst_wakeup_later_result,r,result)}
    function wakeup_later(r,v)
     {return wakeup_later_general(cst_wakeup_later,r,[0,v])}
    function wakeup_later_exn(r,exn)
     {return wakeup_later_general(cst_wakeup_later_exn,r,[1,exn])}
    function cancel(p)
     {var canceled_result=[1,Canceled];
      function cancel_and_collect_callbacks(callbacks_accumulator,p)
       {var p$0=p;
        for(;;)
         {var p$1=underlying(p$0),_gu_=p$1[1];
          switch(_gu_[0])
           {case 1:return callbacks_accumulator;
            case 2:
             var callbacks=_gu_[1],_gv_=callbacks[3];
             if(typeof _gv_ === "number")
              return 0 === _gv_
                      ?callbacks_accumulator
                      :(set_promise_state(p$1,canceled_result),
                        [0,callbacks,callbacks_accumulator]);
             else
              {if(0 === _gv_[0]){var p$2=_gv_[1],p$0=p$2;continue}
               var ps=_gv_[1];
               return caml_call3
                       (Stdlib_List[25],
                        cancel_and_collect_callbacks,
                        callbacks_accumulator,
                        ps)}
            default:return callbacks_accumulator}}}
      var callbacks=cancel_and_collect_callbacks(0,p);
      function _gt_(param)
       {return run_callbacks_or_defer_them(_i_,0,param,canceled_result)}
      return caml_call1(caml_call1(Stdlib_List[17],_gt_),callbacks)}
    function lift(v){return [0,[0,v]]}
    function of_result(result){return [0,state_of_result(result)]}
    function fail(exn){return [0,[1,exn]]}
    var return_unit=lift(0),return_none=lift(0);
    function return_some(x){return lift([0,x])}
    var acc=lift(0),return_true=lift(1),return_false=lift(0);
    function return_ok(x){return lift([0,x])}
    function return_error(x){return lift([1,x])}
    function fail_with(msg){return [0,[1,[0,Stdlib[7],msg]]]}
    function fail_invalid_arg(msg){return [0,[1,[0,Stdlib[6],msg]]]}
    function new_pending(how_to_cancel)
     {var state=[2,[0,0,0,how_to_cancel,0]];return [0,state]}
    function wait(param){var p=new_pending(0);return [0,p,p]}
    function task(param){var p=new_pending(1);return [0,p,p]}
    function waiter_of_wakener(r){return r}
    function add_task_r(sequence)
     {var
       p=new_pending(1),
       node=add_r(p,sequence),
       match=p[1],
       callbacks=match[1];
      callbacks[2] = [2,node];
      return p}
    function add_task_l(sequence)
     {var
       p=new_pending(1),
       node=add_l(p,sequence),
       match=p[1],
       callbacks=match[1];
      callbacks[2] = [2,node];
      return p}
    function protected$0(p)
     {switch(underlying(p)[1][0])
       {case 1:return p;
        case 2:
         var
          p$0=new_pending(1),
          f=
           function(p_result)
            {var p=underlying(p$0);resolve(_j_,0,p,p_result);return 0},
          ps=[0,p,0],
          cell=add_explicitly_removable_callb(ps,f),
          remove_the_callback=
           function(param){return clear_explicitly_removable_cal(cell,ps)},
          match=p$0[1],
          p_callbacks=match[1];
         add_cancel_callback(p_callbacks,remove_the_callback);
         return p$0;
        default:return p}}
    function no_cancel(p)
     {var _gs_=underlying(p)[1];
      switch(_gs_[0])
       {case 1:return p;
        case 2:
         var
          p_callbacks=_gs_[1],
          p$0=new_pending(0),
          callback=
           function(p_result)
            {var p=underlying(p$0);resolve(_k_,0,p,p_result);return 0};
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$0;
        default:return p}}
    function make_into_proxy(outer_promise,user_provided_promise)
     {var p=underlying(user_provided_promise);
      if(p === outer_promise)return p;
      var _gr_=p[1];
      switch(_gr_[0])
       {case 1:return resolve(_m_,0,outer_promise,p[1]);
        case 2:
         var
          p_callbacks=_gr_[1],
          match=outer_promise[1],
          outer_callbacks=match[1],
          regular_callbacks=
           concat_regular_callbacks(outer_callbacks[1],p_callbacks[1]),
          cleanups_deferred=outer_callbacks[4] + p_callbacks[4] | 0;
         if(42 < cleanups_deferred)
          var
           cleanups_deferred$0=0,
           regular_callbacks$0=clean_up_callback_cells(regular_callbacks);
         else
          var
           cleanups_deferred$0=cleanups_deferred,
           regular_callbacks$0=regular_callbacks;
         var
          _gp_=p_callbacks[2],
          _gq_=outer_callbacks[2],
          cancel_callbacks=
           typeof _gq_ === "number"
            ?_gp_
            :typeof _gp_ === "number"?_gq_:[0,_gq_,_gp_];
         outer_callbacks[1] = regular_callbacks$0;
         outer_callbacks[2] = cancel_callbacks;
         outer_callbacks[4] = cleanups_deferred$0;
         outer_callbacks[3] = p_callbacks[3];
         set_promise_state(p,[3,outer_promise]);
         return outer_promise;
        default:return resolve(_l_,0,outer_promise,p[1])}}
    function symbol_bind(p,f)
     {var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var p$2=underlying(p);resolve(_n_,0,p$2,p_result);return 0}
          var v=p_result[1];
          current_storage[1] = saved_storage;
          try
           {var _go_=caml_call1(f,v),p$0=_go_}
          catch(exn){exn = caml_wrap_exception(exn);var p$0=fail(exn)}
          var p$1=underlying(p);
          make_into_proxy(p$1,p$0);
          return 0}
        return [0,p,callback]}
      var _gm_=p$0[1];
      switch(_gm_[0])
       {case 1:return [0,_gm_];
        case 2:
         var
          p_callbacks=_gm_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:
         var
          v=_gm_[1],
          _gn_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_o_,function(param){return caml_call1(f,v)},_gn_)}}
    function backtrace_bind(add_loc,p,f)
     {var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var exn=p_result[1],p$2=underlying(p);
            resolve(_p_,0,p$2,[1,caml_call1(add_loc,exn)]);
            return 0}
          var v=p_result[1];
          current_storage[1] = saved_storage;
          try
           {var _gl_=caml_call1(f,v),p$0=_gl_}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            var p$0=fail(caml_call1(add_loc,exn))}
          var p$1=underlying(p);
          make_into_proxy(p$1,p$0);
          return 0}
        return [0,p,callback]}
      var _gj_=p$0[1];
      switch(_gj_[0])
       {case 1:var exn=_gj_[1];return [0,[1,caml_call1(add_loc,exn)]];
        case 2:
         var
          p_callbacks=_gj_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:
         var
          v=_gj_[1],
          _gk_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_q_,function(param){return caml_call1(f,v)},_gk_)}}
    function symbol(f,p)
     {var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var p$1=underlying(p);resolve(_s_,0,p$1,p_result);return 0}
          var v=p_result[1];
          current_storage[1] = saved_storage;
          try
           {var _gi_=[0,caml_call1(f,v)],p_result$0=_gi_}
          catch(exn){exn = caml_wrap_exception(exn);var p_result$0=[1,exn]}
          var p$0=underlying(p);
          resolve(_r_,0,p$0,p_result$0);
          return 0}
        return [0,p,callback]}
      var _ge_=p$0[1];
      switch(_ge_[0])
       {case 1:return [0,_ge_];
        case 2:
         var
          p_callbacks=_ge_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:
         var
          v=_ge_[1],
          _gf_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_t_,
                  function(param)
                   {try
                     {var _gh_=[0,caml_call1(f,v)],_gg_=_gh_}
                    catch(exn){exn = caml_wrap_exception(exn);var _gg_=[1,exn]}
                    return [0,_gg_]},
                  _gf_)}}
    function catch$0(f,h)
     {try
       {var _gc_=caml_call1(f,0),p=_gc_}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var exn=p_result[1];
            current_storage[1] = saved_storage;
            try
             {var _gd_=caml_call1(h,exn),p$1=_gd_}
            catch(exn){exn = caml_wrap_exception(exn);var p$1=fail(exn)}
            var p$2=underlying(p);
            make_into_proxy(p$2,p$1);
            return 0}
          var p$0=underlying(p);
          resolve(_u_,0,p$0,p_result);
          return 0}
        return [0,p,callback]}
      var _ga_=p$0[1];
      switch(_ga_[0])
       {case 1:
         var
          exn=_ga_[1],
          _gb_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_v_,function(param){return caml_call1(h,exn)},_gb_);
        case 2:
         var
          p_callbacks=_ga_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:return p$0}}
    function backtrace_catch(add_loc,f,h)
     {try
       {var _f__=caml_call1(f,0),p=_f__}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var exn=p_result[1];
            current_storage[1] = saved_storage;
            try
             {var _f$_=caml_call1(h,exn),p$1=_f$_}
            catch(exn)
             {exn = caml_wrap_exception(exn);
              var p$1=fail(caml_call1(add_loc,exn))}
            var p$2=underlying(p);
            make_into_proxy(p$2,p$1);
            return 0}
          var p$0=underlying(p);
          resolve(_w_,0,p$0,p_result);
          return 0}
        return [0,p,callback]}
      var _f8_=p$0[1];
      switch(_f8_[0])
       {case 1:
         var
          exn=_f8_[1],
          _f9_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_x_,
                  function(param)
                   {return caml_call1(h,caml_call1(add_loc,exn))},
                  _f9_);
        case 2:
         var
          p_callbacks=_f8_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:return p$0}}
    function try_bind(f$0,f,h)
     {try
       {var _f5_=caml_call1(f$0,0),p=_f5_}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var exn=p_result[1];
            current_storage[1] = saved_storage;
            try
             {var _f7_=caml_call1(h,exn),p$2=_f7_}
            catch(exn){exn = caml_wrap_exception(exn);var p$2=fail(exn)}
            var p$3=underlying(p);
            make_into_proxy(p$3,p$2);
            return 0}
          var v=p_result[1];
          current_storage[1] = saved_storage;
          try
           {var _f6_=caml_call1(f,v),p$0=_f6_}
          catch(exn){exn = caml_wrap_exception(exn);var p$0=fail(exn)}
          var p$1=underlying(p);
          make_into_proxy(p$1,p$0);
          return 0}
        return [0,p,callback]}
      var _f2_=p$0[1];
      switch(_f2_[0])
       {case 1:
         var
          exn=_f2_[1],
          _f4_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_z_,function(param){return caml_call1(h,exn)},_f4_);
        case 2:
         var
          p_callbacks=_f2_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:
         var
          v=_f2_[1],
          _f3_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_y_,function(param){return caml_call1(f,v)},_f3_)}}
    function backtrace_try_bind(add_loc,f$0,f,h)
     {try
       {var _fZ_=caml_call1(f$0,0),p=_fZ_}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var p$0=underlying(p);
      function create_result_promise_and_call(param)
       {var p=new_pending([0,p$0]),saved_storage=current_storage[1];
        function callback(p_result)
         {if(1 === p_result[0])
           {var exn=p_result[1];
            current_storage[1] = saved_storage;
            try
             {var _f1_=caml_call1(h,exn),p$2=_f1_}
            catch(exn)
             {exn = caml_wrap_exception(exn);
              var p$2=fail(caml_call1(add_loc,exn))}
            var p$3=underlying(p);
            make_into_proxy(p$3,p$2);
            return 0}
          var v=p_result[1];
          current_storage[1] = saved_storage;
          try
           {var _f0_=caml_call1(f,v),p$0=_f0_}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            var p$0=fail(caml_call1(add_loc,exn))}
          var p$1=underlying(p);
          make_into_proxy(p$1,p$0);
          return 0}
        return [0,p,callback]}
      var _fW_=p$0[1];
      switch(_fW_[0])
       {case 1:
         var
          exn=_fW_[1],
          _fY_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_B_,
                  function(param)
                   {return caml_call1(h,caml_call1(add_loc,exn))},
                  _fY_);
        case 2:
         var
          p_callbacks=_fW_[1],
          match=create_result_promise_and_call(0),
          callback=match[2],
          p$1=match[1];
         add_implicitly_removed_callbac(p_callbacks,callback);
         return p$1;
        default:
         var
          v=_fW_[1],
          _fX_=
           function(param)
            {var
              match=create_result_promise_and_call(0),
              callback=match[2],
              p=match[1];
             return [0,p,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_A_,function(param){return caml_call1(f,v)},_fX_)}}
    function finalize(f$0,f)
     {function _fT_(e)
       {function _fV_(param){return fail(e)}
        return symbol_bind(caml_call1(f,0),_fV_)}
      return try_bind
              (f$0,
               function(x)
                {function _fU_(param){return lift(x)}
                 return symbol_bind(caml_call1(f,0),_fU_)},
               _fT_)}
    function backtrace_finalize(add_loc,f$0,f)
     {function _fQ_(e)
       {function _fS_(param){return fail(caml_call1(add_loc,e))}
        return symbol_bind(caml_call1(f,0),_fS_)}
      return backtrace_try_bind
              (add_loc,
               f$0,
               function(x)
                {function _fR_(param){return lift(x)}
                 return symbol_bind(caml_call1(f,0),_fR_)},
               _fQ_)}
    function on_cancel(p,f)
     {var p$0=underlying(p),_fO_=p$0[1];
      switch(_fO_[0])
       {case 1:
         if(_fO_[1] === Canceled)
          {var
            _fP_=
             function(param)
              {return [0,
                       0,
                       function(param){return handle_with_async_exception_ho(f,0)},
                       _C_]};
           return run_callback_or_defer_it
                   (_D_,
                    function(param){return handle_with_async_exception_ho(f,0)},
                    _fP_)}
         return 0;
        case 2:var callbacks=_fO_[1];return add_cancel_callback(callbacks,f);
        default:return 0}}
    function on_success(p,f)
     {var p$0=underlying(p);
      function callback_if_deferred(param)
       {var saved_storage=current_storage[1];
        return function(result)
         {if(1 === result[0])return 0;
          var v=result[1];
          current_storage[1] = saved_storage;
          return handle_with_async_exception_ho(f,v)}}
      var _fM_=p$0[1];
      switch(_fM_[0])
       {case 1:return 0;
        case 2:
         var p_callbacks=_fM_[1],callback=callback_if_deferred(0);
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:
         var
          v=_fM_[1],
          _fN_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_E_,
                  function(param){return handle_with_async_exception_ho(f,v)},
                  _fN_)}}
    function on_failure(p,f)
     {var p$0=underlying(p);
      function callback_if_deferred(param)
       {var saved_storage=current_storage[1];
        return function(result)
         {if(1 === result[0])
           {var exn=result[1];
            current_storage[1] = saved_storage;
            return handle_with_async_exception_ho(f,exn)}
          return 0}}
      var _fK_=p$0[1];
      switch(_fK_[0])
       {case 1:
         var
          exn=_fK_[1],
          _fL_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_F_,
                  function(param)
                   {return handle_with_async_exception_ho(f,exn)},
                  _fL_);
        case 2:
         var p_callbacks=_fK_[1],callback=callback_if_deferred(0);
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:return 0}}
    function on_termination(p,f)
     {var p$0=underlying(p);
      function callback_if_deferred(param)
       {var saved_storage=current_storage[1];
        return function(result)
         {current_storage[1] = saved_storage;
          return handle_with_async_exception_ho(f,0)}}
      var _fH_=p$0[1];
      switch(_fH_[0])
       {case 1:
         var
          _fJ_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_H_,
                  function(param){return handle_with_async_exception_ho(f,0)},
                  _fJ_);
        case 2:
         var p_callbacks=_fH_[1],callback=callback_if_deferred(0);
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:
         var
          _fI_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_G_,
                  function(param){return handle_with_async_exception_ho(f,0)},
                  _fI_)}}
    function on_any(p,f,g)
     {var p$0=underlying(p);
      function callback_if_deferred(param)
       {var saved_storage=current_storage[1];
        return function(result)
         {if(1 === result[0])
           {var exn=result[1];
            current_storage[1] = saved_storage;
            return handle_with_async_exception_ho(g,exn)}
          var v=result[1];
          current_storage[1] = saved_storage;
          return handle_with_async_exception_ho(f,v)}}
      var _fE_=p$0[1];
      switch(_fE_[0])
       {case 1:
         var
          exn=_fE_[1],
          _fG_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_J_,
                  function(param)
                   {return handle_with_async_exception_ho(g,exn)},
                  _fG_);
        case 2:
         var p_callbacks=_fE_[1],callback=callback_if_deferred(0);
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:
         var
          v=_fE_[1],
          _fF_=
           function(param)
            {var callback=callback_if_deferred(0);
             return [0,0,callback,p$0[1]]};
         return run_callback_or_defer_it
                 (_I_,
                  function(param){return handle_with_async_exception_ho(f,v)},
                  _fF_)}}
    function wrap_in_cancelable(p)
     {var p_underlying=underlying(p);
      switch(p_underlying[1][0])
       {case 1:return p;
        case 2:
         var match=task(0),r=match[2],p$0=match[1];
         on_cancel(p$0,function(param){return cancel(p)});
         var _fB_=function(_fD_){return wakeup_exn(r,_fD_)};
         on_any(p,function(_fC_){return wakeup(r,_fC_)},_fB_);
         return p$0;
        default:return p}}
    function dont_wait(f,h)
     {try
       {var _fA_=caml_call1(f,0),p=_fA_}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var _fz_=underlying(p)[1];
      switch(_fz_[0])
       {case 1:var exn=_fz_[1];return caml_call1(h,exn);
        case 2:
         var
          p_callbacks=_fz_[1],
          callback=
           function(result)
            {if(1 === result[0]){var exn=result[1];return caml_call1(h,exn)}
             return 0};
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:return 0}}
    function async(f)
     {try
       {var _fy_=caml_call1(f,0),p=_fy_}
      catch(exn){exn = caml_wrap_exception(exn);var p=fail(exn)}
      var _fx_=underlying(p)[1];
      switch(_fx_[0])
       {case 1:var exn=_fx_[1];return caml_call1(async_exception_hook[1],exn);
        case 2:
         var
          p_callbacks=_fx_[1],
          callback=
           function(result)
            {if(1 === result[0])
              {var exn=result[1];
               return caml_call1(async_exception_hook[1],exn)}
             return 0};
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:return 0}}
    function ignore_result(p)
     {var _fw_=underlying(p)[1];
      switch(_fw_[0])
       {case 1:var exn=_fw_[1];throw exn;
        case 2:
         var
          p_callbacks=_fw_[1],
          callback=
           function(result)
            {if(1 === result[0])
              {var exn=result[1];
               return caml_call1(async_exception_hook[1],exn)}
             return 0};
         return add_implicitly_removed_callbac(p_callbacks,callback);
        default:return 0}}
    function join(ps)
     {var
       p=new_pending([1,ps]),
       number_pending_in_ps=[0,0],
       join_result=[0,_K_];
      function callback(new_result)
       {if(1 === new_result[0] && 1 !== join_result[1][0])
         join_result[1] = new_result;
        number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
        var _ft_=0 === number_pending_in_ps[1]?1:0;
        if(_ft_)
         {var p$0=underlying(p),_fu_=join_result[1];
          resolve(_L_,0,underlying(p$0),_fu_);
          var _fv_=0}
        else
         var _fv_=_ft_;
        return _fv_}
      var ps$0=ps;
      for(;;)
       {if(ps$0)
         {var ps$1=ps$0[2],p$0=ps$0[1],_fs_=underlying(p$0)[1];
          switch(_fs_[0])
           {case 1:
             if(1 !== join_result[1][0])join_result[1] = _fs_;
             var ps$0=ps$1;
             continue;
            case 2:
             var p_callbacks=_fs_[1];
             number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
             add_implicitly_removed_callbac(p_callbacks,callback);
             var ps$0=ps$1;
             continue;
            default:var ps$0=ps$1;continue}}
        return 0 === number_pending_in_ps[1]?[0,join_result[1]]:p}}
    function both(p1,p2)
     {var
       pair=[0,0,0],
       p1$0=symbol_bind(p1,function(v){pair[1] = [0,v];return return_unit}),
       p2$0=symbol_bind(p2,function(v){pair[2] = [0,v];return return_unit}),
       _fp_=join([0,p1$0,[0,p2$0,0]]);
      return symbol
              (function(param)
                {var _fq_=pair[1],_fr_=pair[2];
                 if(_fq_ && _fr_){var v2=_fr_[1],v1=_fq_[1];return [0,v1,v2]}
                 throw [0,Assert_failure,_M_]},
               _fp_)}
    function all(ps)
     {if(ps)
       {var _fk_=ps[2],_fl_=ps[1];
        if(_fk_)
         {if(_fk_[2])
           {var
             vs=runtime.caml_make_vect(caml_call1(Stdlib_List[1],ps),0),
             _fm_=
              function(index,p)
               {return symbol_bind
                        (p,
                         function(v)
                          {runtime.caml_check_bound(vs,index)[1 + index] = [0,v];
                           return return_unit})},
             _fn_=join(caml_call1(caml_call1(Stdlib_List[20],_fm_),ps));
            return symbol
                    (function(param)
                      {var i$1=vs.length - 1 - 1 | 0,i=i$1,acc=0;
                       for(;;)
                        {if(0 <= i)
                          {var match=vs[1 + i];
                           if(match)
                            {var
                              x=match[1],
                              acc$0=[0,x,acc],
                              i$0=i - 1 | 0,
                              i=i$0,
                              acc=acc$0;
                             continue}
                           throw [0,Assert_failure,_N_]}
                         return acc}},
                     _fn_)}
          var y=_fk_[1],_fo_=both(_fl_,y);
          return symbol
                  (function(param)
                    {var y=param[2],x=param[1];return [0,x,[0,y,0]]},
                   _fo_)}
        return symbol(function(y){return [0,y,0]},_fl_)}
      return acc}
    function count_resolved_promises_in(ps)
     {function accumulate(total,p)
       {switch(underlying(p)[1][0])
         {case 1:return total + 1 | 0;
          case 2:return total;
          default:return total + 1 | 0}}
      return caml_call3(Stdlib_List[25],accumulate,0,ps)}
    function nth_resolved(ps,n)
     {var ps$0=ps,n$0=n;
      for(;;)
       {if(ps$0)
         {var ps$1=ps$0[2],p=ps$0[1];
          switch(underlying(p)[1][0])
           {case 1:
             if(0 < n$0){var n$2=n$0 - 1 | 0,ps$0=ps$1,n$0=n$2;continue}
             return p;
            case 2:var ps$0=ps$1;continue;
            default:
             if(0 < n$0){var n$1=n$0 - 1 | 0,ps$0=ps$1,n$0=n$1;continue}
             return p}}
        throw [0,Assert_failure,_O_]}}
    function nth_resolved_and_cancel_pendin(ps,n)
     {var ps$0=ps,n$0=n;
      for(;;)
       {if(ps$0)
         {var ps$1=ps$0[2],p=ps$0[1];
          switch(underlying(p)[1][0])
           {case 1:
             if(0 < n$0){var n$2=n$0 - 1 | 0,ps$0=ps$1,n$0=n$2;continue}
             caml_call2(Stdlib_List[17],cancel,ps$1);
             return p;
            case 2:cancel(p);var ps$0=ps$1;continue;
            default:
             if(0 < n$0){var n$1=n$0 - 1 | 0,ps$0=ps$1,n$0=n$1;continue}
             caml_call2(Stdlib_List[17],cancel,ps$1);
             return p}}
        throw [0,Assert_failure,_P_]}}
    var
     prng=
      [246,function(_fj_){return caml_call1(Stdlib_Random[12][1],[0])}];
    function choose(ps)
     {if(0 === ps)caml_call1(Stdlib[1],cst_Lwt_choose_would_return_a_);
      var n=count_resolved_promises_in(ps);
      if(0 === n)
       {var
         p=new_pending([1,ps]),
         callback=
          function(result)
           {var p$0=underlying(p);resolve(_Q_,0,p$0,result);return 0};
        add_explicitly_removable_callb$0(ps,callback);
        return p}
      if(1 === n)return nth_resolved(ps,0);
      var
       _fh_=caml_obj_tag(prng),
       _fi_=
        250 === _fh_
         ?prng[1]
         :246 === _fh_?caml_call1(CamlinternalLazy[2],prng):prng;
      return nth_resolved(ps,caml_call2(Stdlib_Random[12][5],_fi_,n))}
    function pick(ps)
     {if(0 === ps)caml_call1(Stdlib[1],cst_Lwt_pick_would_return_a_pr);
      var n=count_resolved_promises_in(ps);
      if(0 === n)
       {var
         p=new_pending([1,ps]),
         callback=
          function(result)
           {caml_call2(Stdlib_List[17],cancel,ps);
            var p$0=underlying(p);
            resolve(_R_,0,p$0,result);
            return 0};
        add_explicitly_removable_callb$0(ps,callback);
        return p}
      if(1 === n)return nth_resolved_and_cancel_pendin(ps,0);
      var
       _ff_=caml_obj_tag(prng),
       _fg_=
        250 === _ff_
         ?prng[1]
         :246 === _ff_?caml_call1(CamlinternalLazy[2],prng):prng;
      return nth_resolved_and_cancel_pendin
              (ps,caml_call2(Stdlib_Random[12][5],_fg_,n))}
    function collect_fulfilled_promises_aft(results,ps)
     {var results$0=results,ps$0=ps;
      for(;;)
       {if(ps$0)
         {var ps$1=ps$0[2],p=ps$0[1],_fe_=underlying(p)[1];
          switch(_fe_[0])
           {case 1:return _fe_;
            case 2:var ps$0=ps$1;continue;
            default:
             var
              v=_fe_[1],
              results$1=[0,v,results$0],
              results$0=results$1,
              ps$0=ps$1;
             continue}}
        return [0,caml_call1(Stdlib_List[9],results$0)]}}
    function nchoose(ps)
     {if(0 === ps)caml_call1(Stdlib[1],cst_Lwt_nchoose_would_return_a);
      var ps$2=ps;
      for(;;)
       {if(ps$2)
         {var ps$3=ps$2[2],p$0=ps$2[1],_fd_=underlying(p$0)[1];
          switch(_fd_[0])
           {case 1:return [0,_fd_];
            case 2:var ps$2=ps$3;continue;
            default:
             var v$0=_fd_[1],acc$1=[0,v$0,0],acc=acc$1,ps$0=ps$3;
             for(;;)
              {if(ps$0)
                {var ps$1=ps$0[2],p=ps$0[1],_fc_=underlying(p)[1];
                 switch(_fc_[0])
                  {case 1:return [0,_fc_];
                   case 2:var ps$0=ps$1;continue;
                   default:
                    var v=_fc_[1],acc$0=[0,v,acc],acc=acc$0,ps$0=ps$1;continue}}
               return lift(caml_call1(Stdlib_List[9],acc))}}}
        var
         p$1=new_pending([1,ps]),
         callback=
          function(result)
           {var
             p=underlying(p$1),
             result$0=collect_fulfilled_promises_aft(0,ps);
            resolve(_S_,0,p,result$0);
            return 0};
        add_explicitly_removable_callb$0(ps,callback);
        return p$1}}
    function npick(ps)
     {if(0 === ps)caml_call1(Stdlib[1],cst_Lwt_npick_would_return_a_p);
      var ps$2=ps;
      for(;;)
       {if(ps$2)
         {var ps$3=ps$2[2],p$0=ps$2[1],_fb_=underlying(p$0)[1];
          switch(_fb_[0])
           {case 1:caml_call2(Stdlib_List[17],cancel,ps);return [0,_fb_];
            case 2:var ps$2=ps$3;continue;
            default:
             var v$0=_fb_[1],acc$1=[0,v$0,0],acc=acc$1,ps$0=ps$3;
             for(;;)
              {if(ps$0)
                {var ps$1=ps$0[2],p=ps$0[1],_fa_=underlying(p)[1];
                 switch(_fa_[0])
                  {case 1:
                    caml_call2(Stdlib_List[17],cancel,ps);return [0,_fa_];
                   case 2:var ps$0=ps$1;continue;
                   default:
                    var v=_fa_[1],acc$0=[0,v,acc],acc=acc$0,ps$0=ps$1;continue}}
               caml_call2(Stdlib_List[17],cancel,ps);
               return lift(caml_call1(Stdlib_List[9],acc))}}}
        var
         p$1=new_pending([1,ps]),
         callback=
          function(result)
           {var
             p=underlying(p$1),
             result$0=collect_fulfilled_promises_aft(0,ps);
            caml_call2(Stdlib_List[17],cancel,ps);
            resolve(_T_,0,p,result$0);
            return 0};
        add_explicitly_removable_callb$0(ps,callback);
        return p$1}}
    function nchoose_split(ps)
     {if(0 === ps)caml_call1(Stdlib[1],cst_Lwt_nchoose_split_would_re);
      var pending_acc=0,ps$2=ps;
      for(;;)
       {if(ps$2)
         {var ps$3=ps$2[2],p$0=ps$2[1],_e9_=underlying(p$0)[1];
          switch(_e9_[0])
           {case 1:return [0,_e9_];
            case 2:
             var
              pending_acc$0=[0,p$0,pending_acc],
              pending_acc=pending_acc$0,
              ps$2=ps$3;
             continue;
            default:
             var
              v$0=_e9_[1],
              results$1=[0,v$0,0],
              results=results$1,
              pending=pending_acc,
              ps$0=ps$3;
             for(;;)
              {if(ps$0)
                {var ps$1=ps$0[2],p=ps$0[1],_e8_=underlying(p)[1];
                 switch(_e8_[0])
                  {case 1:return [0,_e8_];
                   case 2:
                    var pending$0=[0,p,pending],pending=pending$0,ps$0=ps$1;
                    continue;
                   default:
                    var
                     v=_e8_[1],
                     results$0=[0,v,results],
                     results=results$0,
                     ps$0=ps$1;
                    continue}}
               return lift([0,caml_call1(Stdlib_List[9],results),pending])}}}
        var
         p$1=new_pending([1,ps]),
         callback=
          function(result)
           {var to_resolve=underlying(p$1),fulfilled=0,pending=0,ps$0=ps;
            for(;;)
             {if(ps$0)
               {var ps$1=ps$0[2],p=ps$0[1],_e__=underlying(p)[1];
                switch(_e__[0])
                 {case 1:resolve(_U_,0,to_resolve,_e__);break;
                  case 2:
                   var pending$0=[0,p,pending],pending=pending$0,ps$0=ps$1;
                   continue;
                  default:
                   var
                    v=_e__[1],
                    fulfilled$0=[0,v,fulfilled],
                    fulfilled=fulfilled$0,
                    ps$0=ps$1;
                   continue}}
              else
               {var _e$_=caml_call1(Stdlib_List[9],pending);
                resolve
                 (_V_,
                  0,
                  to_resolve,
                  [0,[0,caml_call1(Stdlib_List[9],fulfilled),_e$_]])}
              return 0}};
        add_explicitly_removable_callb$0(ps,callback);
        return p$1}}
    function state(p)
     {var _e7_=underlying(p)[1];
      switch(_e7_[0])
       {case 1:var exn=_e7_[1];return [1,exn];
        case 2:return 0;
        default:var v=_e7_[1];return [0,v]}}
    function debug_state_is(expected_state,p)
     {return lift(runtime.caml_equal(state(p),expected_state))}
    function is_sleeping(p)
     {switch(underlying(p)[1][0])
       {case 1:return 0;case 2:return 1;default:return 0}}
    function poll(p)
     {var _e6_=underlying(p)[1];
      switch(_e6_[0])
       {case 1:var e=_e6_[1];throw e;
        case 2:return 0;
        default:var v=_e6_[1];return [0,v]}}
    function apply(f,x)
     {try
       {var _e5_=caml_call1(f,x);return _e5_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap(f)
     {try
       {var _e4_=lift(caml_call1(f,0));return _e4_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap1(f,x1)
     {try
       {var _e3_=lift(caml_call1(f,x1));return _e3_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap2(f,x1,x2)
     {try
       {var _e2_=lift(caml_call2(f,x1,x2));return _e2_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap3(f,x1,x2,x3)
     {try
       {var _e1_=lift(caml_call3(f,x1,x2,x3));return _e1_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap4(f,x1,x2,x3,x4)
     {try
       {var _e0_=lift(caml_call4(f,x1,x2,x3,x4));return _e0_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap5(f,x1,x2,x3,x4,x5)
     {try
       {var _eZ_=lift(caml_call5(f,x1,x2,x3,x4,x5));return _eZ_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap6(f,x1,x2,x3,x4,x5,x6)
     {try
       {var _eY_=lift(caml_call6(f,x1,x2,x3,x4,x5,x6));return _eY_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    function wrap7(f,x1,x2,x3,x4,x5,x6,x7)
     {try
       {var _eX_=lift(caml_call7(f,x1,x2,x3,x4,x5,x6,x7));return _eX_}
      catch(exn){exn = caml_wrap_exception(exn);return fail(exn)}}
    var pause_hook=[0,function(_eW_){return 0}],paused=create(0),_W_=[0,0];
    function pause(param)
     {var p=add_task_r(paused);
      _W_[1]++;
      caml_call1(pause_hook[1],_W_[1]);
      return p}
    function wakeup_paused(param)
     {if(is_empty(paused)){_W_[1] = 0;return 0}
      var tmp=create(0);
      transfer_r(paused,tmp);
      _W_[1] = 0;
      return iter_l(function(r){return wakeup(r,0)},tmp)}
    function register_pause_notifier(f){pause_hook[1] = f;return 0}
    function abandon_paused(param){clear(paused);_W_[1] = 0;return 0}
    function paused_count(param){return _W_[1]}
    function map(t,f){return symbol(f,t)}
    function bind(t,f){return symbol_bind(t,f)}
    var
     Open_on_rhs=[0],
     Let_syntax=[0,lift,map,bind,both,Open_on_rhs],
     Let_syntax$0=[0,Let_syntax];
    function symbol$0(f,p){return symbol_bind(p,f)}
    function symbol$1(p,f){return symbol(f,p)}
    function symbol$2(p$0,p){return join([0,p$0,[0,p,0]])}
    function symbol$3(p$0,p){return choose([0,p$0,[0,p,0]])}
    var Let_syntax$1=Let_syntax$0[1];
    function let$0(x,f){return symbol(f,x)}
    var Syntax=[0,symbol_bind,both,let$0,both];
    function make_value(v){return [0,v]}
    function make_error(exn){return [1,exn]}
    var
     _X_=
      [0,symbol_bind,symbol$1,symbol$2,symbol$3,symbol$0,symbol,Let_syntax$1],
     Lwt=
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       lift,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       _X_,
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       acc,
       return_true,
       return_false,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get$0,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       make_value,
       make_error,
       waiter_of_wakener,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
    caml_register_global(95,Lwt,"Lwt");
    var Off=[248,cst_Lwt_switch_Off,caml_fresh_oo_id(0)];
    function create$0(param){return [0,[0,[0,0]]]}
    function is_on(switch$0){return switch$0[1]?1:0}
    function check(param){if(param && ! param[1][1])throw Off;return 0}
    function add_hook(switch$0,hook)
     {if(switch$0)
       {var _eV_=switch$0[1][1];
        if(_eV_){var os=_eV_[1];os[1] = [0,hook,os[1]];return 0}
        throw Off}
      return 0}
    function add_hook_or_exec(switch$0,hook)
     {if(switch$0)
       {var _eU_=switch$0[1][1];
        if(_eU_){var os=_eU_[1];os[1] = [0,hook,os[1]];return return_unit}
        return caml_call1(hook,0)}
      return return_unit}
    function turn_off(switch$0)
     {var _eS_=switch$0[1];
      if(_eS_)
       {var match=_eS_[1],hooks=match[1];
        switch$0[1] = 0;
        var _eT_=function(hook){return apply(hook,0)};
        return join(caml_call2(Stdlib_List[19],_eT_,hooks))}
      return return_unit}
    function with_switch(fn)
     {var switch$0=create$0(0);
      function _eR_(param){return turn_off(switch$0)}
      return finalize(function(param){return caml_call1(fn,switch$0)},_eR_)}
    var
     Lwt_switch=
      [0,
       create$0,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
    caml_register_global(96,Lwt_switch,"Lwt_switch");
    var
     Closed=[248,cst_Lwt_stream_Closed,caml_fresh_oo_id(0)],
     Full=[248,cst_Lwt_stream_Full,caml_fresh_oo_id(0)],
     Empty$0=[248,cst_Lwt_stream_Empty,caml_fresh_oo_id(0)];
    function new_node(param)
     {var node=[];caml_update_dummy(node,[0,node,0]);return node}
    function clone(s)
     {if(3 === s[1][0])caml_call1(Stdlib[1],cst_Lwt_stream_clone);
      return [0,s[1],s[2],s[3],s[4]]}
    function from_source(source)
     {var last=new_node(0),match=wait(0),close=match[2];
      return [0,source,close,last,[0,last]]}
    function from(f){return from_source([0,[0,f,return_unit]])}
    function from_direct(f){return from_source([1,f])}
    function closed(s){return s[2]}
    function is_closed(s){return 1 - is_sleeping(s[2])}
    function on_terminate(s,f)
     {return async(function(param){return caml_call2(_X_[2],s[2],f)})}
    function enqueue(e,last)
     {var _eQ_=last[1],new_last=new_node(0);
      _eQ_[2] = e;
      _eQ_[1] = new_last;
      last[1] = new_last;
      return 0}
    function enqueue$0(e,s){return enqueue(e,s[4])}
    function create_with_reference(param)
     {var
       match=wait(0),
       push_signal_resolver=match[2],
       push_signal=match[1],
       push_signal_resolver$0=[0,push_signal_resolver],
       source=[0,push_signal,0,0],
       t=from_source([2,source]),
       close=t[2],
       last=t[4];
      function push(x)
       {if(1 - is_sleeping(close))throw Closed;
        enqueue(x,last);
        if(source[2])
         {source[2] = 0;
          var
           old_push_signal_resolver=push_signal_resolver$0[1],
           match=wait(0),
           new_push_signal_resolver=match[2],
           new_waiter=match[1];
          source[1] = new_waiter;
          push_signal_resolver$0[1] = new_push_signal_resolver;
          wakeup_later(old_push_signal_resolver,0)}
        var _eP_=0 === x?1:0;
        return _eP_?wakeup(close,0):_eP_}
      return [0,t,push,function(x){source[3] = x;return 0}]}
    function of_seq(s)
     {var s$0=[0,s];
      function get(param)
       {var match=caml_call1(s$0[1],0);
        if(match){var s=match[2],elt=match[1];s$0[1] = s;return [0,elt]}
        return 0}
      return from_direct(get)}
    function create$1(param)
     {var match=create_with_reference(0),push=match[2],source=match[1];
      return [0,source,push]}
    function of_iter(iter,i)
     {var match=create$1(0),push=match[2],stream=match[1];
      caml_call2(iter,function(x){return caml_call1(push,[0,x])},i);
      caml_call1(push,0);
      return stream}
    function of_list(l){return of_iter(Stdlib_List[17],l)}
    function of_array(a){return of_iter(Stdlib_Array[13],a)}
    function of_string(s){return of_iter(Stdlib_String[29],s)}
    function notify_pusher(info,last)
     {enqueue(info[5],last);
      info[5] = 0;
      var old_wakener=info[7],match=task(0),wakener=match[2],waiter=match[1];
      info[6] = waiter;
      info[7] = wakener;
      return wakeup_later(old_wakener,0)}
    function ___(_eg_)
     {var
       _eh_=caml_call2(CamlinternalOO[3],_eg_,cst),
       _ei_=caml_call2(CamlinternalOO[3],_eg_,cst$0),
       _ej_=caml_call2(CamlinternalOO[3],_eg_,cst$1),
       _ek_=caml_call2(CamlinternalOO[3],_eg_,cst$2),
       _el_=caml_call3(CamlinternalOO[4],_eg_,shared,_Z_),
       _eu_=_el_[10],
       _em_=_el_[1],
       _en_=_el_[2],
       _eo_=_el_[3],
       _ep_=_el_[4],
       _eq_=_el_[5],
       _er_=_el_[6],
       _es_=_el_[7],
       _et_=_el_[8];
      function _ev_(self_1,x){self_1[1 + _eh_][8] = x;return 0}
      function _ew_(self_1){return self_1[1 + _eu_]}
      function _ex_(self_1){return 0 !== self_1[1 + _eh_][5]?1:0}
      function _ey_(self_1){return self_1[1 + _eh_][4]}
      function _ez_(self_1)
       {var _eN_=1 - self_1[1 + _eu_];
        if(_eN_)
         {self_1[1 + _eu_] = 1;
          var _eO_=self_1[1 + _ej_][1],new_last=new_node(0);
          _eO_[2] = 0;
          _eO_[1] = new_last;
          self_1[1 + _ej_][1] = new_last;
          if(0 !== self_1[1 + _eh_][5])
           {self_1[1 + _eh_][5] = 0;
            wakeup_later_exn(self_1[1 + _eh_][7],Closed)}
          if(self_1[1 + _eh_][2])
           {self_1[1 + _eh_][2] = 0;
            var old_wakener=self_1[1 + _ei_][1];
            wakeup_later(old_wakener,0)}
          return wakeup(self_1[1 + _ek_],0)}
        return _eN_}
      function _eA_(self_1,x)
       {if(self_1[1 + _eu_])return fail(Closed);
        if(0 === self_1[1 + _eh_][5])
         {if(self_1[1 + _eh_][3] <= self_1[1 + _eh_][4])
           {self_1[1 + _eh_][5] = [0,x];
            var
             _eM_=
              function(exn)
               {if(exn === Canceled)
                 {self_1[1 + _eh_][5] = 0;
                  var match=task(0),wakener=match[2],waiter=match[1];
                  self_1[1 + _eh_][6] = waiter;
                  self_1[1 + _eh_][7] = wakener;
                  return fail(exn)}
                return fail(exn)};
            return catch$0(function(param){return self_1[1 + _eh_][6]},_eM_)}
          enqueue([0,x],self_1[1 + _ej_]);
          self_1[1 + _eh_][4] = self_1[1 + _eh_][4] + 1 | 0;
          if(self_1[1 + _eh_][2])
           {self_1[1 + _eh_][2] = 0;
            var
             old_wakener=self_1[1 + _ei_][1],
             match=wait(0),
             new_wakener=match[2],
             new_waiter=match[1];
            self_1[1 + _eh_][1] = new_waiter;
            self_1[1 + _ei_][1] = new_wakener;
            wakeup_later(old_wakener,0)}
          return return_unit}
        return fail(Full)}
      function _eB_(self_1,size)
       {if(size < 0)caml_call1(Stdlib[1],cst_Lwt_stream_bounded_push_re);
        self_1[1 + _eh_][3] = size;
        var
         _eK_=self_1[1 + _eh_][4] < self_1[1 + _eh_][3]?1:0,
         _eL_=_eK_?0 !== self_1[1 + _eh_][5]?1:0:_eK_;
        return _eL_
                ?(self_1[1 + _eh_][4]
                  =
                  self_1[1 + _eh_][4]
                  +
                  1
                  |
                  0,
                  notify_pusher(self_1[1 + _eh_],self_1[1 + _ej_]))
                :_eL_}
      var
       _eC_=
        [0,
         _em_,
         function(self_1){return self_1[1 + _eh_][3]},
         _eo_,
         _eB_,
         _ep_,
         _eA_,
         _es_,
         _ez_,
         _eq_,
         _ey_,
         _et_,
         _ex_,
         _er_,
         _ew_,
         _en_,
         _ev_];
      caml_call2(CamlinternalOO[11],_eg_,_eC_);
      return function(_eI_,_eH_,_eG_,_eF_,_eE_,_eD_)
       {var _eJ_=caml_call2(CamlinternalOO[24],_eH_,_eg_);
        _eJ_[1 + _ek_] = _eD_;
        _eJ_[1 + _ej_] = _eE_;
        _eJ_[1 + _ei_] = _eF_;
        _eJ_[1 + _eh_] = _eG_;
        _eJ_[1 + _eu_] = 0;
        return _eJ_}}
    var bounded_push_impl=caml_call2(CamlinternalOO[19],_Y_,___);
    function create_bounded(size)
     {if(size < 0)caml_call1(Stdlib[1],cst_Lwt_stream_create_bounded);
      var
       match=wait(0),
       wakener=match[2],
       waiter=match[1],
       match$0=task(0),
       push_wakener=match$0[2],
       push_waiter=match$0[1],
       wakener_cell=[0,wakener],
       info=[0,waiter,0,size,0,0,push_waiter,push_wakener,0],
       t=from_source([3,info]);
      return [0,
              t,
              caml_call5(bounded_push_impl[1],0,info,wakener_cell,t[4],t[2])]}
    function feed(s)
     {var _ed_=s[1];
      switch(_ed_[0])
       {case 0:
         var from=_ed_[1];
         if(is_sleeping(from[2]))return protected$0(from[2]);
         var
          _ee_=
           function(x)
            {enqueue$0(x,s);if(0 === x)wakeup(s[2],0);return return_unit},
          _ef_=caml_call1(from[1],0),
          thread=caml_call2(_X_[1],_ef_,_ee_);
         from[2] = thread;
         return protected$0(thread);
        case 1:
         var f=_ed_[1],x=caml_call1(f,0);
         enqueue$0(x,s);
         if(0 === x)wakeup(s[2],0);
         return return_unit;
        case 2:var push=_ed_[1];push[2] = 1;return protected$0(push[1]);
        default:var push$0=_ed_[1];push$0[2] = 1;return protected$0(push$0[1])}}
    function consume(s,node)
     {var _eb_=node === s[3]?1:0;
      if(_eb_)
       {s[3] = node[1];
        var _ec_=s[1];
        if(3 === _ec_[0])
         {var info=_ec_[1];
          return 0 === info[5]
                  ?(info[4] = info[4] - 1 | 0,0)
                  :notify_pusher(info,s[4])}
        return 0}
      return _eb_}
    function peek_rec(s,node)
     {if(node === s[4][1])
       {var _d$_=function(param){return peek_rec(s,node)},_ea_=feed(s);
        return caml_call2(_X_[1],_ea_,_d$_)}
      return lift(node[2])}
    function peek(s){return peek_rec(s,s[3])}
    function npeek_rec(node,acc,n,s)
     {var node$0=node,acc$0=acc,n$0=n;
      for(;;)
       {if(0 < n$0)
         {if(node$0 === s[4][1])
           {var
             _d8_=function(param){return npeek_rec(node$0,acc$0,n$0,s)},
             _d9_=feed(s);
            return caml_call2(_X_[1],_d9_,_d8_)}
          var _d__=node$0[2];
          if(_d__)
           {var
             x=_d__[1],
             n$1=n$0 - 1 | 0,
             acc$1=[0,x,acc$0],
             node$1=node$0[1],
             node$0=node$1,
             acc$0=acc$1,
             n$0=n$1;
            continue}
          return lift(caml_call1(Stdlib_List[9],acc$0))}
        return lift(caml_call1(Stdlib_List[9],acc$0))}}
    function npeek(n,s){return npeek_rec(s[3],0,n,s)}
    function get_rec(s,node)
     {if(node === s[4][1])
       {var _d6_=function(param){return get_rec(s,node)},_d7_=feed(s);
        return caml_call2(_X_[1],_d7_,_d6_)}
      if(0 !== node[2])consume(s,node);
      return lift(node[2])}
    function get$1(s){return get_rec(s,s[3])}
    function get_exn_rec(s,node)
     {if(node === s[4][1])
       {var
         _d3_=function(exn){return lift([0,[1,exn]])},
         _d4_=function(param){return get_exn_rec(s,node)};
        return try_bind(function(param){return feed(s)},_d4_,_d3_)}
      var _d5_=node[2];
      if(_d5_){var value=_d5_[1];consume(s,node);return lift([0,[0,value]])}
      return return_none}
    function map_exn(s)
     {return from(function(param){return get_exn_rec(s,s[3])})}
    function get_exn_rec$0(s,node)
     {if(node === s[4][1])
       {var
         _d0_=function(exn){return lift([0,[1,exn]])},
         _d1_=function(param){return get_exn_rec$0(s,node)};
        return try_bind(function(param){return feed(s)},_d1_,_d0_)}
      var _d2_=node[2];
      if(_d2_){var value=_d2_[1];consume(s,node);return lift([0,[0,value]])}
      return return_none}
    function wrap_exn(s)
     {return from(function(param){return get_exn_rec$0(s,s[3])})}
    function nget_rec(node,acc,n,s)
     {var node$0=node,acc$0=acc,n$0=n;
      for(;;)
       {if(0 < n$0)
         {if(node$0 === s[4][1])
           {var
             _dX_=function(param){return nget_rec(node$0,acc$0,n$0,s)},
             _dY_=feed(s);
            return caml_call2(_X_[1],_dY_,_dX_)}
          var _dZ_=s[3][2];
          if(_dZ_)
           {var x=_dZ_[1];
            consume(s,node$0);
            var
             n$1=n$0 - 1 | 0,
             acc$1=[0,x,acc$0],
             node$1=node$0[1],
             node$0=node$1,
             acc$0=acc$1,
             n$0=n$1;
            continue}
          return lift(caml_call1(Stdlib_List[9],acc$0))}
        return lift(caml_call1(Stdlib_List[9],acc$0))}}
    function nget(n,s){return nget_rec(s[3],0,n,s)}
    function get_while_rec(node,acc,f,s)
     {var node$0=node,acc$0=acc;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _dU_=function(param){return get_while_rec(node$0,acc$0,f,s)},
           _dV_=feed(s);
          return caml_call2(_X_[1],_dV_,_dU_)}
        var _dW_=node$0[2];
        if(_dW_)
         {var x=_dW_[1],test=caml_call1(f,x);
          if(test)
           {consume(s,node$0);
            var acc$1=[0,x,acc$0],node$1=node$0[1],node$0=node$1,acc$0=acc$1;
            continue}
          return lift(caml_call1(Stdlib_List[9],acc$0))}
        return lift(caml_call1(Stdlib_List[9],acc$0))}}
    function get_while(f,s){return get_while_rec(s[3],0,f,s)}
    function get_while_s_rec(node,acc,f,s)
     {if(node === s[4][1])
       {var
         _dP_=function(param){return get_while_s_rec(node,acc,f,s)},
         _dQ_=feed(s);
        return caml_call2(_X_[1],_dQ_,_dP_)}
      var _dR_=node[2];
      if(_dR_)
       {var
         x=_dR_[1],
         _dS_=
          function(param)
           {return param
                    ?(consume(s,node),get_while_s_rec(node[1],[0,x,acc],f,s))
                    :lift(caml_call1(Stdlib_List[9],acc))},
         _dT_=caml_call1(f,x);
        return caml_call2(_X_[1],_dT_,_dS_)}
      return lift(caml_call1(Stdlib_List[9],acc))}
    function get_while_s(f,s){return get_while_s_rec(s[3],0,f,s)}
    function next_rec(s,node)
     {if(node === s[4][1])
       {var _dM_=function(param){return next_rec(s,node)},_dN_=feed(s);
        return caml_call2(_X_[1],_dN_,_dM_)}
      var _dO_=node[2];
      if(_dO_){var x=_dO_[1];consume(s,node);return lift(x)}
      return fail(Empty$0)}
    function next(s){return next_rec(s,s[3])}
    function last_new_rec(node,x,s)
     {var node$0=node,x$0=x;
      for(;;)
       {if(node$0 === s[4][1])
         {var thread=feed(s),match=state(thread);
          if(typeof match === "number")
           return lift(x$0);
          else
           {if(0 === match[0])continue;var exn=match[1];return fail(exn)}}
        var _dL_=node$0[2];
        if(_dL_)
         {var x$1=_dL_[1];
          consume(s,node$0);
          var node$1=node$0[1],node$0=node$1,x$0=x$1;
          continue}
        return lift(x$0)}}
    function last_new(s)
     {var node=s[3];
      if(node === s[4][1])
       {var thread=next(s),match=state(thread);
        if(typeof match !== "number" && 0 === match[0])
         {var x=match[1];return last_new_rec(node,x,s)}
        return thread}
      var _dK_=node[2];
      if(_dK_)
       {var x$0=_dK_[1];consume(s,node);return last_new_rec(node[1],x$0,s)}
      return fail(Empty$0)}
    function to_list_rec(node,acc,s)
     {var node$0=node,acc$0=acc;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _dH_=function(param){return to_list_rec(node$0,acc$0,s)},
           _dI_=feed(s);
          return caml_call2(_X_[1],_dI_,_dH_)}
        var _dJ_=node$0[2];
        if(_dJ_)
         {var x=_dJ_[1];
          consume(s,node$0);
          var acc$1=[0,x,acc$0],node$1=node$0[1],node$0=node$1,acc$0=acc$1;
          continue}
        return lift(caml_call1(Stdlib_List[9],acc$0))}}
    function to_list(s){return to_list_rec(s[3],0,s)}
    function to_string_rec(node,buf,s)
     {var node$0=node;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _dE_=function(param){return to_string_rec(node$0,buf,s)},
           _dF_=feed(s);
          return caml_call2(_X_[1],_dF_,_dE_)}
        var _dG_=node$0[2];
        if(_dG_)
         {var x=_dG_[1];
          consume(s,node$0);
          caml_call2(Stdlib_Buffer[12],buf,x);
          var node$1=node$0[1],node$0=node$1;
          continue}
        return lift(caml_call1(Stdlib_Buffer[2],buf))}}
    function to_string(s)
     {var _dD_=caml_call1(Stdlib_Buffer[1],128);
      return to_string_rec(s[3],_dD_,s)}
    function junk(s)
     {var node=s[3];
      if(node === s[4][1])
       {var
         _dB_=
          function(param){if(0 !== node[2])consume(s,node);return return_unit},
         _dC_=feed(s);
        return caml_call2(_X_[1],_dC_,_dB_)}
      if(0 !== node[2])consume(s,node);
      return return_unit}
    function njunk_rec(node,n,s)
     {var node$0=node,n$0=n;
      for(;;)
       {if(0 < n$0)
         {if(node$0 === s[4][1])
           {var
             _dz_=function(param){return njunk_rec(node$0,n$0,s)},
             _dA_=feed(s);
            return caml_call2(_X_[1],_dA_,_dz_)}
          if(node$0[2])
           {consume(s,node$0);
            var n$1=n$0 - 1 | 0,node$1=node$0[1],node$0=node$1,n$0=n$1;
            continue}
          return return_unit}
        return return_unit}}
    function njunk(n,s){return njunk_rec(s[3],n,s)}
    function junk_while_rec(node,f,s)
     {var node$0=node;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _dw_=function(param){return junk_while_rec(node$0,f,s)},
           _dx_=feed(s);
          return caml_call2(_X_[1],_dx_,_dw_)}
        var _dy_=node$0[2];
        if(_dy_)
         {var x=_dy_[1],test=caml_call1(f,x);
          if(test)
           {consume(s,node$0);var node$1=node$0[1],node$0=node$1;continue}
          return return_unit}
        return return_unit}}
    function junk_while(f,s){return junk_while_rec(s[3],f,s)}
    function junk_while_s_rec(node,f,s)
     {if(node === s[4][1])
       {var
         _dr_=function(param){return junk_while_s_rec(node,f,s)},
         _ds_=feed(s);
        return caml_call2(_X_[1],_ds_,_dr_)}
      var _dt_=node[2];
      if(_dt_)
       {var
         x=_dt_[1],
         _du_=
          function(param)
           {return param
                    ?(consume(s,node),junk_while_s_rec(node[1],f,s))
                    :return_unit},
         _dv_=caml_call1(f,x);
        return caml_call2(_X_[1],_dv_,_du_)}
      return return_unit}
    function junk_while_s(f,s){return junk_while_s_rec(s[3],f,s)}
    function junk_old(s)
     {var node=s[3];
      for(;;)
       {if(node === s[4][1])
         {var thread=feed(s),match=state(thread);
          if(typeof match === "number")
           return return_unit;
          else
           {if(0 === match[0])continue;var exn=match[1];return fail(exn)}}
        if(node[2]){consume(s,node);var node$0=node[1],node=node$0;continue}
        return return_unit}}
    function get_available(s)
     {var node=s[3],acc=0;
      for(;;)
       {if(node === s[4][1])
         {var thread=feed(s),match=state(thread);
          if(typeof match === "number")
           return caml_call1(Stdlib_List[9],acc);
          else
           {if(0 === match[0])continue;var exn=match[1];throw exn}}
        var _dq_=node[2];
        if(_dq_)
         {var x=_dq_[1];
          consume(s,node);
          var acc$0=[0,x,acc],node$0=node[1],node=node$0,acc=acc$0;
          continue}
        return caml_call1(Stdlib_List[9],acc)}}
    function get_available_up_to(n$1,s)
     {var node=s[3],acc=0,n=n$1;
      for(;;)
       {if(0 < n)
         {if(node === s[4][1])
           {var thread=feed(s),match=state(thread);
            if(typeof match === "number")
             return caml_call1(Stdlib_List[9],acc);
            else
             {if(0 === match[0])continue;var exn=match[1];throw exn}}
          var _dp_=s[3][2];
          if(_dp_)
           {var x=_dp_[1];
            consume(s,node);
            var
             n$0=n - 1 | 0,
             acc$0=[0,x,acc],
             node$0=node[1],
             node=node$0,
             acc=acc$0,
             n=n$0;
            continue}
          return caml_call1(Stdlib_List[9],acc)}
        return caml_call1(Stdlib_List[9],acc)}}
    function is_empty$0(s)
     {if(s[3] === s[4][1])
       {var _dn_=function(param){return is_empty$0(s)},_do_=feed(s);
        return caml_call2(_X_[1],_do_,_dn_)}
      return lift(0 === s[3][2]?1:0)}
    function map$0(f,s)
     {return from
              (function(param)
                {function _dl_(param)
                  {if(param)
                    {var x=param[1],x$0=caml_call1(f,x);return [0,x$0]}
                   return 0}
                 var _dm_=get$1(s);
                 return caml_call2(_X_[2],_dm_,_dl_)})}
    function map_s(f,s)
     {return from
              (function(param)
                {function _dh_(param)
                  {if(param)
                    {var
                      x=param[1],
                      _dj_=function(x){return [0,x]},
                      _dk_=caml_call1(f,x);
                     return caml_call2(_X_[2],_dk_,_dj_)}
                   return return_none}
                 var _di_=get$1(s);
                 return caml_call2(_X_[1],_di_,_dh_)})}
    function filter(f,s)
     {function next(param)
       {var t=get$1(s);
        function _dg_(param)
         {if(param){var x=param[1],test=caml_call1(f,x);return test?t:next(0)}
          return return_none}
        return caml_call2(_X_[1],t,_dg_)}
      return from(next)}
    function filter_s(f,s)
     {function next(param)
       {var t=get$1(s);
        function _dd_(param)
         {if(param)
           {var
             x=param[1],
             _de_=function(param){return param?t:next(0)},
             _df_=caml_call1(f,x);
            return caml_call2(_X_[1],_df_,_de_)}
          return t}
        return caml_call2(_X_[1],t,_dd_)}
      return from(next)}
    function filter_map(f,s)
     {function next(param)
       {function _db_(param)
         {if(param)
           {var x=param[1],x$0=caml_call1(f,x);return x$0?lift(x$0):next(0)}
          return return_none}
        var _dc_=get$1(s);
        return caml_call2(_X_[1],_dc_,_db_)}
      return from(next)}
    function filter_map_s(f,s)
     {function next(param)
       {function _c__(param)
         {if(param)
           {var
             x=param[1],
             t=caml_call1(f,x),
             _da_=function(param){return param?t:next(0)};
            return caml_call2(_X_[1],t,_da_)}
          return return_none}
        var _c$_=get$1(s);
        return caml_call2(_X_[1],_c$_,_c__)}
      return from(next)}
    function map_list(f,s)
     {var pendings=[0,0];
      function next(param)
       {var _c7_=pendings[1];
        if(_c7_){var l=_c7_[2],x=_c7_[1];pendings[1] = l;return lift([0,x])}
        function _c8_(param)
         {if(param)
           {var x=param[1],l=caml_call1(f,x);pendings[1] = l;return next(0)}
          return return_none}
        var _c9_=get$1(s);
        return caml_call2(_X_[1],_c9_,_c8_)}
      return from(next)}
    function map_list_s(f,s)
     {var pendings=[0,0];
      function next(param)
       {var _c2_=pendings[1];
        if(_c2_){var l=_c2_[2],x=_c2_[1];pendings[1] = l;return lift([0,x])}
        function _c3_(param)
         {if(param)
           {var
             x=param[1],
             _c5_=function(l){pendings[1] = l;return next(0)},
             _c6_=caml_call1(f,x);
            return caml_call2(_X_[1],_c6_,_c5_)}
          return return_none}
        var _c4_=get$1(s);
        return caml_call2(_X_[1],_c4_,_c3_)}
      return from(next)}
    function flatten(s){return map_list(function(l){return l},s)}
    function fold_rec(node,f,s,acc)
     {var node$0=node,acc$0=acc;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _cZ_=function(param){return fold_rec(node$0,f,s,acc$0)},
           _c0_=feed(s);
          return caml_call2(_X_[1],_c0_,_cZ_)}
        var _c1_=node$0[2];
        if(_c1_)
         {var x=_c1_[1];
          consume(s,node$0);
          var
           acc$1=caml_call2(f,x,acc$0),
           node$1=node$0[1],
           node$0=node$1,
           acc$0=acc$1;
          continue}
        return lift(acc$0)}}
    function fold(f,s,acc){return fold_rec(s[3],f,s,acc)}
    function fold_s_rec(node,f,s,acc)
     {if(node === s[4][1])
       {var
         _cU_=function(param){return fold_s_rec(node,f,s,acc)},
         _cV_=feed(s);
        return caml_call2(_X_[1],_cV_,_cU_)}
      var _cW_=node[2];
      if(_cW_)
       {var x=_cW_[1];
        consume(s,node);
        var
         _cX_=function(acc){return fold_s_rec(node[1],f,s,acc)},
         _cY_=caml_call2(f,x,acc);
        return caml_call2(_X_[1],_cY_,_cX_)}
      return lift(acc)}
    function fold_s(f,s,acc){return fold_s_rec(s[3],f,s,acc)}
    function iter_rec(node,f,s)
     {var node$0=node;
      for(;;)
       {if(node$0 === s[4][1])
         {var _cR_=function(param){return iter_rec(node$0,f,s)},_cS_=feed(s);
          return caml_call2(_X_[1],_cS_,_cR_)}
        var _cT_=node$0[2];
        if(_cT_)
         {var x=_cT_[1];
          consume(s,node$0);
          caml_call1(f,x);
          var node$1=node$0[1],node$0=node$1;
          continue}
        return return_unit}}
    function iter(f,s){return iter_rec(s[3],f,s)}
    function iter_s_rec(node,f,s)
     {if(node === s[4][1])
       {var _cM_=function(param){return iter_s_rec(node,f,s)},_cN_=feed(s);
        return caml_call2(_X_[1],_cN_,_cM_)}
      var _cO_=node[2];
      if(_cO_)
       {var x=_cO_[1];
        consume(s,node);
        var
         _cP_=function(param){return iter_s_rec(node[1],f,s)},
         _cQ_=caml_call1(f,x);
        return caml_call2(_X_[1],_cQ_,_cP_)}
      return return_unit}
    function iter_s(f,s){return iter_s_rec(s[3],f,s)}
    function iter_p_rec(node,f,s)
     {if(node === s[4][1])
       {var _cI_=function(param){return iter_p_rec(node,f,s)},_cJ_=feed(s);
        return caml_call2(_X_[1],_cJ_,_cI_)}
      var _cK_=node[2];
      if(_cK_)
       {var x=_cK_[1];
        consume(s,node);
        var
         res=caml_call1(f,x),
         rest=iter_p_rec(node[1],f,s),
         _cL_=function(param){return rest};
        return caml_call2(_X_[1],res,_cL_)}
      return return_unit}
    function iter_p(f,s){return iter_p_rec(s[3],f,s)}
    function iter_n(opt,f,stream)
     {if(opt)var sth=opt[1],max_concurrency=sth;else var max_concurrency=1;
      if(max_concurrency <= 0)
       {var message=caml_call2(Stdlib_Printf[4],_$_,max_concurrency);
        caml_call1(Stdlib[1],message)}
      function loop(running,available)
       {function _cC_(param)
         {var available=param[2],running=param[1];
          function _cG_(param)
           {if(param)
             {var elt=param[1];
              return loop([0,caml_call1(f,elt),running],available - 1 | 0)}
            return join(running)}
          var _cH_=get$1(stream);
          return caml_call2(_X_[1],_cH_,_cG_)}
        if(0 < available)
         var _cD_=lift([0,running,available]);
        else
         var
          _cE_=
           function(param)
            {var running=param[2],complete=param[1];
             return lift
                     ([0,
                       running,
                       available + caml_call1(Stdlib_List[1],complete) | 0])},
          _cF_=nchoose_split(running),
          _cD_=caml_call2(_X_[1],_cF_,_cE_);
        return caml_call2(_X_[1],_cD_,_cC_)}
      return loop(0,max_concurrency)}
    function find_rec(node,f,s)
     {var node$0=node;
      for(;;)
       {if(node$0 === s[4][1])
         {var _cz_=function(param){return find_rec(node$0,f,s)},_cA_=feed(s);
          return caml_call2(_X_[1],_cA_,_cz_)}
        var _cB_=node$0[2];
        if(_cB_)
         {var x=_cB_[1];
          consume(s,node$0);
          var test=caml_call1(f,x);
          if(test)return lift(_cB_);
          var node$1=node$0[1],node$0=node$1;
          continue}
        return return_none}}
    function find(f,s){return find_rec(s[3],f,s)}
    function find_s_rec(node,f,s)
     {if(node === s[4][1])
       {var _cu_=function(param){return find_s_rec(node,f,s)},_cv_=feed(s);
        return caml_call2(_X_[1],_cv_,_cu_)}
      var _cw_=node[2];
      if(_cw_)
       {var x=_cw_[1];
        consume(s,node);
        var
         _cx_=function(param){return param?lift(_cw_):find_s_rec(node[1],f,s)},
         _cy_=caml_call1(f,x);
        return caml_call2(_X_[1],_cy_,_cx_)}
      return return_none}
    function find_s(f,s){return find_s_rec(s[3],f,s)}
    function find_map_rec(node,f,s)
     {var node$0=node;
      for(;;)
       {if(node$0 === s[4][1])
         {var
           _cr_=function(param){return find_map_rec(node$0,f,s)},
           _cs_=feed(s);
          return caml_call2(_X_[1],_cs_,_cr_)}
        var _ct_=node$0[2];
        if(_ct_)
         {var x=_ct_[1];
          consume(s,node$0);
          var x$0=caml_call1(f,x);
          if(0 === x$0){var node$1=node$0[1],node$0=node$1;continue}
          return lift(x$0)}
        return return_none}}
    function find_map(f,s){return find_map_rec(s[3],f,s)}
    function find_map_s_rec(node,f,s)
     {if(node === s[4][1])
       {var
         _cn_=function(param){return find_map_s_rec(node,f,s)},
         _co_=feed(s);
        return caml_call2(_X_[1],_co_,_cn_)}
      var _cp_=node[2];
      if(_cp_)
       {var x=_cp_[1];
        consume(s,node);
        var
         t=caml_call1(f,x),
         _cq_=function(param){return param?t:find_map_s_rec(node[1],f,s)};
        return caml_call2(_X_[1],t,_cq_)}
      return return_none}
    function find_map_s(f,s){return find_map_s_rec(s[3],f,s)}
    function combine(s1,s2)
     {function next(param)
       {var t1=get$1(s1),t2=get$1(s2);
        function _cl_(n1)
         {function _cm_(n2)
           {if(n1 && n2){var x2=n2[1],x1=n1[1];return lift([0,[0,x1,x2]])}
            return return_none}
          return caml_call2(_X_[1],t2,_cm_)}
        return caml_call2(_X_[1],t1,_cl_)}
      return from(next)}
    function append(s1,s2)
     {var current_s=[0,s1];
      function next(param)
       {var t=get$1(current_s[1]);
        function _ck_(param)
         {return param
                  ?t
                  :current_s[1] === s2?return_none:(current_s[1] = s2,next(0))}
        return caml_call2(_X_[1],t,_ck_)}
      return from(next)}
    function concat(s_top)
     {var current_s=[0,from(function(param){return return_none})];
      function next(param)
       {var t=get$1(current_s[1]);
        function _ch_(param)
         {if(param)return t;
          function _ci_(param)
           {if(param){var s=param[1];current_s[1] = s;return next(0)}
            return return_none}
          var _cj_=get$1(s_top);
          return caml_call2(_X_[1],_cj_,_ci_)}
        return caml_call2(_X_[1],t,_ch_)}
      return from(next)}
    function choose$0(streams)
     {function source(s)
       {function _cf_(x){return [0,s,x]}
        var _cg_=get$1(s);
        return [0,s,caml_call2(_X_[2],_cg_,_cf_)]}
      var streams$0=[0,caml_call2(Stdlib_List[19],source,streams)];
      function next(param)
       {var _ca_=streams$0[1];
        if(_ca_)
         {var
           _cb_=
            function(param)
             {var x=param[2],s=param[1],l=caml_call2(Stdlib_List[53],s,_ca_);
              return x
                      ?(streams$0[1] = [0,source(s),l],lift(x))
                      :(streams$0[1] = l,next(0))},
           _cc_=function(_ce_){return _ce_[2]},
           _cd_=choose(caml_call2(Stdlib_List[19],_cc_,_ca_));
          return caml_call2(_X_[1],_cd_,_cb_)}
        return return_none}
      return from(next)}
    function parse(s,f)
     {if(3 === s[1][0])caml_call1(Stdlib[1],cst_Lwt_stream_parse);
      var node=s[3];
      function _b$_(exn){s[3] = node;return fail(exn)}
      return catch$0(function(param){return caml_call1(f,s)},_b$_)}
    function hexdump(stream)
     {var buf=caml_call1(Stdlib_Buffer[1],80),num=[0,0];
      return from
              (function(param)
                {function _b7_(l)
                  {if(l)
                    {caml_call1(Stdlib_Buffer[8],buf);
                     caml_call3(Stdlib_Printf[5],buf,_aa_,num[1]);
                     num[1] = num[1] + 16 | 0;
                     var pos=0,param=l;
                     for(;;)
                      {if(param)
                        {var l$0=param[2],x=param[1];
                         if(8 === pos)caml_call2(Stdlib_Buffer[12],buf,32);
                         caml_call3(Stdlib_Printf[5],buf,_ab_,x);
                         var pos$0=pos + 1 | 0,pos=pos$0,param=l$0;
                         continue}
                       var pos$1=pos;
                       for(;;)
                        {if(pos$1 < 16)
                          {if(8 === pos$1)
                            caml_call2(Stdlib_Buffer[16],buf,cst$3);
                           else
                            caml_call2(Stdlib_Buffer[16],buf,cst$4);
                           var pos$2=pos$1 + 1 | 0,pos$1=pos$2;
                           continue}
                         caml_call2(Stdlib_Buffer[16],buf,cst$5);
                         var
                          _b9_=
                           function(ch)
                            {var switch$0=0;
                             if(32 <= ch && ! (126 < ch)){var _b__=ch;switch$0 = 1}
                             if(! switch$0)var _b__=46;
                             return caml_call2(Stdlib_Buffer[12],buf,_b__)};
                         caml_call2(Stdlib_List[17],_b9_,l);
                         caml_call2(Stdlib_Buffer[12],buf,124);
                         return lift([0,caml_call1(Stdlib_Buffer[2],buf)])}}}
                   return return_none}
                 var _b8_=nget(16,stream);
                 return caml_call2(_X_[1],_b8_,_b7_)})}
    var
     Lwt_stream=
      [0,
       from,
       from_direct,
       Closed,
       create$1,
       create_with_reference,
       Full,
       create_bounded,
       of_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty$0,
       peek,
       npeek,
       get$1,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_old,
       get_available,
       get_available_up_to,
       is_empty$0,
       is_closed,
       closed,
       on_terminate,
       on_terminate,
       choose$0,
       map$0,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump,
       map_exn];
    caml_register_global(101,Lwt_stream,"Lwt_stream");
    function return$0(x){return lift([0,x])}
    function fail$0(e){return lift([1,e])}
    function ok(x){return symbol(function(y){return [0,y]},x)}
    function map$1(f,e)
     {return symbol
              (function(param)
                {if(0 === param[0]){var x=param[1];return [0,caml_call1(f,x)]}
                 var e=param[1];
                 return [1,e]},
               e)}
    function map_err(f,e)
     {return symbol
              (function(param)
                {if(0 === param[0]){var x=param[1];return [0,x]}
                 var e=param[1];
                 return [1,caml_call1(f,e)]},
               e)}
    function catch$1(e){return catch$0(function(param){return ok(e)},fail$0)}
    function get_exn(e)
     {return symbol_bind
              (e,
               function(param)
                {if(0 === param[0]){var x=param[1];return lift(x)}
                 var e=param[1];
                 return fail(e)})}
    function symbol_bind$0(e,f)
     {return symbol_bind
              (e,
               function(param)
                {if(0 === param[0]){var x=param[1];return caml_call1(f,x)}
                 var e=param[1];
                 return lift([1,e])})}
    function bind_lwt(e,f)
     {return symbol_bind
              (e,
               function(param)
                {if(0 === param[0]){var x=param[1];return ok(caml_call1(f,x))}
                 var e=param[1];
                 return fail$0(e)})}
    function bind_result(e,f)
     {return symbol
              (function(param)
                {if(0 === param[0]){var x=param[1];return caml_call1(f,x)}
                 var e=param[1];
                 return [1,e]},
               e)}
    function bind_lwt_err(e,f)
     {return symbol_bind
              (e,
               function(param)
                {if(0 === param[0]){var x=param[1];return return$0(x)}
                 var e=param[1];
                 return symbol_bind(caml_call1(f,e),fail$0)})}
    function both$0(a,b)
     {var s=[0,0];
      function set_once(e){return s[1]?0:(s[1] = [0,e],0)}
      var b$0=map_err(set_once,b),a$0=map_err(set_once,a),_b2_=both(a$0,b$0);
      return symbol
              (function(param)
                {var _b3_=param[1];
                 if(0 === _b3_[0])
                  {var _b4_=param[2],_b5_=_b3_[1];
                   if(0 === _b4_[0]){var y=_b4_[1];return [0,[0,_b5_,y]]}}
                 var _b6_=s[1];
                 if(_b6_){var e=_b6_[1];return [1,e]}
                 throw [0,Assert_failure,_ac_]},
               _b2_)}
    function symbol$4(e,f){return map$1(f,e)}
    function map$2(t,f){return map$1(f,t)}
    function bind$0(t,f){return symbol_bind$0(t,f)}
    var
     Open_on_rhs$0=[0],
     Let_syntax$2=[0,return$0,map$2,bind$0,both$0,Open_on_rhs$0],
     Let_syntax$3=[0,Let_syntax$2];
    function let$1(x,f){return map$1(f,x)}
    var
     Syntax$0=[0,symbol_bind$0,both$0,let$1,both$0],
     Lwt_result=
      [0,
       return$0,
       fail$0,
       lift,
       ok,
       catch$1,
       get_exn,
       map$1,
       map_err,
       symbol_bind$0,
       bind_lwt,
       bind_lwt_err,
       bind_result,
       both$0,
       [0,symbol$4,symbol_bind$0],
       Let_syntax$3,
       Syntax$0,
       symbol$4,
       symbol_bind$0];
    caml_register_global(102,Lwt_result,"Lwt_result");
    function Make(Ord)
     {function link(t1,t2)
       {var
         c2=t2[3],
         r2=t2[2],
         x2=t2[1],
         c1=t1[3],
         r1=t1[2],
         x1=t1[1],
         c=caml_call2(Ord[1],x1,x2);
        return 0 < c?[0,x2,r2 + 1 | 0,[0,t1,c2]]:[0,x1,r1 + 1 | 0,[0,t2,c1]]}
      function ins(t,ts)
       {var t$0=t,ts$0=ts;
        for(;;)
         {if(ts$0)
           {var t$1=ts$0[1];
            if(t$0[2] < t$1[2])return [0,t$0,ts$0];
            var ts$1=ts$0[2],t$2=link(t$0,t$1),t$0=t$2,ts$0=ts$1;
            continue}
          return [0,t$0,0]}}
      var empty=0;
      function is_empty(ts){return 0 === ts?1:0}
      function add(x,ts){return ins([0,x,0,0],ts)}
      function union(ts$0,ts)
       {if(ts$0)
         {if(ts)
           {var ts2=ts[2],t2=ts[1],ts1=ts$0[2],t1=ts$0[1];
            if(t1[2] < t2[2])return [0,t1,union(ts1,[0,t2,ts2])];
            if(t2[2] < t1[2])return [0,t2,union([0,t1,ts1],ts2)];
            var _b1_=union(ts1,ts2);
            return ins(link(t1,t2),_b1_)}
          return ts$0}
        return ts}
      function find_min(param)
       {if(param)
         {var _b0_=param[1];
          if(param[2])
           {var ts=param[2],x=find_min(ts),c=caml_call2(Ord[1],_b0_[1],x);
            return 0 <= c?x:_b0_[1]}
          return _b0_[1]}
        throw Stdlib[8]}
      function lookup_min(param)
       {if(param)
         {var _bZ_=param[1];
          if(param[2])
           {var ts=param[2],result=lookup_min(ts);
            if(result)
             {var x=result[1],c=caml_call2(Ord[1],_bZ_[1],x);
              return 0 <= c?result:[0,_bZ_[1]]}
            return 0}
          return [0,_bZ_[1]]}
        return 0}
      function get_min(param)
       {if(param)
         {var _bY_=param[1];
          if(param[2])
           {var
             ts=param[2],
             match=get_min(ts),
             ts$0=match[2],
             t=match[1],
             c=caml_call2(Ord[1],_bY_[1],t[1]);
            return 0 <= c?[0,t,[0,_bY_,ts$0]]:[0,_bY_,ts]}
          return [0,_bY_,0]}
        throw [0,Assert_failure,_ad_]}
      function remove_min(ts)
       {if(ts)
         {var _bX_=get_min(ts),ts$0=_bX_[2],match=_bX_[1],c=match[3];
          return union(caml_call1(Stdlib_List[9],c),ts$0)}
        throw Stdlib[8]}
      function size(l)
       {var _bV_=0;
        function _bW_(s,t){var tl=t[3];return s + (1 + size(tl) | 0) | 0}
        return caml_call3(Stdlib_List[25],_bW_,_bV_,l)}
      return [0,empty,is_empty,add,union,find_min,lookup_min,remove_min,size]}
    var Lwt_pqueue=[0,Make];
    caml_register_global(103,Lwt_pqueue,"Lwt_pqueue");
    function tail_recursive_map(f,l)
     {var _bU_=caml_call2(Stdlib_List[21],f,l);
      return caml_call1(Stdlib_List[9],_bU_)}
    function tail_recursive_mapi_rev(f,param)
     {var acc=0,i=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           tl=param$0[2],
           hd=param$0[1],
           i$0=i + 1 | 0,
           acc$0=[0,caml_call2(f,i,hd),acc],
           acc=acc$0,
           i=i$0,
           param$0=tl;
          continue}
        return acc}}
    function iter_s$0(f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bS_=function(param){return iter_s$0(f,l$0)},
         _bT_=apply(f,x);
        return caml_call2(_X_[1],_bT_,_bS_)}
      return return_unit}
    function iter_p$0(f,l)
     {function _bQ_(_bR_){return apply(f,_bR_)}
      var ts=caml_call2(Stdlib_List[21],_bQ_,l);
      return join(ts)}
    function _ae_(i,f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bO_=function(param){return _ae_(i + 1 | 0,f,l$0)},
         _bP_=apply(caml_call1(f,i),x);
        return caml_call2(_X_[1],_bP_,_bO_)}
      return return_unit}
    function iteri_s(f,l){return _ae_(0,f,l)}
    function iteri_p(f,l)
     {function f$0(i)
       {var _bM_=caml_call1(f,i);
        return function(_bN_){return apply(_bM_,_bN_)}}
      var ts=tail_recursive_mapi_rev(f$0,l);
      return join(ts)}
    function map_s$0(f,l)
     {function inner(acc,param)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           _bK_=function(r){return inner([0,r,acc],tl)},
           _bL_=apply(f,hd);
          return caml_call2(_X_[1],_bL_,_bK_)}
        return lift(caml_call1(Stdlib_List[9],acc))}
      return inner(0,l)}
    function collect_rev(acc,param)
     {if(param)
       {var
         ts=param[2],
         t=param[1],
         _bJ_=function(i){return collect_rev([0,i,acc],ts)};
        return caml_call2(_X_[1],t,_bJ_)}
      return lift(acc)}
    function map_p(f,l)
     {function _bH_(_bI_){return apply(f,_bI_)}
      var ts=caml_call2(Stdlib_List[21],_bH_,l);
      return collect_rev(0,ts)}
    function filter_map_s$0(f,l)
     {function inner(acc,param)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           _bF_=
            function(param)
             {if(param){var v=param[1];return inner([0,v,acc],tl)}
              return inner(acc,tl)},
           _bG_=apply(f,hd);
          return caml_call2(_X_[1],_bG_,_bF_)}
        return lift(caml_call1(Stdlib_List[9],acc))}
      return inner(0,l)}
    function filter_map_p(f,l)
     {function collect_optional_rev(acc,param)
       {if(param)
         {var
           ts=param[2],
           t=param[1],
           _bE_=
            function(param)
             {if(param)
               {var v=param[1];return collect_optional_rev([0,v,acc],ts)}
              return collect_optional_rev(acc,ts)};
          return caml_call2(_X_[1],t,_bE_)}
        return lift(acc)}
      function _bC_(_bD_){return apply(f,_bD_)}
      var ts=caml_call2(Stdlib_List[21],_bC_,l);
      return collect_optional_rev(0,ts)}
    function mapi_s(f,l)
     {function inner(acc,i,param)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           _bA_=function(v){return inner([0,v,acc],i + 1 | 0,tl)},
           _bB_=apply(caml_call1(f,i),hd);
          return caml_call2(_X_[1],_bB_,_bA_)}
        return lift(caml_call1(Stdlib_List[9],acc))}
      return inner(0,0,l)}
    function mapi_p(f,l)
     {function f$0(i)
       {var _by_=caml_call1(f,i);
        return function(_bz_){return apply(_by_,_bz_)}}
      var ts=tail_recursive_mapi_rev(f$0,l);
      return collect_rev(0,ts)}
    function rev_map_append_s(acc,f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bw_=function(x){return rev_map_append_s([0,x,acc],f,l$0)},
         _bx_=apply(f,x);
        return caml_call2(_X_[1],_bx_,_bw_)}
      return lift(acc)}
    function rev_map_s(f,l){return rev_map_append_s(0,f,l)}
    function rev_map_p(f,l$1)
     {var acc$0=acc,l=l$1;
      for(;;)
       {if(l)
         {var
           l$0=l[2],
           x=l[1],
           _bt_=
            function(acc)
              {return function(x)
                {function _bv_(l){return [0,x,l]}
                 return caml_call2(_X_[2],acc,_bv_)}}
             (acc$0),
           _bu_=apply(f,x),
           acc$1=caml_call2(_X_[1],_bu_,_bt_),
           acc$0=acc$1,
           l=l$0;
          continue}
        return acc$0}}
    function fold_left_s(f,acc,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _br_=function(acc){return fold_left_s(f,acc,l$0)},
         _bs_=apply(caml_call1(f,acc),x);
        return caml_call2(_X_[1],_bs_,_br_)}
      return lift(acc)}
    function fold_right_s(f,l,acc)
     {function inner(f,a,param)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           _bp_=function(a){return inner(f,a,tl)},
           _bq_=apply(caml_call1(f,hd),a);
          return caml_call2(_X_[1],_bq_,_bp_)}
        return lift(a)}
      return inner(f,acc,caml_call1(Stdlib_List[9],l))}
    function for_all_s(f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bn_=function(param){return param?for_all_s(f,l$0):return_false},
         _bo_=apply(f,x);
        return caml_call2(_X_[1],_bo_,_bn_)}
      return return_true}
    function for_all_p(f,l)
     {function _bk_(bl)
       {function _bm_(x){return x}
        return lift(caml_call2(Stdlib_List[32],_bm_,bl))}
      var _bl_=map_p(f,l);
      return caml_call2(_X_[1],_bl_,_bk_)}
    function exists_s(f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bi_=function(param){return param?return_true:exists_s(f,l$0)},
         _bj_=apply(f,x);
        return caml_call2(_X_[1],_bj_,_bi_)}
      return return_false}
    function exists_p(f,l)
     {function _bf_(bl)
       {function _bh_(x){return x}
        return lift(caml_call2(Stdlib_List[33],_bh_,bl))}
      var _bg_=map_p(f,l);
      return caml_call2(_X_[1],_bg_,_bf_)}
    function find_s$0(f,l)
     {if(l)
       {var
         l$0=l[2],
         x=l[1],
         _bd_=function(param){return param?lift(x):find_s$0(f,l$0)},
         _be_=apply(f,x);
        return caml_call2(_X_[1],_be_,_bd_)}
      return fail(Stdlib[8])}
    function optionalize(f,x)
     {function _bb_(b){return b?lift([0,x]):lift(0)}
      var _bc_=caml_call1(f,x);
      return caml_call2(_X_[1],_bc_,_bb_)}
    function filter_s$0(f,l)
     {return filter_map_s$0(function(_ba_){return optionalize(f,_ba_)},l)}
    function filter_p(f,l)
     {return filter_map_p(function(_a$_){return optionalize(f,_a$_)},l)}
    function partition_s(f,l)
     {function inner(acc1,acc2,param)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           _a8_=
            function(b)
             {return b?inner([0,hd,acc1],acc2,tl):inner(acc1,[0,hd,acc2],tl)},
           _a9_=apply(f,hd);
          return caml_call2(_X_[1],_a9_,_a8_)}
        var _a__=caml_call1(Stdlib_List[9],acc2);
        return lift([0,caml_call1(Stdlib_List[9],acc1),_a__])}
      return inner(0,0,l)}
    function partition_p(f,l)
     {function g(x)
       {function _a6_(b){return lift([0,b,x])}
        var _a7_=apply(f,x);
        return caml_call2(_X_[1],_a7_,_a6_)}
      function _aX_(tl)
       {function _aZ_(_a5_){return _a5_[1]}
        var
         _a0_=caml_call2(Stdlib_List[41],_aZ_,tl),
         group1=tail_recursive_map(function(_a4_){return _a4_[2]},_a0_);
        function _a1_(x){return 1 - x[1]}
        var
         _a2_=caml_call2(Stdlib_List[41],_a1_,tl),
         group2=tail_recursive_map(function(_a3_){return _a3_[2]},_a2_);
        return lift([0,group1,group2])}
      var _aY_=map_p(g,l);
      return caml_call2(_X_[1],_aY_,_aX_)}
    var
     Lwt_list=
      [0,
       iter_s$0,
       iter_p$0,
       iteri_s,
       iteri_p,
       map_s$0,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s$0,
       filter_s$0,
       filter_p,
       filter_map_s$0,
       filter_map_p,
       partition_s,
       partition_p];
    caml_register_global(104,Lwt_list,"Lwt_list");
    function create$2(m,opt,_aV_,_aU_,create$0)
     {if(opt)
       var sth=opt[1],validate=sth;
      else
       var validate=function(param){return return_true};
      if(_aV_)
       var sth$0=_aV_[1],check=sth$0;
      else
       var check=function(param,f){return caml_call1(f,1)};
      if(_aU_)
       var sth$1=_aU_[1],dispose=sth$1;
      else
       var dispose=function(param){return return_unit};
      var _aW_=create(0);
      return [0,
              create$0,
              check,
              validate,
              dispose,
              [0,[0,0]],
              m,
              0,
              caml_call1(Stdlib_Queue[2],0),
              _aW_]}
    function create_member(p)
     {function _aT_(exn){p[7] = p[7] - 1 | 0;return fail(exn)}
      return catch$0
              (function(param){p[7] = p[7] + 1 | 0;return caml_call1(p[1],0)},
               _aT_)}
    function release(p,c)
     {var match=take_opt_l(p[9]);
      if(match){var wakener=match[1];return wakeup_later(wakener,c)}
      return caml_call2(Stdlib_Queue[4],c,p[8])}
    function dispose(p,c)
     {function _aR_(param){p[7] = p[7] - 1 | 0;return return_unit}
      var _aS_=caml_call1(p[4],c);
      return caml_call2(_X_[1],_aS_,_aR_)}
    function validate_and_return(p,c)
     {function _aJ_(e)
       {function _aN_(param)
         {var match=take_opt_l(p[9]);
          if(match)
           {var
             wakener=match[1],
             _aP_=function(exn){return wakeup_later_exn(wakener,exn)},
             _aQ_=function(c){return wakeup_later(wakener,c)};
            on_any(apply(p[1],0),_aQ_,_aP_)}
          return fail(e)}
        var _aO_=dispose(p,c);
        return caml_call2(_X_[1],_aO_,_aN_)}
      function _aK_(param)
       {if(param)return lift(c);
        function _aL_(param){return create_member(p)}
        var _aM_=dispose(p,c);
        return caml_call2(_X_[1],_aM_,_aL_)}
      return try_bind(function(param){return caml_call1(p[3],c)},_aK_,_aJ_)}
    function use(p,f)
     {function _ay_(c)
       {var cleared=p[5][1];
        function _aB_(e)
         {function _aG_(param){return fail(e)}
          var ok=[0,0],_aH_=cleared[1];
          function _aF_(result){ok[1] = result;return 0}
          caml_call2(p[2],c,_aF_);
          var switch$0=0;
          if(! _aH_ && ok[1]){release(p,c);var _aI_=return_unit;switch$0 = 1}
          if(! switch$0)var _aI_=dispose(p,c);
          return caml_call2(_X_[1],_aI_,_aG_)}
        var promise=catch$0(function(param){return caml_call1(f,c)},_aB_);
        function _aC_(param)
         {if(cleared[1])
           {var _aD_=function(param){return promise},_aE_=dispose(p,c);
            return caml_call2(_X_[1],_aE_,_aD_)}
          release(p,c);
          return promise}
        return caml_call2(_X_[1],promise,_aC_)}
      if(caml_call1(Stdlib_Queue[13],p[8]))
       if(p[7] < p[6])
        var _az_=create_member(p);
       else
        var
         _aw_=function(_aA_){return validate_and_return(p,_aA_)},
         _ax_=add_task_r(p[9]),
         _az_=caml_call2(_X_[1],_ax_,_aw_);
      else
       var c=caml_call1(Stdlib_Queue[5],p[8]),_az_=validate_and_return(p,c);
      return caml_call2(_X_[1],_az_,_ay_)}
    function clear$0(p)
     {var _as_=p[8],_at_=0;
      function _au_(l,element){return [0,element,l]}
      var elements=caml_call3(Stdlib_Queue[16],_au_,_at_,_as_);
      caml_call1(Stdlib_Queue[11],p[8]);
      var old_cleared=p[5][1];
      old_cleared[1] = 1;
      p[5][1] = [0,0];
      return iter_s$0(function(_av_){return dispose(p,_av_)},elements)}
    function wait_queue_length(p){return length(p[9])}
    var Lwt_pool=[0,create$2,use,clear$0,wait_queue_length];
    caml_register_global(105,Lwt_pool,"Lwt_pool");
    function create_empty(param)
     {var _ar_=create(0);return [0,0,create(0),_ar_]}
    function create$3(v){var _aq_=create(0);return [0,[0,v],create(0),_aq_]}
    function put(mvar,v)
     {if(mvar[1])
       {var match=task(0),w=match[2],res=match[1],node=add_r([0,v,w],mvar[2]);
        on_cancel(res,function(param){return remove(node)});
        return res}
      var match$0=take_opt_l(mvar[3]);
      if(match$0){var w$0=match$0[1];wakeup_later(w$0,v)}else mvar[1] = [0,v];
      return return_unit}
    function take_available(mvar)
     {var _ap_=mvar[1];
      if(_ap_)
       {var v$0=_ap_[1],match=take_opt_l(mvar[2]);
        if(match)
         {var match$0=match[1],w=match$0[2],v=match$0[1];
          mvar[1] = [0,v];
          wakeup_later(w,0)}
        else
         mvar[1] = 0;
        return [0,v$0]}
      return 0}
    function take(mvar)
     {var match=take_available(mvar);
      if(match){var v=match[1];return lift(v)}
      return add_task_r(mvar[3])}
    function is_empty$1(mvar){return mvar[1]?0:1}
    var Lwt_mvar=[0,create$3,create_empty,put,take,take_available,is_empty$1];
    caml_register_global(106,Lwt_mvar,"Lwt_mvar");
    function create$4(param){return [0,0,create(0)]}
    function lock(m){return m[1]?add_task_r(m[2]):(m[1] = 1,return_unit)}
    function unlock(m)
     {var _ao_=m[1];
      return _ao_
              ?is_empty(m[2])?(m[1] = 0,0):wakeup_later(take_l(m[2]),0)
              :_ao_}
    function with_lock(m,f)
     {function _am_(param)
       {return finalize(f,function(param){unlock(m);return return_unit})}
      var _an_=lock(m);
      return caml_call2(_X_[1],_an_,_am_)}
    function is_locked(m){return m[1]}
    function is_empty$2(m){return is_empty(m[2])}
    var Lwt_mutex=[0,create$4,lock,unlock,is_locked,is_empty$2,with_lock];
    caml_register_global(107,Lwt_mutex,"Lwt_mutex");
    function wait$0(mutex,cvar)
     {var waiter=add_task_r(cvar);
      if(mutex){var m=mutex[1];unlock(m)}
      function _al_(param)
       {if(mutex){var m=mutex[1];return lock(m)}return return_unit}
      return finalize(function(param){return waiter},_al_)}
    function signal(cvar,arg)
     {try
       {var _aj_=wakeup_later(take_l(cvar),arg);return _aj_}
      catch(_ak_)
       {_ak_ = caml_wrap_exception(_ak_);
        if(_ak_ === Empty)return 0;
        throw _ak_}}
    function broadcast(cvar,arg)
     {var _ah_=0,wakeners=fold_r(function(x,l){return [0,x,l]},cvar,_ah_);
      iter_node_l(remove,cvar);
      function _ai_(wakener){return wakeup_later(wakener,arg)}
      return caml_call2(Stdlib_List[17],_ai_,wakeners)}
    function broadcast_exn(cvar,exn)
     {var _af_=0,wakeners=fold_r(function(x,l){return [0,x,l]},cvar,_af_);
      iter_node_l(remove,cvar);
      function _ag_(wakener){return wakeup_later_exn(wakener,exn)}
      return caml_call2(Stdlib_List[17],_ag_,wakeners)}
    var Lwt_condition=[0,create,wait$0,signal,broadcast,broadcast_exn];
    caml_register_global(108,Lwt_condition,"Lwt_condition");
    return}
  (function(){return this}()));


//# 1 "../../.js/js_of_ocaml-lwt/js_of_ocaml_lwt.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_js_from_bool=runtime.caml_js_from_bool,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_PATCH=caml_string_of_jsbytes("PATCH"),
     cst_POST=caml_string_of_jsbytes("POST"),
     cst_HEAD=caml_string_of_jsbytes("HEAD"),
     cst_DELETE=caml_string_of_jsbytes("DELETE"),
     cst_PUT=caml_string_of_jsbytes("PUT"),
     cst_OPTIONS=caml_string_of_jsbytes("OPTIONS"),
     cst_GET=caml_string_of_jsbytes("GET"),
     cst_POST$2=caml_string_of_jsbytes("POST"),
     c=caml_string_of_jsbytes("application/x-www-form-urlencoded"),
     cst_POST$0=caml_string_of_jsbytes("POST"),
     cst_POST$1=caml_string_of_jsbytes("POST"),
     cst_GET$0=caml_string_of_jsbytes("GET"),
     cst$3=caml_string_of_jsbytes("&"),
     cst$4=caml_string_of_jsbytes("?"),
     cst$2=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes("="),
     cst$0=caml_string_of_jsbytes("="),
     cst$1=caml_string_of_jsbytes("&"),
     cst_Js_of_ocaml_lwt_Lwt_xmlHtt=
      caml_string_of_jsbytes
       ("Js_of_ocaml_lwt__Lwt_xmlHttpRequest.Wrong_headers"),
     cst_Exception_during_Lwt_async=
      caml_string_of_jsbytes("Exception during Lwt.async: "),
     cst_Jsonp_call_Cannot_parse_ur=
      caml_string_of_jsbytes("Jsonp.call: Cannot parse url"),
     cst_callback=caml_string_of_jsbytes("callback"),
     cst$6=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes(""),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_transitionend=caml_string_of_jsbytes("transitionend"),
     cst_transition=caml_string_of_jsbytes("transition"),
     cst_otransitionend=caml_string_of_jsbytes("otransitionend"),
     cst_oTransitionEnd=caml_string_of_jsbytes("oTransitionEnd"),
     cst_OTransition=caml_string_of_jsbytes("OTransition"),
     cst_transitionend$0=caml_string_of_jsbytes("transitionend"),
     cst_MozTransition=caml_string_of_jsbytes("MozTransition"),
     cst_webkitTransitionEnd=caml_string_of_jsbytes("webkitTransitionEnd"),
     cst_WebkitTransition=caml_string_of_jsbytes("WebkitTransition"),
     cst_Lwt_js_event$1=caml_string_of_jsbytes("Lwt_js_event"),
     cst_Lwt_js_event$0=caml_string_of_jsbytes("Lwt_js_event"),
     cst_Lwt_js_event=caml_string_of_jsbytes("Lwt_js_event"),
     Stdlib_String=global_data.Stdlib__String,
     Stdlib_Char=global_data.Stdlib__Char,
     Js_of_ocaml_Url=global_data.Js_of_ocaml__Url,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Js_of_ocaml_Dom=global_data.Js_of_ocaml__Dom,
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Lwt=global_data.Lwt,
     Js_of_ocaml_Form=global_data.Js_of_ocaml__Form,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib=global_data.Stdlib,
     Js_of_ocaml_XmlHttpRequest=global_data.Js_of_ocaml__XmlHttpRequest,
     Assert_failure=global_data.Assert_failure,
     Js_of_ocaml_File=global_data.Js_of_ocaml__File,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Js_of_ocaml_Firebug=global_data.Js_of_ocaml__Firebug,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Stdlib_Random=global_data.Stdlib__Random,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Lwt_condition=global_data.Lwt_condition,
     Js_of_ocaml_lwt=[0];
    caml_register_global(128,Js_of_ocaml_lwt,"Js_of_ocaml_lwt__");
    var
     Poly=[0],
     _e_=[0,caml_string_of_jsbytes("lib/lwt/lwt_xmlHttpRequest.ml"),98,29],
     _d_=[0,caml_string_of_jsbytes("lib/lwt/lwt_xmlHttpRequest.ml"),90,29],
     _c_=[0,caml_string_of_jsbytes("lib/lwt/lwt_xmlHttpRequest.ml"),82,29],
     _b_=[0,caml_string_of_jsbytes("lib/lwt/lwt_xmlHttpRequest.ml"),74,29],
     _a_=[0,caml_string_of_jsbytes("lib/lwt/lwt_xmlHttpRequest.ml"),66,29],
     _h_=[0,caml_string_of_jsbytes("lib/lwt/lwt_file.ml"),37,22];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_String[1],
     init=Stdlib_String[2],
     empty=Stdlib_String[3],
     of_bytes=Stdlib_String[4],
     to_bytes=Stdlib_String[5],
     concat=Stdlib_String[6],
     cat=Stdlib_String[7],
     compare$0=Stdlib_String[9],
     starts_with=Stdlib_String[10],
     ends_with=Stdlib_String[11],
     contains_from=Stdlib_String[12],
     rcontains_from=Stdlib_String[13],
     contains=Stdlib_String[14],
     sub=Stdlib_String[15],
     split_on_char=Stdlib_String[16],
     map=Stdlib_String[17],
     mapi=Stdlib_String[18],
     fold_left=Stdlib_String[19],
     fold_right=Stdlib_String[20],
     for_all=Stdlib_String[21],
     exists=Stdlib_String[22],
     trim=Stdlib_String[23],
     escaped=Stdlib_String[24],
     uppercase_ascii=Stdlib_String[25],
     lowercase_ascii=Stdlib_String[26],
     capitalize_ascii=Stdlib_String[27],
     uncapitalize_ascii=Stdlib_String[28],
     iter=Stdlib_String[29],
     iteri=Stdlib_String[30],
     index_from=Stdlib_String[31],
     index_from_opt=Stdlib_String[32],
     rindex_from=Stdlib_String[33],
     rindex_from_opt=Stdlib_String[34],
     index=Stdlib_String[35],
     index_opt=Stdlib_String[36],
     rindex=Stdlib_String[37],
     rindex_opt=Stdlib_String[38],
     to_seq=Stdlib_String[39],
     to_seqi=Stdlib_String[40],
     of_seq=Stdlib_String[41],
     blit=Stdlib_String[42],
     copy=Stdlib_String[43],
     fill=Stdlib_String[44],
     uppercase=Stdlib_String[45],
     lowercase=Stdlib_String[46],
     capitalize=Stdlib_String[47],
     uncapitalize=Stdlib_String[48],
     get_uint8=Stdlib_String[49],
     get_int8=Stdlib_String[50],
     get_uint16_ne=Stdlib_String[51],
     get_uint16_be=Stdlib_String[52],
     get_uint16_le=Stdlib_String[53],
     get_int16_ne=Stdlib_String[54],
     get_int16_be=Stdlib_String[55],
     get_int16_le=Stdlib_String[56],
     get_int32_ne=Stdlib_String[57],
     get_int32_be=Stdlib_String[58],
     get_int32_le=Stdlib_String[59],
     get_int64_ne=Stdlib_String[60],
     get_int64_be=Stdlib_String[61],
     get_int64_le=Stdlib_String[62];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       compare$0,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       equal$0],
     chr=Stdlib_Char[1],
     escaped$0=Stdlib_Char[2],
     lowercase$0=Stdlib_Char[3],
     uppercase$0=Stdlib_Char[4],
     lowercase_ascii$0=Stdlib_Char[5],
     uppercase_ascii$0=Stdlib_Char[6],
     compare$1=Stdlib_Char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_lwt_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(131,Js_of_ocaml_lwt_Import,"Js_of_ocaml_lwt__Import");
    var
     Wrong_headers=
      [248,cst_Js_of_ocaml_lwt_Lwt_xmlHtt,runtime.caml_fresh_oo_id(0)];
    function has_get_args(url)
     {try
       {caml_call2(String[34],url,63);var _dr_=1;return _dr_}
      catch(_ds_)
       {_ds_ = caml_wrap_exception(_ds_);
        if(_ds_ === Stdlib[8])return 0;
        throw _ds_}}
    function perform_raw
     (opt,
      content_type,
      _cH_,
      _cG_,
      progress,
      upload_progress,
      contents,
      override_mime_type,
      override_method,
      with_credentials,
      response_type)
     {if(opt)var sth=opt[1],headers=sth;else var headers=0;
      if(_cH_)var sth$0=_cH_[1],get_args=sth$0;else var get_args=0;
      if(_cG_)
       var sth$1=_cG_[1],check_headers=sth$1;
      else
       var check_headers=function(param,_dq_){return 1};
      return function(url)
       {if(contents)
         {var c$0=contents[1],_cK_=c$0[1];
          if(440620227 === _cK_)
           {var
             args=c$0[2],
             _cL_=
              function(x)
               {var _dp_=x[2];
                if(typeof _dp_ !== "number" && -976970511 === _dp_[1])
                 return 1;
                return 0},
             only_strings=caml_call2(Stdlib_List[32],_cL_,args),
             form_contents=
              only_strings
               ?[0,891486873,[0,0]]
               :caml_call1(Js_of_ocaml_Form[6],0),
             _cM_=
              function(param)
               {var value=param[2],name=param[1];
                return caml_call2
                        (Js_of_ocaml_Form[3],form_contents,[0,name,value])};
            caml_call2(Stdlib_List[17],_cM_,args);
            var _cN_=[0,-836918635,form_contents]}
          else
           if(737307005 <= _cK_)
            var b=c$0[2],_cN_=[0,737307005,b];
           else
            var _cN_=c$0;
          var contents$0=[0,_cN_]}
        else
         var contents$0=0;
        function override_method$0(m)
         {if(override_method)
           {var v=override_method[1];
            return 492530731 <= v
                    ?891112544 <= v
                      ?994393768 <= v?cst_PATCH:cst_POST
                      :801894688 <= v?cst_HEAD:cst_DELETE
                    :3546230 === v?cst_GET:3997359 <= v?cst_PUT:cst_OPTIONS}
          return m}
        if(contents$0)
         {var _cO_=contents$0[1];
          if(-836918635 === _cO_[1])
           {var form=_cO_[2];
            if(891486873 <= form[1])
             var
              content_type$0=content_type || [0,c],
              content_type$1=content_type$0,
              method=override_method$0(cst_POST$0);
            else
             var
              content_type$1=content_type,
              method=override_method$0(cst_POST$1)}
          else
           var
            content_type$1=content_type,
            method=override_method$0(cst_POST$2)}
        else
         var
          method$0=override_method$0(cst_GET$0),
          content_type$1=content_type,
          method=method$0;
        if(0 === get_args)
         var url$0=url;
        else
         var
          _cY_=caml_call1(Js_of_ocaml_Url[6],get_args),
          _cZ_=has_get_args(url)?cst$3:cst$4,
          _c0_=caml_call2(Stdlib[28],_cZ_,_cY_),
          url$0=caml_call2(Stdlib[28],url,_c0_);
        var
         match=caml_call1(Lwt[22],0),
         w=match[2],
         res=match[1],
         t59=caml_call1(Js_of_ocaml_XmlHttpRequest[1],0),
         t10=caml_jsstring_of_string(url$0),
         t9=caml_jsstring_of_string(method);
        t59.open(t9,t10,Js_of_ocaml_Js[7]);
        if(override_mime_type)
         {var
           mime_type=override_mime_type[1],
           t13=caml_jsstring_of_string(mime_type);
          t59.overrideMimeType(t13)}
        switch(response_type)
         {case 0:t59.responseType = "arraybuffer";break;
          case 1:t59.responseType = "blob";break;
          case 2:t59.responseType = "document";break;
          case 3:t59.responseType = "json";break;
          case 4:t59.responseType = "text";break;
          default:t59.responseType = ""}
        if(with_credentials)
         {var c$1=with_credentials[1];t59.withCredentials = ! ! c$1}
        if(content_type$1)
         {var
           content_type$2=content_type$1[1],
           t30=caml_jsstring_of_string(content_type$2);
          t59.setRequestHeader("Content-type",t30)}
        function _cP_(param)
         {var
           v=param[2],
           n=param[1],
           t33=caml_jsstring_of_string(v),
           t32=caml_jsstring_of_string(n);
          return t59.setRequestHeader(t32,t33)}
        caml_call2(Stdlib_List[17],_cP_,headers);
        function headers$0(s)
         {function _dm_(v){return [0,caml_string_of_jsstring(v)]}
          var t35=runtime.caml_jsbytes_of_string(s);
          function _dn_(param){return 0}
          var _do_=t59.getResponseHeader(t35);
          return caml_call3(Js_of_ocaml_Js[5][7],_do_,_dn_,_dm_)}
        var st=[0,382334108];
        function do_check_headers(param)
         {if(382334108 === st[1])
           if(caml_call2(check_headers,t59.status,headers$0))
            st[1] = 583419792;
           else
            {caml_call2(Lwt[48],w,[0,Wrong_headers,[0,t59.status,headers$0]]);
             st[1] = 479410653;
             t59.abort()}
          return 479410653 !== st[1]?1:0}
        t59.onreadystatechange
        =
        caml_js_wrap_callback
         (function(param)
           {var match=t59.readyState;
            switch(match)
             {case 2:
               if(! Js_of_ocaml_Dom_html[123]){do_check_headers(0);return 0}
               break;
              case 3:
               if(Js_of_ocaml_Dom_html[123]){do_check_headers(0);return 0}
               break;
              case 4:
               var _dk_=do_check_headers(0);
               if(_dk_)
                {switch(response_type)
                  {case 0:
                    var
                     code=t59.status,
                     _dj_=function(param){throw [0,Assert_failure,_e_]},
                     response=
                      [0,
                       url$0,
                       code,
                       headers$0,
                       caml_call1(Js_of_ocaml_File[3][5],t59.response),
                       _dj_];
                    break;
                   case 1:
                    var
                     code$0=t59.status,
                     _di_=function(param){throw [0,Assert_failure,_d_]},
                     response=
                      [0,
                       url$0,
                       code$0,
                       headers$0,
                       caml_call1(Js_of_ocaml_File[3][2],t59.response),
                       _di_];
                    break;
                   case 2:
                    var
                     code$1=t59.status,
                     _dg_=function(param){throw [0,Assert_failure,_b_]},
                     response=
                      [0,
                       url$0,
                       code$1,
                       headers$0,
                       caml_call1(Js_of_ocaml_File[3][1],t59.response),
                       _dg_];
                    break;
                   case 3:
                    var
                     code$2=t59.status,
                     _dh_=function(param){throw [0,Assert_failure,_c_]},
                     response=
                      [0,
                       url$0,
                       code$2,
                       headers$0,
                       caml_call1(Js_of_ocaml_File[3][3],t59.response),
                       _dh_];
                    break;
                   case 4:
                    var
                     code$3=t59.status,
                     _dd_=function(param){throw [0,Assert_failure,_a_]},
                     _de_=function(x){return x},
                     _df_=function(param){return ""},
                     response=
                      [0,
                       url$0,
                       code$3,
                       headers$0,
                       caml_call3(Js_of_ocaml_Js[5][7],t59.responseText,_df_,_de_),
                       _dd_];
                    break;
                   default:
                    var
                     code$4=t59.status,
                     _da_=
                      function(param)
                       {var
                         match=
                          caml_call1(Js_of_ocaml_Js[5][10],t59.responseXML);
                        if(match)
                         {var doc=match[1],_dl_=Js_of_ocaml_Js[1];
                          return caml_call1(Js_of_ocaml_Js[2],doc.documentElement)
                                  ===
                                  _dl_
                                  ?0
                                  :[0,doc]}
                        return 0},
                     _db_=function(x){return caml_string_of_jsstring(x)},
                     _dc_=function(param){return cst$2},
                     response=
                      [0,
                       url$0,
                       code$4,
                       headers$0,
                       caml_call3(Js_of_ocaml_Js[5][7],t59.responseText,_dc_,_db_),
                       _da_]}
                 return caml_call2(Lwt[47],w,response)}
               return _dk_
              }
            return 0});
        if(progress)
         {var
           progress$0=progress[1],
           _cQ_=
            function(e)
             {caml_call2(progress$0,e.loaded,e.total);
              return Js_of_ocaml_Js[7]};
          t59.onprogress = caml_call1(Js_of_ocaml_Dom[10],_cQ_)}
        function _cR_(upload)
         {if(upload_progress)
           {var
             upload_progress$0=upload_progress[1],
             _c$_=
              function(e)
               {caml_call2(upload_progress$0,e.loaded,e.total);
                return Js_of_ocaml_Js[7]};
            return upload.onprogress = caml_call1(Js_of_ocaml_Dom[10],_c$_)}
          return 0}
        caml_call2(Js_of_ocaml_Js[6][6],t59.upload,_cR_);
        if(contents$0)
         {var _cS_=contents$0[1],_cT_=_cS_[1];
          if(-836918635 === _cT_)
           {var _cU_=_cS_[2];
            if(891486873 <= _cU_[1])
             {var
               l=_cU_[2],
               _cV_=l[1],
               _cI_=
                function(param)
                 {var _c1_=param[2],_c2_=param[1];
                  if(781515420 <= _c1_[1])
                   {var
                     s=_c1_[2],
                     _c3_=caml_string_of_jsstring(s.name),
                     _c4_=caml_call2(Js_of_ocaml_Url[2],0,_c3_),
                     _c5_=caml_call2(Stdlib[28],cst,_c4_),
                     _c6_=caml_call2(Js_of_ocaml_Url[2],0,_c2_);
                    return caml_call2(Stdlib[28],_c6_,_c5_)}
                  var
                   s$0=_c1_[2],
                   _c7_=caml_string_of_jsstring(s$0),
                   _c8_=caml_call2(Js_of_ocaml_Url[2],0,_c7_),
                   _c9_=caml_call2(Stdlib[28],cst$0,_c8_),
                   _c__=caml_call2(Js_of_ocaml_Url[2],0,_c2_);
                  return caml_call2(Stdlib[28],_c__,_c9_)},
               _cJ_=caml_call2(Stdlib_List[19],_cI_,_cV_),
               _cW_=caml_jsstring_of_string(caml_call2(String[6],cst$1,_cJ_)),
               t60=caml_call1(Js_of_ocaml_Js[2],_cW_);
              t59.send(t60)}
            else
             {var f=_cU_[2];t59.send(f)}}
          else
           if(737307005 <= _cT_)
            {var b$0=_cS_[2];t59.send(b$0)}
           else
            {var
              s=_cS_[2],
              t64=caml_call1(Js_of_ocaml_Js[2],caml_jsstring_of_string(s));
             t59.send(t64)}}
        else
         t59.send(Js_of_ocaml_Js[1]);
        function _cX_(param){return t59.abort()}
        caml_call2(Lwt[24],res,_cX_);
        return res}}
    function perform_raw_url
     (opt,
      content_type,
      _cF_,
      check_headers,
      progress,
      upload_progress,
      contents,
      override_mime_type,
      override_method,
      with_credentials,
      url)
     {if(opt)var sth=opt[1],headers=sth;else var headers=0;
      if(_cF_)var sth$0=_cF_[1],get_args=sth$0;else var get_args=0;
      return caml_call1
              (perform_raw
                ([0,headers],
                 content_type,
                 [0,get_args],
                 check_headers,
                 progress,
                 upload_progress,
                 contents,
                 override_mime_type,
                 override_method,
                 with_credentials,
                 5),
               url)}
    function perform
     (opt,
      content_type,
      _cD_,
      check_headers,
      progress,
      upload_progress,
      contents,
      override_mime_type,
      override_method,
      with_credentials,
      url)
     {if(opt)var sth=opt[1],headers=sth;else var headers=0;
      if(_cD_)var sth$0=_cD_[1],get_args=sth$0;else var get_args=0;
      var _cE_=caml_call1(Js_of_ocaml_Url[9],url);
      return caml_call1
              (perform_raw
                ([0,headers],
                 content_type,
                 [0,get_args],
                 check_headers,
                 progress,
                 upload_progress,
                 contents,
                 override_mime_type,
                 override_method,
                 with_credentials,
                 5),
               _cE_)}
    function get(s){return perform_raw_url(0,0,0,0,0,0,0,0,0,0,s)}
    var include=[0,Wrong_headers,perform_raw,perform_raw_url,perform,get];
    caml_register_global(143,include,"Js_of_ocaml_lwt__Lwt_xmlHttpRequest");
    function sleep(d)
     {var
       match=caml_call1(Lwt[22],0),
       w=match[2],
       t=match[1],
       _cB_=caml_call1(Lwt[47],w),
       id=caml_call2(Js_of_ocaml_Dom_html[118],_cB_,d * 1000.);
      function _cC_(param){return caml_call1(Js_of_ocaml_Dom_html[119],id)}
      caml_call2(Lwt[24],t,_cC_);
      return t}
    function yield$0(param){return sleep(0.)}
    function wakeup(param)
     {if(1 === param)
       {var t0=caml_js_wrap_callback(Lwt[56]);
        Js_of_ocaml_Dom_html[8].setTimeout(t0,0.);
        return 0}
      return 0}
    caml_call1(Lwt[58],wakeup);
    function prerr_string(s)
     {var t3=caml_jsstring_of_string(s);return Js_of_ocaml_Firebug[1].log(t3)}
    function _f_(exn)
     {prerr_string(cst_Exception_during_Lwt_async);
      prerr_string(caml_call1(Stdlib_Printexc[1],exn));
      return caml_call1(Stdlib_Printexc[5],Stdlib[40])}
    Lwt[12][1] = _f_;
    var Js_of_ocaml_lwt_Lwt_js=[0,sleep,yield$0];
    caml_register_global(146,Js_of_ocaml_lwt_Lwt_js,"Js_of_ocaml_lwt__Lwt_js");
    function call_custom_url(timeout,opt,make_uri)
     {if(opt)var sth=opt[1],prefix=sth;else var prefix=cst$5;
      var
       match=caml_call1(Lwt[22],0),
       w=match[2],
       t=match[1],
       user_cb=caml_call1(Lwt[47],w);
      function error_cb(param){return caml_call1(Lwt[23],t)}
      var size=10;
      a:
      for(;;)
       {var b=caml_call1(Stdlib_Buffer[1],size),i=0;
        for(;;)
         {var
           _cr_=97 + caml_call1(Stdlib_Random[5],26) | 0,
           _cs_=caml_call1(Char[1],_cr_);
          caml_call2(Stdlib_Buffer[12],b,_cs_);
          var _ct_=i + 1 | 0;
          if(9 !== i){var i=_ct_;continue}
          var s=caml_call1(Stdlib_Buffer[2],b);
          if
           (caml_call1
             (Js_of_ocaml_Js[6][5],
              Js_of_ocaml_Dom_html[8][caml_jsstring_of_string(s)]))
           continue a;
          var
           name=caml_call2(Stdlib[28],prefix,s),
           uri=caml_call1(make_uri,name),
           script=caml_call1(Js_of_ocaml_Dom_html[72],Js_of_ocaml_Dom_html[2]),
           finalize=
            function(param)
             {delete Js_of_ocaml_Dom_html[8][caml_jsstring_of_string(name)];
              function _cA_(parent)
               {return caml_call2(Js_of_ocaml_Dom[4],parent,script)}
              return caml_call2(Js_of_ocaml_Js[5][6],script.parentNode,_cA_)},
           executed=[0,0],
           _cu_=
            function(x)
             {executed[1] = 1;finalize(0);return caml_call1(user_cb,x)};
          Js_of_ocaml_Dom_html[8][caml_jsstring_of_string(name)] = _cu_;
          script.src = caml_jsstring_of_string(uri);
          script.type = "text/javascript";
          script.async = Js_of_ocaml_Js[7];
          script.onerror = function(x){finalize(0);return error_cb(x)};
          script.onload
          =
          function(x)
           {function _cx_(param)
             {function _cy_(param)
               {return executed[1]
                        ?Lwt[36]
                        :(Js_of_ocaml_Firebug[1].warn
                           ("Jsonp: script loaded but callback not executed"),
                          finalize(0),
                          error_cb(x),
                          Lwt[36])}
              var _cz_=sleep(1.);
              return caml_call2(Lwt[6],_cz_,_cy_)}
            return caml_call1(Lwt[11],_cx_)};
          caml_call2(Lwt[24],t,finalize);
          if(timeout)
           var
            delay=timeout[1],
            _cv_=function(param){caml_call1(Lwt[23],t);return t},
            _cw_=sleep(delay),
            wait=caml_call2(Lwt[6],_cw_,_cv_),
            new_t=caml_call1(Lwt[17],[0,wait,[0,t,0]]);
          else
           var new_t=t;
          caml_call2(Js_of_ocaml_Dom[5],Js_of_ocaml_Dom_html[2].body,script);
          return new_t}}}
    function add_param(name,value,l)
     {function _cq_(param)
       {var x=param[1];return 1 - caml_call2(String[62],x,name)}
      var l$0=caml_call2(Stdlib_List[41],_cq_,l);
      return [0,[0,name,value],l$0]}
    function call(timeout,opt,_cj_,url)
     {if(opt)var sth=opt[1],param=sth;else var param=cst_callback;
      if(_cj_)var sth$0=_cj_[1],prefix=sth$0;else var prefix=cst$6;
      function make_uri(cbname)
       {var match=caml_call1(Js_of_ocaml_Url[8],url);
        if(match)
         {var url$0=match[1];
          switch(url$0[0])
           {case 0:
             var
              http=url$0[1],
              _ck_=http[6],
              _cl_=add_param(param,cbname,http[5]),
              new_url=[0,[0,http[1],http[2],http[3],http[4],_cl_,_ck_]];
             break;
            case 1:
             var
              http$0=url$0[1],
              _cm_=http$0[6],
              _cn_=add_param(param,cbname,http$0[5]),
              new_url=
               [1,[0,http$0[1],http$0[2],http$0[3],http$0[4],_cn_,_cm_]];
             break;
            default:
             var
              file=url$0[1],
              _co_=file[4],
              _cp_=add_param(param,cbname,file[3]),
              new_url=[2,[0,file[1],file[2],_cp_,_co_]]}
          return caml_call1(Js_of_ocaml_Url[9],new_url)}
        return caml_call1(Stdlib[2],cst_Jsonp_call_Cannot_parse_ur)}
      return call_custom_url(timeout,[0,prefix],make_uri)}
    var Js_of_ocaml_lwt_Lwt_jsonp=[0,call,call_custom_url];
    caml_register_global
     (149,Js_of_ocaml_lwt_Lwt_jsonp,"Js_of_ocaml_lwt__Lwt_jsonp");
    var _g_=Lwt[6];
    function async(f)
     {function _ci_(param){return caml_call2(_g_,yield$0(0),f)}
      return caml_call1(Lwt[11],_ci_)}
    function opt_map(f,param)
     {if(param){var x=param[1];return [0,caml_call1(f,x)]}return 0}
    function make_event(event_kind,use_capture,passive,target)
     {var
       el=[0,Js_of_ocaml_Js[1]],
       match=caml_call1(Lwt[22],0),
       w=match[2],
       t=match[1];
      function cancel(param)
       {return caml_call2(Js_of_ocaml_Js[5][6],el[1],Js_of_ocaml_Dom_html[18])}
      caml_call2(Lwt[24],t,cancel);
      function _cd_(ev){cancel(0);caml_call2(Lwt[47],w,ev);return ! ! 1}
      var
       _ce_=caml_call1(Js_of_ocaml_Dom_html[10],_cd_),
       _cf_=opt_map(caml_js_from_bool,passive),
       _cg_=opt_map(caml_js_from_bool,use_capture),
       _ch_=caml_call6(Js_of_ocaml_Dom[15],target,event_kind,_cg_,0,_cf_,_ce_);
      el[1] = caml_call1(Js_of_ocaml_Js[2],_ch_);
      return t}
    function catch_cancel(f,x)
     {function _cb_(e)
       {return e === Lwt[21]?caml_call1(Lwt[4],0):caml_call1(Lwt[5],e)}
      function _cc_(param){return caml_call1(f,x)}
      return caml_call2(Lwt[7],_cc_,_cb_)}
    function with_error_log(f,x)
     {function _b$_(e)
       {var t0=caml_jsstring_of_string(caml_call1(Stdlib_Printexc[1],e));
        Js_of_ocaml_Firebug[1].log(t0);
        return caml_call1(Lwt[4],0)}
      function _ca_(param){return caml_call1(f,x)}
      return caml_call2(Lwt[7],_ca_,_b$_)}
    function seq_loop(evh,opt,use_capture,passive,target,handler)
     {if(opt)var sth=opt[1],cancel_handler=sth;else var cancel_handler=0;
      var
       cancelled=[0,0],
       cur=[0,caml_call1(Lwt[5],[0,Stdlib[7],cst_Lwt_js_event])],
       cur_handler=[0,caml_call1(Lwt[4],0)],
       match=caml_call1(Lwt[22],0),
       lt=match[1];
      function _b8_(param)
       {caml_call1(Lwt[23],cur[1]);
        if(cancel_handler)caml_call1(Lwt[23],cur_handler[1]);
        cancelled[1] = 1;
        return 0}
      caml_call2(Lwt[24],lt,_b8_);
      function aux(param)
       {if(cancelled[1])return caml_call1(Lwt[4],0);
        var t=caml_call3(evh,use_capture,passive,target);
        cur[1] = t;
        return caml_call2
                (_g_,
                 t,
                 function(e)
                  {cur_handler[1] = with_error_log(caml_call1(handler,e),lt);
                   return caml_call2(_g_,cur_handler[1],aux)})}
      function _b9_(_b__){return catch_cancel(aux,_b__)}
      caml_call1(Lwt[11],_b9_);
      return lt}
    function async_loop(evh,use_capture,passive,target,handler)
     {var
       cancelled=[0,0],
       cur=[0,caml_call1(Lwt[5],[0,Stdlib[7],cst_Lwt_js_event$0])],
       match=caml_call1(Lwt[22],0),
       lt=match[1];
      function _b4_(param)
       {caml_call1(Lwt[23],cur[1]);cancelled[1] = 1;return 0}
      caml_call2(Lwt[24],lt,_b4_);
      function aux(param)
       {if(cancelled[1])return caml_call1(Lwt[4],0);
        var t=caml_call3(evh,use_capture,passive,target);
        cur[1] = t;
        return caml_call2
                (_g_,
                 t,
                 function(e)
                  {function _b7_(param)
                    {return with_error_log(caml_call1(handler,e),lt)}
                   caml_call1(Lwt[11],_b7_);
                   return aux(0)})}
      function _b5_(_b6_){return catch_cancel(aux,_b6_)}
      caml_call1(Lwt[11],_b5_);
      return lt}
    function buffered_loop(evh,opt,_bZ_,use_capture,passive,target,handler)
     {if(opt)var sth=opt[1],cancel_handler=sth;else var cancel_handler=0;
      if(_bZ_)var sth$0=_bZ_[1],cancel_queue=sth$0;else var cancel_queue=1;
      var
       cancelled=[0,0],
       queue=[0,0],
       cur=[0,caml_call1(Lwt[5],[0,Stdlib[7],cst_Lwt_js_event$1])],
       cur_handler=[0,caml_call1(Lwt[4],0)],
       match=caml_call1(Lwt[22],0),
       lt=match[1],
       spawn=caml_call1(Lwt_condition[1],0);
      function _b0_(param)
       {caml_call1(Lwt[23],cur[1]);
        if(cancel_handler)caml_call1(Lwt[23],cur_handler[1]);
        if(cancel_queue)queue[1] = 0;
        cancelled[1] = 1;
        return 0}
      caml_call2(Lwt[24],lt,_b0_);
      function spawner(param)
       {if(cancelled[1])return caml_call1(Lwt[4],0);
        var t=caml_call3(evh,use_capture,passive,target);
        cur[1] = t;
        return caml_call2
                (_g_,
                 t,
                 function(e)
                  {queue[1] = [0,e,queue[1]];
                   caml_call2(Lwt_condition[3],spawn,0);
                   return spawner(0)})}
      function runner(param)
       {cur_handler[1] = caml_call1(Lwt[4],0);
        if(cancelled[1])return caml_call1(Lwt[4],0);
        var _b3_=queue[1];
        if(_b3_)
         {var tl=_b3_[2],e=_b3_[1];
          queue[1] = tl;
          cur_handler[1] = with_error_log(caml_call1(handler,e),lt);
          return caml_call2(_g_,cur_handler[1],runner)}
        return caml_call2(_g_,caml_call2(Lwt_condition[2],0,spawn),runner)}
      function _b1_(_b2_){return catch_cancel(spawner,_b2_)}
      caml_call1(Lwt[11],_b1_);
      caml_call1(Lwt[11],runner);
      return lt}
    function func_limited_loop
     (event,limited_func,use_capture,passive,target,handler)
     {var count=[0,0];
      return async_loop
              (event,
               use_capture,
               passive,
               target,
               function(ev,lt)
                {count[1]++;
                 var nb=count[1];
                 function _bY_(param)
                  {return caml_call2(symbol$8,count[1],nb)
                           ?caml_call2(handler,ev,lt)
                           :caml_call1(Lwt[4],0)}
                 return caml_call2(_g_,caml_call1(limited_func,0),_bY_)})}
    function limited_loop(event,opt)
     {if(opt)var sth=opt[1],elapsed_time=sth;else var elapsed_time=0.1;
      function _bT_(param){return sleep(elapsed_time)}
      return function(_bU_,_bV_,_bW_,_bX_)
       {return func_limited_loop(event,_bT_,_bU_,_bV_,_bW_,_bX_)}}
    function click(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][1],use_capture,passive,target)}
    function copy$0(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][2],use_capture,passive,target)}
    function cut(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][3],use_capture,passive,target)}
    function paste(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][4],use_capture,passive,target)}
    function dblclick(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][5],use_capture,passive,target)}
    function mousedown(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][6],use_capture,passive,target)}
    function mouseup(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][7],use_capture,passive,target)}
    function mouseover(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][8],use_capture,passive,target)}
    function mousemove(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][9],use_capture,passive,target)}
    function mouseout(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][10],use_capture,passive,target)}
    function keypress(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][11],use_capture,passive,target)}
    function keydown(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][12],use_capture,passive,target)}
    function keyup(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][13],use_capture,passive,target)}
    function change(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][28],use_capture,passive,target)}
    function input(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][29],use_capture,passive,target)}
    function timeupdate(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][30],use_capture,passive,target)}
    function dragstart(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][20],use_capture,passive,target)}
    function dragend(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][21],use_capture,passive,target)}
    function dragenter(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][22],use_capture,passive,target)}
    function dragover(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][23],use_capture,passive,target)}
    function dragleave(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][24],use_capture,passive,target)}
    function drag(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][25],use_capture,passive,target)}
    function drop(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][26],use_capture,passive,target)}
    function focus(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][33],use_capture,passive,target)}
    function blur(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][34],use_capture,passive,target)}
    function scroll(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][32],use_capture,passive,target)}
    function submit(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][31],use_capture,passive,target)}
    function select(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][43],use_capture,passive,target)}
    function abort(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][42],use_capture,passive,target)}
    function error(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][41],use_capture,passive,target)}
    function load(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][35],use_capture,passive,target)}
    function canplay(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][58],use_capture,passive,target)}
    function canplaythrough(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][59],use_capture,passive,target)}
    function durationchange(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][60],use_capture,passive,target)}
    function emptied(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][61],use_capture,passive,target)}
    function ended(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][62],use_capture,passive,target)}
    function loadeddata(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][64],use_capture,passive,target)}
    function loadedmetadata(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][65],use_capture,passive,target)}
    function loadstart(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][66],use_capture,passive,target)}
    function pause(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][68],use_capture,passive,target)}
    function play(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][69],use_capture,passive,target)}
    function playing(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][70],use_capture,passive,target)}
    function ratechange(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][79],use_capture,passive,target)}
    function seeked(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][80],use_capture,passive,target)}
    function seeking(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][81],use_capture,passive,target)}
    function stalled(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][82],use_capture,passive,target)}
    function suspend(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][83],use_capture,passive,target)}
    function volumechange(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][84],use_capture,passive,target)}
    function waiting(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][85],use_capture,passive,target)}
    function mousewheel(use_capture,passive,target)
     {var
       el=[0,Js_of_ocaml_Js[1]],
       match=caml_call1(Lwt[22],0),
       w=match[2],
       t=match[1];
      function cancel(param)
       {return caml_call2(Js_of_ocaml_Js[5][6],el[1],Js_of_ocaml_Dom_html[18])}
      caml_call2(Lwt[24],t,cancel);
      function _bP_(ev,dx,dy)
       {Js_of_ocaml_Firebug[1].log(ev);
        cancel(0);
        caml_call2(Lwt[47],w,[0,ev,[0,dx,dy]]);
        return ! ! 1}
      var
       _bQ_=opt_map(caml_js_from_bool,passive),
       _bR_=opt_map(caml_js_from_bool,use_capture),
       _bS_=caml_call5(Js_of_ocaml_Dom_html[19],target,_bR_,0,_bQ_,_bP_);
      el[1] = caml_call1(Js_of_ocaml_Js[2],_bS_);
      return t}
    function touchstart(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][16],use_capture,passive,target)}
    function touchmove(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][17],use_capture,passive,target)}
    function touchend(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][18],use_capture,passive,target)}
    function touchcancel(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][19],use_capture,passive,target)}
    function lostpointercapture(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][67],use_capture,passive,target)}
    function gotpointercapture(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][63],use_capture,passive,target)}
    function pointerenter(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][71],use_capture,passive,target)}
    function pointercancel(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][72],use_capture,passive,target)}
    function pointerdown(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][73],use_capture,passive,target)}
    function pointerleave(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][74],use_capture,passive,target)}
    function pointermove(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][75],use_capture,passive,target)}
    function pointerout(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][76],use_capture,passive,target)}
    function pointerover(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][77],use_capture,passive,target)}
    function pointerup(use_capture,passive,target)
     {return make_event
              (Js_of_ocaml_Dom_html[15][78],use_capture,passive,target)}
    function clicks(cancel_handler,use_capture,passive,t)
     {return function(_bO_)
       {return seq_loop(click,cancel_handler,use_capture,passive,t,_bO_)}}
    function copies(cancel_handler,use_capture,passive,t)
     {return function(_bN_)
       {return seq_loop(copy$0,cancel_handler,use_capture,passive,t,_bN_)}}
    function cuts(cancel_handler,use_capture,passive,t)
     {return function(_bM_)
       {return seq_loop(cut,cancel_handler,use_capture,passive,t,_bM_)}}
    function pastes(cancel_handler,use_capture,passive,t)
     {return function(_bL_)
       {return seq_loop(paste,cancel_handler,use_capture,passive,t,_bL_)}}
    function dblclicks(cancel_handler,use_capture,passive,t)
     {return function(_bK_)
       {return seq_loop(dblclick,cancel_handler,use_capture,passive,t,_bK_)}}
    function mousedowns(cancel_handler,use_capture,passive,t)
     {return function(_bJ_)
       {return seq_loop(mousedown,cancel_handler,use_capture,passive,t,_bJ_)}}
    function mouseups(cancel_handler,use_capture,passive,t)
     {return function(_bI_)
       {return seq_loop(mouseup,cancel_handler,use_capture,passive,t,_bI_)}}
    function mouseovers(cancel_handler,use_capture,passive,t)
     {return function(_bH_)
       {return seq_loop(mouseover,cancel_handler,use_capture,passive,t,_bH_)}}
    function mousemoves(cancel_handler,use_capture,passive,t)
     {return function(_bG_)
       {return seq_loop(mousemove,cancel_handler,use_capture,passive,t,_bG_)}}
    function mouseouts(cancel_handler,use_capture,passive,t)
     {return function(_bF_)
       {return seq_loop(mouseout,cancel_handler,use_capture,passive,t,_bF_)}}
    function keypresses(cancel_handler,use_capture,passive,t)
     {return function(_bE_)
       {return seq_loop(keypress,cancel_handler,use_capture,passive,t,_bE_)}}
    function keydowns(cancel_handler,use_capture,passive,t)
     {return function(_bD_)
       {return seq_loop(keydown,cancel_handler,use_capture,passive,t,_bD_)}}
    function keyups(cancel_handler,use_capture,passive,t)
     {return function(_bC_)
       {return seq_loop(keyup,cancel_handler,use_capture,passive,t,_bC_)}}
    function changes(cancel_handler,use_capture,passive,t)
     {return function(_bB_)
       {return seq_loop(change,cancel_handler,use_capture,passive,t,_bB_)}}
    function inputs(cancel_handler,use_capture,passive,t)
     {return function(_bA_)
       {return seq_loop(input,cancel_handler,use_capture,passive,t,_bA_)}}
    function timeupdates(cancel_handler,use_capture,passive,t)
     {return function(_bz_)
       {return seq_loop(timeupdate,cancel_handler,use_capture,passive,t,_bz_)}}
    function dragstarts(cancel_handler,use_capture,passive,t)
     {return function(_by_)
       {return seq_loop(dragstart,cancel_handler,use_capture,passive,t,_by_)}}
    function dragends(cancel_handler,use_capture,passive,t)
     {return function(_bx_)
       {return seq_loop(dragend,cancel_handler,use_capture,passive,t,_bx_)}}
    function dragenters(cancel_handler,use_capture,passive,t)
     {return function(_bw_)
       {return seq_loop(dragenter,cancel_handler,use_capture,passive,t,_bw_)}}
    function dragovers(cancel_handler,use_capture,passive,t)
     {return function(_bv_)
       {return seq_loop(dragover,cancel_handler,use_capture,passive,t,_bv_)}}
    function dragleaves(cancel_handler,use_capture,passive,t)
     {return function(_bu_)
       {return seq_loop(dragleave,cancel_handler,use_capture,passive,t,_bu_)}}
    function drags(cancel_handler,use_capture,passive,t)
     {return function(_bt_)
       {return seq_loop(drag,cancel_handler,use_capture,passive,t,_bt_)}}
    function drops(cancel_handler,use_capture,passive,t)
     {return function(_bs_)
       {return seq_loop(drop,cancel_handler,use_capture,passive,t,_bs_)}}
    function mousewheels(cancel_handler,use_capture,passive,t)
     {return function(_br_)
       {return seq_loop(mousewheel,cancel_handler,use_capture,passive,t,_br_)}}
    function touchstarts(cancel_handler,use_capture,passive,t)
     {return function(_bq_)
       {return seq_loop(touchstart,cancel_handler,use_capture,passive,t,_bq_)}}
    function touchmoves(cancel_handler,use_capture,passive,t)
     {return function(_bp_)
       {return seq_loop(touchmove,cancel_handler,use_capture,passive,t,_bp_)}}
    function touchends(cancel_handler,use_capture,passive,t)
     {return function(_bo_)
       {return seq_loop(touchend,cancel_handler,use_capture,passive,t,_bo_)}}
    function touchcancels(cancel_handler,use_capture,passive,t)
     {return function(_bn_)
       {return seq_loop(touchcancel,cancel_handler,use_capture,passive,t,_bn_)}}
    function focuses(cancel_handler,use_capture,passive,t)
     {return function(_bm_)
       {return seq_loop(focus,cancel_handler,use_capture,passive,t,_bm_)}}
    function blurs(cancel_handler,use_capture,passive,t)
     {return function(_bl_)
       {return seq_loop(blur,cancel_handler,use_capture,passive,t,_bl_)}}
    function scrolls(cancel_handler,use_capture,passive,t)
     {return function(_bk_)
       {return seq_loop(scroll,cancel_handler,use_capture,passive,t,_bk_)}}
    function submits(cancel_handler,use_capture,passive,t)
     {return function(_bj_)
       {return seq_loop(submit,cancel_handler,use_capture,passive,t,_bj_)}}
    function selects(cancel_handler,use_capture,passive,t)
     {return function(_bi_)
       {return seq_loop(select,cancel_handler,use_capture,passive,t,_bi_)}}
    function aborts(cancel_handler,use_capture,passive,t)
     {return function(_bh_)
       {return seq_loop(abort,cancel_handler,use_capture,passive,t,_bh_)}}
    function errors(cancel_handler,use_capture,passive,t)
     {return function(_bg_)
       {return seq_loop(error,cancel_handler,use_capture,passive,t,_bg_)}}
    function loads(cancel_handler,use_capture,passive,t)
     {return function(_bf_)
       {return seq_loop(load,cancel_handler,use_capture,passive,t,_bf_)}}
    function canplays(cancel_handler,use_capture,passive,t)
     {return function(_be_)
       {return seq_loop(canplay,cancel_handler,use_capture,passive,t,_be_)}}
    function canplaythroughs(cancel_handler,use_capture,passive,t)
     {return function(_bd_)
       {return seq_loop
                (canplaythrough,cancel_handler,use_capture,passive,t,_bd_)}}
    function durationchanges(cancel_handler,use_capture,passive,t)
     {return function(_bc_)
       {return seq_loop
                (durationchange,cancel_handler,use_capture,passive,t,_bc_)}}
    function emptieds(cancel_handler,use_capture,passive,t)
     {return function(_bb_)
       {return seq_loop(emptied,cancel_handler,use_capture,passive,t,_bb_)}}
    function endeds(cancel_handler,use_capture,passive,t)
     {return function(_ba_)
       {return seq_loop(ended,cancel_handler,use_capture,passive,t,_ba_)}}
    function loadeddatas(cancel_handler,use_capture,passive,t)
     {return function(_a$_)
       {return seq_loop(loadeddata,cancel_handler,use_capture,passive,t,_a$_)}}
    function loadedmetadatas(cancel_handler,use_capture,passive,t)
     {return function(_a__)
       {return seq_loop
                (loadedmetadata,cancel_handler,use_capture,passive,t,_a__)}}
    function loadstarts(cancel_handler,use_capture,passive,t)
     {return function(_a9_)
       {return seq_loop(loadstart,cancel_handler,use_capture,passive,t,_a9_)}}
    function pauses(cancel_handler,use_capture,passive,t)
     {return function(_a8_)
       {return seq_loop(pause,cancel_handler,use_capture,passive,t,_a8_)}}
    function plays(cancel_handler,use_capture,passive,t)
     {return function(_a7_)
       {return seq_loop(play,cancel_handler,use_capture,passive,t,_a7_)}}
    function playings(cancel_handler,use_capture,passive,t)
     {return function(_a6_)
       {return seq_loop(playing,cancel_handler,use_capture,passive,t,_a6_)}}
    function ratechanges(cancel_handler,use_capture,passive,t)
     {return function(_a5_)
       {return seq_loop(ratechange,cancel_handler,use_capture,passive,t,_a5_)}}
    function seekeds(cancel_handler,use_capture,passive,t)
     {return function(_a4_)
       {return seq_loop(seeked,cancel_handler,use_capture,passive,t,_a4_)}}
    function seekings(cancel_handler,use_capture,passive,t)
     {return function(_a3_)
       {return seq_loop(seeking,cancel_handler,use_capture,passive,t,_a3_)}}
    function stalleds(cancel_handler,use_capture,passive,t)
     {return function(_a2_)
       {return seq_loop(stalled,cancel_handler,use_capture,passive,t,_a2_)}}
    function suspends(cancel_handler,use_capture,passive,t)
     {return function(_a1_)
       {return seq_loop(suspend,cancel_handler,use_capture,passive,t,_a1_)}}
    function volumechanges(cancel_handler,use_capture,passive,t)
     {return function(_a0_)
       {return seq_loop
                (volumechange,cancel_handler,use_capture,passive,t,_a0_)}}
    function waitings(cancel_handler,use_capture,passive,t)
     {return function(_aZ_)
       {return seq_loop(waiting,cancel_handler,use_capture,passive,t,_aZ_)}}
    function lostpointercaptures(cancel_handler,use_capture,passive,t)
     {return function(_aY_)
       {return seq_loop
                (lostpointercapture,cancel_handler,use_capture,passive,t,_aY_)}}
    function gotpointercaptures(cancel_handler,use_capture,passive,t)
     {return function(_aX_)
       {return seq_loop
                (gotpointercapture,cancel_handler,use_capture,passive,t,_aX_)}}
    function pointerenters(cancel_handler,use_capture,passive,t)
     {return function(_aW_)
       {return seq_loop
                (pointerenter,cancel_handler,use_capture,passive,t,_aW_)}}
    function pointercancels(cancel_handler,use_capture,passive,t)
     {return function(_aV_)
       {return seq_loop
                (pointercancel,cancel_handler,use_capture,passive,t,_aV_)}}
    function pointerdowns(cancel_handler,use_capture,passive,t)
     {return function(_aU_)
       {return seq_loop(pointerdown,cancel_handler,use_capture,passive,t,_aU_)}}
    function pointerleaves(cancel_handler,use_capture,passive,t)
     {return function(_aT_)
       {return seq_loop
                (pointerleave,cancel_handler,use_capture,passive,t,_aT_)}}
    function pointermoves(cancel_handler,use_capture,passive,t)
     {return function(_aS_)
       {return seq_loop(pointermove,cancel_handler,use_capture,passive,t,_aS_)}}
    function pointerouts(cancel_handler,use_capture,passive,t)
     {return function(_aR_)
       {return seq_loop(pointerout,cancel_handler,use_capture,passive,t,_aR_)}}
    function pointerovers(cancel_handler,use_capture,passive,t)
     {return function(_aQ_)
       {return seq_loop(pointerover,cancel_handler,use_capture,passive,t,_aQ_)}}
    function pointerups(cancel_handler,use_capture,passive,t)
     {return function(_aP_)
       {return seq_loop(pointerup,cancel_handler,use_capture,passive,t,_aP_)}}
    var
     transition_evn=
      [246,
       function(_aG_)
        {var e=caml_call1(Js_of_ocaml_Dom_html[50],Js_of_ocaml_Dom_html[2]);
         try
          {var
            _aH_=
             [0,
              [0,
               cst_transition,
               [0,caml_call1(Js_of_ocaml_Dom[14][1],cst_transitionend),0]],
              0],
            _aI_=[0,caml_call1(Js_of_ocaml_Dom[14][1],cst_otransitionend),0],
            _aJ_=
             [0,
              [0,
               cst_OTransition,
               [0,caml_call1(Js_of_ocaml_Dom[14][1],cst_oTransitionEnd),_aI_]],
              _aH_],
            _aK_=
             [0,
              [0,
               cst_MozTransition,
               [0,caml_call1(Js_of_ocaml_Dom[14][1],cst_transitionend$0),0]],
              _aJ_],
            _aL_=
             [0,
              [0,
               cst_WebkitTransition,
               [0,
                caml_call1(Js_of_ocaml_Dom[14][1],cst_webkitTransitionEnd),
                0]],
              _aK_],
            _aM_=
             function(param)
              {var propname=param[1];
               return e.style[propname] !== Js_of_ocaml_Js[3]?1:0},
            _aN_=caml_call2(Stdlib_List[38],_aM_,_aL_)[2];
           return _aN_}
         catch(_aO_)
          {_aO_ = caml_wrap_exception(_aO_);
           if(_aO_ === Stdlib[8])return 0;
           throw _aO_}}];
    function transitionend(elt)
     {var
       _aB_=runtime.caml_obj_tag(transition_evn),
       _aC_=
        250 === _aB_
         ?transition_evn[1]
         :246 === _aB_
           ?caml_call1(CamlinternalLazy[2],transition_evn)
           :transition_evn;
      if(_aC_)
       {var
         _aD_=function(param){return caml_call1(Lwt[4],0)},
         _aE_=function(ev){return make_event(ev,0,0,elt)},
         _aF_=caml_call2(Stdlib_List[19],_aE_,_aC_);
        return caml_call2(_g_,caml_call1(Lwt[16],_aF_),_aD_)}
      return caml_call1(Lwt[4],0)}
    function transitionends(cancel_handler,elt,f)
     {function _ax_(param,cancel){return caml_call1(f,cancel)}
      var _ay_=0,_az_=0;
      return seq_loop
              (function(param,_aA_,target){return transitionend(target)},
               cancel_handler,
               _az_,
               _ay_,
               elt,
               _ax_)}
    function request_animation_frame(param)
     {var
       match=caml_call1(Lwt[1],0),
       s=match[2],
       t=match[1],
       _aw_=
        caml_js_wrap_callback(function(param){return caml_call2(Lwt[47],s,0)});
      caml_call1(Js_of_ocaml_Dom_html[121],_aw_);
      return t}
    function onload(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][35],0,0,Js_of_ocaml_Dom_html[8])}
    var doc=Js_of_ocaml_Dom_html[8].document;
    function domContentLoaded(param)
     {if(doc.readyState === "complete")return Lwt[36];
      var match=caml_call1(Lwt[22],0),w=match[2],t=match[1];
      function wakeup(w,param)
       {var _av_=caml_call1(Lwt[79],t);
        return _av_?caml_call2(Lwt[47],w,0):_av_}
      function wakeup_exn(w,e)
       {var _au_=caml_call1(Lwt[79],t);
        return _au_?caml_call2(Lwt[48],w,e):_au_}
      var regular=make_event(Js_of_ocaml_Dom_html[15][53],0,0,doc);
      function _ae_(_at_){return wakeup_exn(w,_at_)}
      function _af_(_as_){return wakeup(w,_as_)}
      caml_call3(Lwt[32],regular,_af_,_ae_);
      function _ag_(e,param)
       {if(doc.readyState === "complete")wakeup(w,e);return Lwt[36]}
      var
       _ah_=0,
       _ai_=0,
       _aj_=caml_call1(Js_of_ocaml_Dom[14][1],cst_readystatechange),
       readystatechange=
        async_loop
         (function(_ap_,_aq_,_ar_){return make_event(_aj_,_ap_,_aq_,_ar_)},
          _ai_,
          _ah_,
          doc,
          _ag_),
       init=
        make_event(Js_of_ocaml_Dom_html[15][35],0,0,Js_of_ocaml_Dom_html[8]);
      function _ak_(_ao_){return wakeup_exn(w,_ao_)}
      function _al_(_an_){return wakeup(w,_an_)}
      caml_call3(Lwt[32],init,_al_,_ak_);
      function _am_(e)
       {caml_call1(Lwt[23],regular);
        caml_call1(Lwt[23],readystatechange);
        caml_call1(Lwt[23],init);
        return Lwt[36]}
      return caml_call2(Lwt[6],t,_am_)}
    function onunload(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][36],0,0,Js_of_ocaml_Dom_html[8])}
    function onbeforeunload(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][37],0,0,Js_of_ocaml_Dom_html[8])}
    function onresize(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][38],0,0,Js_of_ocaml_Dom_html[8])}
    function onorientationchange(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][39],0,0,Js_of_ocaml_Dom_html[8])}
    function onpopstate(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][40],0,0,Js_of_ocaml_Dom_html[8])}
    function onhashchange(param)
     {return make_event
              (Js_of_ocaml_Dom_html[15][27],0,0,Js_of_ocaml_Dom_html[8])}
    function onorientationchange_or_onresiz(param)
     {var _ac_=[0,onorientationchange(0),0],_ad_=[0,onresize(0),_ac_];
      return caml_call1(Lwt[16],_ad_)}
    function onresizes(t)
     {var _Y_=0,_Z_=0,___=0,_$_=0;
      return seq_loop
              (function(param,_ab_,_aa_){return onresize(0)},
               _$_,
               ___,
               _Z_,
               _Y_,
               t)}
    function onorientationchanges(t)
     {var _S_=0,_T_=0,_U_=0,_V_=0;
      return seq_loop
              (function(param,_X_,_W_){return onorientationchange(0)},
               _V_,
               _U_,
               _T_,
               _S_,
               t)}
    function onpopstates(t)
     {var _M_=0,_N_=0,_O_=0,_P_=0;
      return seq_loop
              (function(param,_R_,_Q_){return onpopstate(0)},
               _P_,
               _O_,
               _N_,
               _M_,
               t)}
    function onhashchanges(t)
     {var _G_=0,_H_=0,_I_=0,_J_=0;
      return seq_loop
              (function(param,_L_,_K_){return onhashchange(0)},
               _J_,
               _I_,
               _H_,
               _G_,
               t)}
    function onorientationchanges_or_onresi(t)
     {var _A_=0,_B_=0,_C_=0,_D_=0;
      return seq_loop
              (function(param,_F_,_E_)
                {return onorientationchange_or_onresiz(0)},
               _D_,
               _C_,
               _B_,
               _A_,
               t)}
    function limited_onresizes(elapsed_time,t)
     {var _v_=0,_w_=0,_x_=0;
      return caml_call4
              (limited_loop
                (function(param,_z_,_y_){return onresize(0)},elapsed_time),
               _x_,
               _w_,
               _v_,
               t)}
    function limited_onorientationchanges(elapsed_time,t)
     {var _q_=0,_r_=0,_s_=0;
      return caml_call4
              (limited_loop
                (function(param,_u_,_t_){return onorientationchange(0)},
                 elapsed_time),
               _s_,
               _r_,
               _q_,
               t)}
    function limited_onorientationchanges_o(elapsed_time,t)
     {var _l_=0,_m_=0,_n_=0;
      return caml_call4
              (limited_loop
                (function(param,_p_,_o_)
                  {return onorientationchange_or_onresiz(0)},
                 elapsed_time),
               _n_,
               _m_,
               _l_,
               t)}
    var
     Js_of_ocaml_lwt_Lwt_js_events=
      [0,
       make_event,
       seq_loop,
       async_loop,
       buffered_loop,
       async,
       func_limited_loop,
       limited_loop,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       input,
       timeupdate,
       change,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       focus,
       blur,
       scroll,
       submit,
       select,
       mousewheel,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       lostpointercapture,
       gotpointercapture,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       transitionend,
       transitionends,
       load,
       error,
       abort,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       loadeddata,
       loadedmetadata,
       loadstart,
       pause,
       play,
       playing,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       clicks,
       copies,
       cuts,
       pastes,
       dblclicks,
       mousedowns,
       mouseups,
       mouseovers,
       mousemoves,
       mouseouts,
       keypresses,
       keydowns,
       keyups,
       inputs,
       timeupdates,
       changes,
       dragstarts,
       dragends,
       dragenters,
       dragovers,
       dragleaves,
       drags,
       drops,
       mousewheels,
       touchstarts,
       touchmoves,
       touchends,
       touchcancels,
       focuses,
       blurs,
       scrolls,
       submits,
       selects,
       loads,
       errors,
       aborts,
       canplays,
       canplaythroughs,
       durationchanges,
       emptieds,
       endeds,
       loadeddatas,
       loadedmetadatas,
       loadstarts,
       pauses,
       plays,
       playings,
       ratechanges,
       seekeds,
       seekings,
       stalleds,
       suspends,
       volumechanges,
       waitings,
       lostpointercaptures,
       gotpointercaptures,
       pointerenters,
       pointercancels,
       pointerdowns,
       pointerleaves,
       pointermoves,
       pointerouts,
       pointerovers,
       pointerups,
       request_animation_frame,
       onload,
       domContentLoaded,
       onunload,
       onbeforeunload,
       onresize,
       onorientationchange,
       onpopstate,
       onhashchange,
       onorientationchange_or_onresiz,
       onresizes,
       onorientationchanges,
       onpopstates,
       onhashchanges,
       onorientationchanges_or_onresi,
       limited_onresizes,
       limited_onorientationchanges,
       limited_onorientationchanges_o];
    caml_register_global
     (152,Js_of_ocaml_lwt_Lwt_js_events,"Js_of_ocaml_lwt__Lwt_js_events");
    function reader(kind,file)
     {var
       t12=new (Js_of_ocaml_File[6])(),
       match=caml_call1(Lwt[22],0),
       w=match[2],
       res=match[1];
      function _i_(param)
       {if(2 === t12.readyState)
         {var
           _k_=caml_call1(Js_of_ocaml_File[3][4],t12.result),
           match=caml_call1(Js_of_ocaml_Js[5][10],_k_);
          if(! match)throw [0,Assert_failure,_h_];
          var s=match[1];
          caml_call2(Lwt[47],w,s)}
        return Js_of_ocaml_Js[8]}
      t12.onloadend = caml_call1(Js_of_ocaml_Dom[10],_i_);
      function _j_(param){return t12.abort()}
      caml_call2(Lwt[24],res,_j_);
      if(typeof kind === "number")
       if(-550809787 === kind)
        t12.readAsDataURL(file);
       else
        if(936573133 <= kind)
         t12.readAsText(file);
        else
         t12.readAsBinaryString(file);
      else
       {var e=kind[2];t12.readAsText(file,e)}
      return res}
    function readAsBinaryString(file){return reader(-1041425454,file)}
    function readAsText(file){return reader(936573133,file)}
    function readAsText_withEncoding(file,e)
     {return reader([0,-973237525,e],file)}
    function readAsDataURL(file){return reader(-550809787,file)}
    var
     include$0=
      [0,readAsBinaryString,readAsText,readAsText_withEncoding,readAsDataURL];
    caml_register_global(153,include$0,"Js_of_ocaml_lwt__Lwt_file");
    var
     create=Js_of_ocaml_XmlHttpRequest[1],
     Event=Js_of_ocaml_XmlHttpRequest[2],
     XmlHttpRequest=
      [0,create,Event,Wrong_headers,perform_raw,perform_raw_url,perform,get],
     blob_from_string=Js_of_ocaml_File[1],
     blob_from_any=Js_of_ocaml_File[2],
     CoerceTo=Js_of_ocaml_File[3],
     ReaderEvent=Js_of_ocaml_File[4],
     filename=Js_of_ocaml_File[5],
     fileReader=Js_of_ocaml_File[6],
     addEventListener=Js_of_ocaml_File[7],
     File=
      [0,
       blob_from_string,
       blob_from_any,
       CoerceTo,
       ReaderEvent,
       filename,
       fileReader,
       addEventListener,
       readAsBinaryString,
       readAsText,
       readAsText_withEncoding,
       readAsDataURL],
     Js_of_ocaml_lwt$0=[0,XmlHttpRequest,File];
    caml_register_global(154,Js_of_ocaml_lwt$0,"Js_of_ocaml_lwt");
    return}
  (function(){return this}()));


//# 1 "../../lib/.camlboy_lib.objs/camlboy_lib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_ba_get_1=runtime.caml_ba_get_1,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_check_bound=runtime.caml_check_bound,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     partial=
      [11,
       caml_string_of_jsbytes("), if:(vblank:"),
       [4,
        0,
        0,
        0,
        [11,
         caml_string_of_jsbytes(", lcd_stat:"),
         [4,
          0,
          0,
          0,
          [11,
           caml_string_of_jsbytes(", timer:"),
           [4,
            0,
            0,
            0,
            [11,
             caml_string_of_jsbytes(", serial_port:"),
             [4,
              0,
              0,
              0,
              [11,caml_string_of_jsbytes(", joypad:"),[4,0,0,0,[12,41,0]]]]]]]]]]],
     cst_VBlank=caml_string_of_jsbytes("VBlank"),
     cst_LCD_stat=caml_string_of_jsbytes("LCD_stat"),
     cst_Timer=caml_string_of_jsbytes("Timer"),
     cst_Serial_port=caml_string_of_jsbytes("Serial_port"),
     cst_Joypad=caml_string_of_jsbytes("Joypad"),
     cst_cannot_write=caml_string_of_jsbytes("cannot write"),
     cst_invalid_addr$0=caml_string_of_jsbytes("invalid addr"),
     cst_cannot_read=caml_string_of_jsbytes("cannot read"),
     cst_invalid_addr=caml_string_of_jsbytes("invalid addr"),
     cst_invalid_addr$2=caml_string_of_jsbytes("invalid addr"),
     cst_invalid_addr$1=caml_string_of_jsbytes("invalid addr"),
     cst_AF=caml_string_of_jsbytes("AF"),
     cst_BC=caml_string_of_jsbytes("BC"),
     cst_DE=caml_string_of_jsbytes("DE"),
     cst_HL=caml_string_of_jsbytes("HL"),
     cst_A=caml_string_of_jsbytes("A"),
     cst_B=caml_string_of_jsbytes("B"),
     cst_C=caml_string_of_jsbytes("C"),
     cst_D=caml_string_of_jsbytes("D"),
     cst_E=caml_string_of_jsbytes("E"),
     cst_F=caml_string_of_jsbytes("F"),
     cst_H=caml_string_of_jsbytes("H"),
     cst_L=caml_string_of_jsbytes("L"),
     cst_Address_out_of_bounds$0=
      caml_string_of_jsbytes("Address out of bounds"),
     cst_Address_out_of_bounds=caml_string_of_jsbytes("Address out of bounds"),
     cst_Bank1=caml_string_of_jsbytes("`Bank1"),
     cst_Bank0=caml_string_of_jsbytes("`Bank0"),
     cst_OBP1=caml_string_of_jsbytes("`OBP1"),
     cst_OBP0=caml_string_of_jsbytes("`OBP0"),
     cst_Sprite_bottom=caml_string_of_jsbytes("`Sprite_bottom"),
     cst_Sprite_top=caml_string_of_jsbytes("`Sprite_top"),
     partial$0=
      [11,
       caml_string_of_jsbytes(", x_flip:"),
       [9,
        0,
        [11,
         caml_string_of_jsbytes(", pallete:"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes(", tile_vram_bank:"),
           [2,
            0,
            [11,caml_string_of_jsbytes(", pallete_num:"),[4,0,0,0,[12,10,0]]]]]]]]],
     cst_Address_out_of_bounds$2=
      caml_string_of_jsbytes("Address out of bounds"),
     cst_Address_out_of_bounds$1=
      caml_string_of_jsbytes("Address out of bounds"),
     cst_Address_out_of_bounds$4=
      caml_string_of_jsbytes("Address out of bounds"),
     cst_Address_out_of_bounds$3=
      caml_string_of_jsbytes("Address out of bounds"),
     cst=caml_string_of_jsbytes("-"),
     partial$1=[12,41,0],
     cst$0=caml_string_of_jsbytes(""),
     cst_NZ=caml_string_of_jsbytes("NZ"),
     cst_Z=caml_string_of_jsbytes("Z"),
     cst_NC=caml_string_of_jsbytes("NC"),
     cst_C$0=caml_string_of_jsbytes("C"),
     cst_FF00_C=caml_string_of_jsbytes("($FF00+C)"),
     cst_HL$0=caml_string_of_jsbytes("(HL+)"),
     cst_HL$1=caml_string_of_jsbytes("(HL-)"),
     cst_SP=caml_string_of_jsbytes("SP"),
     cst_ROM_ONLY=caml_string_of_jsbytes("ROM_ONLY"),
     cst_MBC1=caml_string_of_jsbytes("MBC1"),
     cst_MBC1_RAM=caml_string_of_jsbytes("MBC1_RAM"),
     cst_MBC1_RAM_BATTERY=caml_string_of_jsbytes("MBC1_RAM_BATTERY"),
     cst_MBC2=caml_string_of_jsbytes("MBC2"),
     cst_MBC2_BATTERY=caml_string_of_jsbytes("MBC2_BATTERY"),
     cst_MBC3_TIMER_BATTERY=caml_string_of_jsbytes("MBC3_TIMER_BATTERY"),
     cst_MBC3_TIMER_RAM_BATTERY=
      caml_string_of_jsbytes("MBC3_TIMER_RAM_BATTERY"),
     cst_MBC3=caml_string_of_jsbytes("MBC3"),
     cst_Address_out_of_bounds$5=
      caml_string_of_jsbytes("Address out of bounds"),
     Stdlib_Int=global_data.Stdlib__Int,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Assert_failure=global_data.Assert_failure,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Bool=global_data.Stdlib__Bool,
     Stdlib=global_data.Stdlib,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_ArrayLabels=global_data.Stdlib__ArrayLabels,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_String=global_data.Stdlib__String,
     Bigstringaf=global_data.Bigstringaf,
     Camlboy_lib=[0];
    caml_register_global(1199,Camlboy_lib,"Camlboy_lib");
    var Camlboy_lib_Uints_intf=[0];
    caml_register_global
     (1200,Camlboy_lib_Uints_intf,"Camlboy_lib__Uints_intf");
    var
     _d_=[0,[12,45,[4,0,0,0,0]],caml_string_of_jsbytes("-%d")],
     _c_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _a_=[0,[12,36,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes("$%02X")],
     _b_=[0,[12,36,[4,8,[0,2,4],0,0]],caml_string_of_jsbytes("$%04X")],
     _p_=
      [0,
       caml_string_of_jsbytes
        ("lib/interrupt_controller/interrupt_controller.ml"),
       124,
       4],
     _o_=
      [0,
       caml_string_of_jsbytes
        ("lib/interrupt_controller/interrupt_controller.ml"),
       94,
       4],
     _j_=[0,0],
     _k_=[0,1],
     _l_=[0,2],
     _m_=[0,3],
     _n_=[0,4],
     _i_=[0,0,[0,1,[0,2,[0,3,[0,4,0]]]]],
     _h_=
      [0,
       [11,
        caml_string_of_jsbytes("ie:(vblank:"),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", lcd_stat:"),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", timer:"),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(", serial_port:"),
              [4,
               0,
               0,
               0,
               [11,caml_string_of_jsbytes(", joypad:"),[4,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("ie:(vblank:%d, lcd_stat:%d, timer:%d, serial_port:%d, joypad:%d), if:(vblank:%d, lcd_stat:%d, timer:%d, serial_port:%d, joypad:%d)")],
     _r_=[0,caml_string_of_jsbytes("lib/timer/timer.ml"),92,11],
     _s_=[0,caml_string_of_jsbytes("lib/timer/timer.ml"),106,9],
     _q_=[0,caml_string_of_jsbytes("lib/timer/timer.ml"),82,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _t_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _v_=[0,0,1,2,3,4,5,6,7],
     _w_=[0,0,1,2,3,4,5,6,7],
     _y_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _x_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _z_=[0,[0,0],caml_string_of_jsbytes("%c")],
     _B_=
      [0,
       [11,
        caml_string_of_jsbytes("A:"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" F:"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" BC:"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" DE:"),
              [2,0,[11,caml_string_of_jsbytes(" HL:"),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes("A:%s F:%s BC:%s DE:%s HL:%s")],
     _A_=[0,[0,[0,[0,[0,0]]]],caml_string_of_jsbytes("%c%c%c%c")],
     _C_=[0,caml_string_of_jsbytes("lib/gpu/pallete.ml"),53,14],
     _F_=[0,caml_string_of_jsbytes("lib/gpu/oam_table.ml"),89,9],
     _E_=[0,caml_string_of_jsbytes("lib/gpu/oam_table.ml"),67,9],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes("y_pos:"),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", x_pos:"),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", tile_index:"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(", priority:"),
              [2,0,[11,caml_string_of_jsbytes(", y_flip:"),[9,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes
        ("y_pos:%d, x_pos:%d, tile_index:%s, priority:%s, y_flip:%b, x_flip:%b, pallete:%s, tile_vram_bank:%s, pallete_num:%d\n")],
     _G_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _J_=
      [0,
       [11,
        caml_string_of_jsbytes("mode="),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(", mcycles="),
          [4,
           0,
           [0,1,4],
           0,
           [11,
            caml_string_of_jsbytes(", ly="),
            [4,
             0,
             [0,1,3],
             0,
             [11,
              caml_string_of_jsbytes(", lcd_stat="),
              [2,
               0,
               [11,caml_string_of_jsbytes(", interrupt="),[2,0,partial$1]]]]]]]]]],
       caml_string_of_jsbytes
        ("mode=%d, mcycles=%4d, ly=%3d, lcd_stat=%s, interrupt=%s)")],
     _I_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _H_=
      [0,
       [11,caml_string_of_jsbytes("Address out of range: "),[2,0,0]],
       caml_string_of_jsbytes("Address out of range: %s")],
     _P_=
      [0,[11,caml_string_of_jsbytes("DAA"),0],caml_string_of_jsbytes("DAA")],
     _Q_=
      [0,[11,caml_string_of_jsbytes("CPL"),0],caml_string_of_jsbytes("CPL")],
     _R_=
      [0,[11,caml_string_of_jsbytes("CCF"),0],caml_string_of_jsbytes("CCF")],
     _S_=
      [0,[11,caml_string_of_jsbytes("SCF"),0],caml_string_of_jsbytes("SCF")],
     _T_=
      [0,[11,caml_string_of_jsbytes("NOP"),0],caml_string_of_jsbytes("NOP")],
     _U_=
      [0,[11,caml_string_of_jsbytes("HALT"),0],caml_string_of_jsbytes("HALT")],
     _V_=
      [0,[11,caml_string_of_jsbytes("STOP"),0],caml_string_of_jsbytes("STOP")],
     _W_=[0,[11,caml_string_of_jsbytes("DI"),0],caml_string_of_jsbytes("DI")],
     _X_=[0,[11,caml_string_of_jsbytes("EI"),0],caml_string_of_jsbytes("EI")],
     _Y_=
      [0,[11,caml_string_of_jsbytes("RLCA"),0],caml_string_of_jsbytes("RLCA")],
     _Z_=
      [0,[11,caml_string_of_jsbytes("RLA"),0],caml_string_of_jsbytes("RLA")],
     ___=
      [0,[11,caml_string_of_jsbytes("RRCA"),0],caml_string_of_jsbytes("RRCA")],
     _$_=
      [0,[11,caml_string_of_jsbytes("RRA"),0],caml_string_of_jsbytes("RRA")],
     _aa_=
      [0,[11,caml_string_of_jsbytes("RETI"),0],caml_string_of_jsbytes("RETI")],
     _ab_=
      [0,
       [11,
        caml_string_of_jsbytes("LD "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("LD %s, %s")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("LD "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("LD %s, %s")],
     _ad_=
      [0,
       [11,
        caml_string_of_jsbytes("ADD "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("ADD %s, %s")],
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("ADD "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("ADD %s, %s")],
     _af_=
      [0,
       [11,caml_string_of_jsbytes("ADD SP, "),[2,0,0]],
       caml_string_of_jsbytes("ADD SP, %s")],
     _ag_=
      [0,
       [11,
        caml_string_of_jsbytes("ADC "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("ADC %s, %s")],
     _ah_=
      [0,
       [11,
        caml_string_of_jsbytes("SUB "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("SUB %s, %s")],
     _ai_=
      [0,
       [11,
        caml_string_of_jsbytes("SBC "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("SBC %s, %s")],
     _aj_=
      [0,
       [11,
        caml_string_of_jsbytes("AND "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("AND %s, %s")],
     _ak_=
      [0,
       [11,
        caml_string_of_jsbytes("OR "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("OR %s, %s")],
     _al_=
      [0,
       [11,
        caml_string_of_jsbytes("XOR "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("XOR %s, %s")],
     _am_=
      [0,
       [11,
        caml_string_of_jsbytes("CP "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("CP %s, %s")],
     _an_=
      [0,
       [11,caml_string_of_jsbytes("INC "),[2,0,0]],
       caml_string_of_jsbytes("INC %s")],
     _ao_=
      [0,
       [11,caml_string_of_jsbytes("INC "),[2,0,0]],
       caml_string_of_jsbytes("INC %s")],
     _ap_=
      [0,
       [11,caml_string_of_jsbytes("DEC "),[2,0,0]],
       caml_string_of_jsbytes("DEC %s")],
     _aq_=
      [0,
       [11,caml_string_of_jsbytes("DEC "),[2,0,0]],
       caml_string_of_jsbytes("DEC %s")],
     _ar_=
      [0,
       [11,caml_string_of_jsbytes("SWAP "),[2,0,0]],
       caml_string_of_jsbytes("SWAP %s")],
     _as_=
      [0,
       [11,caml_string_of_jsbytes("RLC "),[2,0,0]],
       caml_string_of_jsbytes("RLC %s")],
     _at_=
      [0,
       [11,caml_string_of_jsbytes("RL "),[2,0,0]],
       caml_string_of_jsbytes("RL %s")],
     _au_=
      [0,
       [11,caml_string_of_jsbytes("RRC "),[2,0,0]],
       caml_string_of_jsbytes("RRC %s")],
     _av_=
      [0,
       [11,caml_string_of_jsbytes("RR "),[2,0,0]],
       caml_string_of_jsbytes("RR %s")],
     _aw_=
      [0,
       [11,caml_string_of_jsbytes("SLA "),[2,0,0]],
       caml_string_of_jsbytes("SLA %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("SRA "),[2,0,0]],
       caml_string_of_jsbytes("SRA %s")],
     _ay_=
      [0,
       [11,caml_string_of_jsbytes("SRL "),[2,0,0]],
       caml_string_of_jsbytes("SRL %s")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("BIT "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("BIT %d, %s")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("SET "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("SET %d, %s")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("RES "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("RES %d, %s")],
     _aC_=
      [0,
       [11,caml_string_of_jsbytes("PUSH "),[2,0,0]],
       caml_string_of_jsbytes("PUSH %s")],
     _aD_=
      [0,
       [11,caml_string_of_jsbytes("POP "),[2,0,0]],
       caml_string_of_jsbytes("POP %s")],
     _aE_=
      [0,
       [11,
        caml_string_of_jsbytes("JP "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("JP %s, %s")],
     _aF_=
      [0,
       [11,caml_string_of_jsbytes("JP "),[2,0,0]],
       caml_string_of_jsbytes("JP %s")],
     _aG_=
      [0,
       [11,
        caml_string_of_jsbytes("JR "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("JR %s, %s")],
     _aH_=
      [0,
       [11,caml_string_of_jsbytes("JR "),[2,0,0]],
       caml_string_of_jsbytes("JR %s")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("CALL "),
        [2,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]],
       caml_string_of_jsbytes("CALL %s, %s")],
     _aJ_=
      [0,
       [11,caml_string_of_jsbytes("CALL "),[2,0,0]],
       caml_string_of_jsbytes("CALL %s")],
     _aK_=
      [0,
       [11,caml_string_of_jsbytes("RST "),[2,0,0]],
       caml_string_of_jsbytes("RST %s")],
     _aL_=
      [0,
       [11,caml_string_of_jsbytes("RET "),[2,0,0]],
       caml_string_of_jsbytes("RET %s")],
     _L_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _M_=
      [0,
       [11,caml_string_of_jsbytes("($FF00+"),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("($FF00+%s)")],
     _N_=
      [0,
       [11,caml_string_of_jsbytes("SP-"),[2,0,0]],
       caml_string_of_jsbytes("SP-%s")],
     _O_=
      [0,
       [11,caml_string_of_jsbytes("SP+"),[2,0,0]],
       caml_string_of_jsbytes("SP+%s")],
     _K_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _aM_=
      [0,
       [11,
        caml_string_of_jsbytes("Unrecognized opcode: 0x"),
        [4,6,[0,2,2],0,0]],
       caml_string_of_jsbytes("Unrecognized opcode: 0x%02x")],
     _aN_=[0,1,1],
     _aO_=[5,1],
     _aP_=[0,3,3],
     _aQ_=[0,[6,1],[4,0]],
     _aR_=[0,2,2],
     _aS_=[13,[5,1]],
     _aT_=[0,2,2],
     _aU_=[12,[4,1]],
     _aV_=[0,1,1],
     _aW_=[14,[4,1]],
     _aX_=[0,1,1],
     _aY_=[4,1],
     _aZ_=[0,2,2],
     _a0_=[0,1,1],
     _a1_=[0,5,5],
     _a2_=[3,[5,3],[5,1]],
     _a3_=[0,2,2],
     _a4_=[0,[4,0],[6,1]],
     _a5_=[0,2,2],
     _a6_=[15,[5,1]],
     _a7_=[0,2,2],
     _a8_=[12,[4,2]],
     _a9_=[0,1,1],
     _a__=[14,[4,2]],
     _a$_=[0,1,1],
     _ba_=[4,2],
     _bb_=[0,2,2],
     _bc_=[0,1,1],
     _bd_=[0,1,1],
     _be_=[5,2],
     _bf_=[0,3,3],
     _bg_=[0,[6,2],[4,0]],
     _bh_=[0,2,2],
     _bi_=[13,[5,2]],
     _bj_=[0,2,2],
     _bk_=[12,[4,3]],
     _bl_=[0,1,1],
     _bm_=[14,[4,3]],
     _bn_=[0,1,1],
     _bo_=[4,3],
     _bp_=[0,2,2],
     _bq_=[0,1,1],
     _br_=[0,3,3],
     _bs_=[3,[5,3],[5,2]],
     _bt_=[0,2,2],
     _bu_=[0,[4,0],[6,2]],
     _bv_=[0,2,2],
     _bw_=[15,[5,2]],
     _bx_=[0,2,2],
     _by_=[12,[4,4]],
     _bz_=[0,1,1],
     _bA_=[14,[4,4]],
     _bB_=[0,1,1],
     _bC_=[4,4],
     _bD_=[0,2,2],
     _bE_=[0,1,1],
     _bF_=[0,2,3],
     _bG_=[5,3],
     _bH_=[0,3,3],
     _bI_=[0,1,[4,0]],
     _bJ_=[0,2,2],
     _bK_=[13,[5,3]],
     _bL_=[0,2,2],
     _bM_=[12,[4,6]],
     _bN_=[0,1,1],
     _bO_=[14,[4,6]],
     _bP_=[0,1,1],
     _bQ_=[4,6],
     _bR_=[0,2,2],
     _bS_=[0,1,1],
     _bT_=[0,2,3],
     _bU_=[3,[5,3],[5,3]],
     _bV_=[0,2,2],
     _bW_=[0,[4,0],1],
     _bX_=[0,2,2],
     _bY_=[15,[5,3]],
     _bZ_=[0,2,2],
     _b0_=[12,[4,7]],
     _b1_=[0,1,1],
     _b2_=[14,[4,7]],
     _b3_=[0,1,1],
     _b4_=[4,7],
     _b5_=[0,2,2],
     _b6_=[0,1,1],
     _b7_=[0,2,3],
     _b8_=[0,3,3],
     _b9_=[0,2,[4,0]],
     _b__=[0,2,2],
     _b$_=[13,3],
     _ca_=[0,2,2],
     _cb_=[12,[6,3]],
     _cc_=[0,3,3],
     _cd_=[14,[6,3]],
     _ce_=[0,3,3],
     _cf_=[6,3],
     _cg_=[0,3,3],
     _ch_=[0,1,1],
     _ci_=[0,2,3],
     _cj_=[3,[5,3],3],
     _ck_=[0,2,2],
     _cl_=[0,[4,0],2],
     _cm_=[0,2,2],
     _cn_=[15,3],
     _co_=[0,2,2],
     _cp_=[12,[4,0]],
     _cq_=[0,1,1],
     _cr_=[14,[4,0]],
     _cs_=[0,1,1],
     _ct_=[4,0],
     _cu_=[0,2,2],
     _cv_=[0,1,1],
     _cw_=[0,[4,1],[4,1]],
     _cx_=[0,1,1],
     _cy_=[0,[4,1],[4,2]],
     _cz_=[0,1,1],
     _cA_=[0,[4,1],[4,3]],
     _cB_=[0,1,1],
     _cC_=[0,[4,1],[4,4]],
     _cD_=[0,1,1],
     _cE_=[0,[4,1],[4,6]],
     _cF_=[0,1,1],
     _cG_=[0,[4,1],[4,7]],
     _cH_=[0,1,1],
     _cI_=[0,[4,1],[6,3]],
     _cJ_=[0,2,2],
     _cK_=[0,[4,1],[4,0]],
     _cL_=[0,1,1],
     _cM_=[0,[4,2],[4,1]],
     _cN_=[0,1,1],
     _cO_=[0,[4,2],[4,2]],
     _cP_=[0,1,1],
     _cQ_=[0,[4,2],[4,3]],
     _cR_=[0,1,1],
     _cS_=[0,[4,2],[4,4]],
     _cT_=[0,1,1],
     _cU_=[0,[4,2],[4,6]],
     _cV_=[0,1,1],
     _cW_=[0,[4,2],[4,7]],
     _cX_=[0,1,1],
     _cY_=[0,[4,2],[6,3]],
     _cZ_=[0,2,2],
     _c0_=[0,[4,2],[4,0]],
     _c1_=[0,1,1],
     _c2_=[0,[4,3],[4,1]],
     _c3_=[0,1,1],
     _c4_=[0,[4,3],[4,2]],
     _c5_=[0,1,1],
     _c6_=[0,[4,3],[4,3]],
     _c7_=[0,1,1],
     _c8_=[0,[4,3],[4,4]],
     _c9_=[0,1,1],
     _c__=[0,[4,3],[4,6]],
     _c$_=[0,1,1],
     _da_=[0,[4,3],[4,7]],
     _db_=[0,1,1],
     _dc_=[0,[4,3],[6,3]],
     _dd_=[0,2,2],
     _de_=[0,[4,3],[4,0]],
     _df_=[0,1,1],
     _dg_=[0,[4,4],[4,1]],
     _dh_=[0,1,1],
     _di_=[0,[4,4],[4,2]],
     _dj_=[0,1,1],
     _dk_=[0,[4,4],[4,3]],
     _dl_=[0,1,1],
     _dm_=[0,[4,4],[4,4]],
     _dn_=[0,1,1],
     _do_=[0,[4,4],[4,6]],
     _dp_=[0,1,1],
     _dq_=[0,[4,4],[4,7]],
     _dr_=[0,1,1],
     _ds_=[0,[4,4],[6,3]],
     _dt_=[0,2,2],
     _du_=[0,[4,4],[4,0]],
     _dv_=[0,1,1],
     _dw_=[0,[4,6],[4,1]],
     _dx_=[0,1,1],
     _dy_=[0,[4,6],[4,2]],
     _dz_=[0,1,1],
     _dA_=[0,[4,6],[4,3]],
     _dB_=[0,1,1],
     _dC_=[0,[4,6],[4,4]],
     _dD_=[0,1,1],
     _dE_=[0,[4,6],[4,6]],
     _dF_=[0,1,1],
     _dG_=[0,[4,6],[4,7]],
     _dH_=[0,1,1],
     _dI_=[0,[4,6],[6,3]],
     _dJ_=[0,2,2],
     _dK_=[0,[4,6],[4,0]],
     _dL_=[0,1,1],
     _dM_=[0,[4,7],[4,1]],
     _dN_=[0,1,1],
     _dO_=[0,[4,7],[4,2]],
     _dP_=[0,1,1],
     _dQ_=[0,[4,7],[4,3]],
     _dR_=[0,1,1],
     _dS_=[0,[4,7],[4,4]],
     _dT_=[0,1,1],
     _dU_=[0,[4,7],[4,6]],
     _dV_=[0,1,1],
     _dW_=[0,[4,7],[4,7]],
     _dX_=[0,1,1],
     _dY_=[0,[4,7],[6,3]],
     _dZ_=[0,2,2],
     _d0_=[0,[4,7],[4,0]],
     _d1_=[0,1,1],
     _d2_=[0,[6,3],[4,1]],
     _d3_=[0,2,2],
     _d4_=[0,[6,3],[4,2]],
     _d5_=[0,2,2],
     _d6_=[0,[6,3],[4,3]],
     _d7_=[0,2,2],
     _d8_=[0,[6,3],[4,4]],
     _d9_=[0,2,2],
     _d__=[0,[6,3],[4,6]],
     _d$_=[0,2,2],
     _ea_=[0,[6,3],[4,7]],
     _eb_=[0,2,2],
     _ec_=[0,1,1],
     _ed_=[0,[6,3],[4,0]],
     _ee_=[0,2,2],
     _ef_=[0,[4,0],[4,1]],
     _eg_=[0,1,1],
     _eh_=[0,[4,0],[4,2]],
     _ei_=[0,1,1],
     _ej_=[0,[4,0],[4,3]],
     _ek_=[0,1,1],
     _el_=[0,[4,0],[4,4]],
     _em_=[0,1,1],
     _en_=[0,[4,0],[4,6]],
     _eo_=[0,1,1],
     _ep_=[0,[4,0],[4,7]],
     _eq_=[0,1,1],
     _er_=[0,[4,0],[6,3]],
     _es_=[0,2,2],
     _et_=[0,[4,0],[4,0]],
     _eu_=[0,1,1],
     _ev_=[2,[4,0],[4,1]],
     _ew_=[0,1,1],
     _ex_=[2,[4,0],[4,2]],
     _ey_=[0,1,1],
     _ez_=[2,[4,0],[4,3]],
     _eA_=[0,1,1],
     _eB_=[2,[4,0],[4,4]],
     _eC_=[0,1,1],
     _eD_=[2,[4,0],[4,6]],
     _eE_=[0,1,1],
     _eF_=[2,[4,0],[4,7]],
     _eG_=[0,1,1],
     _eH_=[2,[4,0],[6,3]],
     _eI_=[0,2,2],
     _eJ_=[2,[4,0],[4,0]],
     _eK_=[0,1,1],
     _eL_=[5,[4,0],[4,1]],
     _eM_=[0,1,1],
     _eN_=[5,[4,0],[4,2]],
     _eO_=[0,1,1],
     _eP_=[5,[4,0],[4,3]],
     _eQ_=[0,1,1],
     _eR_=[5,[4,0],[4,4]],
     _eS_=[0,1,1],
     _eT_=[5,[4,0],[4,6]],
     _eU_=[0,1,1],
     _eV_=[5,[4,0],[4,7]],
     _eW_=[0,1,1],
     _eX_=[5,[4,0],[6,3]],
     _eY_=[0,2,2],
     _eZ_=[5,[4,0],[4,0]],
     _e0_=[0,1,1],
     _e1_=[6,[4,0],[4,1]],
     _e2_=[0,1,1],
     _e3_=[6,[4,0],[4,2]],
     _e4_=[0,1,1],
     _e5_=[6,[4,0],[4,3]],
     _e6_=[0,1,1],
     _e7_=[6,[4,0],[4,4]],
     _e8_=[0,1,1],
     _e9_=[6,[4,0],[4,6]],
     _e__=[0,1,1],
     _e$_=[6,[4,0],[4,7]],
     _fa_=[0,1,1],
     _fb_=[6,[4,0],[6,3]],
     _fc_=[0,2,2],
     _fd_=[6,[4,0],[4,0]],
     _fe_=[0,1,1],
     _ff_=[7,[4,0],[4,1]],
     _fg_=[0,1,1],
     _fh_=[7,[4,0],[4,2]],
     _fi_=[0,1,1],
     _fj_=[7,[4,0],[4,3]],
     _fk_=[0,1,1],
     _fl_=[7,[4,0],[4,4]],
     _fm_=[0,1,1],
     _fn_=[7,[4,0],[4,6]],
     _fo_=[0,1,1],
     _fp_=[7,[4,0],[4,7]],
     _fq_=[0,1,1],
     _fr_=[7,[4,0],[6,3]],
     _fs_=[0,2,2],
     _ft_=[7,[4,0],[4,0]],
     _fu_=[0,1,1],
     _fv_=[8,[4,0],[4,1]],
     _fw_=[0,1,1],
     _fx_=[8,[4,0],[4,2]],
     _fy_=[0,1,1],
     _fz_=[8,[4,0],[4,3]],
     _fA_=[0,1,1],
     _fB_=[8,[4,0],[4,4]],
     _fC_=[0,1,1],
     _fD_=[8,[4,0],[4,6]],
     _fE_=[0,1,1],
     _fF_=[8,[4,0],[4,7]],
     _fG_=[0,1,1],
     _fH_=[8,[4,0],[6,3]],
     _fI_=[0,2,2],
     _fJ_=[8,[4,0],[4,0]],
     _fK_=[0,1,1],
     _fL_=[10,[4,0],[4,1]],
     _fM_=[0,1,1],
     _fN_=[10,[4,0],[4,2]],
     _fO_=[0,1,1],
     _fP_=[10,[4,0],[4,3]],
     _fQ_=[0,1,1],
     _fR_=[10,[4,0],[4,4]],
     _fS_=[0,1,1],
     _fT_=[10,[4,0],[4,6]],
     _fU_=[0,1,1],
     _fV_=[10,[4,0],[4,7]],
     _fW_=[0,1,1],
     _fX_=[10,[4,0],[6,3]],
     _fY_=[0,2,2],
     _fZ_=[10,[4,0],[4,0]],
     _f0_=[0,1,1],
     _f1_=[9,[4,0],[4,1]],
     _f2_=[0,1,1],
     _f3_=[9,[4,0],[4,2]],
     _f4_=[0,1,1],
     _f5_=[9,[4,0],[4,3]],
     _f6_=[0,1,1],
     _f7_=[9,[4,0],[4,4]],
     _f8_=[0,1,1],
     _f9_=[9,[4,0],[4,6]],
     _f__=[0,1,1],
     _f$_=[9,[4,0],[4,7]],
     _ga_=[0,1,1],
     _gb_=[9,[4,0],[6,3]],
     _gc_=[0,2,2],
     _gd_=[9,[4,0],[4,0]],
     _ge_=[0,1,1],
     _gf_=[11,[4,0],[4,1]],
     _gg_=[0,1,1],
     _gh_=[11,[4,0],[4,2]],
     _gi_=[0,1,1],
     _gj_=[11,[4,0],[4,3]],
     _gk_=[0,1,1],
     _gl_=[11,[4,0],[4,4]],
     _gm_=[0,1,1],
     _gn_=[11,[4,0],[4,6]],
     _go_=[0,1,1],
     _gp_=[11,[4,0],[4,7]],
     _gq_=[0,1,1],
     _gr_=[11,[4,0],[6,3]],
     _gs_=[0,2,2],
     _gt_=[11,[4,0],[4,0]],
     _gu_=[0,1,1],
     _gv_=[33,1],
     _gw_=[0,2,5],
     _gx_=[28,1],
     _gy_=[0,3,3],
     _gz_=[0,3,4],
     _gA_=[0,4,4],
     _gB_=[0,3,6],
     _gC_=[27,1],
     _gD_=[0,4,4],
     _gE_=[4,0],
     _gF_=[0,2,2],
     _gG_=[0,4,4],
     _gH_=[33,2],
     _gI_=[0,2,5],
     _gJ_=[33,0],
     _gK_=[0,4,4],
     _gL_=[0,3,4],
     _gM_=
      [0,
       [11,
        caml_string_of_jsbytes("Unrecognized opcode after 0xCB: 0x"),
        [4,6,[0,2,2],0,0]],
       caml_string_of_jsbytes("Unrecognized opcode after 0xCB: 0x%02x")],
     _gN_=[17,[4,1]],
     _gO_=[0,2,2],
     _gP_=[17,[4,2]],
     _gQ_=[0,2,2],
     _gR_=[17,[4,3]],
     _gS_=[0,2,2],
     _gT_=[17,[4,4]],
     _gU_=[0,2,2],
     _gV_=[17,[4,6]],
     _gW_=[0,2,2],
     _gX_=[17,[4,7]],
     _gY_=[0,2,2],
     _gZ_=[17,[6,3]],
     _g0_=[0,4,4],
     _g1_=[17,[4,0]],
     _g2_=[0,2,2],
     _g3_=[19,[4,1]],
     _g4_=[0,2,2],
     _g5_=[19,[4,2]],
     _g6_=[0,2,2],
     _g7_=[19,[4,3]],
     _g8_=[0,2,2],
     _g9_=[19,[4,4]],
     _g__=[0,2,2],
     _g$_=[19,[4,6]],
     _ha_=[0,2,2],
     _hb_=[19,[4,7]],
     _hc_=[0,2,2],
     _hd_=[19,[6,3]],
     _he_=[0,4,4],
     _hf_=[19,[4,0]],
     _hg_=[0,2,2],
     _hh_=[18,[4,1]],
     _hi_=[0,2,2],
     _hj_=[18,[4,2]],
     _hk_=[0,2,2],
     _hl_=[18,[4,3]],
     _hm_=[0,2,2],
     _hn_=[18,[4,4]],
     _ho_=[0,2,2],
     _hp_=[18,[4,6]],
     _hq_=[0,2,2],
     _hr_=[18,[4,7]],
     _hs_=[0,2,2],
     _ht_=[18,[6,3]],
     _hu_=[0,4,4],
     _hv_=[18,[4,0]],
     _hw_=[0,2,2],
     _hx_=[20,[4,1]],
     _hy_=[0,2,2],
     _hz_=[20,[4,2]],
     _hA_=[0,2,2],
     _hB_=[20,[4,3]],
     _hC_=[0,2,2],
     _hD_=[20,[4,4]],
     _hE_=[0,2,2],
     _hF_=[20,[4,6]],
     _hG_=[0,2,2],
     _hH_=[20,[4,7]],
     _hI_=[0,2,2],
     _hJ_=[20,[6,3]],
     _hK_=[0,4,4],
     _hL_=[20,[4,0]],
     _hM_=[0,2,2],
     _hN_=[21,[4,1]],
     _hO_=[0,2,2],
     _hP_=[21,[4,2]],
     _hQ_=[0,2,2],
     _hR_=[21,[4,3]],
     _hS_=[0,2,2],
     _hT_=[21,[4,4]],
     _hU_=[0,2,2],
     _hV_=[21,[4,6]],
     _hW_=[0,2,2],
     _hX_=[21,[4,7]],
     _hY_=[0,2,2],
     _hZ_=[21,[6,3]],
     _h0_=[0,4,4],
     _h1_=[21,[4,0]],
     _h2_=[0,2,2],
     _h3_=[22,[4,1]],
     _h4_=[0,2,2],
     _h5_=[22,[4,2]],
     _h6_=[0,2,2],
     _h7_=[22,[4,3]],
     _h8_=[0,2,2],
     _h9_=[22,[4,4]],
     _h__=[0,2,2],
     _h$_=[22,[4,6]],
     _ia_=[0,2,2],
     _ib_=[22,[4,7]],
     _ic_=[0,2,2],
     _id_=[22,[6,3]],
     _ie_=[0,4,4],
     _if_=[22,[4,0]],
     _ig_=[0,2,2],
     _ih_=[16,[4,1]],
     _ii_=[0,2,2],
     _ij_=[16,[4,2]],
     _ik_=[0,2,2],
     _il_=[16,[4,3]],
     _im_=[0,2,2],
     _in_=[16,[4,4]],
     _io_=[0,2,2],
     _ip_=[16,[4,6]],
     _iq_=[0,2,2],
     _ir_=[16,[4,7]],
     _is_=[0,2,2],
     _it_=[16,[6,3]],
     _iu_=[0,4,4],
     _iv_=[16,[4,0]],
     _iw_=[0,2,2],
     _ix_=[23,[4,1]],
     _iy_=[0,2,2],
     _iz_=[23,[4,2]],
     _iA_=[0,2,2],
     _iB_=[23,[4,3]],
     _iC_=[0,2,2],
     _iD_=[23,[4,4]],
     _iE_=[0,2,2],
     _iF_=[23,[4,6]],
     _iG_=[0,2,2],
     _iH_=[23,[4,7]],
     _iI_=[0,2,2],
     _iJ_=[23,[6,3]],
     _iK_=[0,4,4],
     _iL_=[23,[4,0]],
     _iM_=[0,2,2],
     _iN_=[24,0,[4,1]],
     _iO_=[0,2,2],
     _iP_=[24,0,[4,2]],
     _iQ_=[0,2,2],
     _iR_=[24,0,[4,3]],
     _iS_=[0,2,2],
     _iT_=[24,0,[4,4]],
     _iU_=[0,2,2],
     _iV_=[24,0,[4,6]],
     _iW_=[0,2,2],
     _iX_=[24,0,[4,7]],
     _iY_=[0,2,2],
     _iZ_=[24,0,[6,3]],
     _i0_=[0,3,3],
     _i1_=[24,0,[4,0]],
     _i2_=[0,2,2],
     _i3_=[24,1,[4,1]],
     _i4_=[0,2,2],
     _i5_=[24,1,[4,2]],
     _i6_=[0,2,2],
     _i7_=[24,1,[4,3]],
     _i8_=[0,2,2],
     _i9_=[24,1,[4,4]],
     _i__=[0,2,2],
     _i$_=[24,1,[4,6]],
     _ja_=[0,2,2],
     _jb_=[24,1,[4,7]],
     _jc_=[0,2,2],
     _jd_=[24,1,[6,3]],
     _je_=[0,3,3],
     _jf_=[24,1,[4,0]],
     _jg_=[0,2,2],
     _jh_=[24,2,[4,1]],
     _ji_=[0,2,2],
     _jj_=[24,2,[4,2]],
     _jk_=[0,2,2],
     _jl_=[24,2,[4,3]],
     _jm_=[0,2,2],
     _jn_=[24,2,[4,4]],
     _jo_=[0,2,2],
     _jp_=[24,2,[4,6]],
     _jq_=[0,2,2],
     _jr_=[24,2,[4,7]],
     _js_=[0,2,2],
     _jt_=[24,2,[6,3]],
     _ju_=[0,3,3],
     _jv_=[24,2,[4,0]],
     _jw_=[0,2,2],
     _jx_=[24,3,[4,1]],
     _jy_=[0,2,2],
     _jz_=[24,3,[4,2]],
     _jA_=[0,2,2],
     _jB_=[24,3,[4,3]],
     _jC_=[0,2,2],
     _jD_=[24,3,[4,4]],
     _jE_=[0,2,2],
     _jF_=[24,3,[4,6]],
     _jG_=[0,2,2],
     _jH_=[24,3,[4,7]],
     _jI_=[0,2,2],
     _jJ_=[24,3,[6,3]],
     _jK_=[0,3,3],
     _jL_=[24,3,[4,0]],
     _jM_=[0,2,2],
     _jN_=[24,4,[4,1]],
     _jO_=[0,2,2],
     _jP_=[24,4,[4,2]],
     _jQ_=[0,2,2],
     _jR_=[24,4,[4,3]],
     _jS_=[0,2,2],
     _jT_=[24,4,[4,4]],
     _jU_=[0,2,2],
     _jV_=[24,4,[4,6]],
     _jW_=[0,2,2],
     _jX_=[24,4,[4,7]],
     _jY_=[0,2,2],
     _jZ_=[24,4,[6,3]],
     _j0_=[0,3,3],
     _j1_=[24,4,[4,0]],
     _j2_=[0,2,2],
     _j3_=[24,5,[4,1]],
     _j4_=[0,2,2],
     _j5_=[24,5,[4,2]],
     _j6_=[0,2,2],
     _j7_=[24,5,[4,3]],
     _j8_=[0,2,2],
     _j9_=[24,5,[4,4]],
     _j__=[0,2,2],
     _j$_=[24,5,[4,6]],
     _ka_=[0,2,2],
     _kb_=[24,5,[4,7]],
     _kc_=[0,2,2],
     _kd_=[24,5,[6,3]],
     _ke_=[0,3,3],
     _kf_=[24,5,[4,0]],
     _kg_=[0,2,2],
     _kh_=[24,6,[4,1]],
     _ki_=[0,2,2],
     _kj_=[24,6,[4,2]],
     _kk_=[0,2,2],
     _kl_=[24,6,[4,3]],
     _km_=[0,2,2],
     _kn_=[24,6,[4,4]],
     _ko_=[0,2,2],
     _kp_=[24,6,[4,6]],
     _kq_=[0,2,2],
     _kr_=[24,6,[4,7]],
     _ks_=[0,2,2],
     _kt_=[24,6,[6,3]],
     _ku_=[0,3,3],
     _kv_=[24,6,[4,0]],
     _kw_=[0,2,2],
     _kx_=[24,7,[4,1]],
     _ky_=[0,2,2],
     _kz_=[24,7,[4,2]],
     _kA_=[0,2,2],
     _kB_=[24,7,[4,3]],
     _kC_=[0,2,2],
     _kD_=[24,7,[4,4]],
     _kE_=[0,2,2],
     _kF_=[24,7,[4,6]],
     _kG_=[0,2,2],
     _kH_=[24,7,[4,7]],
     _kI_=[0,2,2],
     _kJ_=[24,7,[6,3]],
     _kK_=[0,3,3],
     _kL_=[24,7,[4,0]],
     _kM_=[0,2,2],
     _kN_=[26,0,[4,1]],
     _kO_=[0,2,2],
     _kP_=[26,0,[4,2]],
     _kQ_=[0,2,2],
     _kR_=[26,0,[4,3]],
     _kS_=[0,2,2],
     _kT_=[26,0,[4,4]],
     _kU_=[0,2,2],
     _kV_=[26,0,[4,6]],
     _kW_=[0,2,2],
     _kX_=[26,0,[4,7]],
     _kY_=[0,2,2],
     _kZ_=[26,0,[6,3]],
     _k0_=[0,4,4],
     _k1_=[26,0,[4,0]],
     _k2_=[0,2,2],
     _k3_=[26,1,[4,1]],
     _k4_=[0,2,2],
     _k5_=[26,1,[4,2]],
     _k6_=[0,2,2],
     _k7_=[26,1,[4,3]],
     _k8_=[0,2,2],
     _k9_=[26,1,[4,4]],
     _k__=[0,2,2],
     _k$_=[26,1,[4,6]],
     _la_=[0,2,2],
     _lb_=[26,1,[4,7]],
     _lc_=[0,2,2],
     _ld_=[26,1,[6,3]],
     _le_=[0,4,4],
     _lf_=[26,1,[4,0]],
     _lg_=[0,2,2],
     _lh_=[26,2,[4,1]],
     _li_=[0,2,2],
     _lj_=[26,2,[4,2]],
     _lk_=[0,2,2],
     _ll_=[26,2,[4,3]],
     _lm_=[0,2,2],
     _ln_=[26,2,[4,4]],
     _lo_=[0,2,2],
     _lp_=[26,2,[4,6]],
     _lq_=[0,2,2],
     _lr_=[26,2,[4,7]],
     _ls_=[0,2,2],
     _lt_=[26,2,[6,3]],
     _lu_=[0,4,4],
     _lv_=[26,2,[4,0]],
     _lw_=[0,2,2],
     _lx_=[26,3,[4,1]],
     _ly_=[0,2,2],
     _lz_=[26,3,[4,2]],
     _lA_=[0,2,2],
     _lB_=[26,3,[4,3]],
     _lC_=[0,2,2],
     _lD_=[26,3,[4,4]],
     _lE_=[0,2,2],
     _lF_=[26,3,[4,6]],
     _lG_=[0,2,2],
     _lH_=[26,3,[4,7]],
     _lI_=[0,2,2],
     _lJ_=[26,3,[6,3]],
     _lK_=[0,4,4],
     _lL_=[26,3,[4,0]],
     _lM_=[0,2,2],
     _lN_=[26,4,[4,1]],
     _lO_=[0,2,2],
     _lP_=[26,4,[4,2]],
     _lQ_=[0,2,2],
     _lR_=[26,4,[4,3]],
     _lS_=[0,2,2],
     _lT_=[26,4,[4,4]],
     _lU_=[0,2,2],
     _lV_=[26,4,[4,6]],
     _lW_=[0,2,2],
     _lX_=[26,4,[4,7]],
     _lY_=[0,2,2],
     _lZ_=[26,4,[6,3]],
     _l0_=[0,4,4],
     _l1_=[26,4,[4,0]],
     _l2_=[0,2,2],
     _l3_=[26,5,[4,1]],
     _l4_=[0,2,2],
     _l5_=[26,5,[4,2]],
     _l6_=[0,2,2],
     _l7_=[26,5,[4,3]],
     _l8_=[0,2,2],
     _l9_=[26,5,[4,4]],
     _l__=[0,2,2],
     _l$_=[26,5,[4,6]],
     _ma_=[0,2,2],
     _mb_=[26,5,[4,7]],
     _mc_=[0,2,2],
     _md_=[26,5,[6,3]],
     _me_=[0,4,4],
     _mf_=[26,5,[4,0]],
     _mg_=[0,2,2],
     _mh_=[26,6,[4,1]],
     _mi_=[0,2,2],
     _mj_=[26,6,[4,2]],
     _mk_=[0,2,2],
     _ml_=[26,6,[4,3]],
     _mm_=[0,2,2],
     _mn_=[26,6,[4,4]],
     _mo_=[0,2,2],
     _mp_=[26,6,[4,6]],
     _mq_=[0,2,2],
     _mr_=[26,6,[4,7]],
     _ms_=[0,2,2],
     _mt_=[26,6,[6,3]],
     _mu_=[0,4,4],
     _mv_=[26,6,[4,0]],
     _mw_=[0,2,2],
     _mx_=[26,7,[4,1]],
     _my_=[0,2,2],
     _mz_=[26,7,[4,2]],
     _mA_=[0,2,2],
     _mB_=[26,7,[4,3]],
     _mC_=[0,2,2],
     _mD_=[26,7,[4,4]],
     _mE_=[0,2,2],
     _mF_=[26,7,[4,6]],
     _mG_=[0,2,2],
     _mH_=[26,7,[4,7]],
     _mI_=[0,2,2],
     _mJ_=[26,7,[6,3]],
     _mK_=[0,4,4],
     _mL_=[26,7,[4,0]],
     _mM_=[0,2,2],
     _mN_=[25,0,[4,1]],
     _mO_=[0,2,2],
     _mP_=[25,0,[4,2]],
     _mQ_=[0,2,2],
     _mR_=[25,0,[4,3]],
     _mS_=[0,2,2],
     _mT_=[25,0,[4,4]],
     _mU_=[0,2,2],
     _mV_=[25,0,[4,6]],
     _mW_=[0,2,2],
     _mX_=[25,0,[4,7]],
     _mY_=[0,2,2],
     _mZ_=[25,0,[6,3]],
     _m0_=[0,4,4],
     _m1_=[25,0,[4,0]],
     _m2_=[0,2,2],
     _m3_=[25,1,[4,1]],
     _m4_=[0,2,2],
     _m5_=[25,1,[4,2]],
     _m6_=[0,2,2],
     _m7_=[25,1,[4,3]],
     _m8_=[0,2,2],
     _m9_=[25,1,[4,4]],
     _m__=[0,2,2],
     _m$_=[25,1,[4,6]],
     _na_=[0,2,2],
     _nb_=[25,1,[4,7]],
     _nc_=[0,2,2],
     _nd_=[25,1,[6,3]],
     _ne_=[0,4,4],
     _nf_=[25,1,[4,0]],
     _ng_=[0,2,2],
     _nh_=[25,2,[4,1]],
     _ni_=[0,2,2],
     _nj_=[25,2,[4,2]],
     _nk_=[0,2,2],
     _nl_=[25,2,[4,3]],
     _nm_=[0,2,2],
     _nn_=[25,2,[4,4]],
     _no_=[0,2,2],
     _np_=[25,2,[4,6]],
     _nq_=[0,2,2],
     _nr_=[25,2,[4,7]],
     _ns_=[0,2,2],
     _nt_=[25,2,[6,3]],
     _nu_=[0,4,4],
     _nv_=[25,2,[4,0]],
     _nw_=[0,2,2],
     _nx_=[25,3,[4,1]],
     _ny_=[0,2,2],
     _nz_=[25,3,[4,2]],
     _nA_=[0,2,2],
     _nB_=[25,3,[4,3]],
     _nC_=[0,2,2],
     _nD_=[25,3,[4,4]],
     _nE_=[0,2,2],
     _nF_=[25,3,[4,6]],
     _nG_=[0,2,2],
     _nH_=[25,3,[4,7]],
     _nI_=[0,2,2],
     _nJ_=[25,3,[6,3]],
     _nK_=[0,4,4],
     _nL_=[25,3,[4,0]],
     _nM_=[0,2,2],
     _nN_=[25,4,[4,1]],
     _nO_=[0,2,2],
     _nP_=[25,4,[4,2]],
     _nQ_=[0,2,2],
     _nR_=[25,4,[4,3]],
     _nS_=[0,2,2],
     _nT_=[25,4,[4,4]],
     _nU_=[0,2,2],
     _nV_=[25,4,[4,6]],
     _nW_=[0,2,2],
     _nX_=[25,4,[4,7]],
     _nY_=[0,2,2],
     _nZ_=[25,4,[6,3]],
     _n0_=[0,4,4],
     _n1_=[25,4,[4,0]],
     _n2_=[0,2,2],
     _n3_=[25,5,[4,1]],
     _n4_=[0,2,2],
     _n5_=[25,5,[4,2]],
     _n6_=[0,2,2],
     _n7_=[25,5,[4,3]],
     _n8_=[0,2,2],
     _n9_=[25,5,[4,4]],
     _n__=[0,2,2],
     _n$_=[25,5,[4,6]],
     _oa_=[0,2,2],
     _ob_=[25,5,[4,7]],
     _oc_=[0,2,2],
     _od_=[25,5,[6,3]],
     _oe_=[0,4,4],
     _of_=[25,5,[4,0]],
     _og_=[0,2,2],
     _oh_=[25,6,[4,1]],
     _oi_=[0,2,2],
     _oj_=[25,6,[4,2]],
     _ok_=[0,2,2],
     _ol_=[25,6,[4,3]],
     _om_=[0,2,2],
     _on_=[25,6,[4,4]],
     _oo_=[0,2,2],
     _op_=[25,6,[4,6]],
     _oq_=[0,2,2],
     _or_=[25,6,[4,7]],
     _os_=[0,2,2],
     _ot_=[25,6,[6,3]],
     _ou_=[0,4,4],
     _ov_=[25,6,[4,0]],
     _ow_=[0,2,2],
     _ox_=[25,7,[4,1]],
     _oy_=[0,2,2],
     _oz_=[25,7,[4,2]],
     _oA_=[0,2,2],
     _oB_=[25,7,[4,3]],
     _oC_=[0,2,2],
     _oD_=[25,7,[4,4]],
     _oE_=[0,2,2],
     _oF_=[25,7,[4,6]],
     _oG_=[0,2,2],
     _oH_=[25,7,[4,7]],
     _oI_=[0,2,2],
     _oJ_=[25,7,[6,3]],
     _oK_=[0,4,4],
     _oL_=[25,7,[4,0]],
     _oM_=[0,2,2],
     _oN_=[0,3,6],
     _oO_=[0,6,6],
     _oP_=[4,0],
     _oQ_=[0,2,2],
     _oR_=[0,4,4],
     _oS_=[33,3],
     _oT_=[0,2,5],
     _oU_=[28,2],
     _oV_=[0,3,3],
     _oW_=[0,3,4],
     _oX_=[0,1,1],
     _oY_=[0,3,6],
     _oZ_=[27,2],
     _o0_=[0,4,4],
     _o1_=[4,0],
     _o2_=[0,2,2],
     _o3_=[0,4,4],
     _o4_=[33,4],
     _o5_=[0,2,5],
     _o6_=[0,4,4],
     _o7_=[0,3,4],
     _o8_=[0,1,1],
     _o9_=[0,3,6],
     _o__=[0,1,1],
     _o$_=[4,0],
     _pa_=[0,2,2],
     _pb_=[0,4,4],
     _pc_=[4,0],
     _pd_=[0,3,3],
     _pe_=[28,3],
     _pf_=[0,3,3],
     _pg_=[0,0,[4,0]],
     _ph_=[0,2,2],
     _pi_=[0,1,1],
     _pj_=[0,1,1],
     _pk_=[27,3],
     _pl_=[0,4,4],
     _pm_=[4,0],
     _pn_=[0,2,2],
     _po_=[0,4,4],
     _pp_=[0,4,4],
     _pq_=[29,0,[5,3]],
     _pr_=[0,1,1],
     _ps_=[4,0],
     _pt_=[0,4,4],
     _pu_=[0,1,1],
     _pv_=[0,1,1],
     _pw_=[0,1,1],
     _px_=[4,0],
     _py_=[0,2,2],
     _pz_=[0,4,4],
     _pA_=[4,0],
     _pB_=[0,3,3],
     _pC_=[28,0],
     _pD_=[0,3,3],
     _pE_=[0,[4,0],0],
     _pF_=[0,2,2],
     _pG_=[0,1,1],
     _pH_=[0,1,1],
     _pI_=[27,0],
     _pJ_=[0,4,4],
     _pK_=[4,0],
     _pL_=[0,2,2],
     _pM_=[0,4,4],
     _pN_=[5,3],
     _pO_=[0,3,3],
     _pP_=[1,3,[5,3]],
     _pQ_=[0,2,2],
     _pR_=[4,0],
     _pS_=[0,4,4],
     _pT_=[0,1,1],
     _pU_=[0,1,1],
     _pV_=[0,1,1],
     _pW_=[4,0],
     _pX_=[0,2,2],
     _pY_=[0,4,4],
     _p0_=
      [0,
       [11,caml_string_of_jsbytes("Unknown rom type : 0x"),[4,6,0,0,0]],
       caml_string_of_jsbytes("Unknown rom type : 0x%x")],
     _p1_=
      [0,caml_string_of_jsbytes("lib/cartridge/cartridge_header.ml"),33,11],
     _p2_=
      [0,caml_string_of_jsbytes("lib/cartridge/cartridge_header.ml"),43,11],
     _p8_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc1.ml"),114,9],
     _p7_=
      [0,
       [11,caml_string_of_jsbytes("Unexpected rom size: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Unexpected rom size: %d")],
     _p6_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc1.ml"),84,9],
     _p5_=
      [0,
       [11,caml_string_of_jsbytes("Unexpected ram size: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Unexpected ram size: %d")],
     _p4_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc1.ml"),51,9],
     _p3_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc1.ml"),39,13],
     _p9_=
      [0,caml_string_of_jsbytes("lib/cartridge/detect_cartridge.ml"),11,31],
     _qb_=
      [0,
       [11,caml_string_of_jsbytes("Invalid arugment"),0],
       caml_string_of_jsbytes("Invalid arugment")],
     _p$_=[0,0],
     _qa_=[0,0],
     _qd_=[0,1],
     _qc_=[0,0],
     _qe_=[0,1],
     _qf_=[0,1],
     _qg_=[0,0],
     _qh_=[0,0],
     _qi_=[0,0],
     _qj_=[0,0],
     _qk_=[0,1],
     _ql_=[0,caml_string_of_jsbytes("lib/cpu/cpu.ml"),279,16],
     _qm_=[0,0],
     _qn_=[0,0],
     _qo_=[0,0],
     _qp_=[0,0],
     _qq_=[0,0],
     _qr_=[0,0],
     _qs_=[0,0],
     _qt_=[0,0],
     _qu_=[0,0],
     _qv_=[0,0],
     _qw_=[0,0],
     _qx_=[0,0],
     _qy_=[0,0],
     _qz_=[0,0],
     _qA_=[0,0],
     _qB_=[0,0],
     _qC_=[0,0],
     _qD_=[0,1],
     _qE_=[0,1],
     _qF_=[0,0],
     _qG_=[0,1],
     _qH_=[0,0],
     _qI_=[0,0],
     _qJ_=[0,0],
     _qK_=[0,0],
     _qL_=[0,0],
     _qM_=[0,0],
     _qN_=[0,0],
     _qO_=[0,1],
     _qP_=[0,0],
     _qQ_=[0,1],
     _qR_=[0,0],
     _qS_=[0,0],
     _qT_=[0,0],
     _qU_=[0,0],
     _qV_=[0,0],
     _qW_=[0,0],
     _qX_=[0,0],
     _qY_=[0,0],
     _qZ_=[0,0],
     _q0_=[0,0],
     _q1_=[0,0],
     _q2_=[0,0],
     _q3_=[0,0],
     _q4_=[0,0],
     _q5_=[0,0],
     _q6_=[0,0],
     _q7_=[0,0],
     _q8_=[0,0],
     _q9_=[0,1],
     _p__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" SP:"),
         [2,0,[11,caml_string_of_jsbytes(" PC:"),[2,0,0]]]]],
       caml_string_of_jsbytes("%s SP:%s PC:%s")],
     _ra_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc3.ml"),64,9],
     _q$_=[0,caml_string_of_jsbytes("lib/cartridge/cartridge_mbc3.ml"),43,9],
     _rb_=[0,1],
     _rc_=[0,0],
     _rd_=[0,1],
     _re_=[0,1],
     _rf_=[0,[0,0,432],[0,[0,1,19],[0,[0,2,216],[0,[0,3,333],0]]]],
     _rg_=
      caml_list_of_js_array
       ([[0,65280,207],
         [0,65281,0],
         [0,65282,126],
         [0,65284,171],
         [0,65285,0],
         [0,65286,0],
         [0,65287,248],
         [0,65295,225],
         [0,65344,145],
         [0,65346,0],
         [0,65347,0],
         [0,65348,0],
         [0,65349,0],
         [0,65350,255],
         [0,65351,252],
         [0,65354,0],
         [0,65355,0],
         [0,65535,0]]);
    function MakeInfix(B)
     {var
       symbol=B[8],
       symbol$0=B[9],
       symbol$1=B[10],
       symbol$2=B[11],
       symbol$3=B[6];
      function symbol$4(a,b){return 1 - caml_call2(B[6],a,b)}
      var
       symbol$5=B[7],
       mod=B[12],
       land=B[15],
       lor=B[16],
       lxor=B[17],
       lsl=B[18],
       lsr=B[19];
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              symbol$5,
              mod,
              land,
              lor,
              lxor,
              lsl,
              lsr]}
    var compare=Stdlib_Int[9],max_int=255,zero=0,one=1;
    function equal(x,y){return 0 === caml_call2(compare,x,y)?1:0}
    function le(x,y){return caml_lessequal(x,y)}
    function add(x,y){return (x + y | 0) & 255}
    function sub(x,y){return (x - y | 0) & 255}
    function mul(x,y){return caml_mul(x,y) & 255}
    function div(x,y){return caml_div(x,y) & 255}
    function rem(x,y){return caml_mod(x,y) & 255}
    function succ(x){return add(x,one)}
    function pred(x){return sub(x,one)}
    function logand(x,y){return x & y}
    function logor(x,y){return x | y}
    function logxor(_Bb_,_Ba_){return _Bb_ ^ _Ba_}
    function shift_left(x,y){return x << y & 255}
    function shift_right(_A$_,_A__){return _A$_ >>> _A__ | 0}
    function of_int(x){return x & 255}
    function of_char(c){return c}
    function to_char(t){return t}
    var
     show=caml_call1(Stdlib_Printf[4],_a_),
     Infix=
      MakeInfix
       ([0,
         show,
         max_int,
         zero,
         one,
         compare,
         equal,
         le,
         add,
         sub,
         mul,
         div,
         rem,
         succ,
         pred,
         logand,
         logor,
         logxor,
         shift_left,
         shift_right,
         of_int,
         function(_A9_){return _A9_}]),
     symbol=Infix[1],
     symbol$0=Infix[2],
     symbol$1=Infix[3],
     symbol$2=Infix[4],
     symbol$3=Infix[5],
     symbol$4=Infix[6],
     symbol$5=Infix[7],
     mod=Infix[8],
     land=Infix[9],
     lor=Infix[10],
     lxor=Infix[11],
     lsl=Infix[12],
     lsr=Infix[13],
     compare$0=Stdlib_Int[9],
     max_int$0=65535,
     zero$0=0,
     one$0=1;
    function equal$0(x,y){return 0 === caml_call2(compare$0,x,y)?1:0}
    function le$0(x,y){return caml_lessequal(x,y)}
    function add$0(x,y){return (x + y | 0) & 65535}
    function sub$0(x,y){return (x - y | 0) & 65535}
    function mul$0(x,y){return caml_mul(x,y) & 65535}
    function div$0(x,y){return caml_div(x,y) & 65535}
    function rem$0(x,y){return caml_mod(x,y) & 65535}
    function succ$0(x){return add$0(x,one$0)}
    function pred$0(x){return sub$0(x,one$0)}
    function logand$0(x,y){return x & y}
    function logor$0(x,y){return x | y}
    function logxor$0(_A8_,_A7_){return _A8_ ^ _A7_}
    function shift_left$0(x,y){return x << y & 65535}
    function shift_right$0(_A6_,_A5_){return _A6_ >>> _A5_ | 0}
    function of_int$0(x){return x & 65535}
    var
     show$0=caml_call1(Stdlib_Printf[4],_b_),
     Infix$0=
      MakeInfix
       ([0,
         show$0,
         max_int$0,
         zero$0,
         one$0,
         compare$0,
         equal$0,
         le$0,
         add$0,
         sub$0,
         mul$0,
         div$0,
         rem$0,
         succ$0,
         pred$0,
         logand$0,
         logor$0,
         logxor$0,
         shift_left$0,
         shift_right$0,
         of_int$0,
         function(_A4_){return _A4_}]),
     symbol$6=Infix$0[1],
     symbol$7=Infix$0[2],
     symbol$8=Infix$0[3],
     symbol$9=Infix$0[4],
     symbol$10=Infix$0[5],
     symbol$11=Infix$0[6],
     symbol$12=Infix$0[7],
     mod$0=Infix$0[8],
     land$0=Infix$0[9],
     lor$0=Infix$0[10],
     lxor$0=Infix$0[11],
     lsl$0=Infix$0[12],
     lsr$0=Infix$0[13];
    function of_uint8(x){return x & 65535}
    function to_uint8(x){return x & 255}
    function of_byte(b){return b}
    function of_int$1(x){return 0 <= x?x & 255:x & 255 | 128}
    function is_neg(t){return 0 !== (t & 128)?1:0}
    function abs(t){return is_neg(t)?(t - 1 | 0) ^ 255:t}
    function to_int(t){return is_neg(t)?- abs(t) | 0:t}
    function show$1(t)
     {if(0 === (t & 128))return caml_call2(Stdlib_Printf[4],_c_,t);
      var _A3_=caml_call1(Stdlib_Int[4],t - 256 | 0);
      return caml_call2(Stdlib_Printf[4],_d_,_A3_)}
    var
     _e_=[0,of_byte,of_int$1,to_int,is_neg,abs,show$1],
     _f_=
      [0,
       show$0,
       max_int$0,
       zero$0,
       one$0,
       compare$0,
       equal$0,
       le$0,
       add$0,
       sub$0,
       mul$0,
       div$0,
       rem$0,
       succ$0,
       pred$0,
       logand$0,
       logor$0,
       logxor$0,
       shift_left$0,
       shift_right$0,
       of_int$0,
       function(_A2_){return _A2_},
       Infix$0,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       mod$0,
       land$0,
       lor$0,
       lxor$0,
       lsl$0,
       lsr$0,
       of_uint8,
       to_uint8],
     _g_=
      [0,
       show,
       max_int,
       zero,
       one,
       compare,
       equal,
       le,
       add,
       sub,
       mul,
       div,
       rem,
       succ,
       pred,
       logand,
       logor,
       logxor,
       shift_left,
       shift_right,
       of_int,
       function(_A1_){return _A1_},
       Infix,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       mod,
       land,
       lor,
       lxor,
       lsl,
       lsr,
       of_char,
       to_char],
     Camlboy_lib_Uints=[0,_g_,_f_,_e_];
    caml_register_global(1203,Camlboy_lib_Uints,"Camlboy_lib__Uints");
    var Camlboy_lib_Addressable_intf=[0];
    caml_register_global
     (1204,Camlboy_lib_Addressable_intf,"Camlboy_lib__Addressable_intf");
    var Camlboy_lib_Word_addressable_i=[0];
    caml_register_global
     (1205,
      Camlboy_lib_Word_addressable_i,
      "Camlboy_lib__Word_addressable_intf");
    function show_type(param)
     {switch(param)
       {case 0:return cst_VBlank;
        case 1:return cst_LCD_stat;
        case 2:return cst_Timer;
        case 3:return cst_Serial_port;
        default:return cst_Joypad}}
    function show$2(t)
     {var
       _AR_=caml_call1(Stdlib_Bool[4],t[2][6]),
       _AS_=caml_call1(Stdlib_Bool[4],t[2][5]),
       _AT_=caml_call1(Stdlib_Bool[4],t[2][4]),
       _AU_=caml_call1(Stdlib_Bool[4],t[2][3]),
       _AV_=caml_call1(Stdlib_Bool[4],t[2][2]),
       _AW_=caml_call1(Stdlib_Bool[4],t[1][6]),
       _AX_=caml_call1(Stdlib_Bool[4],t[1][5]),
       _AY_=caml_call1(Stdlib_Bool[4],t[1][4]),
       _AZ_=caml_call1(Stdlib_Bool[4],t[1][3]),
       _A0_=caml_call1(Stdlib_Bool[4],t[1][2]);
      return caml_call11
              (Stdlib_Printf[4],
               _h_,
               _A0_,
               _AZ_,
               _AY_,
               _AX_,
               _AW_,
               _AV_,
               _AU_,
               _AT_,
               _AS_,
               _AR_)}
    function create(ie_addr,if_addr)
     {return [0,[0,ie_addr,0,0,0,0,0],[0,if_addr,0,0,0,0,0]]}
    function update(state,type,b)
     {switch(type)
       {case 0:return [0,state[1],b,state[3],state[4],state[5],state[6]];
        case 1:return [0,state[1],state[2],b,state[4],state[5],state[6]];
        case 2:return [0,state[1],state[2],state[3],b,state[5],state[6]];
        case 3:return [0,state[1],state[2],state[3],state[4],b,state[6]];
        default:return [0,state[1],state[2],state[3],state[4],state[5],b]}}
    function request(t,type){t[2] = update(t[2],type,1);return 0}
    function clear(t,type){t[2] = update(t[2],type,0);return 0}
    function clear_all(t)
     {function _AQ_(type){return clear(t,type)}
      return caml_call1(caml_call1(Stdlib_List[17],_AQ_),_i_)}
    function next(t)
     {if(t[1][2] && t[2][2])return _j_;
      if(t[1][3] && t[2][3])return _k_;
      if(t[1][4] && t[2][4])return _l_;
      if(t[1][5] && t[2][5])return _m_;
      if(t[1][6] && t[2][6])return _n_;
      return 0}
    function accepts(t,addr)
     {var _AP_=caml_call2(_f_[27],t[1][1],addr);
      return _AP_?_AP_:caml_call2(_f_[27],t[2][1],addr)}
    function byte_of_state(s)
     {var
       _AK_=s[6]?16:0,
       _AL_=s[5]?8:0,
       _AM_=s[4]?4:0,
       _AN_=s[3]?2:0,
       _AO_=s[2]?1:0;
      return caml_call1(_g_[20],_AO_ | _AN_ | _AM_ | _AL_ | _AK_)}
    function read_byte(t,addr)
     {if(caml_call2(_f_[27],addr,t[1][1]))return byte_of_state(t[1]);
      if(caml_call2(_f_[27],addr,t[2][1]))
       {var _AI_=byte_of_state(t[2]),_AJ_=caml_call1(_g_[20],224);
        return caml_call2(_g_[32],_AJ_,_AI_)}
      throw [0,Assert_failure,_o_]}
    function state_of_byte(b,addr)
     {var
       _At_=caml_call1(_g_[20],0),
       _Au_=caml_call1(_g_[20],1),
       _Av_=caml_call2(_g_[31],b,_Au_),
       b0=caml_call2(_g_[28],_Av_,_At_),
       _Aw_=caml_call1(_g_[20],0),
       _Ax_=caml_call1(_g_[20],2),
       _Ay_=caml_call2(_g_[31],b,_Ax_),
       b1=caml_call2(_g_[28],_Ay_,_Aw_),
       _Az_=caml_call1(_g_[20],0),
       _AA_=caml_call1(_g_[20],4),
       _AB_=caml_call2(_g_[31],b,_AA_),
       b2=caml_call2(_g_[28],_AB_,_Az_),
       _AC_=caml_call1(_g_[20],0),
       _AD_=caml_call1(_g_[20],8),
       _AE_=caml_call2(_g_[31],b,_AD_),
       b3=caml_call2(_g_[28],_AE_,_AC_),
       _AF_=caml_call1(_g_[20],0),
       _AG_=caml_call1(_g_[20],16),
       _AH_=caml_call2(_g_[31],b,_AG_),
       b4=caml_call2(_g_[28],_AH_,_AF_);
      return [0,addr,b0,b1,b2,b3,b4]}
    function write_byte(t,addr,data)
     {if(caml_equal(addr,t[1][1]))
       {t[1] = state_of_byte(data,t[1][1]);return 0}
      if(caml_equal(addr,t[2][1]))
       {t[2] = state_of_byte(data,t[2][1]);return 0}
      throw [0,Assert_failure,_p_]}
    var
     Camlboy_lib_Interrupt_controll=
      [0,
       show$2,
       show_type,
       create,
       request,
       clear,
       clear_all,
       next,
       read_byte,
       write_byte,
       accepts];
    caml_register_global
     (1209,Camlboy_lib_Interrupt_controll,"Camlboy_lib__Interrupt_controller");
    function create$0(div_addr,tima_addr,tma_addr,tac_addr,ic)
     {return [0,div_addr,tima_addr,tma_addr,tac_addr,ic,0,0,0,0,0,0]}
    function run(t,mcycles)
     {var
       before_mcycle_count=t[6],
       after_mcycle_count=before_mcycle_count + mcycles | 0;
      t[6] = after_mcycle_count % 65536 | 0;
      var
       quotient_diff=
        (after_mcycle_count / 64 | 0) - (before_mcycle_count / 64 | 0) | 0;
      t[7] = (t[7] + quotient_diff | 0) % 256 | 0;
      var _Ao_=t[8];
      if(_Ao_)
       {switch(t[9])
         {case 0:var divider=256;break;
          case 1:var divider=4;break;
          case 2:var divider=16;break;
          default:var divider=64}
        var
         _Ap_=caml_div(before_mcycle_count,divider),
         quotient_diff$0=caml_div(after_mcycle_count,divider) - _Ap_ | 0,
         before_tima_counter=t[11];
        t[11] = (t[11] + quotient_diff$0 | 0) % 256 | 0;
        var
         after_tima_counter=t[11],
         _Aq_=after_tima_counter < before_tima_counter?1:0,
         _Ar_=_Aq_?(request(t[5],2),t[11] = t[10],0):_Aq_,
         _As_=_Ar_}
      else
       var _As_=_Ao_;
      return _As_}
    function accepts$0(t,addr)
     {var _Ak_=caml_equal(addr,t[1]);
      if(_Ak_)
       var _Al_=_Ak_;
      else
       {var _Am_=caml_equal(addr,t[2]);
        if(_Am_)
         var _Al_=_Am_;
        else
         var _An_=caml_equal(addr,t[3]),_Al_=_An_ || caml_equal(addr,t[4])}
      return _Al_}
    function read_byte$0(t,addr)
     {if(caml_equal(addr,t[1]))return caml_call1(_g_[20],t[7]);
      if(caml_equal(addr,t[2]))return caml_call1(_g_[20],t[11]);
      if(caml_equal(addr,t[3]))return caml_call1(_g_[20],t[10]);
      if(caml_equal(addr,t[4]))
       {var _Ai_=t[8]?4:0,enable_bit=caml_call1(_g_[20],_Ai_);
        switch(t[9])
         {case 0:var _Aj_=caml_call1(_g_[20],0);break;
          case 1:var _Aj_=caml_call1(_g_[20],1);break;
          case 2:var _Aj_=caml_call1(_g_[20],2);break;
          default:var _Aj_=caml_call1(_g_[20],3)}
        return caml_call2(_g_[31],enable_bit,_Aj_)}
      throw [0,Assert_failure,_q_]}
    function write_byte$0(t,addr,data)
     {if(caml_equal(addr,t[1])){t[7] = 0;t[6] = 0;return 0}
      if(caml_equal(addr,t[2])){t[11] = caml_call1(_g_[21],data);return 0}
      if(caml_equal(addr,t[3])){t[10] = caml_call1(_g_[21],data);return 0}
      if(caml_equal(addr,t[4]))
       {var
         _Ae_=_g_[3],
         _Af_=caml_call1(_g_[20],4),
         _Ag_=caml_call2(_g_[31],data,_Af_);
        if(caml_call2(_g_[28],_Ag_,_Ae_))t[8] = 1;
        var byte$0=caml_call1(_g_[21],data),match=byte$0 & 3;
        if(3 < match >>> 0)throw [0,Assert_failure,_r_];
        switch(match)
         {case 0:var _Ah_=0;break;
          case 1:var _Ah_=1;break;
          case 2:var _Ah_=2;break;
          default:var _Ah_=3}
        t[9] = _Ah_;
        return 0}
      throw [0,Assert_failure,_s_]}
    function get_tima_count(t){return caml_call1(_g_[20],t[11])}
    var
     For_tests=[0,get_tima_count],
     Camlboy_lib_Timer=
      [0,create$0,run,read_byte$0,write_byte$0,accepts$0,For_tests];
    caml_register_global(1210,Camlboy_lib_Timer,"Camlboy_lib__Timer");
    function create$1
     (area0_start_addr,area0_end_addr,area1_start_addr,area1_end_addr)
     {var _Ad_=caml_call3(Stdlib_Array[3],32,32,_g_[3]);
      return [0,
              caml_call3(Stdlib_Array[3],32,32,_g_[3]),
              _Ad_,
              area0_start_addr,
              area0_end_addr,
              area1_start_addr,
              area1_end_addr]}
    function get_tile_index(t,area,y,x)
     {if(area)
       {var _z$_=x / 8 | 0,_Aa_=y / 8 | 0;
        return caml_check_bound(caml_check_bound(t[2],_Aa_)[1 + _Aa_],_z$_)
                [1 + _z$_]}
      var _Ab_=x / 8 | 0,_Ac_=y / 8 | 0;
      return caml_check_bound(caml_check_bound(t[1],_Ac_)[1 + _Ac_],_Ab_)
              [1 + _Ab_]}
    function accepts$1(t,addr)
     {var
       _z7_=caml_call2(_f_[29],t[3],addr),
       _z8_=_z7_?caml_call2(_f_[29],addr,t[4]):_z7_;
      if(_z8_)
       var _z9_=_z8_;
      else
       {var _z__=caml_call2(_f_[29],t[5],addr);
        if(_z__)return caml_call2(_f_[29],addr,t[6]);
        var _z9_=_z__}
      return _z9_}
    function read_byte$1(t,addr)
     {if(caml_call2(_f_[29],t[3],addr) && caml_call2(_f_[29],addr,t[4]))
       {var
         _zZ_=caml_call2(_f_[24],addr,t[3]),
         offset=caml_call1(_f_[21],_zZ_),
         _z0_=offset % 32 | 0,
         _z1_=offset / 32 | 0;
        return caml_check_bound(caml_check_bound(t[1],_z1_)[1 + _z1_],_z0_)
                [1 + _z0_]}
      if(caml_call2(_f_[29],t[5],addr) && caml_call2(_f_[29],addr,t[6]))
       {var
         _z2_=caml_call2(_f_[24],addr,t[5]),
         offset$0=caml_call1(_f_[21],_z2_),
         _z3_=offset$0 % 32 | 0,
         _z4_=offset$0 / 32 | 0;
        return caml_check_bound(caml_check_bound(t[2],_z4_)[1 + _z4_],_z3_)
                [1 + _z3_]}
      var
       _z5_=caml_call1(_f_[1],addr),
       _z6_=caml_call2(Stdlib_Printf[4],_t_,_z5_);
      throw [0,Stdlib[6],_z6_]}
    function write_byte$1(t,addr,data)
     {if(caml_call2(_f_[29],t[3],addr) && caml_call2(_f_[29],addr,t[4]))
       {var
         _zR_=caml_call2(_f_[24],addr,t[3]),
         offset=caml_call1(_f_[21],_zR_),
         _zS_=offset % 32 | 0,
         _zT_=offset / 32 | 0;
        caml_check_bound(caml_check_bound(t[1],_zT_)[1 + _zT_],_zS_)[1 + _zS_]
        =
        data;
        return 0}
      if(caml_call2(_f_[29],t[5],addr) && caml_call2(_f_[29],addr,t[6]))
       {var
         _zU_=caml_call2(_f_[24],addr,t[5]),
         offset$0=caml_call1(_f_[21],_zU_),
         _zV_=offset$0 % 32 | 0,
         _zW_=offset$0 / 32 | 0;
        caml_check_bound(caml_check_bound(t[2],_zW_)[1 + _zW_],_zV_)[1 + _zV_]
        =
        data;
        return 0}
      var
       _zX_=caml_call1(_f_[1],addr),
       _zY_=caml_call2(Stdlib_Printf[4],_u_,_zX_);
      throw [0,Stdlib[6],_zY_]}
    var
     Camlboy_lib_Tile_map=
      [0,create$1,get_tile_index,read_byte$1,write_byte$1,accepts$1];
    caml_register_global(1213,Camlboy_lib_Tile_map,"Camlboy_lib__Tile_map");
    function bitflags_of_byte(x)
     {var
       _zm_=_g_[3],
       _zn_=caml_call1(_g_[20],1),
       _zo_=caml_call2(_g_[31],x,_zn_),
       _zp_=caml_call2(_g_[28],_zo_,_zm_),
       _zq_=_g_[3],
       _zr_=caml_call1(_g_[20],2),
       _zs_=caml_call2(_g_[31],x,_zr_),
       _zt_=caml_call2(_g_[28],_zs_,_zq_),
       _zu_=_g_[3],
       _zv_=caml_call1(_g_[20],4),
       _zw_=caml_call2(_g_[31],x,_zv_),
       _zx_=caml_call2(_g_[28],_zw_,_zu_),
       _zy_=_g_[3],
       _zz_=caml_call1(_g_[20],8),
       _zA_=caml_call2(_g_[31],x,_zz_),
       _zB_=caml_call2(_g_[28],_zA_,_zy_),
       _zC_=_g_[3],
       _zD_=caml_call1(_g_[20],16),
       _zE_=caml_call2(_g_[31],x,_zD_),
       _zF_=caml_call2(_g_[28],_zE_,_zC_),
       _zG_=_g_[3],
       _zH_=caml_call1(_g_[20],32),
       _zI_=caml_call2(_g_[31],x,_zH_),
       _zJ_=caml_call2(_g_[28],_zI_,_zG_),
       _zK_=_g_[3],
       _zL_=caml_call1(_g_[20],64),
       _zM_=caml_call2(_g_[31],x,_zL_),
       _zN_=caml_call2(_g_[28],_zM_,_zK_),
       _zO_=_g_[3],
       _zP_=caml_call1(_g_[20],128),
       _zQ_=caml_call2(_g_[31],x,_zP_);
      return [0,
              caml_call2(_g_[28],_zQ_,_zO_),
              _zN_,
              _zJ_,
              _zF_,
              _zB_,
              _zx_,
              _zt_,
              _zp_]}
    function byte_of_bitflags(b7,b6,b5,b4,b3,b2,b1,b0)
     {var
       _ze_=caml_call1(Stdlib_Bool[4],b7) << 7,
       _zf_=caml_call1(Stdlib_Bool[4],b6) << 6,
       _zg_=caml_call1(Stdlib_Bool[4],b5) << 5,
       _zh_=caml_call1(Stdlib_Bool[4],b4) << 4,
       _zi_=caml_call1(Stdlib_Bool[4],b3) << 3,
       _zj_=caml_call1(Stdlib_Bool[4],b2) << 2,
       _zk_=caml_call1(Stdlib_Bool[4],b1) << 1,
       _zl_=
        caml_call1(Stdlib_Bool[4],b0)
        |
        _zk_
        |
        _zj_
        |
        _zi_
        |
        _zh_
        |
        _zg_
        |
        _zf_
        |
        _ze_;
      return caml_call1(_g_[20],_zl_)}
    function bitarray_of_byte(x)
     {var
       _yL_=_g_[3],
       _yM_=caml_call1(_g_[20],1),
       _yN_=caml_call2(_g_[31],x,_yM_),
       _yO_=caml_call2(_g_[28],_yN_,_yL_),
       _yP_=_g_[3],
       _yQ_=caml_call1(_g_[20],2),
       _yR_=caml_call2(_g_[31],x,_yQ_),
       _yS_=caml_call2(_g_[28],_yR_,_yP_),
       _yT_=_g_[3],
       _yU_=caml_call1(_g_[20],4),
       _yV_=caml_call2(_g_[31],x,_yU_),
       _yW_=caml_call2(_g_[28],_yV_,_yT_),
       _yX_=_g_[3],
       _yY_=caml_call1(_g_[20],8),
       _yZ_=caml_call2(_g_[31],x,_yY_),
       _y0_=caml_call2(_g_[28],_yZ_,_yX_),
       _y1_=_g_[3],
       _y2_=caml_call1(_g_[20],16),
       _y3_=caml_call2(_g_[31],x,_y2_),
       _y4_=caml_call2(_g_[28],_y3_,_y1_),
       _y5_=_g_[3],
       _y6_=caml_call1(_g_[20],32),
       _y7_=caml_call2(_g_[31],x,_y6_),
       _y8_=caml_call2(_g_[28],_y7_,_y5_),
       _y9_=_g_[3],
       _y__=caml_call1(_g_[20],64),
       _y$_=caml_call2(_g_[31],x,_y__),
       _za_=caml_call2(_g_[28],_y$_,_y9_),
       _zb_=_g_[3],
       _zc_=caml_call1(_g_[20],128),
       _zd_=caml_call2(_g_[31],x,_zc_);
      return [0,
              caml_call2(_g_[28],_zd_,_zb_),
              _za_,
              _y8_,
              _y4_,
              _y0_,
              _yW_,
              _yS_,
              _yO_]}
    function byte_of_bitarray(a)
     {var _yG_=_v_.slice(),_yH_=0;
      function _yI_(acc,i)
       {var _yK_=caml_check_bound(a,i)[1 + i];
        return acc | caml_call1(Stdlib_Bool[4],_yK_) << (7 - i | 0)}
      var _yJ_=caml_call1(caml_call2(Stdlib_ArrayLabels[17],_yI_,_yH_),_yG_);
      return caml_call1(_g_[20],_yJ_)}
    var
     Camlboy_lib_Bit_util=
      [0,bitflags_of_byte,byte_of_bitflags,bitarray_of_byte,byte_of_bitarray];
    caml_register_global(1215,Camlboy_lib_Bit_util,"Camlboy_lib__Bit_util");
    function of_bits(hi,lo){return hi?lo?3:2:lo?1:0}
    function to_int$0(param)
     {switch(param)
       {case 0:return 0;case 1:return 1;case 2:return 2;default:return 3}}
    function set_bit(t,param)
     {if(17059 <= param)
       switch(t)
        {case 0:return 1;case 1:return 1;case 2:return 3;default:return 3}
      switch(t)
       {case 0:return 2;case 1:return 3;case 2:return 2;default:return 3}}
    function clear_bit(t,param)
     {if(17059 <= param)
       switch(t)
        {case 0:return 0;case 1:return 0;case 2:return 2;default:return 2}
      switch(t)
       {case 0:return 0;case 1:return 1;case 2:return 0;default:return 1}}
    function get_bit(t,param)
     {if(17059 <= param){if(1 !== t && ! (3 <= t))return 0;return 1}
      return 2 <= t?1:0}
    var Camlboy_lib_Color_id=[0,of_bits,to_int$0,set_bit,clear_bit,get_bit];
    caml_register_global(1216,Camlboy_lib_Color_id,"Camlboy_lib__Color_id");
    function create$2(start_addr,end_addr)
     {function _yF_(param){return caml_call3(Stdlib_Array[3],8,8,0)}
      var tiles=caml_call2(Stdlib_Array[2],384,_yF_);
      return [0,tiles,start_addr,end_addr]}
    function get_row_pixels(t,area,index,row)
     {if(area)
       var
        _yC_=caml_call1(_e_[1],index),
        signed_index=caml_call1(_e_[3],_yC_),
        index$0=signed_index + 256 | 0;
      else
       var index$0=caml_call1(_g_[21],index);
      if(8 <= row)
       {var _yD_=row - 8 | 0,_yE_=index$0 + 1 | 0;
        return caml_check_bound(caml_check_bound(t[1],_yE_)[1 + _yE_],_yD_)
                [1 + _yD_]}
      return caml_check_bound(caml_check_bound(t[1],index$0)[1 + index$0],row)
              [1 + row]}
    function get_pixel(t,area,index,row,col)
     {var row$0=get_row_pixels(t,area,index,row);
      return caml_check_bound(row$0,col)[1 + col]}
    function get_full_pixels(t,area,index)
     {var _yA_=_w_.slice();
      function _yB_(row){return get_row_pixels(t,area,index,row)}
      return caml_call1(caml_call1(Stdlib_Array[15],_yB_),_yA_)}
    function print_full_pixels(t,area,index)
     {var _yx_=get_full_pixels(t,area,index);
      function _yy_(color_ids)
       {var _yz_=caml_call1(caml_call1(Stdlib_Array[15],to_int$0),color_ids);
        caml_call1(caml_call1(Stdlib_Array[13],Stdlib[44]),_yz_);
        return caml_call1(Stdlib[47],0)}
      return caml_call1(caml_call1(Stdlib_Array[13],_yy_),_yx_)}
    function accepts$2(t,addr)
     {var _yw_=caml_call2(_f_[29],t[2],addr);
      return _yw_?caml_call2(_f_[29],addr,t[3]):_yw_}
    function read_byte$2(t,addr)
     {var
       _yt_=caml_call2(_f_[24],addr,t[2]),
       offset=caml_call1(_f_[21],_yt_),
       index=offset / 16 | 0,
       row=(offset % 16 | 0) / 2 | 0,
       hi_or_lo=0 === (offset % 2 | 0)?17059:16161,
       _yu_=
        caml_check_bound(caml_check_bound(t[1],index)[1 + index],row)[1 + row];
      function _yv_(id){return get_bit(id,hi_or_lo)}
      return byte_of_bitarray
              (caml_call1(caml_call1(Stdlib_Array[15],_yv_),_yu_))}
    function write_byte$2(t,addr,data)
     {var
       data_bits=bitarray_of_byte(data),
       _yq_=caml_call2(_f_[24],addr,t[2]),
       offset=caml_call1(_f_[21],_yq_),
       index=offset / 16 | 0,
       row=(offset % 16 | 0) / 2 | 0,
       colors_in_row=
        caml_check_bound(caml_check_bound(t[1],index)[1 + index],row)[1 + row],
       hi_or_lo=0 === (offset % 2 | 0)?17059:16161;
      function _yr_(i,b)
       {var id=caml_check_bound(colors_in_row,i)[1 + i];
        return b?set_bit(id,hi_or_lo):clear_bit(id,hi_or_lo)}
      var _ys_=caml_call1(caml_call1(Stdlib_Array[16],_yr_),data_bits);
      caml_check_bound(caml_check_bound(t[1],index)[1 + index],row)[1 + row]
      =
      _ys_;
      return 0}
    var
     Camlboy_lib_Tile_data=
      [0,
       create$2,
       get_pixel,
       get_row_pixels,
       get_full_pixels,
       print_full_pixels,
       read_byte$2,
       write_byte$2,
       accepts$2];
    caml_register_global(1217,Camlboy_lib_Tile_data,"Camlboy_lib__Tile_data");
    function create$3(start_addr,end_addr)
     {function _yl_(param){return caml_call1(Stdlib_Char[1],0)}
      var
       _ym_=_f_[4],
       _yn_=caml_call2(_f_[24],end_addr,start_addr),
       _yo_=caml_call2(_f_[23],_yn_,_ym_),
       _yp_=caml_call1(_f_[21],_yo_),
       string=caml_call2(Stdlib_String[2],_yp_,_yl_),
       bytes=
        caml_call3
         (Bigstringaf[3],0,runtime.caml_ml_string_length(string),string);
      return [0,bytes,start_addr,end_addr]}
    function accepts$3(t,addr)
     {var _yk_=caml_call2(_f_[29],t[2],addr);
      return _yk_?caml_call2(_f_[29],addr,t[3]):_yk_}
    function read_byte$3(t,addr)
     {var
       _yi_=caml_call2(_f_[24],addr,t[2]),
       offset=caml_call1(_f_[21],_yi_),
       _yj_=caml_ba_get_1(t[1],offset);
      return caml_call1(_g_[36],_yj_)}
    function write_byte$3(t,addr,data)
     {var
       _yg_=caml_call2(_f_[24],addr,t[2]),
       offset=caml_call1(_f_[21],_yg_),
       _yh_=caml_call1(_g_[37],data);
      return caml_ba_set_1(t[1],offset,_yh_)}
    var Camlboy_lib_Ram=[0,create$3,read_byte$3,write_byte$3,accepts$3];
    caml_register_global(1221,Camlboy_lib_Ram,"Camlboy_lib__Ram");
    function create$4(target,target_start,shadow_start,shadow_end)
     {return [0,target,target_start,shadow_start,shadow_end]}
    function accepts$4(t,addr)
     {var _yf_=caml_call2(_f_[29],t[3],addr);
      return _yf_?caml_call2(_f_[29],addr,t[4]):_yf_}
    function read_byte$4(t,addr)
     {if(accepts$4(t,addr))
       {var
         offset=caml_call2(_f_[24],addr,t[3]),
         _yc_=caml_call2(_f_[23],t[2],offset);
        return read_byte$3(t[1],_yc_)}
      var
       _yd_=caml_call1(_f_[1],addr),
       _ye_=caml_call2(Stdlib_Printf[4],_x_,_yd_);
      throw [0,Stdlib[6],_ye_]}
    function write_byte$4(t,addr,data)
     {if(accepts$4(t,addr))
       {var
         offset=caml_call2(_f_[24],addr,t[3]),
         _x$_=caml_call2(_f_[23],t[2],offset);
        return write_byte$3(t[1],_x$_,data)}
      var
       _ya_=caml_call1(_f_[1],addr),
       _yb_=caml_call2(Stdlib_Printf[4],_y_,_ya_);
      throw [0,Stdlib[6],_yb_]}
    var
     Camlboy_lib_Shadow_ram=
      [0,create$4,read_byte$4,write_byte$4,accepts$4];
    caml_register_global
     (1222,Camlboy_lib_Shadow_ram,"Camlboy_lib__Shadow_ram");
    function create$5(addr,type,opt,param)
     {if(opt)var sth=opt[1],default$0=sth;else var default$0=_g_[3];
      return 87 === type
              ?[0,addr,default$0,0,1]
              :18373 <= type?[0,addr,default$0,1,1]:[0,addr,default$0,1,0]}
    function accepts$5(t,addr){return caml_call2(_f_[27],addr,t[1])}
    function read_byte$5(t,addr)
     {return t[3]
              ?accepts$5(t,addr)?t[2]:caml_call1(Stdlib[2],cst_invalid_addr)
              :caml_call1(Stdlib[2],cst_cannot_read)}
    function write_byte$5(t,addr,data)
     {return t[3]
              ?accepts$5(t,addr)
                ?(t[2] = data,0)
                :caml_call1(Stdlib[2],cst_invalid_addr$0)
              :caml_call1(Stdlib[2],cst_cannot_write)}
    function peek(t){return t[2]}
    var
     Camlboy_lib_Mmap_register=
      [0,create$5,peek,read_byte$5,write_byte$5,accepts$5];
    caml_register_global
     (1223,Camlboy_lib_Mmap_register,"Camlboy_lib__Mmap_register");
    function create$6(sb,sc,opt,param)
     {if(opt)
       var sth=opt[1],print_serial_port=sth;
      else
       var print_serial_port=0;
      return [0,sb,sc,print_serial_port]}
    function read_byte$6(t,addr)
     {return accepts$5(t[1],addr)
              ?read_byte$5(t[1],addr)
              :accepts$5(t[2],addr)
                ?read_byte$5(t[2],addr)
                :caml_call1(Stdlib[2],cst_invalid_addr$1)}
    function write_byte$6(t,addr,data)
     {if(accepts$5(t[1],addr))return write_byte$5(t[1],addr,data);
      if(accepts$5(t[2],addr))
       {write_byte$5(t[2],addr,data);
        var _x7_=t[3];
        if(_x7_)
         var _x8_=caml_call1(_g_[20],129),_x9_=caml_call2(_g_[27],data,_x8_);
        else
         var _x9_=_x7_;
        if(_x9_)
         {var _x__=caml_call1(_g_[21],t[1][2]);
          caml_call2(Stdlib_Printf[2],_z_,_x__);
          return caml_call1(Stdlib[64],0)}
        return _x9_}
      return caml_call1(Stdlib[2],cst_invalid_addr$2)}
    function accepts$6(t,addr)
     {var _x6_=accepts$5(t[1],addr);return _x6_?_x6_:accepts$5(t[2],addr)}
    var
     Camlboy_lib_Serial_port=
      [0,create$6,read_byte$6,write_byte$6,accepts$6];
    caml_register_global
     (1224,Camlboy_lib_Serial_port,"Camlboy_lib__Serial_port");
    function create$7(param)
     {return [0,_g_[3],_g_[3],_g_[3],_g_[3],_g_[3],_g_[3],_g_[3],_g_[3]]}
    function read_r(t,param)
     {switch(param)
       {case 0:return t[1];
        case 1:return t[2];
        case 2:return t[3];
        case 3:return t[4];
        case 4:return t[5];
        case 5:return t[6];
        case 6:return t[7];
        default:return t[8]}}
    function read_rr(t,rr)
     {switch(rr)
       {case 0:
         var
          _xU_=caml_call1(_f_[36],t[6]),
          _xV_=caml_call1(_f_[36],t[1]),
          _xW_=caml_call2(_f_[34],_xV_,8);
         return caml_call2(_f_[32],_xW_,_xU_);
        case 1:
         var
          _xX_=caml_call1(_f_[36],t[3]),
          _xY_=caml_call1(_f_[36],t[2]),
          _xZ_=caml_call2(_f_[34],_xY_,8);
         return caml_call2(_f_[32],_xZ_,_xX_);
        case 2:
         var
          _x0_=caml_call1(_f_[36],t[5]),
          _x1_=caml_call1(_f_[36],t[4]),
          _x2_=caml_call2(_f_[34],_x1_,8);
         return caml_call2(_f_[32],_x2_,_x0_);
        default:
         var
          _x3_=caml_call1(_f_[36],t[8]),
          _x4_=caml_call1(_f_[36],t[7]),
          _x5_=caml_call2(_f_[34],_x4_,8);
         return caml_call2(_f_[32],_x5_,_x3_)}}
    function write_r(t,r,x)
     {switch(r)
       {case 0:t[1] = x;return 0;
        case 1:t[2] = x;return 0;
        case 2:t[3] = x;return 0;
        case 3:t[4] = x;return 0;
        case 4:t[5] = x;return 0;
        case 5:
         var _xT_=caml_call1(_g_[20],240);
         t[6] = caml_call2(_g_[31],x,_xT_);
         return 0;
        case 6:t[7] = x;return 0;
        default:t[8] = x;return 0}}
    function write_rr(t,rr,x)
     {var
       x$0=caml_call1(_f_[21],x),
       high=caml_call1(_g_[20],(x$0 & 65280) >>> 8 | 0),
       low=caml_call1(_g_[20],x$0 & 255);
      switch(rr)
       {case 0:
         t[1] = high;
         var _xS_=caml_call1(_g_[20],240);
         t[6] = caml_call2(_g_[31],low,_xS_);
         return 0;
        case 1:t[2] = high;t[3] = low;return 0;
        case 2:t[4] = high;t[5] = low;return 0;
        default:t[7] = high;t[8] = low;return 0}}
    function read_flag(t,flag)
     {var f=caml_call1(_g_[21],t[6]);
      switch(flag)
       {case 0:return 0 !== (f & 16)?1:0;
        case 1:return 0 !== (f & 32)?1:0;
        case 2:return 0 !== (f & 64)?1:0;
        default:return 0 !== (f & 128)?1:0}}
    var
     mask_0b00010000=caml_call1(_g_[20],16),
     mask_0b11100000=caml_call1(_g_[20],224),
     mask_0b00100000=caml_call1(_g_[20],32),
     mask_0b11010000=caml_call1(_g_[20],208),
     mask_0b01000000=caml_call1(_g_[20],64),
     mask_0b10110000=caml_call1(_g_[20],176),
     mask_0b10000000=caml_call1(_g_[20],128),
     mask_0b01110000=caml_call1(_g_[20],112),
     mask_0b11101111=caml_call1(_g_[20],239),
     mask_0b11011111=caml_call1(_g_[20],223),
     mask_0b10111111=caml_call1(_g_[20],191),
     mask_0b01111111=caml_call1(_g_[20],127);
    function set_flag(t,flag)
     {switch(flag)
       {case 0:t[6] = caml_call2(_g_[32],t[6],mask_0b00010000);return 0;
        case 1:t[6] = caml_call2(_g_[32],t[6],mask_0b00100000);return 0;
        case 2:t[6] = caml_call2(_g_[32],t[6],mask_0b01000000);return 0;
        default:t[6] = caml_call2(_g_[32],t[6],mask_0b10000000);return 0}}
    function set_flags(t,opt,_xR_,_xQ_,_xP_,param)
     {if(opt)var sth=opt[1],c=sth;else var c=read_flag(t,0);
      if(_xR_)var sth$0=_xR_[1],h=sth$0;else var h=read_flag(t,1);
      if(_xQ_)var sth$1=_xQ_[1],n=sth$1;else var n=read_flag(t,2);
      if(_xP_)var sth$2=_xP_[1],z=sth$2;else var z=read_flag(t,3);
      t[6]
      =
      c
       ?caml_call2(_g_[32],t[6],mask_0b00010000)
       :caml_call2(_g_[31],t[6],mask_0b11100000);
      t[6]
      =
      h
       ?caml_call2(_g_[32],t[6],mask_0b00100000)
       :caml_call2(_g_[31],t[6],mask_0b11010000);
      t[6]
      =
      n
       ?caml_call2(_g_[32],t[6],mask_0b01000000)
       :caml_call2(_g_[31],t[6],mask_0b10110000);
      return z
              ?(t[6] = caml_call2(_g_[32],t[6],mask_0b10000000),0)
              :(t[6] = caml_call2(_g_[31],t[6],mask_0b01110000),0)}
    function unset_flag(t,flag)
     {switch(flag)
       {case 0:t[6] = caml_call2(_g_[31],t[6],mask_0b11101111);return 0;
        case 1:t[6] = caml_call2(_g_[31],t[6],mask_0b11011111);return 0;
        case 2:t[6] = caml_call2(_g_[31],t[6],mask_0b10111111);return 0;
        default:t[6] = caml_call2(_g_[31],t[6],mask_0b01111111);return 0}}
    function clear_flags(t){t[6] = _g_[3];return 0}
    function show_r(param)
     {switch(param)
       {case 0:return cst_A;
        case 1:return cst_B;
        case 2:return cst_C;
        case 3:return cst_D;
        case 4:return cst_E;
        case 5:return cst_F;
        case 6:return cst_H;
        default:return cst_L}}
    function show_rr(param)
     {switch(param)
       {case 0:return cst_AF;
        case 1:return cst_BC;
        case 2:return cst_DE;
        default:return cst_HL}}
    function show$3(t)
     {var
       _xH_=read_rr(t,3),
       _xI_=caml_call1(_f_[1],_xH_),
       _xJ_=read_rr(t,2),
       _xK_=caml_call1(_f_[1],_xJ_),
       _xL_=read_rr(t,1),
       _xM_=caml_call1(_f_[1],_xL_),
       f=caml_call1(_g_[21],t[6]),
       z=0 === (f & 128)?45:90,
       n=0 === (f & 64)?45:78,
       h=0 === (f & 32)?45:72,
       c=0 === (f & 16)?45:67,
       _xG_=caml_call5(Stdlib_Printf[4],_A_,z,n,h,c),
       _xN_=read_r(t,0),
       _xO_=caml_call1(_g_[1],_xN_);
      return caml_call6(Stdlib_Printf[4],_B_,_xO_,_xG_,_xM_,_xK_,_xI_)}
    var
     Camlboy_lib_Registers=
      [0,
       show$3,
       show_r,
       show_rr,
       create$7,
       read_r,
       write_r,
       read_rr,
       write_rr,
       read_flag,
       set_flag,
       set_flags,
       unset_flag,
       clear_flags];
    caml_register_global(1225,Camlboy_lib_Registers,"Camlboy_lib__Registers");
    function f(rom_file_name)
     {var
       rom_in=caml_call1(Stdlib[79],rom_file_name),
       rom_len=caml_call1(Stdlib[92],rom_in),
       rom_string=caml_call2(Stdlib[86],rom_in,rom_len);
      return caml_call3(Bigstringaf[3],0,rom_len,rom_string)}
    var Camlboy_lib_Read_rom_file=[0,f];
    caml_register_global
     (1226,Camlboy_lib_Read_rom_file,"Camlboy_lib__Read_rom_file");
    function create$8(addr)
     {return [0,addr,-588596599,-603547828,-126317716,-937474657]}
    function lookup(t,color_id)
     {switch(color_id)
       {case 0:return t[2];
        case 1:return t[3];
        case 2:return t[4];
        default:return t[5]}}
    function accepts$7(t,addr){return caml_call2(_f_[27],addr,t[1])}
    function read_byte$7(t,addr)
     {function bits_of_color(param)
       {return -588596599 <= param
                ?-126317716 <= param?2:0
                :-603547828 <= param?1:3}
      if(accepts$7(t,addr))
       {var
         _xC_=bits_of_color(t[5]) << 6,
         _xD_=bits_of_color(t[4]) << 4,
         _xE_=bits_of_color(t[3]) << 2,
         _xF_=bits_of_color(t[2]) | _xE_ | _xD_ | _xC_;
        return caml_call1(_g_[20],_xF_)}
      throw [0,Stdlib[6],cst_Address_out_of_bounds]}
    function write_byte$7(t,addr,data)
     {function color_of_bits(param)
       {if(3 < param >>> 0)throw [0,Assert_failure,_C_];
        switch(param)
         {case 0:return -588596599;
          case 1:return -603547828;
          case 2:return -126317716;
          default:return -937474657}}
      var data$0=caml_call1(_g_[21],data);
      if(accepts$7(t,addr))
       {t[2] = color_of_bits(data$0 & 3);
        t[3] = color_of_bits((data$0 & 12) >>> 2 | 0);
        t[4] = color_of_bits((data$0 & 48) >>> 4 | 0);
        t[5] = color_of_bits((data$0 & 192) >>> 6 | 0);
        return 0}
      throw [0,Stdlib[6],cst_Address_out_of_bounds$0]}
    var
     Camlboy_lib_Pallete=
      [0,create$8,lookup,read_byte$7,write_byte$7,accepts$7];
    caml_register_global(1227,Camlboy_lib_Pallete,"Camlboy_lib__Pallete");
    function show_sprite(s)
     {var
       _xv_=s[9],
       _xw_=-1058811691 <= s[8]?cst_Bank1:cst_Bank0,
       _xx_=879375796 <= s[7]?cst_OBP1:cst_OBP0,
       _xy_=s[6],
       _xz_=s[5],
       _xA_=486156037 <= s[4]?cst_Sprite_bottom:cst_Sprite_top,
       _xB_=caml_call1(_g_[1],s[3]);
      return caml_call10
              (Stdlib_Printf[4],
               _D_,
               s[1],
               s[2],
               _xB_,
               _xA_,
               _xz_,
               _xy_,
               _xx_,
               _xw_,
               _xv_)}
    function create$9(start_addr,end_addr)
     {var
       default_sprite=[0,0,0,_g_[3],-259427781,0,0,879375795,-1058811692,0],
       sprites=runtime.caml_make_vect(40,default_sprite);
      return [0,sprites,start_addr,end_addr]}
    function read_byte$8(t,addr)
     {var
       _xt_=caml_call1(_f_[21],t[2]),
       offset=caml_call1(_f_[21],addr) - _xt_ | 0,
       _xu_=offset / 4 | 0,
       sprite=caml_check_bound(t[1],_xu_)[1 + _xu_],
       match=offset % 4 | 0;
      if(3 < match >>> 0)throw [0,Assert_failure,_E_];
      switch(match)
       {case 0:return caml_call1(_g_[20],sprite[1] + 16 | 0);
        case 1:return caml_call1(_g_[20],sprite[2] + 8 | 0);
        case 2:return sprite[3];
        default:
         return byte_of_bitflags
                 (486156037 === sprite[4]?1:0,
                  sprite[5],
                  sprite[6],
                  879375796 === sprite[7]?1:0,
                  -1058811691 === sprite[8]?1:0,
                  0 !== (sprite[9] & 4)?1:0,
                  0 !== (sprite[9] & 2)?1:0,
                  0 !== (sprite[9] & 1)?1:0)}}
    function write_byte$8(t,addr,data)
     {var
       _xi_=caml_call1(_f_[21],t[2]),
       offset=caml_call1(_f_[21],addr) - _xi_ | 0,
       data$0=caml_call1(_g_[21],data),
       sprite_index=offset / 4 | 0,
       match=offset % 4 | 0;
      if(3 < match >>> 0)throw [0,Assert_failure,_F_];
      switch(match)
       {case 0:
         var
          _xj_=caml_check_bound(t[1],sprite_index)[1 + sprite_index],
          _xk_=
           [0,
            data$0 - 16 | 0,
            _xj_[2],
            _xj_[3],
            _xj_[4],
            _xj_[5],
            _xj_[6],
            _xj_[7],
            _xj_[8],
            _xj_[9]];
         caml_check_bound(t[1],sprite_index)[1 + sprite_index] = _xk_;
         return 0;
        case 1:
         var
          _xl_=caml_check_bound(t[1],sprite_index)[1 + sprite_index],
          _xm_=
           [0,
            _xl_[1],
            data$0 - 8 | 0,
            _xl_[3],
            _xl_[4],
            _xl_[5],
            _xl_[6],
            _xl_[7],
            _xl_[8],
            _xl_[9]];
         caml_check_bound(t[1],sprite_index)[1 + sprite_index] = _xm_;
         return 0;
        case 2:
         var
          _xn_=caml_check_bound(t[1],sprite_index)[1 + sprite_index],
          _xo_=
           [0,
            _xn_[1],
            _xn_[2],
            data,
            _xn_[4],
            _xn_[5],
            _xn_[6],
            _xn_[7],
            _xn_[8],
            _xn_[9]];
         caml_check_bound(t[1],sprite_index)[1 + sprite_index] = _xo_;
         return 0;
        default:
         var
          match$0=bitflags_of_byte(data),
          b0=match$0[8],
          b1=match$0[7],
          b2=match$0[6],
          b3=match$0[5],
          b4=match$0[4],
          x_flip=match$0[3],
          y_flip=match$0[2],
          b7=match$0[1],
          priority=b7?486156037:-259427781,
          pallete=b4?879375796:879375795,
          tile_vram_bank=b3?-1058811691:-1058811692,
          _xp_=caml_call1(Stdlib_Bool[4],b0),
          _xq_=caml_call1(Stdlib_Bool[4],b1) << 1,
          pallete_num=caml_call1(Stdlib_Bool[4],b2) << 2 | _xq_ | _xp_,
          _xr_=caml_check_bound(t[1],sprite_index)[1 + sprite_index],
          _xs_=
           [0,
            _xr_[1],
            _xr_[2],
            _xr_[3],
            priority,
            y_flip,
            x_flip,
            pallete,
            tile_vram_bank,
            pallete_num];
         caml_check_bound(t[1],sprite_index)[1 + sprite_index] = _xs_;
         return 0}}
    function accepts$8(t,addr)
     {var _xh_=caml_call2(_f_[29],t[2],addr);
      return _xh_?caml_call2(_f_[29],addr,t[3]):_xh_}
    function get_all_sprites(t){return t[1]}
    function write_with_offset(t,offset,data)
     {var _xg_=caml_call1(_f_[20],offset);
      return write_byte$8(t,caml_call2(_f_[23],t[2],_xg_),data)}
    var
     Camlboy_lib_Oam_table=
      [0,
       show_sprite,
       create$9,
       get_all_sprites,
       write_with_offset,
       read_byte$8,
       write_byte$8,
       accepts$8];
    caml_register_global(1228,Camlboy_lib_Oam_table,"Camlboy_lib__Oam_table");
    function to_int$1(param)
     {switch(param)
       {case 0:return 2;case 1:return 3;case 2:return 0;default:return 1}}
    var Camlboy_lib_Gpu_mode=[0,to_int$1];
    caml_register_global(1229,Camlboy_lib_Gpu_mode,"Camlboy_lib__Gpu_mode");
    function create$10(addr){return [0,addr,1,0,0,0,0,1056320505,0,1]}
    function get_lcd_enable(t){return t[2]}
    function get_window_tile_map_area(t){return t[3]}
    function get_window_enable(t){return t[4]}
    function get_tile_data_area(t){return t[5]}
    function get_bg_tile_map_area(t){return t[6]}
    function get_obj_size(t){return t[7]}
    function get_obj_enable(t){return t[8]}
    function get_bg_window_display(t){return t[9]}
    function accepts$9(t,addr){return caml_call2(_f_[27],addr,t[1])}
    function read_byte$9(t,addr)
     {if(accepts$9(t,addr))
       return byte_of_bitflags
               (t[2],
                1 === t[3]?1:0,
                t[4],
                0 === t[5]?1:0,
                1 === t[6]?1:0,
                -663730172 === t[7]?1:0,
                t[8],
                t[9]);
      throw [0,Stdlib[6],cst_Address_out_of_bounds$1]}
    function write_byte$9(t,addr,data)
     {if(accepts$9(t,addr))
       {var
         match=bitflags_of_byte(data),
         b0=match[8],
         b1=match[7],
         b2=match[6],
         b3=match[5],
         b4=match[4],
         b5=match[3],
         b6=match[2],
         b7=match[1];
        t[2] = b7;
        var _xc_=b6?1:0;
        t[3] = _xc_;
        t[4] = b5;
        var _xd_=b4?0:1;
        t[5] = _xd_;
        var _xe_=b3?1:0;
        t[6] = _xe_;
        var _xf_=b2?-663730172:1056320505;
        t[7] = _xf_;
        t[8] = b1;
        t[9] = b0;
        return 0}
      throw [0,Stdlib[6],cst_Address_out_of_bounds$2]}
    var
     Camlboy_lib_Lcd_control=
      [0,
       create$10,
       get_lcd_enable,
       get_window_tile_map_area,
       get_window_enable,
       get_tile_data_area,
       get_bg_tile_map_area,
       get_obj_size,
       get_obj_enable,
       get_bg_window_display,
       read_byte$9,
       write_byte$9,
       accepts$9];
    caml_register_global
     (1230,Camlboy_lib_Lcd_control,"Camlboy_lib__Lcd_control");
    function create$11(scy_addr,scx_addr,ly_addr,lyc_addr,wy_addr,wx_addr)
     {return [0,
              [0,scy_addr,0],
              [0,scx_addr,0],
              [0,ly_addr,0],
              [0,lyc_addr,0],
              [0,wy_addr,0],
              [0,wx_addr,0]]}
    function get_scy(t){return t[1][2]}
    function get_scx(t){return t[2][2]}
    function get_ly(t){return t[3][2]}
    function incr_ly(t){t[3][2] = t[3][2] + 1 | 0;return 0}
    function reset_ly(t){t[3][2] = 0;return 0}
    function get_lyc(t){return t[4][2]}
    function get_wy(t){return t[5][2]}
    function get_wx(t){return t[6][2]}
    function accepts$10(t,addr)
     {var
       _xa_=
        [0,
         t[1][1],
         [0,t[2][1],[0,t[3][1],[0,t[4][1],[0,t[5][1],[0,t[6][1],0]]]]]];
      function _xb_(x){return caml_call2(_f_[27],addr,x)}
      return caml_call1(caml_call1(Stdlib_List[33],_xb_),_xa_)}
    function register_of_addr(t,addr)
     {if(caml_call2(_f_[27],addr,t[1][1]))return t[1];
      if(caml_call2(_f_[27],addr,t[2][1]))return t[2];
      if(caml_call2(_f_[27],addr,t[3][1]))return t[3];
      if(caml_call2(_f_[27],addr,t[4][1]))return t[4];
      if(caml_call2(_f_[27],addr,t[6][1]))return t[6];
      if(caml_call2(_f_[27],addr,t[5][1]))return t[5];
      var
       _w__=caml_call1(_f_[1],addr),
       _w$_=caml_call2(Stdlib_Printf[4],_G_,_w__);
      throw [0,Stdlib[6],_w$_]}
    function read_byte$10(t,addr)
     {var r=register_of_addr(t,addr);return caml_call1(_g_[20],r[2])}
    function write_byte$10(t,addr,data)
     {if(caml_call2(_f_[27],addr,t[3][1])){t[3][2] = 0;return 0}
      var r=register_of_addr(t,addr);
      r[2] = caml_call1(_g_[21],data);
      return 0}
    var
     Camlboy_lib_Lcd_position=
      [0,
       create$11,
       get_scy,
       get_scx,
       get_ly,
       incr_ly,
       reset_ly,
       get_lyc,
       get_wy,
       get_wx,
       read_byte$10,
       write_byte$10,
       accepts$10];
    caml_register_global
     (1231,Camlboy_lib_Lcd_position,"Camlboy_lib__Lcd_position");
    function create$12(addr){return [0,addr,0,0,0,0,0,0]}
    function is_enabled(t,param)
     {switch(param)
       {case 0:return t[2];
        case 1:return t[3];
        case 2:return t[4];
        default:return t[5]}}
    function get_lyc_eq_ly_flag(t){return t[6]}
    function set_lyc_eq_ly_flag(t,b){t[6] = b;return 0}
    function get_gpu_mode(t){return t[7]}
    function set_gpu_mode(t,mode){t[7] = mode;return 0}
    function accepts$11(t,addr){return caml_call2(_f_[27],addr,t[1])}
    function read_byte$11(t,addr)
     {if(accepts$11(t,addr))
       {switch(t[7])
         {case 0:var b0=0,b1=1;break;
          case 1:var b0=1,b1=1;break;
          case 2:var b0=0,b1=0;break;
          default:var b0=1,b1=0}
        var
         _w6_=t[6],
         _w7_=is_enabled(t,3),
         _w8_=is_enabled(t,2),
         _w9_=is_enabled(t,1);
        return byte_of_bitflags(1,is_enabled(t,0),_w9_,_w8_,_w7_,_w6_,b1,b0)}
      throw [0,Stdlib[6],cst_Address_out_of_bounds$3]}
    function write_byte$11(t,addr,data)
     {if(accepts$11(t,addr))
       {var
         match=bitflags_of_byte(data),
         b3=match[5],
         b4=match[4],
         b5=match[3],
         b6=match[2];
        t[2] = b6;
        t[3] = b5;
        t[4] = b4;
        t[5] = b3;
        return 0}
      throw [0,Stdlib[6],cst_Address_out_of_bounds$4]}
    function peek$0(t){return read_byte$11(t,t[1])}
    var
     Camlboy_lib_Lcd_stat=
      [0,
       create$12,
       is_enabled,
       get_lyc_eq_ly_flag,
       set_lyc_eq_ly_flag,
       get_gpu_mode,
       set_gpu_mode,
       peek$0,
       read_byte$11,
       write_byte$11,
       accepts$11];
    caml_register_global(1232,Camlboy_lib_Lcd_stat,"Camlboy_lib__Lcd_stat");
    function handle_ly_eq_lyc(t)
     {var ly=get_ly(t[9]),lyc=get_lyc(t[9]),ly_eq_lyc=ly === lyc?1:0;
      set_lyc_eq_ly_flag(t[7],ly_eq_lyc);
      var _w5_=ly_eq_lyc?is_enabled(t[7],0):ly_eq_lyc;
      return _w5_?request(t[10],1):_w5_}
    var screen_w=160,screen_h=144;
    function create$13
     (tile_data,
      tile_map,
      oam,
      bgp,
      obp0,
      obp1,
      lcd_stat,
      lcd_control,
      lcd_position,
      ic)
     {var
       t=
        [0,
         tile_data,
         tile_map,
         oam,
         bgp,
         obp0,
         obp1,
         lcd_stat,
         lcd_control,
         lcd_position,
         ic,
         0,
         0,
         caml_call3(Stdlib_ArrayLabels[3],screen_h,screen_w,-588596599)];
      handle_ly_eq_lyc(t);
      return t}
    function set_mcycles_in_mode(t,mcycles_in_mode)
     {t[11] = mcycles_in_mode;return 0}
    function get_frame_buffer(t){return t[13]}
    function run$0(t,mcycles)
     {function incr_ly$0(t){incr_ly(t[9]);return get_ly(t[9])}
      switch(t[12])
       {case 0:
         t[11] = t[11] + mcycles | 0;
         var match$0=t[7][7];
         switch(match$0)
          {case 0:
            if(20 <= t[11]){t[11] = t[11] % 20 | 0;set_gpu_mode(t[7],1)}
            return 0;
           case 1:
            if(43 <= t[11])
             {t[11] = t[11] % 43 | 0;
              set_gpu_mode(t[7],2);
              if(is_enabled(t[7],3))request(t[10],1);
              var ly=get_ly(t[9]);
              if(t[8][9])
               {var
                 tile_data_area=t[8][5],
                 scy=get_scy(t[9]),
                 scx=get_scx(t[9]),
                 y=(scy + ly | 0) % 256 | 0,
                 bg_tile_map_area=t[8][6],
                 row_in_tile=y % 8 | 0,
                 lx=[0,0];
                for(;;)
                 {if(lx[1] < 160)
                   {var
                     x=(scx + lx[1] | 0) % 256 | 0,
                     col_in_tile=x % 8 | 0,
                     tile_index=get_tile_index(t[2],bg_tile_map_area,y,x),
                     tile_pixel_row=
                      get_row_pixels(t[1],tile_data_area,tile_index,row_in_tile),
                     len=
                      0 < col_in_tile
                       ?8 - col_in_tile | 0
                       :8 <= (160 - lx[1] | 0)?8:160 - lx[1] | 0,
                     _wJ_=len - 1 | 0,
                     _wI_=0;
                    if(! (_wJ_ < 0))
                     {var i=_wI_;
                      for(;;)
                       {var
                         _wK_=col_in_tile + i | 0,
                         _wL_=caml_check_bound(tile_pixel_row,_wK_)[1 + _wK_],
                         color=lookup(t[4],_wL_),
                         _wM_=lx[1] + i | 0;
                        caml_check_bound(caml_check_bound(t[13],ly)[1 + ly],_wM_)
                         [1 + _wM_]
                        =
                        color;
                        var _wN_=i + 1 | 0;
                        if(_wJ_ !== i){var i=_wN_;continue}
                        break}}
                    lx[1] = lx[1] + len | 0;
                    continue}
                  if(t[8][4])
                   {var
                     wy=get_wy(t[9]),
                     wx=get_wx(t[9]) - 7 | 0,
                     _wO_=wy <= ly?1:0;
                    if(_wO_)
                     var
                      _wP_=ly <= (wy + 256 | 0)?1:0,
                      _wQ_=_wP_?wx <= 160?1:0:_wP_;
                    else
                     var _wQ_=_wO_;
                    if(_wQ_)
                     {var
                       window_tile_map_area=t[8][3],
                       y_in_w=caml_call1(Stdlib_Int[4],ly - wy | 0),
                       row_in_tile$0=y_in_w % 8 | 0,
                       wx$0=0 <= wx?wx:0,
                       lx$0=[0,wx$0];
                      for(;;)
                       {if(lx$0[1] < 160)
                         {var
                           x_in_w=caml_call1(Stdlib_Int[4],lx$0[1] - wx | 0),
                           tile_index$0=
                            get_tile_index(t[2],window_tile_map_area,y_in_w,x_in_w),
                           tile_pixel_row$0=
                            get_row_pixels
                             (t[1],tile_data_area,tile_index$0,row_in_tile$0),
                           len$0=8 <= (160 - lx$0[1] | 0)?8:160 - lx$0[1] | 0,
                           _wS_=len$0 - 1 | 0,
                           _wR_=0;
                          if(! (_wS_ < 0))
                           {var i$0=_wR_;
                            for(;;)
                             {var
                               _wT_=caml_check_bound(tile_pixel_row$0,i$0)[1 + i$0],
                               color$0=lookup(t[4],_wT_),
                               _wU_=lx$0[1] + i$0 | 0;
                              caml_check_bound(caml_check_bound(t[13],ly)[1 + ly],_wU_)
                               [1 + _wU_]
                              =
                              color$0;
                              var _wV_=i$0 + 1 | 0;
                              if(_wS_ !== i$0){var i$0=_wV_;continue}
                              break}}
                          lx$0[1] = lx$0[1] + len$0 | 0;
                          continue}
                        break}}}
                  break}}
              if(t[8][8])
               {var
                 match=t[8][7],
                 y_sprite_size=1056320505 <= match?8:16,
                 _wW_=t[3][1],
                 _wX_=
                  function(sprite)
                   {var
                     _wY_=sprite[1] <= ly?1:0,
                     _wZ_=
                      _wY_
                       ?ly <= ((sprite[1] + y_sprite_size | 0) - 1 | 0)?1:0
                       :_wY_;
                    if(_wZ_)
                     {var
                       row=ly - sprite[1] | 0,
                       pallete=879375796 <= sprite[7]?t[6]:t[5],
                       col=0;
                      for(;;)
                       {var lx=sprite[2] + col | 0,switch$0=0;
                        if(0 <= lx && ! (160 <= lx))
                         {var
                           _w2_=sprite[6]?7 - col | 0:col,
                           _w3_=sprite[5]?(y_sprite_size - row | 0) - 1 | 0:row,
                           color_id=get_pixel(t[1],0,sprite[3],_w3_,_w2_);
                          if(color_id)
                           {var
                             _w4_=sprite[4],
                             match=
                              caml_check_bound(caml_check_bound(t[13],ly)[1 + ly],lx)
                               [1 + lx],
                             switch$1=0;
                            if(486156037 <= _w4_)
                             {var switch$2=0;
                              if
                               (-937474657
                                !==
                                match
                                &&
                                -603547828
                                !==
                                match
                                &&
                                -126317716
                                !==
                                match)
                               switch$2 = 1;
                              if(! switch$2)switch$1 = 1}
                            if(! switch$1)
                             {var color=lookup(pallete,color_id);
                              caml_check_bound(caml_check_bound(t[13],ly)[1 + ly],lx)
                               [1 + lx]
                              =
                              color}}
                          switch$0 = 1}
                        var _w1_=col + 1 | 0;
                        if(7 !== col){var col=_w1_;continue}
                        var _w0_=0;
                        break}}
                    else
                     var _w0_=_wZ_;
                    return _w0_};
                caml_call1(caml_call1(Stdlib_ArrayLabels[13],_wX_),_wW_)}}
            return 0;
           case 2:
            if(51 <= t[11])
             {t[11] = t[11] % 51 | 0;
              var ly$0=incr_ly$0(t);
              handle_ly_eq_lyc(t);
              if(ly$0 === 144)
               {set_gpu_mode(t[7],3);
                if(is_enabled(t[7],2))request(t[10],1);
                request(t[10],0)}
              else
               {set_gpu_mode(t[7],0);if(is_enabled(t[7],1))request(t[10],1)}}
            return 0;
           default:
            if(t[11] < 114)return 0;
            t[11] = t[11] % 114 | 0;
            var ly$1=incr_ly$0(t);
            handle_ly_eq_lyc(t);
            if(154 <= ly$1)
             {reset_ly(t[9]);
              handle_ly_eq_lyc(t);
              set_gpu_mode(t[7],0);
              if(is_enabled(t[7],1))request(t[10],1);
              return [0,t[13]]}
            return 0}
        case 1:return 0;
        default:
         t[11] = t[11] + mcycles | 0;
         if(51 <= t[11])
          {t[11] = t[11] % 51 | 0;
           t[12] = 0;
           handle_ly_eq_lyc(t);
           set_gpu_mode(t[7],0);
           if(is_enabled(t[7],1))request(t[10],1)}
         return 0}}
    function accepts$12(t,addr)
     {var _wz_=accepts$1(t[2],addr);
      if(_wz_)
       var _wA_=_wz_;
      else
       {var _wB_=accepts$2(t[1],addr);
        if(_wB_)
         var _wA_=_wB_;
        else
         {var _wC_=accepts$8(t[3],addr);
          if(_wC_)
           var _wA_=_wC_;
          else
           {var _wD_=accepts$7(t[4],addr);
            if(_wD_)
             var _wA_=_wD_;
            else
             {var _wE_=accepts$7(t[5],addr);
              if(_wE_)
               var _wA_=_wE_;
              else
               {var _wF_=accepts$7(t[6],addr);
                if(_wF_)
                 var _wA_=_wF_;
                else
                 {var _wG_=accepts$11(t[7],addr);
                  if(_wG_)
                   var _wA_=_wG_;
                  else
                   {var _wH_=accepts$9(t[8],addr);
                    if(! _wH_)return accepts$10(t[9],addr);
                    var _wA_=_wH_}}}}}}}
      return _wA_}
    function read_byte$12(t,addr)
     {if(accepts$2(t[1],addr))
       {var match=t[7][7];
        return 1 === match?caml_call1(_g_[20],255):read_byte$2(t[1],addr)}
      if(accepts$1(t[2],addr))
       {var match$0=t[7][7];
        return 1 === match$0?caml_call1(_g_[20],255):read_byte$1(t[2],addr)}
      if(accepts$8(t[3],addr))
       {var match$1=t[7][7];
        return 2 <= match$1?read_byte$8(t[3],addr):caml_call1(_g_[20],255)}
      if(accepts$7(t[4],addr))return read_byte$7(t[4],addr);
      if(accepts$7(t[5],addr))return read_byte$7(t[5],addr);
      if(accepts$7(t[6],addr))return read_byte$7(t[6],addr);
      if(accepts$11(t[7],addr))return read_byte$11(t[7],addr);
      if(accepts$9(t[8],addr))return read_byte$9(t[8],addr);
      if(accepts$10(t[9],addr))return read_byte$10(t[9],addr);
      var
       _wx_=caml_call1(_f_[1],addr),
       _wy_=caml_call2(Stdlib_Printf[4],_H_,_wx_);
      throw [0,Stdlib[6],_wy_]}
    function write_byte$12(t,addr,data)
     {if(accepts$2(t[1],addr))
       {var match=t[7][7];return 1 === match?0:write_byte$2(t[1],addr,data)}
      if(accepts$1(t[2],addr))
       {var match$0=t[7][7];
        return 1 === match$0?0:write_byte$1(t[2],addr,data)}
      if(accepts$8(t[3],addr))
       {var match$1=t[7][7];
        return 2 <= match$1?write_byte$8(t[3],addr,data):0}
      if(accepts$7(t[4],addr))return write_byte$7(t[4],addr,data);
      if(accepts$7(t[5],addr))return write_byte$7(t[5],addr,data);
      if(accepts$7(t[6],addr))return write_byte$7(t[6],addr,data);
      if(accepts$11(t[7],addr))return write_byte$11(t[7],addr,data);
      if(accepts$9(t[8],addr))
       {var lcd_enable_before=t[8][2];
        write_byte$9(t[8],addr,data);
        var lcd_enable_after=t[8][2];
        if(lcd_enable_before)
         {if(! lcd_enable_after)
           {reset_ly(t[9]);t[11] = 0;t[12] = 1;return set_gpu_mode(t[7],2)}}
        else
         if(lcd_enable_after){t[12] = 2;t[11] = 18;return handle_ly_eq_lyc(t)}
        return 0}
      if(accepts$10(t[9],addr))return write_byte$10(t[9],addr,data);
      var
       _wv_=caml_call1(_f_[1],addr),
       _ww_=caml_call2(Stdlib_Printf[4],_I_,_wv_);
      throw [0,Stdlib[6],_ww_]}
    function write_oam_with_offset(t,offset,data)
     {return write_with_offset(t[3],offset,data)}
    function run$1(t,mcycles)
     {var mode_before=t[7][7];
      run$0(t,mcycles);
      var mode_after=t[7][7];
      return mode_before !== mode_after?64931064:-720694132}
    function show$4(t)
     {var match=next(t[10]);
      if(match)
       var int$0=match[1],interrupt_str=show_type(int$0);
      else
       var interrupt_str=cst;
      var
       _wq_=peek$0(t[7]),
       _wr_=caml_call1(_g_[1],_wq_),
       _ws_=get_ly(t[9]),
       _wt_=t[11],
       _wu_=to_int$1(t[7][7]);
      return caml_call6
              (Stdlib_Printf[4],_J_,_wu_,_wt_,_ws_,_wr_,interrupt_str)}
    function get_mcycles_in_mode(t){return t[11]}
    var
     For_tests$0=[0,run$1,show$4,get_mcycles_in_mode],
     Camlboy_lib_Gpu=
      [0,
       create$13,
       set_mcycles_in_mode,
       get_frame_buffer,
       write_oam_with_offset,
       run$0,
       read_byte$12,
       write_byte$12,
       accepts$12,
       For_tests$0];
    caml_register_global(1233,Camlboy_lib_Gpu,"Camlboy_lib__Gpu");
    function create$14(addr,ic){return [0,addr,ic,1,1,1,1,1,1,1,1,1]}
    function press(t,key)
     {request(t[2],4);
      switch(key)
       {case 0:t[4] = 0;return 0;
        case 1:t[5] = 0;return 0;
        case 2:t[6] = 0;return 0;
        case 3:t[7] = 0;return 0;
        case 4:t[8] = 0;return 0;
        case 5:t[9] = 0;return 0;
        case 6:t[10] = 0;return 0;
        default:t[11] = 0;return 0}}
    function release(t,param)
     {switch(param)
       {case 0:t[4] = 1;return 0;
        case 1:t[5] = 1;return 0;
        case 2:t[6] = 1;return 0;
        case 3:t[7] = 1;return 0;
        case 4:t[8] = 1;return 0;
        case 5:t[9] = 1;return 0;
        case 6:t[10] = 1;return 0;
        default:t[11] = 1;return 0}}
    function read_byte$13(t,param)
     {switch(t[3])
       {case 0:return caml_call1(_g_[20],15);
        case 1:
         return byte_of_bitflags
                 (1,
                  1,
                  0,
                  1,
                  1 === t[4]?1:0,
                  1 === t[5]?1:0,
                  1 === t[6]?1:0,
                  1 === t[7]?1:0);
        default:
         return byte_of_bitflags
                 (1,
                  1,
                  1,
                  0,
                  1 === t[8]?1:0,
                  1 === t[9]?1:0,
                  1 === t[10]?1:0,
                  1 === t[11]?1:0)}}
    function write_byte$13(t,param,data)
     {var match=bitflags_of_byte(data),b4=match[4],b5=match[3];
      return b4?b5?(t[3] = 0,0):(t[3] = 2,0):(t[3] = 1,0)}
    function accepts$13(t,addr){return caml_equal(addr,t[1])}
    var
     Camlboy_lib_Joypad=
      [0,create$14,press,release,read_byte$13,write_byte$13,accepts$13];
    caml_register_global(1234,Camlboy_lib_Joypad,"Camlboy_lib__Joypad");
    function Make(Cartridge)
     {function create
       (cartridge,
        wram,
        gpu,
        zero_page,
        shadow_ram,
        joypad,
        serial_port,
        ic,
        timer,
        dma_transfer)
       {return [0,
                cartridge,
                wram,
                shadow_ram,
                gpu,
                zero_page,
                joypad,
                serial_port,
                ic,
                timer,
                dma_transfer]}
      function read_byte$1(t,addr)
       {return caml_call2(Cartridge[3],t[1],addr)
                ?caml_call2(Cartridge[1],t[1],addr)
                :accepts$3(t[2],addr)
                  ?read_byte$3(t[2],addr)
                  :accepts$3(t[5],addr)
                    ?read_byte$3(t[5],addr)
                    :accepts$12(t[4],addr)
                      ?read_byte$12(t[4],addr)
                      :accepts$13(t[6],addr)
                        ?read_byte$13(t[6],addr)
                        :accepts$4(t[3],addr)
                          ?read_byte$4(t[3],addr)
                          :accepts$6(t[7],addr)
                            ?read_byte$6(t[7],addr)
                            :accepts(t[8],addr)
                              ?read_byte(t[8],addr)
                              :accepts$0(t[9],addr)
                                ?read_byte$0(t[9],addr)
                                :accepts$5(t[10],addr)
                                  ?read_byte$5(t[10],addr)
                                  :caml_call1(_g_[20],255)}
      function write_byte$1(t,addr,data)
       {if(caml_call2(Cartridge[3],t[1],addr))
         return caml_call3(Cartridge[2],t[1],addr,data);
        if(accepts$3(t[2],addr))return write_byte$3(t[2],addr,data);
        if(accepts$3(t[5],addr))return write_byte$3(t[5],addr,data);
        if(accepts$12(t[4],addr))return write_byte$12(t[4],addr,data);
        if(accepts$13(t[6],addr))return write_byte$13(t[6],addr,data);
        if(accepts$4(t[3],addr))return write_byte$4(t[3],addr,data);
        if(accepts$6(t[7],addr))return write_byte$6(t[7],addr,data);
        if(accepts(t[8],addr))return write_byte(t[8],addr,data);
        if(accepts$0(t[9],addr))return write_byte$0(t[9],addr,data);
        if(accepts$5(t[10],addr))
         {write_byte$5(t[10],addr,data);
          var
           _wn_=caml_call1(_f_[36],data),
           source=caml_call2(_f_[34],_wn_,8),
           i=0;
          for(;;)
           {var
             _wo_=caml_call1(_f_[20],i),
             data$0=read_byte$1(t,caml_call2(_f_[23],source,_wo_));
            write_oam_with_offset(t[4],i,data$0);
            var _wp_=i + 1 | 0;
            if(159 !== i){var i=_wp_;continue}
            return 0}}
        return 0}
      function accepts$1(t,addr)
       {var _wc_=caml_call2(Cartridge[3],t[1],addr);
        if(_wc_)
         var _wd_=_wc_;
        else
         {var _we_=accepts$3(t[2],addr);
          if(_we_)
           var _wd_=_we_;
          else
           {var _wf_=accepts$12(t[4],addr);
            if(_wf_)
             var _wd_=_wf_;
            else
             {var _wg_=accepts$3(t[5],addr);
              if(_wg_)
               var _wd_=_wg_;
              else
               {var _wh_=accepts$4(t[3],addr);
                if(_wh_)
                 var _wd_=_wh_;
                else
                 {var _wi_=accepts$4(t[3],addr);
                  if(_wi_)
                   var _wd_=_wi_;
                  else
                   {var _wj_=accepts$13(t[6],addr);
                    if(_wj_)
                     var _wd_=_wj_;
                    else
                     {var _wk_=accepts$6(t[7],addr);
                      if(_wk_)
                       var _wd_=_wk_;
                      else
                       {var _wl_=accepts(t[8],addr);
                        if(_wl_)
                         var _wd_=_wl_;
                        else
                         {var _wm_=accepts$0(t[9],addr);
                          if(! _wm_)return accepts$5(t[10],addr);
                          var _wd_=_wm_}}}}}}}}}
        return _wd_}
      function read_word(t,addr)
       {var
         _wa_=read_byte$1(t,addr),
         lo=caml_call1(_g_[21],_wa_),
         _wb_=read_byte$1(t,caml_call1(_f_[13],addr)),
         hi=caml_call1(_g_[21],_wb_);
        return caml_call1(_f_[20],(hi << 8) + lo | 0)}
      function write_word(t,addr,data)
       {var
         data$0=caml_call1(_f_[21],data),
         hi=caml_call1(_g_[20],data$0 >>> 8 | 0),
         lo=caml_call1(_g_[20],data$0 & 255);
        write_byte$1(t,addr,lo);
        return write_byte$1(t,caml_call1(_f_[13],addr),hi)}
      return [0,
              create,
              read_byte$1,
              write_byte$1,
              accepts$1,
              read_word,
              write_word]}
    var Camlboy_lib_Mmu=[0,Make];
    caml_register_global(1235,Camlboy_lib_Mmu,"Camlboy_lib__Mmu");
    function show_arg(param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return cst_FF00_C;
         case 1:return cst_HL$0;
         case 2:return cst_HL$1;
         default:return cst_SP}
      else
       switch(param[0])
        {case 0:var n=param[1];return caml_call1(_g_[1],n);
         case 1:var n$0=param[1];return caml_call1(_f_[1],n$0);
         case 4:var r=param[1];return show_r(r);
         case 5:var rr=param[1];return show_rr(rr);
         case 6:
          var rr$0=param[1],_v7_=show_rr(rr$0);
          return caml_call2(Stdlib_Printf[4],_L_,_v7_);
         case 7:
          var n$2=param[1],_v8_=caml_call1(_g_[1],n$2);
          return caml_call2(Stdlib_Printf[4],_M_,_v8_);
         case 8:
          var n$3=param[1];
          if(caml_call1(_e_[4],n$3))
           {var _v9_=caml_call1(_e_[5],n$3),_v__=caml_call1(_e_[6],_v9_);
            return caml_call2(Stdlib_Printf[4],_N_,_v__)}
          var _v$_=caml_call1(_e_[6],n$3);
          return caml_call2(Stdlib_Printf[4],_O_,_v$_);
         default:
          var n$1=param[1],_v6_=caml_call1(_f_[1],n$1);
          return caml_call2(Stdlib_Printf[4],_K_,_v6_)}}
    function show_condition(param)
     {switch(param)
       {case 0:return cst$0;
        case 1:return cst_NZ;
        case 2:return cst_Z;
        case 3:return cst_NC;
        default:return cst_C$0}}
    function show$5(param)
     {if(typeof param === "number")
       switch(param)
        {case 0:return caml_call1(Stdlib_Printf[4],_P_);
         case 1:return caml_call1(Stdlib_Printf[4],_Q_);
         case 2:return caml_call1(Stdlib_Printf[4],_R_);
         case 3:return caml_call1(Stdlib_Printf[4],_S_);
         case 4:return caml_call1(Stdlib_Printf[4],_T_);
         case 5:return caml_call1(Stdlib_Printf[4],_U_);
         case 6:return caml_call1(Stdlib_Printf[4],_V_);
         case 7:return caml_call1(Stdlib_Printf[4],_W_);
         case 8:return caml_call1(Stdlib_Printf[4],_X_);
         case 9:return caml_call1(Stdlib_Printf[4],_Y_);
         case 10:return caml_call1(Stdlib_Printf[4],_Z_);
         case 11:return caml_call1(Stdlib_Printf[4],___);
         case 12:return caml_call1(Stdlib_Printf[4],_$_);
         default:return caml_call1(Stdlib_Printf[4],_aa_)}
      else
       switch(param[0])
        {case 0:
          var y=param[2],x=param[1],_vh_=show_arg(y),_vi_=show_arg(x);
          return caml_call3(Stdlib_Printf[4],_ab_,_vi_,_vh_);
         case 1:
          var y$0=param[2],x$0=param[1],_vj_=show_arg(y$0),_vk_=show_arg(x$0);
          return caml_call3(Stdlib_Printf[4],_ac_,_vk_,_vj_);
         case 2:
          var y$1=param[2],x$1=param[1],_vl_=show_arg(y$1),_vm_=show_arg(x$1);
          return caml_call3(Stdlib_Printf[4],_ad_,_vm_,_vl_);
         case 3:
          var y$2=param[2],x$2=param[1],_vn_=show_arg(y$2),_vo_=show_arg(x$2);
          return caml_call3(Stdlib_Printf[4],_ae_,_vo_,_vn_);
         case 4:
          var y$3=param[1],_vp_=caml_call1(_e_[6],y$3);
          return caml_call2(Stdlib_Printf[4],_af_,_vp_);
         case 5:
          var y$4=param[2],x$3=param[1],_vq_=show_arg(y$4),_vr_=show_arg(x$3);
          return caml_call3(Stdlib_Printf[4],_ag_,_vr_,_vq_);
         case 6:
          var y$5=param[2],x$4=param[1],_vs_=show_arg(y$5),_vt_=show_arg(x$4);
          return caml_call3(Stdlib_Printf[4],_ah_,_vt_,_vs_);
         case 7:
          var y$6=param[2],x$5=param[1],_vu_=show_arg(y$6),_vv_=show_arg(x$5);
          return caml_call3(Stdlib_Printf[4],_ai_,_vv_,_vu_);
         case 8:
          var y$7=param[2],x$6=param[1],_vw_=show_arg(y$7),_vx_=show_arg(x$6);
          return caml_call3(Stdlib_Printf[4],_aj_,_vx_,_vw_);
         case 9:
          var y$8=param[2],x$7=param[1],_vy_=show_arg(y$8),_vz_=show_arg(x$7);
          return caml_call3(Stdlib_Printf[4],_ak_,_vz_,_vy_);
         case 10:
          var y$9=param[2],x$8=param[1],_vA_=show_arg(y$9),_vB_=show_arg(x$8);
          return caml_call3(Stdlib_Printf[4],_al_,_vB_,_vA_);
         case 11:
          var
           y$10=param[2],
           x$9=param[1],
           _vC_=show_arg(y$10),
           _vD_=show_arg(x$9);
          return caml_call3(Stdlib_Printf[4],_am_,_vD_,_vC_);
         case 12:
          var x$10=param[1],_vE_=show_arg(x$10);
          return caml_call2(Stdlib_Printf[4],_an_,_vE_);
         case 13:
          var x$11=param[1],_vF_=show_arg(x$11);
          return caml_call2(Stdlib_Printf[4],_ao_,_vF_);
         case 14:
          var x$12=param[1],_vG_=show_arg(x$12);
          return caml_call2(Stdlib_Printf[4],_ap_,_vG_);
         case 15:
          var x$13=param[1],_vH_=show_arg(x$13);
          return caml_call2(Stdlib_Printf[4],_aq_,_vH_);
         case 16:
          var x$14=param[1],_vI_=show_arg(x$14);
          return caml_call2(Stdlib_Printf[4],_ar_,_vI_);
         case 17:
          var x$15=param[1],_vJ_=show_arg(x$15);
          return caml_call2(Stdlib_Printf[4],_as_,_vJ_);
         case 18:
          var x$16=param[1],_vK_=show_arg(x$16);
          return caml_call2(Stdlib_Printf[4],_at_,_vK_);
         case 19:
          var x$17=param[1],_vL_=show_arg(x$17);
          return caml_call2(Stdlib_Printf[4],_au_,_vL_);
         case 20:
          var x$18=param[1],_vM_=show_arg(x$18);
          return caml_call2(Stdlib_Printf[4],_av_,_vM_);
         case 21:
          var x$19=param[1],_vN_=show_arg(x$19);
          return caml_call2(Stdlib_Printf[4],_aw_,_vN_);
         case 22:
          var x$20=param[1],_vO_=show_arg(x$20);
          return caml_call2(Stdlib_Printf[4],_ax_,_vO_);
         case 23:
          var x$21=param[1],_vP_=show_arg(x$21);
          return caml_call2(Stdlib_Printf[4],_ay_,_vP_);
         case 24:
          var x$22=param[2],n=param[1],_vQ_=show_arg(x$22);
          return caml_call3(Stdlib_Printf[4],_az_,n,_vQ_);
         case 25:
          var x$23=param[2],n$0=param[1],_vR_=show_arg(x$23);
          return caml_call3(Stdlib_Printf[4],_aA_,n$0,_vR_);
         case 26:
          var x$24=param[2],n$1=param[1],_vS_=show_arg(x$24);
          return caml_call3(Stdlib_Printf[4],_aB_,n$1,_vS_);
         case 27:
          var rr=param[1],_vT_=show_rr(rr);
          return caml_call2(Stdlib_Printf[4],_aC_,_vT_);
         case 28:
          var rr$0=param[1],_vU_=show_rr(rr$0);
          return caml_call2(Stdlib_Printf[4],_aD_,_vU_);
         case 29:
          var x$25=param[2],c=param[1];
          if(c)
           {var _vV_=show_arg(x$25),_vW_=show_condition(c);
            return caml_call3(Stdlib_Printf[4],_aE_,_vW_,_vV_)}
          var _vX_=show_arg(x$25);
          return caml_call2(Stdlib_Printf[4],_aF_,_vX_);
         case 30:
          var x$26=param[2],c$0=param[1];
          if(c$0)
           {var _vY_=caml_call1(_e_[6],x$26),_vZ_=show_condition(c$0);
            return caml_call3(Stdlib_Printf[4],_aG_,_vZ_,_vY_)}
          var _v0_=caml_call1(_e_[6],x$26);
          return caml_call2(Stdlib_Printf[4],_aH_,_v0_);
         case 31:
          var x$27=param[2],c$1=param[1];
          if(c$1)
           {var _v1_=caml_call1(_f_[1],x$27),_v2_=show_condition(c$1);
            return caml_call3(Stdlib_Printf[4],_aI_,_v2_,_v1_)}
          var _v3_=caml_call1(_f_[1],x$27);
          return caml_call2(Stdlib_Printf[4],_aJ_,_v3_);
         case 32:
          var x$28=param[1],_v4_=caml_call1(_f_[1],x$28);
          return caml_call2(Stdlib_Printf[4],_aK_,_v4_);
         default:
          var c$2=param[1],_v5_=show_condition(c$2);
          return caml_call2(Stdlib_Printf[4],_aL_,_v5_)}}
    var Camlboy_lib_Instruction=[0,show$5];
    caml_register_global
     (1236,Camlboy_lib_Instruction,"Camlboy_lib__Instruction");
    function _pZ_(Mmu)
     {var
       x00=caml_call1(_f_[20],0),
       x08=caml_call1(_f_[20],8),
       x10=caml_call1(_f_[20],16),
       x18=caml_call1(_f_[20],24),
       x20=caml_call1(_f_[20],32),
       x28=caml_call1(_f_[20],40),
       x30=caml_call1(_f_[20],48),
       x38=caml_call1(_f_[20],56),
       l1=caml_call1(_f_[20],1),
       l2=caml_call1(_f_[20],2),
       l3=caml_call1(_f_[20],3);
      function f(mmu,pc)
       {var addr_after_pc=caml_call1(_f_[13],pc);
        function next_byte(param){return caml_call2(Mmu[1],mmu,addr_after_pc)}
        function next_word(param){return caml_call2(Mmu[4],mmu,addr_after_pc)}
        var _u6_=caml_call2(Mmu[1],mmu,pc),op=caml_call1(_g_[21],_u6_);
        if(255 < op >>> 0)
         {var _u7_=caml_call2(Stdlib_Printf[4],_aM_,op);
          return caml_call1(Stdlib[2],_u7_)}
        var _vf_=op;
        if(128 <= _vf_)
         {if(192 <= _vf_)
           {if(224 <= _vf_)
             switch(_vf_)
              {case 224:return [0,l2,_pd_,[0,[7,next_byte(0)],_pc_]];
               case 225:return [0,l1,_pf_,_pe_];
               case 226:return [0,l1,_ph_,_pg_];
               case 227:return [0,l1,_pi_,4];
               case 228:return [0,l1,_pj_,4];
               case 229:return [0,l1,_pl_,_pk_];
               case 230:return [0,l2,_pn_,[8,_pm_,[0,next_byte(0)]]];
               case 231:return [0,l1,_po_,[32,x20]];
               case 232:
                var _vd_=next_byte(0);
                return [0,l2,_pp_,[4,caml_call1(_e_[1],_vd_)]];
               case 233:return [0,l1,_pr_,_pq_];
               case 234:return [0,l3,_pt_,[0,[2,next_word(0)],_ps_]];
               case 235:return [0,l1,_pu_,4];
               case 236:return [0,l1,_pv_,4];
               case 237:return [0,l1,_pw_,4];
               case 238:return [0,l2,_py_,[10,_px_,[0,next_byte(0)]]];
               case 239:return [0,l1,_pz_,[32,x28]];
               case 240:return [0,l2,_pB_,[0,_pA_,[7,next_byte(0)]]];
               case 241:return [0,l1,_pD_,_pC_];
               case 242:return [0,l1,_pF_,_pE_];
               case 243:return [0,l1,_pG_,7];
               case 244:return [0,l1,_pH_,4];
               case 245:return [0,l1,_pJ_,_pI_];
               case 246:return [0,l2,_pL_,[9,_pK_,[0,next_byte(0)]]];
               case 247:return [0,l1,_pM_,[32,x30]];
               case 248:
                var _ve_=next_byte(0);
                return [0,l2,_pO_,[1,_pN_,[8,caml_call1(_e_[1],_ve_)]]];
               case 249:return [0,l1,_pQ_,_pP_];
               case 250:return [0,l3,_pS_,[0,_pR_,[2,next_word(0)]]];
               case 251:return [0,l1,_pT_,8];
               case 252:return [0,l1,_pU_,4];
               case 253:return [0,l1,_pV_,4];
               case 254:return [0,l2,_pX_,[11,_pW_,[0,next_byte(0)]]];
               default:return [0,l1,_pY_,[32,x38]]}
            switch(_vf_)
             {case 192:return [0,l1,_gw_,_gv_];
              case 193:return [0,l1,_gy_,_gx_];
              case 194:return [0,l3,_gz_,[29,1,[1,next_word(0)]]];
              case 195:return [0,l3,_gA_,[29,0,[1,next_word(0)]]];
              case 196:return [0,l3,_gB_,[31,1,next_word(0)]];
              case 197:return [0,l1,_gD_,_gC_];
              case 198:return [0,l2,_gF_,[2,_gE_,[0,next_byte(0)]]];
              case 199:return [0,l1,_gG_,[32,x00]];
              case 200:return [0,l1,_gI_,_gH_];
              case 201:return [0,l1,_gK_,_gJ_];
              case 202:return [0,l3,_gL_,[29,2,[1,next_word(0)]]];
              case 203:
               var _vb_=next_byte(0),op$0=caml_call1(_g_[21],_vb_);
               if(255 < op$0 >>> 0)
                {var _vc_=caml_call2(Stdlib_Printf[4],_gM_,op$0);
                 return caml_call1(Stdlib[2],_vc_)}
               var _vg_=op$0;
               if(128 <= _vg_)
                {if(192 <= _vg_)
                  {if(224 <= _vg_)
                    switch(_vg_)
                     {case 224:return [0,l2,_nO_,_nN_];
                      case 225:return [0,l2,_nQ_,_nP_];
                      case 226:return [0,l2,_nS_,_nR_];
                      case 227:return [0,l2,_nU_,_nT_];
                      case 228:return [0,l2,_nW_,_nV_];
                      case 229:return [0,l2,_nY_,_nX_];
                      case 230:return [0,l2,_n0_,_nZ_];
                      case 231:return [0,l2,_n2_,_n1_];
                      case 232:return [0,l2,_n4_,_n3_];
                      case 233:return [0,l2,_n6_,_n5_];
                      case 234:return [0,l2,_n8_,_n7_];
                      case 235:return [0,l2,_n__,_n9_];
                      case 236:return [0,l2,_oa_,_n$_];
                      case 237:return [0,l2,_oc_,_ob_];
                      case 238:return [0,l2,_oe_,_od_];
                      case 239:return [0,l2,_og_,_of_];
                      case 240:return [0,l2,_oi_,_oh_];
                      case 241:return [0,l2,_ok_,_oj_];
                      case 242:return [0,l2,_om_,_ol_];
                      case 243:return [0,l2,_oo_,_on_];
                      case 244:return [0,l2,_oq_,_op_];
                      case 245:return [0,l2,_os_,_or_];
                      case 246:return [0,l2,_ou_,_ot_];
                      case 247:return [0,l2,_ow_,_ov_];
                      case 248:return [0,l2,_oy_,_ox_];
                      case 249:return [0,l2,_oA_,_oz_];
                      case 250:return [0,l2,_oC_,_oB_];
                      case 251:return [0,l2,_oE_,_oD_];
                      case 252:return [0,l2,_oG_,_oF_];
                      case 253:return [0,l2,_oI_,_oH_];
                      case 254:return [0,l2,_oK_,_oJ_];
                      default:return [0,l2,_oM_,_oL_]}
                   switch(_vg_)
                    {case 192:return [0,l2,_mO_,_mN_];
                     case 193:return [0,l2,_mQ_,_mP_];
                     case 194:return [0,l2,_mS_,_mR_];
                     case 195:return [0,l2,_mU_,_mT_];
                     case 196:return [0,l2,_mW_,_mV_];
                     case 197:return [0,l2,_mY_,_mX_];
                     case 198:return [0,l2,_m0_,_mZ_];
                     case 199:return [0,l2,_m2_,_m1_];
                     case 200:return [0,l2,_m4_,_m3_];
                     case 201:return [0,l2,_m6_,_m5_];
                     case 202:return [0,l2,_m8_,_m7_];
                     case 203:return [0,l2,_m__,_m9_];
                     case 204:return [0,l2,_na_,_m$_];
                     case 205:return [0,l2,_nc_,_nb_];
                     case 206:return [0,l2,_ne_,_nd_];
                     case 207:return [0,l2,_ng_,_nf_];
                     case 208:return [0,l2,_ni_,_nh_];
                     case 209:return [0,l2,_nk_,_nj_];
                     case 210:return [0,l2,_nm_,_nl_];
                     case 211:return [0,l2,_no_,_nn_];
                     case 212:return [0,l2,_nq_,_np_];
                     case 213:return [0,l2,_ns_,_nr_];
                     case 214:return [0,l2,_nu_,_nt_];
                     case 215:return [0,l2,_nw_,_nv_];
                     case 216:return [0,l2,_ny_,_nx_];
                     case 217:return [0,l2,_nA_,_nz_];
                     case 218:return [0,l2,_nC_,_nB_];
                     case 219:return [0,l2,_nE_,_nD_];
                     case 220:return [0,l2,_nG_,_nF_];
                     case 221:return [0,l2,_nI_,_nH_];
                     case 222:return [0,l2,_nK_,_nJ_];
                     default:return [0,l2,_nM_,_nL_]}}
                 if(160 <= _vg_)
                  switch(_vg_)
                   {case 160:return [0,l2,_lO_,_lN_];
                    case 161:return [0,l2,_lQ_,_lP_];
                    case 162:return [0,l2,_lS_,_lR_];
                    case 163:return [0,l2,_lU_,_lT_];
                    case 164:return [0,l2,_lW_,_lV_];
                    case 165:return [0,l2,_lY_,_lX_];
                    case 166:return [0,l2,_l0_,_lZ_];
                    case 167:return [0,l2,_l2_,_l1_];
                    case 168:return [0,l2,_l4_,_l3_];
                    case 169:return [0,l2,_l6_,_l5_];
                    case 170:return [0,l2,_l8_,_l7_];
                    case 171:return [0,l2,_l__,_l9_];
                    case 172:return [0,l2,_ma_,_l$_];
                    case 173:return [0,l2,_mc_,_mb_];
                    case 174:return [0,l2,_me_,_md_];
                    case 175:return [0,l2,_mg_,_mf_];
                    case 176:return [0,l2,_mi_,_mh_];
                    case 177:return [0,l2,_mk_,_mj_];
                    case 178:return [0,l2,_mm_,_ml_];
                    case 179:return [0,l2,_mo_,_mn_];
                    case 180:return [0,l2,_mq_,_mp_];
                    case 181:return [0,l2,_ms_,_mr_];
                    case 182:return [0,l2,_mu_,_mt_];
                    case 183:return [0,l2,_mw_,_mv_];
                    case 184:return [0,l2,_my_,_mx_];
                    case 185:return [0,l2,_mA_,_mz_];
                    case 186:return [0,l2,_mC_,_mB_];
                    case 187:return [0,l2,_mE_,_mD_];
                    case 188:return [0,l2,_mG_,_mF_];
                    case 189:return [0,l2,_mI_,_mH_];
                    case 190:return [0,l2,_mK_,_mJ_];
                    default:return [0,l2,_mM_,_mL_]}
                 switch(_vg_)
                  {case 128:return [0,l2,_kO_,_kN_];
                   case 129:return [0,l2,_kQ_,_kP_];
                   case 130:return [0,l2,_kS_,_kR_];
                   case 131:return [0,l2,_kU_,_kT_];
                   case 132:return [0,l2,_kW_,_kV_];
                   case 133:return [0,l2,_kY_,_kX_];
                   case 134:return [0,l2,_k0_,_kZ_];
                   case 135:return [0,l2,_k2_,_k1_];
                   case 136:return [0,l2,_k4_,_k3_];
                   case 137:return [0,l2,_k6_,_k5_];
                   case 138:return [0,l2,_k8_,_k7_];
                   case 139:return [0,l2,_k__,_k9_];
                   case 140:return [0,l2,_la_,_k$_];
                   case 141:return [0,l2,_lc_,_lb_];
                   case 142:return [0,l2,_le_,_ld_];
                   case 143:return [0,l2,_lg_,_lf_];
                   case 144:return [0,l2,_li_,_lh_];
                   case 145:return [0,l2,_lk_,_lj_];
                   case 146:return [0,l2,_lm_,_ll_];
                   case 147:return [0,l2,_lo_,_ln_];
                   case 148:return [0,l2,_lq_,_lp_];
                   case 149:return [0,l2,_ls_,_lr_];
                   case 150:return [0,l2,_lu_,_lt_];
                   case 151:return [0,l2,_lw_,_lv_];
                   case 152:return [0,l2,_ly_,_lx_];
                   case 153:return [0,l2,_lA_,_lz_];
                   case 154:return [0,l2,_lC_,_lB_];
                   case 155:return [0,l2,_lE_,_lD_];
                   case 156:return [0,l2,_lG_,_lF_];
                   case 157:return [0,l2,_lI_,_lH_];
                   case 158:return [0,l2,_lK_,_lJ_];
                   default:return [0,l2,_lM_,_lL_]}}
               if(64 <= _vg_)
                {if(96 <= _vg_)
                  switch(_vg_)
                   {case 96:return [0,l2,_jO_,_jN_];
                    case 97:return [0,l2,_jQ_,_jP_];
                    case 98:return [0,l2,_jS_,_jR_];
                    case 99:return [0,l2,_jU_,_jT_];
                    case 100:return [0,l2,_jW_,_jV_];
                    case 101:return [0,l2,_jY_,_jX_];
                    case 102:return [0,l2,_j0_,_jZ_];
                    case 103:return [0,l2,_j2_,_j1_];
                    case 104:return [0,l2,_j4_,_j3_];
                    case 105:return [0,l2,_j6_,_j5_];
                    case 106:return [0,l2,_j8_,_j7_];
                    case 107:return [0,l2,_j__,_j9_];
                    case 108:return [0,l2,_ka_,_j$_];
                    case 109:return [0,l2,_kc_,_kb_];
                    case 110:return [0,l2,_ke_,_kd_];
                    case 111:return [0,l2,_kg_,_kf_];
                    case 112:return [0,l2,_ki_,_kh_];
                    case 113:return [0,l2,_kk_,_kj_];
                    case 114:return [0,l2,_km_,_kl_];
                    case 115:return [0,l2,_ko_,_kn_];
                    case 116:return [0,l2,_kq_,_kp_];
                    case 117:return [0,l2,_ks_,_kr_];
                    case 118:return [0,l2,_ku_,_kt_];
                    case 119:return [0,l2,_kw_,_kv_];
                    case 120:return [0,l2,_ky_,_kx_];
                    case 121:return [0,l2,_kA_,_kz_];
                    case 122:return [0,l2,_kC_,_kB_];
                    case 123:return [0,l2,_kE_,_kD_];
                    case 124:return [0,l2,_kG_,_kF_];
                    case 125:return [0,l2,_kI_,_kH_];
                    case 126:return [0,l2,_kK_,_kJ_];
                    default:return [0,l2,_kM_,_kL_]}
                 switch(_vg_)
                  {case 64:return [0,l2,_iO_,_iN_];
                   case 65:return [0,l2,_iQ_,_iP_];
                   case 66:return [0,l2,_iS_,_iR_];
                   case 67:return [0,l2,_iU_,_iT_];
                   case 68:return [0,l2,_iW_,_iV_];
                   case 69:return [0,l2,_iY_,_iX_];
                   case 70:return [0,l2,_i0_,_iZ_];
                   case 71:return [0,l2,_i2_,_i1_];
                   case 72:return [0,l2,_i4_,_i3_];
                   case 73:return [0,l2,_i6_,_i5_];
                   case 74:return [0,l2,_i8_,_i7_];
                   case 75:return [0,l2,_i__,_i9_];
                   case 76:return [0,l2,_ja_,_i$_];
                   case 77:return [0,l2,_jc_,_jb_];
                   case 78:return [0,l2,_je_,_jd_];
                   case 79:return [0,l2,_jg_,_jf_];
                   case 80:return [0,l2,_ji_,_jh_];
                   case 81:return [0,l2,_jk_,_jj_];
                   case 82:return [0,l2,_jm_,_jl_];
                   case 83:return [0,l2,_jo_,_jn_];
                   case 84:return [0,l2,_jq_,_jp_];
                   case 85:return [0,l2,_js_,_jr_];
                   case 86:return [0,l2,_ju_,_jt_];
                   case 87:return [0,l2,_jw_,_jv_];
                   case 88:return [0,l2,_jy_,_jx_];
                   case 89:return [0,l2,_jA_,_jz_];
                   case 90:return [0,l2,_jC_,_jB_];
                   case 91:return [0,l2,_jE_,_jD_];
                   case 92:return [0,l2,_jG_,_jF_];
                   case 93:return [0,l2,_jI_,_jH_];
                   case 94:return [0,l2,_jK_,_jJ_];
                   default:return [0,l2,_jM_,_jL_]}}
               if(32 <= _vg_)
                switch(_vg_)
                 {case 32:return [0,l2,_hO_,_hN_];
                  case 33:return [0,l2,_hQ_,_hP_];
                  case 34:return [0,l2,_hS_,_hR_];
                  case 35:return [0,l2,_hU_,_hT_];
                  case 36:return [0,l2,_hW_,_hV_];
                  case 37:return [0,l2,_hY_,_hX_];
                  case 38:return [0,l2,_h0_,_hZ_];
                  case 39:return [0,l2,_h2_,_h1_];
                  case 40:return [0,l2,_h4_,_h3_];
                  case 41:return [0,l2,_h6_,_h5_];
                  case 42:return [0,l2,_h8_,_h7_];
                  case 43:return [0,l2,_h__,_h9_];
                  case 44:return [0,l2,_ia_,_h$_];
                  case 45:return [0,l2,_ic_,_ib_];
                  case 46:return [0,l2,_ie_,_id_];
                  case 47:return [0,l2,_ig_,_if_];
                  case 48:return [0,l2,_ii_,_ih_];
                  case 49:return [0,l2,_ik_,_ij_];
                  case 50:return [0,l2,_im_,_il_];
                  case 51:return [0,l2,_io_,_in_];
                  case 52:return [0,l2,_iq_,_ip_];
                  case 53:return [0,l2,_is_,_ir_];
                  case 54:return [0,l2,_iu_,_it_];
                  case 55:return [0,l2,_iw_,_iv_];
                  case 56:return [0,l2,_iy_,_ix_];
                  case 57:return [0,l2,_iA_,_iz_];
                  case 58:return [0,l2,_iC_,_iB_];
                  case 59:return [0,l2,_iE_,_iD_];
                  case 60:return [0,l2,_iG_,_iF_];
                  case 61:return [0,l2,_iI_,_iH_];
                  case 62:return [0,l2,_iK_,_iJ_];
                  default:return [0,l2,_iM_,_iL_]}
               switch(_vg_)
                {case 0:return [0,l2,_gO_,_gN_];
                 case 1:return [0,l2,_gQ_,_gP_];
                 case 2:return [0,l2,_gS_,_gR_];
                 case 3:return [0,l2,_gU_,_gT_];
                 case 4:return [0,l2,_gW_,_gV_];
                 case 5:return [0,l2,_gY_,_gX_];
                 case 6:return [0,l2,_g0_,_gZ_];
                 case 7:return [0,l2,_g2_,_g1_];
                 case 8:return [0,l2,_g4_,_g3_];
                 case 9:return [0,l2,_g6_,_g5_];
                 case 10:return [0,l2,_g8_,_g7_];
                 case 11:return [0,l2,_g__,_g9_];
                 case 12:return [0,l2,_ha_,_g$_];
                 case 13:return [0,l2,_hc_,_hb_];
                 case 14:return [0,l2,_he_,_hd_];
                 case 15:return [0,l2,_hg_,_hf_];
                 case 16:return [0,l2,_hi_,_hh_];
                 case 17:return [0,l2,_hk_,_hj_];
                 case 18:return [0,l2,_hm_,_hl_];
                 case 19:return [0,l2,_ho_,_hn_];
                 case 20:return [0,l2,_hq_,_hp_];
                 case 21:return [0,l2,_hs_,_hr_];
                 case 22:return [0,l2,_hu_,_ht_];
                 case 23:return [0,l2,_hw_,_hv_];
                 case 24:return [0,l2,_hy_,_hx_];
                 case 25:return [0,l2,_hA_,_hz_];
                 case 26:return [0,l2,_hC_,_hB_];
                 case 27:return [0,l2,_hE_,_hD_];
                 case 28:return [0,l2,_hG_,_hF_];
                 case 29:return [0,l2,_hI_,_hH_];
                 case 30:return [0,l2,_hK_,_hJ_];
                 default:return [0,l2,_hM_,_hL_]}
              case 204:return [0,l3,_oN_,[31,2,next_word(0)]];
              case 205:return [0,l3,_oO_,[31,0,next_word(0)]];
              case 206:return [0,l2,_oQ_,[5,_oP_,[0,next_byte(0)]]];
              case 207:return [0,l1,_oR_,[32,x08]];
              case 208:return [0,l1,_oT_,_oS_];
              case 209:return [0,l1,_oV_,_oU_];
              case 210:return [0,l3,_oW_,[29,3,[1,next_word(0)]]];
              case 211:return [0,l1,_oX_,4];
              case 212:return [0,l3,_oY_,[31,3,next_word(0)]];
              case 213:return [0,l1,_o0_,_oZ_];
              case 214:return [0,l2,_o2_,[6,_o1_,[0,next_byte(0)]]];
              case 215:return [0,l1,_o3_,[32,x10]];
              case 216:return [0,l1,_o5_,_o4_];
              case 217:return [0,l1,_o6_,13];
              case 218:return [0,l3,_o7_,[29,4,[1,next_word(0)]]];
              case 219:return [0,l1,_o8_,4];
              case 220:return [0,l3,_o9_,[31,4,next_word(0)]];
              case 221:return [0,l1,_o__,4];
              case 222:return [0,l2,_pa_,[7,_o$_,[0,next_byte(0)]]];
              default:return [0,l1,_pb_,[32,x18]]}}
          if(160 <= _vf_)
           switch(_vf_)
            {case 160:return [0,l1,_fw_,_fv_];
             case 161:return [0,l1,_fy_,_fx_];
             case 162:return [0,l1,_fA_,_fz_];
             case 163:return [0,l1,_fC_,_fB_];
             case 164:return [0,l1,_fE_,_fD_];
             case 165:return [0,l1,_fG_,_fF_];
             case 166:return [0,l1,_fI_,_fH_];
             case 167:return [0,l1,_fK_,_fJ_];
             case 168:return [0,l1,_fM_,_fL_];
             case 169:return [0,l1,_fO_,_fN_];
             case 170:return [0,l1,_fQ_,_fP_];
             case 171:return [0,l1,_fS_,_fR_];
             case 172:return [0,l1,_fU_,_fT_];
             case 173:return [0,l1,_fW_,_fV_];
             case 174:return [0,l1,_fY_,_fX_];
             case 175:return [0,l1,_f0_,_fZ_];
             case 176:return [0,l1,_f2_,_f1_];
             case 177:return [0,l1,_f4_,_f3_];
             case 178:return [0,l1,_f6_,_f5_];
             case 179:return [0,l1,_f8_,_f7_];
             case 180:return [0,l1,_f__,_f9_];
             case 181:return [0,l1,_ga_,_f$_];
             case 182:return [0,l1,_gc_,_gb_];
             case 183:return [0,l1,_ge_,_gd_];
             case 184:return [0,l1,_gg_,_gf_];
             case 185:return [0,l1,_gi_,_gh_];
             case 186:return [0,l1,_gk_,_gj_];
             case 187:return [0,l1,_gm_,_gl_];
             case 188:return [0,l1,_go_,_gn_];
             case 189:return [0,l1,_gq_,_gp_];
             case 190:return [0,l1,_gs_,_gr_];
             default:return [0,l1,_gu_,_gt_]}
          switch(_vf_)
           {case 128:return [0,l1,_ew_,_ev_];
            case 129:return [0,l1,_ey_,_ex_];
            case 130:return [0,l1,_eA_,_ez_];
            case 131:return [0,l1,_eC_,_eB_];
            case 132:return [0,l1,_eE_,_eD_];
            case 133:return [0,l1,_eG_,_eF_];
            case 134:return [0,l1,_eI_,_eH_];
            case 135:return [0,l1,_eK_,_eJ_];
            case 136:return [0,l1,_eM_,_eL_];
            case 137:return [0,l1,_eO_,_eN_];
            case 138:return [0,l1,_eQ_,_eP_];
            case 139:return [0,l1,_eS_,_eR_];
            case 140:return [0,l1,_eU_,_eT_];
            case 141:return [0,l1,_eW_,_eV_];
            case 142:return [0,l1,_eY_,_eX_];
            case 143:return [0,l1,_e0_,_eZ_];
            case 144:return [0,l1,_e2_,_e1_];
            case 145:return [0,l1,_e4_,_e3_];
            case 146:return [0,l1,_e6_,_e5_];
            case 147:return [0,l1,_e8_,_e7_];
            case 148:return [0,l1,_e__,_e9_];
            case 149:return [0,l1,_fa_,_e$_];
            case 150:return [0,l1,_fc_,_fb_];
            case 151:return [0,l1,_fe_,_fd_];
            case 152:return [0,l1,_fg_,_ff_];
            case 153:return [0,l1,_fi_,_fh_];
            case 154:return [0,l1,_fk_,_fj_];
            case 155:return [0,l1,_fm_,_fl_];
            case 156:return [0,l1,_fo_,_fn_];
            case 157:return [0,l1,_fq_,_fp_];
            case 158:return [0,l1,_fs_,_fr_];
            default:return [0,l1,_fu_,_ft_]}}
        if(64 <= _vf_)
         {if(96 <= _vf_)
           switch(_vf_)
            {case 96:return [0,l1,_dx_,_dw_];
             case 97:return [0,l1,_dz_,_dy_];
             case 98:return [0,l1,_dB_,_dA_];
             case 99:return [0,l1,_dD_,_dC_];
             case 100:return [0,l1,_dF_,_dE_];
             case 101:return [0,l1,_dH_,_dG_];
             case 102:return [0,l1,_dJ_,_dI_];
             case 103:return [0,l1,_dL_,_dK_];
             case 104:return [0,l1,_dN_,_dM_];
             case 105:return [0,l1,_dP_,_dO_];
             case 106:return [0,l1,_dR_,_dQ_];
             case 107:return [0,l1,_dT_,_dS_];
             case 108:return [0,l1,_dV_,_dU_];
             case 109:return [0,l1,_dX_,_dW_];
             case 110:return [0,l1,_dZ_,_dY_];
             case 111:return [0,l1,_d1_,_d0_];
             case 112:return [0,l1,_d3_,_d2_];
             case 113:return [0,l1,_d5_,_d4_];
             case 114:return [0,l1,_d7_,_d6_];
             case 115:return [0,l1,_d9_,_d8_];
             case 116:return [0,l1,_d$_,_d__];
             case 117:return [0,l1,_eb_,_ea_];
             case 118:return [0,l1,_ec_,5];
             case 119:return [0,l1,_ee_,_ed_];
             case 120:return [0,l1,_eg_,_ef_];
             case 121:return [0,l1,_ei_,_eh_];
             case 122:return [0,l1,_ek_,_ej_];
             case 123:return [0,l1,_em_,_el_];
             case 124:return [0,l1,_eo_,_en_];
             case 125:return [0,l1,_eq_,_ep_];
             case 126:return [0,l1,_es_,_er_];
             default:return [0,l1,_eu_,_et_]}
          switch(_vf_)
           {case 64:return [0,l1,_cx_,_cw_];
            case 65:return [0,l1,_cz_,_cy_];
            case 66:return [0,l1,_cB_,_cA_];
            case 67:return [0,l1,_cD_,_cC_];
            case 68:return [0,l1,_cF_,_cE_];
            case 69:return [0,l1,_cH_,_cG_];
            case 70:return [0,l1,_cJ_,_cI_];
            case 71:return [0,l1,_cL_,_cK_];
            case 72:return [0,l1,_cN_,_cM_];
            case 73:return [0,l1,_cP_,_cO_];
            case 74:return [0,l1,_cR_,_cQ_];
            case 75:return [0,l1,_cT_,_cS_];
            case 76:return [0,l1,_cV_,_cU_];
            case 77:return [0,l1,_cX_,_cW_];
            case 78:return [0,l1,_cZ_,_cY_];
            case 79:return [0,l1,_c1_,_c0_];
            case 80:return [0,l1,_c3_,_c2_];
            case 81:return [0,l1,_c5_,_c4_];
            case 82:return [0,l1,_c7_,_c6_];
            case 83:return [0,l1,_c9_,_c8_];
            case 84:return [0,l1,_c$_,_c__];
            case 85:return [0,l1,_db_,_da_];
            case 86:return [0,l1,_dd_,_dc_];
            case 87:return [0,l1,_df_,_de_];
            case 88:return [0,l1,_dh_,_dg_];
            case 89:return [0,l1,_dj_,_di_];
            case 90:return [0,l1,_dl_,_dk_];
            case 91:return [0,l1,_dn_,_dm_];
            case 92:return [0,l1,_dp_,_do_];
            case 93:return [0,l1,_dr_,_dq_];
            case 94:return [0,l1,_dt_,_ds_];
            default:return [0,l1,_dv_,_du_]}}
        if(32 <= _vf_)
         switch(_vf_)
          {case 32:
            var _u9_=next_byte(0);
            return [0,l2,_bF_,[30,1,caml_call1(_e_[1],_u9_)]];
           case 33:return [0,l3,_bH_,[1,_bG_,[1,next_word(0)]]];
           case 34:return [0,l1,_bJ_,_bI_];
           case 35:return [0,l1,_bL_,_bK_];
           case 36:return [0,l1,_bN_,_bM_];
           case 37:return [0,l1,_bP_,_bO_];
           case 38:return [0,l2,_bR_,[0,_bQ_,[0,next_byte(0)]]];
           case 39:return [0,l1,_bS_,0];
           case 40:
            var _u__=next_byte(0);
            return [0,l2,_bT_,[30,2,caml_call1(_e_[1],_u__)]];
           case 41:return [0,l1,_bV_,_bU_];
           case 42:return [0,l1,_bX_,_bW_];
           case 43:return [0,l1,_bZ_,_bY_];
           case 44:return [0,l1,_b1_,_b0_];
           case 45:return [0,l1,_b3_,_b2_];
           case 46:return [0,l2,_b5_,[0,_b4_,[0,next_byte(0)]]];
           case 47:return [0,l1,_b6_,1];
           case 48:
            var _u$_=next_byte(0);
            return [0,l2,_b7_,[30,3,caml_call1(_e_[1],_u$_)]];
           case 49:return [0,l3,_b8_,[1,3,[1,next_word(0)]]];
           case 50:return [0,l1,_b__,_b9_];
           case 51:return [0,l1,_ca_,_b$_];
           case 52:return [0,l1,_cc_,_cb_];
           case 53:return [0,l1,_ce_,_cd_];
           case 54:return [0,l2,_cg_,[0,_cf_,[0,next_byte(0)]]];
           case 55:return [0,l1,_ch_,3];
           case 56:
            var _va_=next_byte(0);
            return [0,l2,_ci_,[30,4,caml_call1(_e_[1],_va_)]];
           case 57:return [0,l1,_ck_,_cj_];
           case 58:return [0,l1,_cm_,_cl_];
           case 59:return [0,l1,_co_,_cn_];
           case 60:return [0,l1,_cq_,_cp_];
           case 61:return [0,l1,_cs_,_cr_];
           case 62:return [0,l2,_cu_,[0,_ct_,[0,next_byte(0)]]];
           default:return [0,l1,_cv_,2]}
        switch(_vf_)
         {case 0:return [0,l1,_aN_,4];
          case 1:return [0,l3,_aP_,[1,_aO_,[1,next_word(0)]]];
          case 2:return [0,l1,_aR_,_aQ_];
          case 3:return [0,l1,_aT_,_aS_];
          case 4:return [0,l1,_aV_,_aU_];
          case 5:return [0,l1,_aX_,_aW_];
          case 6:return [0,l2,_aZ_,[0,_aY_,[0,next_byte(0)]]];
          case 7:return [0,l1,_a0_,9];
          case 8:return [0,l3,_a1_,[1,[3,next_word(0)],3]];
          case 9:return [0,l1,_a3_,_a2_];
          case 10:return [0,l1,_a5_,_a4_];
          case 11:return [0,l1,_a7_,_a6_];
          case 12:return [0,l1,_a9_,_a8_];
          case 13:return [0,l1,_a$_,_a__];
          case 14:return [0,l2,_bb_,[0,_ba_,[0,next_byte(0)]]];
          case 15:return [0,l1,_bc_,11];
          case 16:next_byte(0);return [0,l2,_bd_,6];
          case 17:return [0,l3,_bf_,[1,_be_,[1,next_word(0)]]];
          case 18:return [0,l1,_bh_,_bg_];
          case 19:return [0,l1,_bj_,_bi_];
          case 20:return [0,l1,_bl_,_bk_];
          case 21:return [0,l1,_bn_,_bm_];
          case 22:return [0,l2,_bp_,[0,_bo_,[0,next_byte(0)]]];
          case 23:return [0,l1,_bq_,10];
          case 24:
           var _u8_=next_byte(0);
           return [0,l2,_br_,[30,0,caml_call1(_e_[1],_u8_)]];
          case 25:return [0,l1,_bt_,_bs_];
          case 26:return [0,l1,_bv_,_bu_];
          case 27:return [0,l1,_bx_,_bw_];
          case 28:return [0,l1,_bz_,_by_];
          case 29:return [0,l1,_bB_,_bA_];
          case 30:return [0,l2,_bD_,[0,_bC_,[0,next_byte(0)]]];
          default:return [0,l1,_bE_,12]}}
      return [0,f]}
    var Camlboy_lib_Fetch_and_decode=[0,_pZ_];
    caml_register_global
     (1237,Camlboy_lib_Fetch_and_decode,"Camlboy_lib__Fetch_and_decode");
    function show$6(param)
     {switch(param)
       {case 0:return cst_ROM_ONLY;
        case 1:return cst_MBC1;
        case 2:return cst_MBC1_RAM;
        case 3:return cst_MBC1_RAM_BATTERY;
        case 4:return cst_MBC2;
        case 5:return cst_MBC2_BATTERY;
        case 6:return cst_MBC3_TIMER_BATTERY;
        case 7:return cst_MBC3_TIMER_RAM_BATTERY;
        default:return cst_MBC3}}
    var Camlboy_lib_Cartridge_type=[0,show$6];
    caml_register_global
     (1238,Camlboy_lib_Cartridge_type,"Camlboy_lib__Cartridge_type");
    function create$15(rom_bytes)
     {var x=caml_ba_get_1(rom_bytes,327);
      if(! (17 < x >>> 0))
       {var switch$0=0;
        switch(x)
         {case 0:var cartridge_type=0;break;
          case 1:var cartridge_type=1;break;
          case 2:var cartridge_type=2;break;
          case 3:var cartridge_type=3;break;
          case 5:var cartridge_type=4;break;
          case 6:var cartridge_type=5;break;
          case 15:var cartridge_type=6;break;
          case 16:var cartridge_type=7;break;
          case 17:var cartridge_type=8;break;
          default:switch$0 = 1}
        if(! switch$0)
         {var match=caml_ba_get_1(rom_bytes,328);
          if(8 < match >>> 0)throw [0,Assert_failure,_p1_];
          switch(match)
           {case 0:var rom_bank_count=2;break;
            case 1:var rom_bank_count=4;break;
            case 2:var rom_bank_count=8;break;
            case 3:var rom_bank_count=16;break;
            case 4:var rom_bank_count=32;break;
            case 5:var rom_bank_count=64;break;
            case 6:var rom_bank_count=128;break;
            case 7:var rom_bank_count=256;break;
            default:var rom_bank_count=512}
          var match$0=caml_ba_get_1(rom_bytes,329);
          if(5 < match$0 >>> 0)throw [0,Assert_failure,_p2_];
          switch(match$0)
           {case 0:var ram_bank_count=0;break;
            case 1:var ram_bank_count=1;break;
            case 2:var ram_bank_count=1;break;
            case 3:var ram_bank_count=4;break;
            case 4:var ram_bank_count=16;break;
            default:var ram_bank_count=8}
          return [0,cartridge_type,rom_bank_count,ram_bank_count]}}
      var _u5_=caml_call2(Stdlib_Printf[4],_p0_,x);
      throw [0,Stdlib[6],_u5_]}
    function get_cartridge_type(t){return t[1]}
    function get_rom_bank_count(t){return t[2]}
    function get_ram_bank_count(t){return t[3]}
    var
     Camlboy_lib_Cartridge_header=
      [0,create$15,get_cartridge_type,get_rom_bank_count,get_ram_bank_count];
    caml_register_global
     (1239,Camlboy_lib_Cartridge_header,"Camlboy_lib__Cartridge_header");
    var Camlboy_lib_Cartridge_intf=[0];
    caml_register_global
     (1240,Camlboy_lib_Cartridge_intf,"Camlboy_lib__Cartridge_intf");
    function create$16(rom_bytes)
     {var
       h=create$15(rom_bytes),
       rom_bank_size=h[2],
       ram_bank_size=h[3],
       ram_bytes=caml_call1(Bigstringaf[1],ram_bank_size * 8192 | 0);
      return [0,rom_bytes,ram_bytes,rom_bank_size,ram_bank_size,0,1,0,0]}
    function ram_addr_of_addr(t,addr)
     {var _u3_=t[4];
      if(t[8] && 1 !== _u3_)
       {if(4 === _u3_)return (8192 * t[7] | 0) + (addr - 40960 | 0) | 0;
        var _u4_=caml_call2(Stdlib_Printf[4],_p5_,_u3_);
        throw [0,Stdlib[6],_u4_]}
      return (addr - 40960 | 0) % 8192 | 0}
    function read_byte$14(t,addr)
     {var addr$0=caml_call1(_f_[21],addr);
      if(0 <= addr$0 && ! (16383 < addr$0))
       {var _uY_=t[3];
        if(t[8] && 32 < _uY_)
         if(64 === _uY_)
          var zero_bank_num=(t[7] & 1) << 5;
         else
          {if(128 !== _uY_)throw [0,Assert_failure,_p3_];
           var zero_bank_num=(t[7] & 3) << 5}
        else
         var zero_bank_num=0;
        var _uZ_=caml_ba_get_1(t[1],(16384 * zero_bank_num | 0) + addr$0 | 0);
        return caml_call1(_g_[36],_uZ_)}
      if(16384 <= addr$0 && ! (32767 < addr$0))
       {var n=t[3];
        if(32 < n)
         if(64 === n)
          var bit5=(t[7] & 1) << 5,high_bank_num=bit5 | t[6];
         else
          {if(128 !== n)throw [0,Assert_failure,_p4_];
           var bit56=(t[7] & 3) << 5,high_bank_num=bit56 | t[6]}
        else
         var high_bank_num=t[6];
        var
         _u0_=
          caml_ba_get_1
           (t[1],(16384 * high_bank_num | 0) + (addr$0 - 16384 | 0) | 0);
        return caml_call1(_g_[36],_u0_)}
      if(40960 <= addr$0 && ! (49151 < addr$0))
       {if(t[5] && 0 < t[4])
         {var _u1_=ram_addr_of_addr(t,addr$0),_u2_=caml_ba_get_1(t[2],_u1_);
          return caml_call1(_g_[36],_u2_)}
        return caml_call1(_g_[20],255)}
      throw [0,Assert_failure,_p6_]}
    function write_byte$14(t,addr,data)
     {var addr$0=caml_call1(_f_[21],addr),data$0=caml_call1(_g_[21],data);
      if(0 <= addr$0 && ! (8191 < addr$0)){t[5] = 10 === data$0?1:0;return 0}
      if(8192 <= addr$0 && ! (16383 < addr$0))
       {var _uV_=t[3],switch$0=0;
        if(33 <= _uV_)
         if(64 === _uV_ || 128 === _uV_)var _uW_=31;else switch$0 = 1;
        else
         if(17 <= _uV_)
          if(32 <= _uV_)var _uW_=31;else switch$0 = 1;
         else
          if(2 <= _uV_)
           {var switcher=_uV_ - 2 | 0;
            switch(switcher)
             {case 0:var _uW_=1;break;
              case 2:var _uW_=3;break;
              case 6:var _uW_=7;break;
              case 14:var _uW_=15;break;
              default:switch$0 = 1}}
          else
           switch$0 = 1;
        if(switch$0)
         {var _uQ_=caml_call2(Stdlib_Printf[4],_p7_,_uV_);
          throw [0,Stdlib[6],_uQ_]}
        var rom_bank_num=data$0 & _uW_,_uX_=0 === rom_bank_num?1:rom_bank_num;
        t[6] = _uX_;
        return 0}
      if(16384 <= addr$0 && ! (24575 < addr$0)){t[7] = data$0 & 3;return 0}
      if(24576 <= addr$0 && ! (32767 < addr$0))
       {var _uU_=0 === (data$0 & 1)?0:1;t[8] = _uU_;return 0}
      if(40960 <= addr$0 && ! (49151 < addr$0))
       {var _uR_=t[5],_uS_=_uR_?0 < t[4]?1:0:_uR_;
        if(_uS_)
         var
          ram_addr=ram_addr_of_addr(t,addr$0),
          _uT_=caml_ba_set_1(t[2],ram_addr,data$0);
        else
         var _uT_=_uS_;
        return _uT_}
      throw [0,Assert_failure,_p8_]}
    function accepts$14(param,addr)
     {var
       addr$0=caml_call1(_f_[21],addr),
       _uM_=0 <= addr$0?1:0,
       _uN_=_uM_?addr$0 <= 32767?1:0:_uM_;
      if(_uN_)
       var _uO_=_uN_;
      else
       var _uP_=40960 <= addr$0?1:0,_uO_=_uP_?addr$0 <= 49151?1:0:_uP_;
      return _uO_}
    var
     Camlboy_lib_Cartridge_mbc1=
      [0,create$16,read_byte$14,write_byte$14,accepts$14];
    caml_register_global
     (1241,Camlboy_lib_Cartridge_mbc1,"Camlboy_lib__Cartridge_mbc1");
    function create$17(rom_bytes){return [0,rom_bytes]}
    function read_byte$15(t,addr)
     {var addr$0=caml_call1(_f_[21],addr);
      if(0 <= addr$0 && ! (32767 < addr$0))
       {var _uL_=caml_ba_get_1(t[1],addr$0);return caml_call1(_g_[36],_uL_)}
      throw [0,Stdlib[6],cst_Address_out_of_bounds$5]}
    function write_byte$15(param,_uK_,_uJ_){return 0}
    function accepts$15(param,addr)
     {var
       addr$0=caml_call1(_f_[21],addr),
       _uH_=0 <= addr$0?1:0,
       _uI_=_uH_?addr$0 <= 32767?1:0:_uH_;
      return _uI_}
    var
     Camlboy_lib_Cartridge_rom_only=
      [0,create$17,read_byte$15,write_byte$15,accepts$15];
    caml_register_global
     (1242,Camlboy_lib_Cartridge_rom_only,"Camlboy_lib__Cartridge_rom_only");
    function f$0(rom_bytes)
     {var type=create$15(rom_bytes)[1];
      if(type)
       {if(4 <= type)throw [0,Assert_failure,_p9_];
        return Camlboy_lib_Cartridge_mbc1}
      return Camlboy_lib_Cartridge_rom_only}
    var Camlboy_lib_Detect_cartridge=[0,f$0];
    caml_register_global
     (1243,Camlboy_lib_Detect_cartridge,"Camlboy_lib__Detect_cartridge");
    function _q__(Mmu)
     {function show(t)
       {var
         _uE_=caml_call1(_f_[1],t[2]),
         _uF_=caml_call1(_f_[1],t[3]),
         _uG_=show$3(t[1]);
        return caml_call4(Stdlib_Printf[4],_p__,_uG_,_uF_,_uE_)}
      function create(mmu,ic,registers,sp,pc,halted,ime)
       {return [0,registers,pc,sp,mmu,halted,ime,0,4,ic]}
      function execute(t,mcycles,inst)
       {var _rY_=t[1];
        function set_flags$0(_uz_,_uA_,_uB_,_uC_,_uD_)
         {return set_flags(_rY_,_uz_,_uA_,_uB_,_uC_,_uD_)}
        function read(arg)
         {if(typeof arg === "number")
           switch(arg)
            {case 0:
              var
               c=read_r(t[1],2),
               _ut_=caml_call1(_f_[36],c),
               _uu_=caml_call1(_f_[20],65280),
               addr=caml_call2(_f_[23],_uu_,_ut_);
              return caml_call2(Mmu[1],t[4],addr);
             case 1:
              var addr$0=read_rr(t[1],3),_uv_=caml_call1(_f_[13],addr$0);
              write_rr(t[1],3,_uv_);
              return caml_call2(Mmu[1],t[4],addr$0);
             case 2:
              var addr$1=read_rr(t[1],3),_uw_=caml_call1(_f_[14],addr$1);
              write_rr(t[1],3,_uw_);
              return caml_call2(Mmu[1],t[4],addr$1);
             default:return t[3]}
          else
           switch(arg[0])
            {case 0:var n=arg[1];return n;
             case 1:var n$0=arg[1];return n$0;
             case 2:var addr$2=arg[1];return caml_call2(Mmu[1],t[4],addr$2);
             case 3:var addr$3=arg[1];return caml_call2(Mmu[4],t[4],addr$3);
             case 4:var r=arg[1];return read_r(t[1],r);
             case 5:var rr=arg[1];return read_rr(t[1],rr);
             case 6:
              var rr$0=arg[1],addr$4=read_rr(t[1],rr$0);
              return caml_call2(Mmu[1],t[4],addr$4);
             case 7:
              var
               n$1=arg[1],
               _ux_=caml_call1(_f_[36],n$1),
               _uy_=caml_call1(_f_[20],65280),
               addr$5=caml_call2(_f_[23],_uy_,_ux_);
              return caml_call2(Mmu[1],t[4],addr$5);
             default:
              var
               n$2=arg[1],
               sp=caml_call1(_f_[21],t[3]),
               n$3=caml_call1(_e_[3],n$2);
              set_flags$0
               ([0,255 < ((sp & 255) + (n$3 & 255) | 0)?1:0],
                [0,15 < ((sp & 15) + (n$3 & 15) | 0)?1:0],
                _qa_,
                _p$_,
                0);
              return caml_call1(_f_[20],sp + n$3 | 0)}}
        function symbol(x,y)
         {if(typeof x === "number")
           switch(x)
            {case 0:
              var
               c=read_r(t[1],2),
               _um_=caml_call1(_f_[36],c),
               _un_=caml_call1(_f_[20],65280),
               addr=caml_call2(_f_[23],_un_,_um_);
              return caml_call3(Mmu[2],t[4],addr,y);
             case 1:
              var addr$0=read_rr(t[1],3);
              caml_call3(Mmu[2],t[4],addr$0,y);
              var _uo_=caml_call1(_f_[13],addr$0);
              return write_rr(t[1],3,_uo_);
             case 2:
              var addr$1=read_rr(t[1],3);
              caml_call3(Mmu[2],t[4],addr$1,y);
              var _up_=caml_call1(_f_[14],addr$1);
              return write_rr(t[1],3,_up_);
             default:t[3] = y;return 0}
          else
           switch(x[0])
            {case 2:var addr$2=x[1];return caml_call3(Mmu[2],t[4],addr$2,y);
             case 3:var addr$3=x[1];return caml_call3(Mmu[5],t[4],addr$3,y);
             case 4:var r=x[1];return write_r(t[1],r,y);
             case 5:var rr=x[1];return write_rr(t[1],rr,y);
             case 6:
              var rr$0=x[1],addr$4=read_rr(t[1],rr$0);
              return caml_call3(Mmu[2],t[4],addr$4,y);
             case 7:
              var
               n=x[1],
               _ur_=caml_call1(_f_[36],n),
               _us_=caml_call1(_f_[20],65280),
               addr$5=caml_call2(_f_[23],_us_,_ur_);
              return caml_call3(Mmu[2],t[4],addr$5,y);
             default:
              var _uq_=caml_call1(Stdlib_Printf[4],_qb_);
              return caml_call1(Stdlib[2],_uq_)}}
        function check_condition(t,param)
         {switch(param)
           {case 0:return 1;
            case 1:return 1 - read_flag(t[1],3);
            case 2:return read_flag(t[1],3);
            case 3:return 1 - read_flag(t[1],0);
            default:return read_flag(t[1],0)}}
        if(typeof inst === "number")
         switch(inst)
          {case 0:
            var
             n_flag=read_flag(t[1],2),
             c_flag=read_flag(t[1],0),
             h_flag=read_flag(t[1],1),
             a=[0,read_r(t[1],0)];
            if(n_flag)
             {if(c_flag)
               {var _rZ_=caml_call1(_g_[20],96);
                a[1] = caml_call2(_g_[24],a[1],_rZ_)}
              if(h_flag)
               {var _r0_=caml_call1(_g_[20],6);
                a[1] = caml_call2(_g_[24],a[1],_r0_)}}
            else
             {if(c_flag)
               var c_flag$0=c_flag;
              else
               var
                _r5_=caml_call1(_g_[20],153),
                c_flag$0=caml_greaterthan(a[1],_r5_);
              if(c_flag$0)
               {var _r1_=caml_call1(_g_[20],96);
                a[1] = caml_call2(_g_[23],a[1],_r1_);
                set_flags$0(_qd_,0,0,0,0)}
              if(h_flag)
               var h_flag$0=h_flag;
              else
               var
                _r3_=caml_call1(_g_[20],9),
                _r4_=caml_call1(_g_[20],15),
                h_flag$0=caml_greaterthan(caml_call2(_g_[31],a[1],_r4_),_r3_);
              if(h_flag$0)
               {var _r2_=caml_call1(_g_[20],6);
                a[1] = caml_call2(_g_[23],a[1],_r2_)}}
            set_flags$0(0,_qc_,0,[0,caml_call2(_g_[27],a[1],_g_[3])],0);
            write_r(t[1],0,a[1]);
            var next_pc=0;
            break;
           case 1:
            set_flags$0(0,_qf_,_qe_,0,0);
            var n=read_r(t[1],0),_r6_=caml_call2(_g_[33],n,_g_[2]);
            write_r(t[1],0,_r6_);
            var next_pc=0;
            break;
           case 2:
            var c=read_flag(t[1],0);
            set_flags$0([0,1 - c],_qh_,_qg_,0,0);
            var next_pc=0;
            break;
           case 3:set_flags$0(_qk_,_qj_,_qi_,0,0);var next_pc=0;break;
           case 4:var next_pc=0;break;
           case 5:t[5] = 1;var next_pc=0;break;
           case 6:throw [0,Assert_failure,_ql_];
           case 7:t[7] = 0;t[6] = 0;var next_pc=0;break;
           case 8:t[7] = 1;var next_pc=0;break;
           case 9:
            var
             a$0=read_r(t[1],0),
             _r7_=_g_[3],
             _r8_=caml_call1(_g_[20],128),
             _r9_=caml_call2(_g_[31],a$0,_r8_),
             c$0=caml_call2(_g_[28],_r9_,_r7_),
             _r__=c$0?_g_[4]:_g_[3],
             _r$_=caml_call2(_g_[34],a$0,1),
             n$0=caml_call2(_g_[32],_r$_,_r__);
            write_r(t[1],0,n$0);
            set_flags$0([0,c$0],_qo_,_qn_,_qm_,0);
            var next_pc=0;
            break;
           case 10:
            var
             a$1=read_r(t[1],0),
             old_c=read_flag(t[1],0),
             _sa_=old_c?_g_[4]:_g_[3],
             _sb_=caml_call2(_g_[34],a$1,1),
             n$1=caml_call2(_g_[32],_sb_,_sa_);
            write_r(t[1],0,n$1);
            var
             _sc_=_g_[3],
             _sd_=caml_call1(_g_[20],128),
             _se_=caml_call2(_g_[31],a$1,_sd_),
             new_c=caml_call2(_g_[28],_se_,_sc_);
            set_flags$0([0,new_c],_qr_,_qq_,_qp_,0);
            var next_pc=0;
            break;
           case 11:
            var
             a$2=read_r(t[1],0),
             _sf_=_g_[3],
             _sg_=caml_call1(_g_[20],1),
             _sh_=caml_call2(_g_[31],a$2,_sg_),
             c$1=caml_call2(_g_[28],_sh_,_sf_),
             _si_=c$1?caml_call1(_g_[20],128):_g_[3],
             _sj_=caml_call2(_g_[35],a$2,1),
             n$2=caml_call2(_g_[32],_sj_,_si_);
            write_r(t[1],0,n$2);
            set_flags$0([0,c$1],_qu_,_qt_,_qs_,0);
            var next_pc=0;
            break;
           case 12:
            var
             a$3=read_r(t[1],0),
             old_c$0=read_flag(t[1],0),
             _sk_=old_c$0?caml_call1(_g_[20],128):_g_[3],
             _sl_=caml_call2(_g_[35],a$3,1),
             n$3=caml_call2(_g_[32],_sl_,_sk_);
            write_r(t[1],0,n$3);
            var
             _sm_=_g_[3],
             _sn_=caml_call1(_g_[20],1),
             _so_=caml_call2(_g_[31],a$3,_sn_),
             new_c$0=caml_call2(_g_[28],_so_,_sm_);
            set_flags$0([0,new_c$0],_qx_,_qw_,_qv_,0);
            var next_pc=0;
            break;
           default:
            var
             addr$0=caml_call2(Mmu[4],t[4],t[3]),
             _sp_=caml_call1(_f_[20],2);
            t[3] = caml_call2(_f_[23],t[3],_sp_);
            t[6] = 1;
            var next_pc=[0,addr$0]}
        else
         switch(inst[0])
          {case 0:
            var y=inst[2],x=inst[1];symbol(x,read(y));var next_pc=0;break;
           case 1:
            var y$0=inst[2],x$0=inst[1];
            symbol(x$0,read(y$0));
            var next_pc=0;
            break;
           case 2:
            var
             y$1=inst[2],
             x$1=inst[1],
             y$2=read(y$1),
             x$2=read(x$1),
             n$4=caml_call2(_g_[23],x$2,y$2),
             _sq_=[0,caml_equal(n$4,_g_[3])],
             _sr_=caml_call1(_g_[20],15),
             _ss_=caml_call1(_g_[20],15),
             _st_=caml_call2(_g_[31],y$2,_ss_),
             _su_=caml_call1(_g_[20],15),
             _sv_=caml_call2(_g_[31],x$2,_su_),
             _sw_=[0,caml_greaterthan(caml_call2(_g_[23],_sv_,_st_),_sr_)],
             _sx_=caml_call1(_g_[20],255);
            set_flags$0
             ([0,caml_greaterthan(x$2,caml_call2(_g_[24],_sx_,y$2))],
              _sw_,
              _qy_,
              _sq_,
              0);
            symbol(x$1,n$4);
            var next_pc=0;
            break;
           case 3:
            var
             y$3=inst[2],
             x$3=inst[1],
             y$4=read(y$3),
             x$4=read(x$3),
             n$5=caml_call2(_f_[23],x$4,y$4),
             _sy_=caml_call1(_f_[20],4095),
             _sz_=caml_call1(_f_[20],4095),
             _sA_=caml_call2(_f_[31],y$4,_sz_),
             _sB_=caml_call1(_f_[20],4095),
             _sC_=caml_call2(_f_[31],x$4,_sB_),
             _sD_=[0,caml_greaterthan(caml_call2(_f_[23],_sC_,_sA_),_sy_)],
             _sE_=caml_call1(_f_[20],65535);
            set_flags$0
             ([0,caml_greaterthan(x$4,caml_call2(_f_[24],_sE_,y$4))],
              _sD_,
              _qz_,
              0,
              0);
            symbol(x$3,n$5);
            var next_pc=0;
            break;
           case 4:
            var
             y$5=inst[1],
             _sF_=read(3),
             x$5=caml_call1(_f_[21],_sF_),
             y$6=caml_call1(_e_[3],y$5);
            set_flags$0
             ([0,255 < ((x$5 & 255) + (y$6 & 255) | 0)?1:0],
              [0,15 < ((x$5 & 15) + (y$6 & 15) | 0)?1:0],
              _qB_,
              _qA_,
              0);
            symbol(3,caml_call1(_f_[20],x$5 + y$6 | 0));
            var next_pc=0;
            break;
           case 5:
            var
             y$7=inst[2],
             x$6=inst[1],
             c$2=read_flag(t[1],0)?_g_[4]:_g_[3],
             y$8=read(y$7),
             x$7=read(x$6),
             _sG_=caml_call2(_g_[23],x$7,y$8),
             n$6=caml_call2(_g_[23],_sG_,c$2),
             _sH_=[0,caml_equal(n$6,_g_[3])],
             _sI_=caml_call1(_g_[20],15),
             _sJ_=caml_call1(_g_[20],15),
             _sK_=caml_call2(_g_[31],y$8,_sJ_),
             _sL_=caml_call1(_g_[20],15),
             _sM_=caml_call2(_g_[31],x$7,_sL_),
             _sN_=caml_call2(_g_[23],_sM_,_sK_),
             _sO_=[0,caml_greaterthan(caml_call2(_g_[23],_sN_,c$2),_sI_)],
             _sP_=caml_call1(_g_[21],c$2),
             _sQ_=caml_call1(_g_[21],y$8);
            set_flags$0
             ([0,255 < ((caml_call1(_g_[21],x$7) + _sQ_ | 0) + _sP_ | 0)?1:0],
              _sO_,
              _qC_,
              _sH_,
              0);
            symbol(x$6,n$6);
            var next_pc=0;
            break;
           case 6:
            var
             y$9=inst[2],
             x$8=inst[1],
             y$10=read(y$9),
             x$9=read(x$8),
             n$7=caml_call2(_g_[24],x$9,y$10),
             _sR_=[0,caml_equal(n$7,_g_[3])],
             _sS_=caml_call1(_g_[20],15),
             _sT_=caml_call2(_g_[31],y$10,_sS_),
             _sU_=caml_call1(_g_[20],15),
             _sV_=[0,caml_lessthan(caml_call2(_g_[31],x$9,_sU_),_sT_)],
             _sW_=caml_call1(_g_[21],y$10);
            set_flags$0
             ([0,caml_call1(_g_[21],x$9) < _sW_?1:0],_sV_,_qD_,_sR_,0);
            symbol(x$8,n$7);
            var next_pc=0;
            break;
           case 7:
            var
             y$11=inst[2],
             x$10=inst[1],
             c$3=read_flag(t[1],0)?_g_[4]:_g_[3],
             y$12=read(y$11),
             x$11=read(x$10),
             _sX_=caml_call2(_g_[23],y$12,c$3),
             n$8=caml_call2(_g_[24],x$11,_sX_),
             _sY_=[0,caml_equal(n$8,_g_[3])],
             _sZ_=caml_call1(_g_[20],15),
             _s0_=caml_call2(_g_[31],y$12,_sZ_),
             _s1_=caml_call2(_g_[23],_s0_,c$3),
             _s2_=caml_call1(_g_[20],15),
             _s3_=[0,caml_lessthan(caml_call2(_g_[31],x$11,_s2_),_s1_)],
             _s4_=caml_call1(_g_[21],c$3),
             _s5_=caml_call1(_g_[21],y$12) + _s4_ | 0;
            set_flags$0
             ([0,caml_call1(_g_[21],x$11) < _s5_?1:0],_s3_,_qE_,_sY_,0);
            symbol(x$10,n$8);
            var next_pc=0;
            break;
           case 8:
            var
             y$13=inst[2],
             x$12=inst[1],
             _s6_=read(y$13),
             _s7_=read(x$12),
             n$9=caml_call2(_g_[31],_s7_,_s6_);
            set_flags$0(_qH_,_qG_,_qF_,[0,caml_equal(n$9,_g_[3])],0);
            symbol(x$12,n$9);
            var next_pc=0;
            break;
           case 9:
            var
             y$14=inst[2],
             x$13=inst[1],
             _s8_=read(y$14),
             _s9_=read(x$13),
             n$10=caml_call2(_g_[32],_s9_,_s8_);
            set_flags$0(_qK_,_qJ_,_qI_,[0,caml_equal(n$10,_g_[3])],0);
            symbol(x$13,n$10);
            var next_pc=0;
            break;
           case 10:
            var
             y$15=inst[2],
             x$14=inst[1],
             _s__=read(y$15),
             _s$_=read(x$14),
             n$11=caml_call2(_g_[33],_s$_,_s__);
            set_flags$0(_qN_,_qM_,_qL_,[0,caml_equal(n$11,_g_[3])],0);
            symbol(x$14,n$11);
            var next_pc=0;
            break;
           case 11:
            var
             y$16=inst[2],
             x$15=inst[1],
             y$17=read(y$16),
             x$16=read(x$15),
             n$12=caml_call2(_g_[24],x$16,y$17),
             _ta_=[0,caml_equal(n$12,_g_[3])],
             _tb_=caml_call1(_g_[20],15),
             _tc_=caml_call2(_g_[31],y$17,_tb_),
             _td_=caml_call1(_g_[20],15),
             _te_=[0,caml_lessthan(caml_call2(_g_[31],x$16,_td_),_tc_)],
             _tf_=caml_call1(_g_[21],y$17);
            set_flags$0
             ([0,caml_call1(_g_[21],x$16) < _tf_?1:0],_te_,_qO_,_ta_,0);
            var next_pc=0;
            break;
           case 12:
            var
             x$17=inst[1],
             x$18=read(x$17),
             n$13=caml_call1(_g_[13],x$18),
             _tg_=[0,caml_equal(n$13,_g_[3])],
             _th_=caml_call1(_g_[20],15),
             _ti_=caml_call1(_g_[20],15),
             _tj_=caml_call2(_g_[31],x$18,_ti_);
            set_flags$0(0,[0,caml_call2(_g_[27],_tj_,_th_)],_qP_,_tg_,0);
            symbol(x$17,n$13);
            var next_pc=0;
            break;
           case 13:
            var x$19=inst[1],_tk_=read(x$19);
            symbol(x$19,caml_call1(_f_[13],_tk_));
            var next_pc=0;
            break;
           case 14:
            var
             x$20=inst[1],
             x$21=read(x$20),
             n$14=caml_call1(_g_[14],x$21),
             _tl_=[0,caml_equal(n$14,_g_[3])],
             _tm_=caml_call1(_g_[20],0),
             _tn_=caml_call1(_g_[20],15),
             _to_=caml_call2(_g_[31],x$21,_tn_);
            set_flags$0(0,[0,caml_call2(_g_[27],_to_,_tm_)],_qQ_,_tl_,0);
            symbol(x$20,n$14);
            var next_pc=0;
            break;
           case 15:
            var x$22=inst[1],_tp_=read(x$22);
            symbol(x$22,caml_call1(_f_[14],_tp_));
            var next_pc=0;
            break;
           case 16:
            var
             x$23=inst[1],
             x$24=read(x$23),
             _tq_=caml_call2(_g_[35],x$24,4),
             _tr_=caml_call2(_g_[34],x$24,4),
             n$15=caml_call2(_g_[32],_tr_,_tq_);
            set_flags$0(_qT_,_qS_,_qR_,[0,caml_equal(n$15,_g_[3])],0);
            symbol(x$23,n$15);
            var next_pc=0;
            break;
           case 17:
            var
             x$25=inst[1],
             x$26=read(x$25),
             _ts_=_g_[3],
             _tt_=caml_call1(_g_[20],128),
             _tu_=caml_call2(_g_[31],x$26,_tt_),
             c$4=caml_call2(_g_[28],_tu_,_ts_),
             _tv_=c$4?_g_[4]:_g_[3],
             _tw_=caml_call2(_g_[34],x$26,1),
             n$16=caml_call2(_g_[32],_tw_,_tv_);
            symbol(x$25,n$16);
            set_flags$0
             ([0,c$4],_qV_,_qU_,[0,caml_call2(_g_[27],n$16,_g_[3])],0);
            var next_pc=0;
            break;
           case 18:
            var
             x$27=inst[1],
             x$28=read(x$27),
             old_c$1=read_flag(t[1],0),
             _tx_=old_c$1?_g_[4]:_g_[3],
             _ty_=caml_call2(_g_[34],x$28,1),
             n$17=caml_call2(_g_[32],_ty_,_tx_);
            symbol(x$27,n$17);
            var
             _tz_=_g_[3],
             _tA_=caml_call1(_g_[20],128),
             _tB_=caml_call2(_g_[31],x$28,_tA_),
             new_c$1=caml_call2(_g_[28],_tB_,_tz_);
            set_flags$0
             ([0,new_c$1],_qX_,_qW_,[0,caml_call2(_g_[27],n$17,_g_[3])],0);
            var next_pc=0;
            break;
           case 19:
            var
             x$29=inst[1],
             x$30=read(x$29),
             _tC_=_g_[3],
             _tD_=caml_call1(_g_[20],1),
             _tE_=caml_call2(_g_[31],x$30,_tD_),
             c$5=caml_call2(_g_[28],_tE_,_tC_),
             _tF_=c$5?caml_call1(_g_[20],128):_g_[3],
             _tG_=caml_call2(_g_[35],x$30,1),
             n$18=caml_call2(_g_[32],_tG_,_tF_);
            symbol(x$29,n$18);
            set_flags$0
             ([0,c$5],_qZ_,_qY_,[0,caml_call2(_g_[27],n$18,_g_[3])],0);
            var next_pc=0;
            break;
           case 20:
            var
             x$31=inst[1],
             x$32=read(x$31),
             old_c$2=read_flag(t[1],0),
             _tH_=old_c$2?caml_call1(_g_[20],128):_g_[3],
             _tI_=caml_call2(_g_[35],x$32,1),
             n$19=caml_call2(_g_[32],_tI_,_tH_);
            symbol(x$31,n$19);
            var
             _tJ_=[0,caml_call2(_g_[27],n$19,_g_[3])],
             _tK_=_g_[3],
             _tL_=caml_call1(_g_[20],1),
             _tM_=caml_call2(_g_[31],x$32,_tL_);
            set_flags$0([0,caml_call2(_g_[28],_tM_,_tK_)],_q1_,_q0_,_tJ_,0);
            var next_pc=0;
            break;
           case 21:
            var x$33=inst[1],x$34=read(x$33),n$20=caml_call2(_g_[34],x$34,1);
            symbol(x$33,n$20);
            var
             _tN_=[0,caml_call2(_g_[27],n$20,_g_[3])],
             _tO_=_g_[3],
             _tP_=caml_call1(_g_[20],128),
             _tQ_=caml_call2(_g_[31],x$34,_tP_);
            set_flags$0([0,caml_call2(_g_[28],_tQ_,_tO_)],_q3_,_q2_,_tN_,0);
            var next_pc=0;
            break;
           case 22:
            var
             x$35=inst[1],
             x$36=read(x$35),
             _tR_=caml_call1(_g_[20],128),
             _tS_=caml_call2(_g_[31],x$36,_tR_),
             _tT_=caml_call2(_g_[35],x$36,1),
             n$21=caml_call2(_g_[32],_tT_,_tS_);
            symbol(x$35,n$21);
            var
             _tU_=[0,caml_call2(_g_[27],n$21,_g_[3])],
             _tV_=_g_[3],
             _tW_=caml_call1(_g_[20],1),
             _tX_=caml_call2(_g_[31],x$36,_tW_);
            set_flags$0([0,caml_call2(_g_[28],_tX_,_tV_)],_q5_,_q4_,_tU_,0);
            var next_pc=0;
            break;
           case 23:
            var x$37=inst[1],x$38=read(x$37),n$22=caml_call2(_g_[35],x$38,1);
            symbol(x$37,n$22);
            var
             _tY_=[0,caml_call2(_g_[27],n$22,_g_[3])],
             _tZ_=_g_[3],
             _t0_=caml_call1(_g_[20],1),
             _t1_=caml_call2(_g_[31],x$38,_t0_);
            set_flags$0([0,caml_call2(_g_[28],_t1_,_tZ_)],_q7_,_q6_,_tY_,0);
            var next_pc=0;
            break;
           case 24:
            var
             x$39=inst[2],
             n$23=inst[1],
             _t2_=_g_[3],
             _t3_=caml_call2(_g_[34],_g_[4],n$23),
             _t4_=read(x$39),
             _t5_=caml_call2(_g_[31],_t4_,_t3_),
             b=caml_call2(_g_[27],_t5_,_t2_);
            set_flags$0(0,_q9_,_q8_,[0,b],0);
            var next_pc=0;
            break;
           case 25:
            var
             x$40=inst[2],
             n$24=inst[1],
             _t6_=caml_call2(_g_[34],_g_[4],n$24),
             _t7_=read(x$40);
            symbol(x$40,caml_call2(_g_[32],_t7_,_t6_));
            var next_pc=0;
            break;
           case 26:
            var
             x$41=inst[2],
             n$25=inst[1],
             _t8_=caml_call1(_g_[20],255),
             _t9_=caml_call2(_g_[34],_g_[4],n$25),
             mask=caml_call2(_g_[33],_t9_,_t8_),
             _t__=read(x$41);
            symbol(x$41,caml_call2(_g_[31],_t__,mask));
            var next_pc=0;
            break;
           case 27:
            var rr=inst[1],_t$_=caml_call1(_f_[20],2);
            t[3] = caml_call2(_f_[24],t[3],_t$_);
            var _ua_=read_rr(t[1],rr);
            caml_call3(Mmu[5],t[4],t[3],_ua_);
            var next_pc=0;
            break;
           case 28:
            var rr$0=inst[1],_ub_=caml_call2(Mmu[4],t[4],t[3]);
            write_rr(t[1],rr$0,_ub_);
            var _uc_=caml_call1(_f_[20],2);
            t[3] = caml_call2(_f_[23],t[3],_uc_);
            var next_pc=0;
            break;
           case 29:
            var
             x$42=inst[2],
             c$6=inst[1],
             _ud_=check_condition(t,c$6)?[0,read(x$42)]:0,
             next_pc=_ud_;
            break;
           case 30:
            var x$43=inst[2],c$7=inst[1];
            if(check_condition(t,c$7))
             var
              _ue_=caml_call1(_e_[3],x$43),
              _uf_=caml_call1(_f_[21],t[2]) + _ue_ | 0,
              addr$1=caml_call1(_f_[20],_uf_),
              _ug_=[0,addr$1];
            else
             var _ug_=0;
            var next_pc=_ug_;
            break;
           case 31:
            var x$44=inst[2],c$8=inst[1];
            if(check_condition(t,c$8))
             {var _uh_=caml_call1(_f_[20],2);
              t[3] = caml_call2(_f_[24],t[3],_uh_);
              caml_call3(Mmu[5],t[4],t[3],t[2]);
              var _ui_=[0,x$44]}
            else
             var _ui_=0;
            var next_pc=_ui_;
            break;
           case 32:
            var x$45=inst[1],_uj_=caml_call1(_f_[20],2);
            t[3] = caml_call2(_f_[24],t[3],_uj_);
            caml_call3(Mmu[5],t[4],t[3],t[2]);
            var next_pc=[0,x$45];
            break;
           default:
            var c$9=inst[1];
            if(check_condition(t,c$9))
             {var
               addr$2=caml_call2(Mmu[4],t[4],t[3]),
               _uk_=caml_call1(_f_[20],2);
              t[3] = caml_call2(_f_[23],t[3],_uk_);
              var _ul_=[0,addr$2]}
            else
             var _ul_=0;
            var next_pc=_ul_}
        t[8] = inst;
        if(next_pc)
         {var branched_mcycle=mcycles[2],addr=next_pc[1];
          t[2] = addr;
          return branched_mcycle}
        var not_branched_mcycle=mcycles[1];
        return not_branched_mcycle}
      var Fetch_and_decode=_pZ_(Mmu);
      function run_instruction(t)
       {if(t[7]){t[6] = 1;t[7] = 0}
        if(t[5])
         var inst_mcycles=4;
        else
         {var
           match=caml_call2(Fetch_and_decode[1],t[4],t[2]),
           inst=match[3],
           mcycles=match[2],
           len=match[1];
          t[2] = caml_call2(_f_[23],t[2],len);
          var inst_mcycles=execute(t,mcycles,inst)}
        var match$0=next(t[9]);
        if(match$0)
         {var type=match$0[1];
          t[5] = 0;
          if(t[6])
           {t[6] = 0;
            clear(t[9],type);
            switch(type)
             {case 0:var addr=caml_call1(_f_[20],64);break;
              case 1:var addr=caml_call1(_f_[20],72);break;
              case 2:var addr=caml_call1(_f_[20],80);break;
              case 3:var addr=caml_call1(_f_[20],88);break;
              default:var addr=caml_call1(_f_[20],96)}
            var _rX_=caml_call1(_f_[20],2);
            t[3] = caml_call2(_f_[24],t[3],_rX_);
            caml_call3(Mmu[5],t[4],t[3],t[2]);
            t[2] = addr;
            var interrupt_mcycles=5}
          else
           var interrupt_mcycles=0}
        else
         var interrupt_mcycles=0;
        return inst_mcycles + interrupt_mcycles | 0}
      function prev_inst(t){return t[8]}
      var For_tests=[0,execute,prev_inst];
      return [0,show,create,run_instruction,For_tests]}
    var Camlboy_lib_Cpu=[0,_q__];
    caml_register_global(1244,Camlboy_lib_Cpu,"Camlboy_lib__Cpu");
    function create$18(rom_bytes)
     {var
       h=create$15(rom_bytes),
       ram_bank_size=h[3],
       ram_bytes=caml_call1(Bigstringaf[1],ram_bank_size * 8192 | 0);
      return [0,rom_bytes,ram_bytes,0,1,0]}
    function read_byte$16(t,addr)
     {var addr$0=caml_call1(_f_[21],addr);
      if(0 <= addr$0 && ! (16383 < addr$0))
       {var _rU_=caml_ba_get_1(t[1],addr$0);return caml_call1(_g_[36],_rU_)}
      if(16384 <= addr$0 && ! (32767 < addr$0))
       {var
         _rV_=
          caml_ba_get_1(t[1],(16384 * t[4] | 0) + (addr$0 - 16384 | 0) | 0);
        return caml_call1(_g_[36],_rV_)}
      if(40960 <= addr$0 && ! (49151 < addr$0))
       {if(t[3])
         {var
           _rW_=
            caml_ba_get_1(t[2],(16384 * t[4] | 0) + (addr$0 - 16384 | 0) | 0);
          return caml_call1(_g_[36],_rW_)}
        return caml_call1(_g_[20],255)}
      throw [0,Assert_failure,_q$_]}
    function write_byte$16(t,addr,data)
     {var addr$0=caml_call1(_f_[21],addr),data$0=caml_call1(_g_[21],data);
      if(0 <= addr$0 && ! (8191 < addr$0)){t[3] = 10 === data$0?1:0;return 0}
      if(8192 <= addr$0 && ! (16383 < addr$0))
       {var rom_bank_num=data$0 & 127,_rT_=0 === rom_bank_num?1:rom_bank_num;
        t[4] = _rT_;
        return 0}
      if(16384 <= addr$0 && ! (24575 < addr$0))
       {var
         _rQ_=0 <= data$0?1:0,
         _rR_=_rQ_?data$0 <= 3?1:0:_rQ_,
         _rS_=_rR_?(t[5] = data$0,0):_rR_;
        return _rS_}
      if(24576 <= addr$0 && ! (32767 < addr$0))return 0;
      if(40960 <= addr$0 && ! (49151 < addr$0))
       {var _rO_=t[3];
        if(_rO_)
         var
          ram_addr=(16384 * t[4] | 0) + (addr$0 - 16384 | 0) | 0,
          _rP_=caml_ba_set_1(t[2],ram_addr,data$0);
        else
         var _rP_=_rO_;
        return _rP_}
      throw [0,Assert_failure,_ra_]}
    function accepts$16(param,addr)
     {var
       addr$0=caml_call1(_f_[21],addr),
       _rK_=0 <= addr$0?1:0,
       _rL_=_rK_?addr$0 <= 32767?1:0:_rK_;
      if(_rL_)
       var _rM_=_rL_;
      else
       var _rN_=40960 <= addr$0?1:0,_rM_=_rN_?addr$0 <= 49151?1:0:_rN_;
      return _rM_}
    var
     Camlboy_lib_Cartridge_mbc3=
      [0,create$18,read_byte$16,write_byte$16,accepts$16];
    caml_register_global
     (1245,Camlboy_lib_Cartridge_mbc3,"Camlboy_lib__Cartridge_mbc3");
    var Camlboy_lib_Camlboy_intf=[0];
    caml_register_global
     (1246,Camlboy_lib_Camlboy_intf,"Camlboy_lib__Camlboy_intf");
    var
     Camlboy_lib_Camlboy=
      [0,
       function(Cartridge)
        {var
          Mmu=Make([0,Cartridge[2],Cartridge[3],Cartridge[4]]),
          Cpu=_q__([0,Mmu[2],Mmu[3],Mmu[4],Mmu[5],Mmu[6]]);
         function show(t){return caml_call1(Cpu[1],t[1])}
         var
          ly_addr=caml_call1(_f_[20],65348),
          lcd_stat_addr=caml_call1(_f_[20],65345);
         function create_with_rom(print_serial_port,rom_bytes)
          {var
            cartridge=caml_call1(Cartridge[1],rom_bytes),
            _rk_=caml_call1(_f_[20],57343),
            wram=create$3(caml_call1(_f_[20],49152),_rk_),
            _rl_=caml_call1(_f_[20],65023),
            _rm_=caml_call1(_f_[20],57344),
            shadow_ram=[0,wram,caml_call1(_f_[20],49152),_rm_,_rl_],
            _rn_=caml_call1(_f_[20],65534),
            zero_page=create$3(caml_call1(_f_[20],65408),_rn_),
            _ro_=create$5(caml_call1(_f_[20],65282),18373,0,0),
            serial_port=
             create$6
              (create$5(caml_call1(_f_[20],65281),18373,0,0),
               _ro_,
               [0,print_serial_port],
               0),
            _rp_=caml_call1(_f_[20],65295),
            ic=create(caml_call1(_f_[20],65535),_rp_),
            _rq_=caml_call1(_f_[20],38911),
            tile_data=create$2(caml_call1(_f_[20],32768),_rq_),
            _rr_=caml_call1(_f_[20],40959),
            _rs_=caml_call1(_f_[20],39936),
            _rt_=caml_call1(_f_[20],39935),
            tile_map=create$1(caml_call1(_f_[20],38912),_rt_,_rs_,_rr_),
            _ru_=caml_call1(_f_[20],65183),
            oam_table=create$9(caml_call1(_f_[20],65024),_ru_),
            lcd_stat=create$12(lcd_stat_addr),
            joypad=create$14(caml_call1(_f_[20],65280),ic),
            _rv_=caml_call1(_f_[20],65355),
            _rw_=caml_call1(_f_[20],65354),
            _rx_=caml_call1(_f_[20],65349),
            _ry_=caml_call1(_f_[20],65347),
            _rz_=
             create$11(caml_call1(_f_[20],65346),_ry_,ly_addr,_rx_,_rw_,_rv_),
            _rA_=create$10(caml_call1(_f_[20],65344)),
            _rB_=create$8(caml_call1(_f_[20],65353)),
            _rC_=create$8(caml_call1(_f_[20],65352)),
            gpu=
             create$13
              (tile_data,
               tile_map,
               oam_table,
               create$8(caml_call1(_f_[20],65351)),
               _rC_,
               _rB_,
               lcd_stat,
               _rA_,
               _rz_,
               ic),
            _rD_=caml_call1(_f_[20],65287),
            _rE_=caml_call1(_f_[20],65286),
            _rF_=caml_call1(_f_[20],65285),
            timer=create$0(caml_call1(_f_[20],65284),_rF_,_rE_,_rD_,ic),
            dma_transfer=create$5(caml_call1(_f_[20],65350),18373,0,0),
            mmu=
             caml_call10
              (Mmu[1],
               cartridge,
               wram,
               gpu,
               zero_page,
               shadow_ram,
               joypad,
               serial_port,
               ic,
               timer,
               dma_transfer),
            registers=create$7(0),
            _rG_=caml_call1(_f_[20],256),
            _rH_=caml_call1(_f_[20],65534),
            cpu=caml_call7(Cpu[2],mmu,ic,registers,_rH_,_rG_,0,0);
           set_flags(registers,_re_,_rd_,_rc_,_rb_,0);
           function _ri_(param)
            {var data=param[2],reg=param[1];
             return write_rr(registers,reg,caml_call1(_f_[20],data))}
           caml_call1(caml_call1(Stdlib_List[17],_ri_),_rf_);
           function _rj_(param)
            {var
              data=param[2],
              addr=param[1],
              _rI_=caml_call1(_g_[20],data),
              _rJ_=caml_call1(_f_[20],addr);
             return caml_call3(Mmu[3],mmu,_rJ_,_rI_)}
           caml_call1(caml_call1(Stdlib_List[17],_rj_),_rg_);
           set_gpu_mode(lcd_stat,3);
           set_mcycles_in_mode(gpu,0);
           return [0,cpu,timer,gpu,joypad]}
         function run_instruction(t)
          {var mcycles=caml_call1(Cpu[3],t[1]);
           run(t[2],mcycles);
           return run$0(t[3],mcycles)}
         function press$0(t,key){return press(t[4],key)}
         function release$0(t,key){return release(t[4],key)}
         function prev_inst(t){return caml_call1(Cpu[4][2],t[1])}
         function get_ly(t)
          {var _rh_=read_byte$12(t[3],ly_addr);
           return caml_call1(_g_[21],_rh_)}
         function get_lcd_stat(t){return read_byte$12(t[3],lcd_stat_addr)}
         function get_mcycles_in_mode(t)
          {return caml_call1(For_tests$0[3],t[3])}
         function get_tima_count(t){return caml_call1(For_tests[1],t[2])}
         var
          For_tests$1=
           [0,
            prev_inst,
            get_ly,
            get_lcd_stat,
            get_mcycles_in_mode,
            get_tima_count];
         return [0,
                 show,
                 create_with_rom,
                 run_instruction,
                 press$0,
                 release$0,
                 For_tests$1]}];
    caml_register_global(1247,Camlboy_lib_Camlboy,"Camlboy_lib__Camlboy");
    return}
  (function(){return this}()));


//# 1 ".index.eobjs/byte/dune__exe__Index.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_fps=caml_string_of_jsbytes("fps"),
     cst_right=caml_string_of_jsbytes("right"),
     cst_left=caml_string_of_jsbytes("left"),
     cst_down=caml_string_of_jsbytes("down"),
     cst_up=caml_string_of_jsbytes("up"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_Enter$0=caml_string_of_jsbytes("Enter"),
     cst_Shift$0=caml_string_of_jsbytes("Shift"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_d$0=caml_string_of_jsbytes("d"),
     cst_j$0=caml_string_of_jsbytes("j"),
     cst_k$0=caml_string_of_jsbytes("k"),
     cst_s$0=caml_string_of_jsbytes("s"),
     cst_w$0=caml_string_of_jsbytes("w"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Shift=caml_string_of_jsbytes("Shift"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_d=caml_string_of_jsbytes("d"),
     cst_j=caml_string_of_jsbytes("j"),
     cst_k=caml_string_of_jsbytes("k"),
     cst_s=caml_string_of_jsbytes("s"),
     cst_w=caml_string_of_jsbytes("w"),
     rom_options=
      [0,
       [0,
        caml_string_of_jsbytes("The Bouncing Ball"),
        caml_string_of_jsbytes("./the-bouncing-ball.gb")],
       [0,
        [0,
         caml_string_of_jsbytes("Retroid"),
         caml_string_of_jsbytes("./retroid.gb")],
        [0,
         [0,
          caml_string_of_jsbytes("Into The Blue"),
          caml_string_of_jsbytes("./into-the-blue.gb")],
         [0,
          [0,
           caml_string_of_jsbytes("Tobu Tobu Girl"),
           caml_string_of_jsbytes("./tobu.gb")],
          [0,
           [0,
            caml_string_of_jsbytes("Wishing Sarah"),
            caml_string_of_jsbytes("./dreaming-sarah.gb")],
           [0,
            [0,
             caml_string_of_jsbytes("Rocket Man Demo"),
             caml_string_of_jsbytes("./rocket-man-demo.gb")],
            [0,
             [0,
              caml_string_of_jsbytes("SHEEP IT UP"),
              caml_string_of_jsbytes("./sheep-it-up.gb")],
             0]]]]]]],
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_throttle=caml_string_of_jsbytes("throttle"),
     cst_load_rom=caml_string_of_jsbytes("load-rom"),
     cst_rom_selector=caml_string_of_jsbytes("rom-selector"),
     Brr=global_data.Brr,
     Fut=global_data.Fut,
     Stdlib_List=global_data.Stdlib__List,
     Jv=global_data.Jv,
     Brr_io=global_data.Brr_io,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Camlboy_lib_Detect_cartridge=global_data.Camlboy_lib__Detect_cartridge,
     Camlboy_lib_Camlboy=global_data.Camlboy_lib__Camlboy,
     Brr_canvas=global_data.Brr_canvas,
     Stdlib_Option=global_data.Stdlib__Option,
     Stdlib_Array=global_data.Stdlib__Array,
     _b_=[0,[8,[0,0,0],0,[0,2],0],caml_string_of_jsbytes("%.2f")],
     _a_=[0,1],
     gb_w=160,
     gb_h=144;
    function alert(v)
     {var alert=Jv[12].alert;alert(caml_call1(Jv[23],v));return 0}
    function find_el_by_id(id)
     {var _$_=caml_call2(Brr[10][2],Brr[16][2],caml_jsstring_of_string(id));
      return caml_call1(Stdlib_Option[4],_$_)}
    function draw_framebuffer(ctx,image_data,fb)
     {var d=caml_call1(Brr_canvas[4][90][4],image_data),y=0;
      a:
      for(;;)
       {var x=0;
        for(;;)
         {var
           off=4 * ((y * 160 | 0) + x | 0) | 0,
           match=caml_check_bound(caml_check_bound(fb,y)[1 + y],x)[1 + x];
          if(-588596599 <= match)
           if(-126317716 <= match)
            {d[off] = 97;
             d[off + 1 | 0] = 104;
             d[off + 2 | 0] = 125;
             d[off + 3 | 0] = 255}
           else
            {d[off] = 229;
             d[off + 1 | 0] = 251;
             d[off + 2 | 0] = 244;
             d[off + 3 | 0] = 255}
          else
           if(-603547828 <= match)
            {d[off] = 151;
             d[off + 1 | 0] = 174;
             d[off + 2 | 0] = 184;
             d[off + 3 | 0] = 255}
           else
            {d[off] = 34;
             d[off + 1 | 0] = 30;
             d[off + 2 | 0] = 49;
             d[off + 3 | 0] = 255}
          var ___=x + 1 | 0;
          if(159 !== x){var x=___;continue}
          var _Z_=y + 1 | 0;
          if(143 !== y){var y=_Z_;continue a}
          return caml_call4(Brr_canvas[4][93],ctx,image_data,0,0)}}}
    var run_id=[0,0],key_down_listener=[0,0],key_up_listener=[0,0];
    function set_listener(down,up)
     {key_down_listener[1] = [0,down];key_up_listener[1] = [0,up];return 0}
    function clear(param)
     {var _W_=run_id[1];
      if(_W_)
       {var timer_id=_W_[1];
        caml_call1(Brr[16][10],timer_id);
        caml_call1(Brr[16][12],timer_id)}
      var _X_=key_down_listener[1];
      if(_X_)
       {var lister=_X_[1];
        caml_call4(Brr[7][21],0,Brr[7][76],lister,Brr[16][6])}
      var _Y_=key_up_listener[1];
      if(_Y_)
       {var lister$0=_Y_[1];
        return caml_call4(Brr[7][21],0,Brr[7][77],lister$0,Brr[16][6])}
      return 0}
    var State=[0,run_id,key_down_listener,key_up_listener,set_listener,clear];
    function set_up_keyboard(C)
     {return function(t)
       {function key_down_listener(ev)
         {var key_name=caml_string_of_jsstring(caml_call1(Brr[7][31][2],ev));
          return caml_string_notequal(key_name,cst_Enter)
                  ?caml_string_notequal(key_name,cst_Shift)
                    ?caml_string_notequal(key_name,cst_a)
                      ?caml_string_notequal(key_name,cst_d)
                        ?caml_string_notequal(key_name,cst_j)
                          ?caml_string_notequal(key_name,cst_k)
                            ?caml_string_notequal(key_name,cst_s)
                              ?caml_string_notequal(key_name,cst_w)?0:caml_call2(C[4],t,1)
                              :caml_call2(C[4],t,0)
                            :caml_call2(C[4],t,7)
                          :caml_call2(C[4],t,6)
                        :caml_call2(C[4],t,3)
                      :caml_call2(C[4],t,2)
                    :caml_call2(C[4],t,5)
                  :caml_call2(C[4],t,4)}
        function key_up_listener(ev)
         {var key_name=caml_string_of_jsstring(caml_call1(Brr[7][31][2],ev));
          return caml_string_notequal(key_name,cst_Enter$0)
                  ?caml_string_notequal(key_name,cst_Shift$0)
                    ?caml_string_notequal(key_name,cst_a$0)
                      ?caml_string_notequal(key_name,cst_d$0)
                        ?caml_string_notequal(key_name,cst_j$0)
                          ?caml_string_notequal(key_name,cst_k$0)
                            ?caml_string_notequal(key_name,cst_s$0)
                              ?caml_string_notequal(key_name,cst_w$0)
                                ?0
                                :caml_call2(C[5],t,1)
                              :caml_call2(C[5],t,0)
                            :caml_call2(C[5],t,7)
                          :caml_call2(C[5],t,6)
                        :caml_call2(C[5],t,3)
                      :caml_call2(C[5],t,2)
                    :caml_call2(C[5],t,5)
                  :caml_call2(C[5],t,4)}
        caml_call4(Brr[7][20],0,Brr[7][76],key_down_listener,Brr[16][6]);
        caml_call4(Brr[7][20],0,Brr[7][77],key_up_listener,Brr[16][6]);
        return caml_call2(State[4],key_down_listener,key_up_listener)}}
    function set_up_joypad(C)
     {return function(t)
       {var
         right_el=find_el_by_id(cst_right),
         left_el=find_el_by_id(cst_left),
         down_el=find_el_by_id(cst_down),
         up_el=find_el_by_id(cst_up),
         b_el=find_el_by_id(cst_b),
         a_el=find_el_by_id(cst_a$1),
         select_el=find_el_by_id(cst_select),
         start_el=find_el_by_id(cst_start);
        function press(ev,t,key)
         {caml_call1(Brr[7][13],ev);return caml_call2(C[4],t,key)}
        function release(ev,t,key)
         {caml_call1(Brr[7][13],ev);return caml_call2(C[5],t,key)}
        var listen_ops=caml_call4(Brr[7][19],_a_,0,0,0);
        function _G_(ev){return press(ev,t,1)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_G_,up_el);
        function _H_(ev){return press(ev,t,0)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_H_,down_el);
        function _I_(ev){return press(ev,t,2)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_I_,left_el);
        function _J_(ev){return press(ev,t,3)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_J_,right_el);
        function _K_(ev){return press(ev,t,7)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_K_,a_el);
        function _L_(ev){return press(ev,t,6)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_L_,b_el);
        function _M_(ev){return press(ev,t,4)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_M_,start_el);
        function _N_(ev){return press(ev,t,5)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][97],_N_,select_el);
        function _O_(ev){return release(ev,t,1)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_O_,up_el);
        function _P_(ev){return release(ev,t,0)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_P_,down_el);
        function _Q_(ev){return release(ev,t,2)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_Q_,left_el);
        function _R_(ev){return release(ev,t,3)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_R_,right_el);
        function _S_(ev){return release(ev,t,7)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_S_,a_el);
        function _T_(ev){return release(ev,t,6)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_T_,b_el);
        function _U_(ev){return release(ev,t,4)}
        caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_U_,start_el);
        function _V_(ev){return release(ev,t,5)}
        return caml_call4(Brr[7][20],[0,listen_ops],Brr[7][99],_V_,select_el)}}
    var throttled=[0,1];
    function run_rom_bytes(ctx,image_data,rom_bytes)
     {caml_call1(State[5],0);
      var
       cartridge=caml_call1(Camlboy_lib_Detect_cartridge[1],rom_bytes),
       C=caml_call1(Camlboy_lib_Camlboy[1],cartridge),
       t=caml_call2(C[2],1,rom_bytes);
      caml_call1(set_up_keyboard(C),t);
      caml_call1(set_up_joypad(C),t);
      var cnt=[0,0],start_time=[0,caml_call1(Brr[15][9],Brr[16][4])];
      function main_loop(param)
       {for(;;)
         {var match=caml_call1(C[3],t);
          if(match)
           {var fb=match[1];
            cnt[1]++;
            if(60 === cnt[1])
             {var
               end_time=caml_call1(Brr[15][9],Brr[16][4]),
               sec_per_60_frame=(end_time - start_time[1]) / 1000.,
               fps=60. / sec_per_60_frame;
              start_time[1] = end_time;
              var
               fps_str=caml_call2(Stdlib_Printf[4],_b_,fps),
               fps_el=find_el_by_id(cst_fps),
               _C_=
                [0,caml_call2(Brr[9][2],0,caml_jsstring_of_string(fps_str)),0];
              caml_call2(Brr[9][18],fps_el,_C_);
              cnt[1] = 0}
            draw_framebuffer(ctx,image_data,fb);
            if(throttled[1])
             {var
               _D_=function(param){return main_loop(0)},
               _E_=[0,caml_call1(Brr[16][11],_D_)];
              State[1][1] = _E_;
              return 0}
            var _F_=[0,caml_call2(Brr[16][8],0,main_loop)];
            State[1][1] = _F_;
            return 0}
          continue}}
      return main_loop(0)}
    function run_rom_blob(ctx,image_data,rom_blob)
     {function _x_(result)
       {if(0 === result[0])
         {var
           buf=result[1],
           rom_bytes=
            runtime.caml_ba_from_typed_array(caml_call4(Brr[1][5],3,0,0,buf)),
           _z_=run_rom_bytes(ctx,image_data,rom_bytes);
          return caml_call1(Fut[3],_z_)}
        var
         e=result[1],
         _A_=[0,caml_call1(Jv[30][4],e),0],
         _B_=caml_call1(Brr[12][9],_A_);
        return caml_call1(Fut[3],_B_)}
      var _y_=caml_call1(Brr[2][8],rom_blob);
      return caml_call2(Fut[15][1],_y_,_x_)}
    function on_load_rom(ctx,image_data,input_el)
     {var
       _u_=caml_call1(Brr[9][56][1],input_el),
       file=caml_call1(Stdlib_List[5],_u_);
      function _v_(param){return 0}
      var _w_=run_rom_blob(ctx,image_data,file);
      return caml_call2(Fut[2],_w_,_v_)}
    function run_selected_rom(ctx,image_data,rom_path)
     {function _m_(result)
       {if(0 === result[0])
         {var
           response=result[1],
           _o_=
            function(result)
             {if(0 === result[0])
               {var blob=result[1];return run_rom_blob(ctx,image_data,blob)}
              var
               e=result[1],
               _s_=[0,caml_call1(Jv[30][4],e),0],
               _t_=caml_call1(Brr[12][9],_s_);
              return caml_call1(Fut[3],_t_)},
           _p_=caml_call1(Brr_io[3][1][9],response);
          return caml_call2(Fut[15][1],_p_,_o_)}
        var
         e=result[1],
         _q_=[0,caml_call1(Jv[30][4],e),0],
         _r_=caml_call1(Brr[12][9],_q_);
        return caml_call1(Fut[3],_r_)}
      var _n_=caml_call2(Brr_io[3][7],0,caml_jsstring_of_string(rom_path));
      return caml_call2(Fut[15][1],_n_,_m_)}
    function set_up_rom_selector(ctx,image_data,selector_el)
     {function _g_(rom_option)
       {var
         _k_=[0,caml_call2(Brr[9][3],0,rom_option[1]),0],
         _l_=
          [0,
           [0,caml_call1(Brr[8][37],caml_jsstring_of_string(rom_option[2])),0]];
        return caml_call3(Brr[9][127],0,_l_,_k_)}
      var _h_=caml_call1(caml_call1(Stdlib_List[19],_g_),rom_options);
      caml_call1(caml_call1(Brr[9][20],selector_el),_h_);
      function on_change(param)
       {var
         rom_path=
          caml_string_of_jsstring
           (caml_call2(Brr[9][26],Brr[9][25][10],selector_el));
        function _i_(param){return 0}
        var _j_=run_selected_rom(ctx,image_data,rom_path);
        return caml_call2(Fut[2],_j_,_i_)}
      return caml_call4(Brr[7][20],0,Brr[7][43],on_change,selector_el)}
    function on_checkbox_change(checkbox_el)
     {var checked=caml_call2(Brr[9][26],Brr[9][25][5],checkbox_el);
      throttled[1] = checked;
      return 0}
    var
     _c_=find_el_by_id(cst_canvas),
     canvas=caml_call1(Brr_canvas[3][2],_c_),
     ctx=caml_call2(Brr_canvas[4][15],0,canvas);
    caml_call3(Brr_canvas[4][36],ctx,1.5,1.5);
    var
     image_data=caml_call3(Brr_canvas[4][91],ctx,gb_w,gb_h),
     fb=caml_call3(Stdlib_Array[3],gb_h,gb_w,-603547828);
    draw_framebuffer(ctx,image_data,fb);
    var checkbox_el=find_el_by_id(cst_throttle);
    function _d_(param){return on_checkbox_change(checkbox_el)}
    caml_call4(Brr[7][20],0,Brr[7][43],_d_,checkbox_el);
    var input_el=find_el_by_id(cst_load_rom);
    function _e_(param){return on_load_rom(ctx,image_data,input_el)}
    caml_call4(Brr[7][20],0,Brr[7][43],_e_,input_el);
    var selector_el=find_el_by_id(cst_rom_selector);
    set_up_rom_selector(ctx,image_data,selector_el);
    var
     rom=caml_call1(Stdlib_List[5],rom_options),
     fut=run_selected_rom(ctx,image_data,rom[2]);
    function _f_(param){return 0}
    caml_call2(Fut[2],fut,_f_);
    var
     Dune_exe_Index=
      [0,
       gb_w,
       gb_h,
       rom_options,
       alert,
       find_el_by_id,
       draw_framebuffer,
       State,
       set_up_keyboard,
       set_up_joypad,
       throttled,
       run_rom_bytes,
       run_rom_blob,
       on_load_rom,
       run_selected_rom,
       set_up_rom_selector,
       on_checkbox_change];
    runtime.caml_register_global(48,Dune_exe_Index,"Dune__exe__Index");
    return}
  (function(){return this}()));


//# 1 "../../.js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmRleC5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjYW1sX2ludDY0X2lzX3plcm8iLCJ4IiwiY2FtbF9zdHJfcmVwZWF0IiwibiIsInMiLCJyIiwibCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiTWF0aCIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJ0YWciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSIsIk1sSW50NjQiLCJsbyIsIm1pIiwiaGkiLCJ0aGlzIiwieGhpIiwiaCIsInNpZ24iLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJpIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJhcmciLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJqIiwiTWxCeXRlcyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfYnl0ZXNfb2ZfanNieXRlcyIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiYnVmZmVyIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwicCIsImNhbWxfZXhwbTFfZmxvYXQiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsIm1ha2VfcGF0aF9pc19hYnNvbHV0ZSIsInBvc2l4IiwicGF0aCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInJvb3QiLCJzZXAiLCJqb29fZ2xvYmFsX29iamVjdCIsInBhdGhfaXNfYWJzb2x1dGUiLCJjYW1sX3RyYWlsaW5nX3NsYXNoIiwibmFtZSIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAwIiwiY29tcCIsIm5jb21wIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsImVycm5vIiwidmFyaWFudCIsImFyZ3MiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfcmFpc2Vfd2l0aF9hcmdzIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJBcnJheSIsImNhbWxfYmxpdF9ieXRlcyIsInMxIiwiaTEiLCJzMiIsImkyIiwiY2FtbF9ibGl0X3N0cmluZyIsImUiLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwiYnVmIiwicG9zIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsIk1sRmFrZURldmljZSIsInJlcyIsIlN5bWJvbCIsIm5hbWVfc2xhc2giLCJtb2RlIiwicmFpc2VfdW5peCIsInBhcmVudCIsIlJlZ0V4cCIsInNlZW4iLCJtIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsIm8iLCJqc19zdGF0cyIsInRvX2RpciIsInRhcmdldCIsImxpbmsiLCJmaWxlX2tpbmQiLCJjYW1sX2dldF9yb290IiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfcm9vdCIsImZzX25vZGVfc3VwcG9ydGVkIiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJnIiwidW5kZWZpbmVkIiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiaW0iLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9sb2cxMF9mbG9hdCIsInVuaXhfdW5saW5rIiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsInVuaXhfcm1kaXIiLCJjYW1sX21sX3JlZmlsbF9pbnB1dCIsImNoYW4iLCJzdHIiLCJzdHJfbGVuIiwiY2FtbF9tbF9jaGFubmVscyIsImNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCIsImNoYW5pZCIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX21sX2lucHV0X3NjYW5fbGluZSIsImNhbWxfZ2NfbWlub3IiLCJjYW1sX2ludDY0X29mX2J5dGVzIiwiY2FtbF9iYV91aW50OF9nZXQ2NCIsImJhIiwiaTAiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfaW50NjRfbWFyc2hhbCIsIndyaXRlciIsInNpemVzIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2ludF9jb21wYXJlIiwiYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZyIsImJhMSIsImJhMV9vZmYiLCJiYTIiLCJiYTJfb2ZmIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsIkRhdGUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3NMZW4iLCJleHRyYV9hcmdzIiwiYXJndW1lbnRzIiwibmFyZ3MiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zeXNfY2hkaXIiLCJkaXIiLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9ncl9zeW5jaHJvbml6ZSIsInVuaXhfaGFzX3N5bWxpbmsiLCJ1bml0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwicG9zMSIsInBvczIiLCJzbGljZSIsImJpZ3N0cmluZ2FmX2JsaXRfZnJvbV9ieXRlcyIsInNyYyIsInNyY19vZmYiLCJkc3QiLCJkc3Rfb2ZmIiwibG9nMl9vayIsImpzb29fZmxvb3JfbG9nMiIsIkluZmluaXR5IiwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IiwiZmxvYXQzMmEiLCJpbnQzMmEiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImV4cCIsImsiLCJyMyIsInIyIiwicjEiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJkYXRhIiwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiTmFOIiwiY2FtbF9iYV9nZXRfc2l6ZSIsImRpbXMiLCJuX2RpbXMiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYmFfY3VzdG9tX25hbWUiLCJNbF9CaWdhcnJheSIsImxheW91dCIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l6ZV9kaW0iLCJzaXplX2RpbV9oaSIsInNpemVfZGltX2xvIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsInciLCJjYW1sX2ludDMyX3VubWFyc2hhbCIsImNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCIsImNhbWxfaW50NjRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9oYXNoIiwiY2FtbF9jdXN0b21fb3BzIiwiY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tIiwiY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tIiwibnVtIiwiY3VzdG9tIiwic3dhcCIsImNhbWxfY29tcGFyZV92YWxfdGFnIiwiTnVtYmVyIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsInoiLCJkaXZfZGlnaXRfbmF0IiwibmF0cSIsIm9mc3EiLCJuYXRyIiwib2ZzciIsInJlbSIsIm51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCIsInNoaWZ0X2xlZnRfbmF0IiwiTWxOYXQiLCJjcmVhdGVfbmF0IiwiYXJyIiwic2V0X3RvX3plcm9fbmF0IiwiaW5jcl9uYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsImxlbjIiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJzdWJfbmF0IiwiY29tcGFyZV9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0IiwiaXNfZGlnaXRfaW50IiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiZG9jdW1lbnQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfZXJmX2Zsb2F0IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCIsIl91bml0IiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX29ial9hZGRfb2Zmc2V0IiwiY2FtbF9maW5hbF9yZWxlYXNlIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfZ3JfcGxvdCIsImNvbG9yIiwiY2FtbF9ieXRlc19zZXQ2NCIsImk2NCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2ZpbGxfYnl0ZXMiLCJjYW1sX2ZpbGxfc3RyaW5nIiwiY2FtbF9nY19tYWpvciIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwic3RhdGUiLCJiYXNlIiwiYmFja3RyayIsInVuaXhfZ2V0dWlkIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwib3NfdHlwZSIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2Fjb3NoX2Zsb2F0IiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9sb2cyX2Zsb2F0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYnl0ZXMyIiwiYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX3JhaXNlX2VuZF9vZl9maWxlIiwiY2FtbF9tbF9pbnB1dF9pbnQiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsImNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyIsIm50aF9kaWdpdF9uYXQiLCJjYW1sX2FycmF5X2JsaXQiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImV4cG9uZW50IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJmbGFncyIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX3N0cmluZ19vZl9hcnJheSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjbWQiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJ1bml4X2xzdGF0IiwidW5peF9sc3RhdF82NCIsImpzX3ByaW50X3N0ZG91dCIsImNhbWxfY29weXNpZ25fZmxvYXQiLCJjYW1sX2dyX3NldF90ZXh0X3NpemUiLCJjYW1sX21kNV9ieXRlcyIsImFkZCIsInh4IiwiZmYiLCJnZyIsImhoIiwiaWkiLCJtZDUiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwib25lIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsIk1sU3RyaW5nUmVhZGVyIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJfbWFnaWMiLCJfYmxvY2tfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwiRXJyb3IiLCJyZV9zZWFyY2hfYmFja3dhcmQiLCJjYW1sX2pzX2Zyb21fc3RyaW5nIiwiY2FtbF9iYV9zdWIiLCJjaGFuZ2VkX2RpbSIsIm11bCIsIm5ld19kaW1zIiwibmV3X2RhdGEiLCJjYW1sX2djX2Z1bGxfbWFqb3IiLCJjYW1sX2J5dGVzX3NldDMyIiwiaTMyIiwiY2FtbF9ncl9zaWdpb19zaWduYWwiLCJjYW1sX2JhX3VpbnQ4X3NldDMyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXgiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX2N1cnJlbnRfeCIsImNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgiLCJjYW1sX2dyX3NldF9mb250IiwiY2FtbF9ncl9zZXRfY29sb3IiLCJjb252ZXJ0IiwibnVtYmVyIiwiY19zdHIiLCJjYW1sX2dyX21vdmV0byIsImNhbWxfZ3JfcmVzaXplX3dpbmRvdyIsImNhbWxfZ3Jfc3RhdGVfaW5pdCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsInRhIiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJidCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24iLCJjYW1sX2Zvcm1hdF9leGNlcHRpb24iLCJidWNrZXQiLCJzdGFydCIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwiaGFuZGxlciIsImF0X2V4aXQiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZXhwMl9mbG9hdCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX2F0YW5oX2Zsb2F0IiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJzdHJpbmciLCJqc3N0cmluZyIsImlkIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfanNfZXhwciIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfZXZlbnRsb2dfcmVzdW1lIiwiY2FtbF9oYXNoX3VuaXZfcGFyYW0iLCJjb3VudCIsImxpbWl0Iiwib2JqIiwiaGFzaF9hY2N1IiwiaGFzaF9hdXgiLCJqc2J5dGVzIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJyZV9yZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJjdXIiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJjYW1sX3RvX2pzX3N0cmluZyIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsInJlX3NlYXJjaF9mb3J3YXJkIiwiY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX21ha2VfdmVjdCIsImluaXQiLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeSIsImNhbWxfbWxfb3V0cHV0X2NoYXIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIiLCJjYW1sX29ial9pc19ibG9jayIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfb2JqX3NldF9yYXdfZmllbGQiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSIsImNhbWxfYmFfZ2V0XzIiLCJ3aW5faGFuZGxlX2ZkIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsIndpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbCIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9saXN0X21vdW50X3BvaW50IiwicHJldiIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX2pzX2VxdWFscyIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImNhbWxfZ3JfYXJjX2F1eCIsImN0eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSIsImdldDMyIiwiY2FtbF9pbnB1dF92YWx1ZSIsImNhbWxfYmFfa2luZCIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2djX21ham9yX3NsaWNlIiwid29yayIsImNhbWxfanNfcHVyZV9leHByIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZSIsInVuaXhfZ210aW1lIiwiY2FtbF9zeXNfZ2V0X2NvbmZpZyIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsInVuaXhfdGltZSIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJjYW1sX2FzaW5oX2Zsb2F0IiwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciIsImFiIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX3N0cmluZ19sZXNzdGhhbiIsImNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuIiwiY2FtbF9kaXYiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfbWVtcHJvZl9zdGFydCIsInJhdGUiLCJzdGFja19zaXplIiwidHJhY2tlciIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nIiwiYmFfb2ZmIiwic3RyX29mZiIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJtdWx0X25hdCIsImxlbjMiLCJzcXVhcmVfbmF0IiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZ2Nfc3RhdCIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImJpZ3N0cmluZ2FmX21lbWNociIsImNociIsImNhbWxfc3lzX21vZGlmeV9hcmd2IiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9zeXNfdW5zYWZlX2dldGVudiIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwicmVmaWxsIiwiZnMiLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsInVuaXhfc3RhdCIsInVuaXhfc3RhdF82NCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJsYW5kX2RpZ2l0X25hdCIsImNhbWxfaW50NjRfbW9kIiwidW5peF9yZWFkbGluayIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX2NyZWF0ZV9maWxlX2V4dGVybiIsImNhbWxfaW50MzJfYnN3YXAiLCJ3aW5fc3RhcnR1cCIsImNhbWxfYmFfc2V0XzMiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2dldF9tYWpvcl9idWNrZXQiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJkaWdpdCIsImNhbWxfc3RyaW5nX3NldDY0IiwiY2FtbF9ncl9zdGF0ZV9jcmVhdGUiLCJjYW52YXMiLCJjb250ZXh0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiY2FtbF9ncl9kcmF3X2FyYyIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsInVuaXhfc3ltbGluayIsInNyY19yb290IiwiZHN0X3Jvb3QiLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX21sX3Bvc19vdXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9ieXRlc19ub3RlcXVhbCIsImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJjYW1sX3dlYWtfYmxpdCIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfZm1hX2Zsb2F0IiwiU1BMSVQiLCJNSU5fVkFMVUUiLCJFUFNJTE9OIiwiQyIsIkEiLCJCIiwibXVsdGlwbHkiLCJhdCIsImFoaSIsImFsbyIsImJoaSIsImJsbyIsImFkanVzdCIsInNjYWxlIiwieHMiLCJ5cyIsInpzIiwieHkiLCJ1IiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsInVuaXhfZ2V0cHd1aWQiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsImNhbWxfaGFzaCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJjYW1sX29ial90YWciLCJGdW5jdGlvbiIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2pzX2V4cG9ydF92YXIiLCJtb2R1bGUiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX2Zsb2F0YXJyYXlfYmxpdCIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX3NldF9zdGF0aWNfZW52IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwiY2FtbF9qc19uZXciLCJ1bml4X21rZGlyIiwicGVybSIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjYW1sX2pzX3RvX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJnZXQiLCJzcGVjcyIsInN0YXR1cyIsIndpbiIsImRvYyIsInRpdGxlIiwiYm9keSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9jYnJ0X2Zsb2F0IiwiY2FtbF9ldmVudGxvZ19wYXVzZSIsImNhbWxfbWVtcHJvZl9zdG9wIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSIsImNhbWxfbG9nMXBfZmxvYXQiLCJiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwibG9vcCIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3lzX21rZGlyIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQiLCJjYW1sX3JlYWRfZmlsZV9jb250ZW50IiwiY2FtbF9qc190b19mbG9hdCIsImNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJvcmlnaW4iLCJldmVudCIsImVycl9ub19wcmVkIiwiZXJyX25vX3N1Y2MiLCJ6ZXJvJDIiLCJvbmUkMiIsIm1pbnVzX29uZSQyIiwibWluX2ludCQyIiwibWF4X2ludCQyIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJudWxsJDAiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJudWxsJDEiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsIm51bGwkMiIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQ0Iiwib25lJDQiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwidiIsInIiLCJjdXIiLCJzZWVuIiwibiIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uIiwibWF4X2ludCIsIm1pbl9pbnQiLCJzMSIsInMyIiwibDEiLCJsMiIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwibGVuJDEiLCJvZnMkMSIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9saW5lIiwiYnVpbGRfcmVzdWx0IiwiYnVmIiwiYWNjdSIsImJlZyIsImFjY3UkMCIsInJlcyIsImNsb3NlX2luX25vZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludCIsInJlYWRfaW50X29wdCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsInBvc19pbiIsInNlZWtfaW4iLCJpbnB1dF92YWx1ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJwb3Nfb3V0Iiwic2Vla19vdXQiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2NoYXIiLCJmbHVzaCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCQwIiwic2VxMSIsInNlcTIiLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJjb25jYXQiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJ1bmZvbGQiLCJ1IiwidSQwIiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsIm8iLCJkZWZhdWx0JDAiLCJnZXQkMCIsImJpbmQiLCJqb2luIiwibWFwJDAiLCJmb2xkIiwiaXRlciQwIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJlcXVhbCIsImVxIiwibzAiLCJvMSIsInYxIiwidjAiLCJjb21wYXJlIiwiY21wIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsImxlZnQiLCJyaWdodCIsImlzX2xlZnQiLCJpc19yaWdodCIsImZpbmRfbGVmdCIsImZpbmRfcmlnaHQiLCJtYXBfbGVmdCIsImUiLCJtYXBfcmlnaHQiLCJtYXAkMSIsInYkMCIsImZvbGQkMCIsImVxdWFsJDAiLCJlMSIsImUyIiwidjIiLCJ2MiQwIiwiY29tcGFyZSQwIiwib2siLCJlcnJvciIsInZhbHVlJDAiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJiaW5kJDAiLCJqb2luJDAiLCJtYXAkMiIsIm1hcF9lcnJvciIsImZvbGQkMSIsIml0ZXIkMSIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwiZXF1YWwkMSIsInIwIiwicjEiLCJjb21wYXJlJDEiLCJ0b19vcHRpb24iLCJ0b19saXN0JDAiLCJ0b19zZXEkMCIsImVxdWFsJDIiLCJjb21wYXJlJDIiLCJ0b19mbG9hdCIsInRvX3N0cmluZyQwIiwiZXNjYXBlZCIsInMkMCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImNvbXBhcmUkMyIsImMxIiwiYzIiLCJlcXVhbCQzIiwibWluJDAiLCJtYXgkMCIsImxvX2JvdW5kIiwiaGlfYm91bmQiLCJib20iLCJyZXAiLCJzdWNjIiwicHJlZCIsImlzX3ZhbGlkIiwib2ZfaW50IiwiaXNfY2hhciIsIm9mX2NoYXIiLCJ0b19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJlcXVhbCQ0IiwiY29tcGFyZSQ0IiwiaGFzaCIsIm1hdGNoJDEiLCJsZW5ndGgiLCJwYXJhbSQwIiwiY29ucyQwIiwibnRoIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwiaW5pdF9hdXgiLCJyZXZfaW5pdF90aHJlc2hvbGQiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJlc3VsdCIsInhzIiwieCQwIiwicnkiLCJyeCIsInQyIiwiaDIiLCJ0MSIsImgxIiwicmV2X3NvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwic29ydCIsInRsJDAiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJhdXgiLCJ0YWlsIiwiZGlyZWN0IiwiZGVwdGgiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwiYWJzJDAiLCJtYXhfaW50JDAiLCJtaW5faW50JDAiLCJsb2dub3QiLCJlcXVhbCQ2IiwiY29tcGFyZSQ2IiwibWluJDEiLCJtYXgkMSIsInRvX3N0cmluZyQxIiwic3ltYm9sJDAiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsInByZWZpeCIsImxlbl9zIiwibGVuX3ByZSIsInN1ZmZpeCIsImxlbl9zdWYiLCJkaWZmIiwiaW5kZXhfcmVjIiwibGltIiwiaSQxIiwiaW5kZXhfcmVjX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXhfcmVjX29wdCIsIm5ld19sZW4iLCJuZXdfYnVmIiwiaXNfc3BhY2UkMCIsImluZGV4X3JlYyQwIiwiaW5kZXhfcmVjX29wdCQwIiwicmluZGV4X3JlYyQwIiwicmluZGV4X3JlY19vcHQkMCIsImciLCJlcXVhbCQ5IiwiY29tcGFyZSQ5IiwidG9fc3RyaW5nJDIiLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJoZWFkZXJfc2l6ZSIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJtYXJzaGFsIiwib2JqIiwidW5tYXJzaGFsIiwicG9zIiwiZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiaW5mbyIsInN0YXJ0X2VudiIsIm9mX3ZhbCIsInNsb3QiLCJpZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3JlYXRlIiwibGVuZ3RoJDAiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwiaGQkMCIsImlucHV0X2FycmF5IiwiZWx0Iiwib3V0cHV0X2FycmF5IiwiZWx0JDAiLCJhY2MkMiIsImIwIiwiYTAiLCJiaSIsImFpIiwibmEiLCJuYiIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJwaSIsImlzX2ludGVnZXIiLCJzdWNjJDAiLCJwcmVkJDAiLCJlcXVhbCQxMCIsIm1pbiQyIiwibWF4JDIiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsImhhc2gkMCIsInVuc2FmZV9maWxsIiwiY2hlY2siLCJtYWtlJDIiLCJpbml0JDMiLCJhcHBlbmQkMiIsImNvbmNhdCQzIiwiaGxlbiIsInN1YiQyIiwiY29weSQyIiwiZmlsbCQxIiwiYmxpdCQyIiwic3JjIiwic29mcyIsImRvZnMiLCJ0b19saXN0JDIiLCJvZl9saXN0JDAiLCJoIiwiaXRlciQ2IiwiaXRlcjIkMSIsIm1hcCQ3IiwibWFwMiQxIiwiaXRlcmkkMyIsIm1hcGkkMyIsImZvbGRfbGVmdCQ0IiwiZm9sZF9yaWdodCQzIiwiZXhpc3RzJDMiLCJmb3JfYWxsJDMiLCJtZW0kMSIsIm1lbV9pZWVlIiwic29ydCQwIiwic3RhYmxlX3NvcnQiLCJ0b19zZXEkNSIsInRvX3NlcWkkMiIsIm9mX3NlcSQzIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQzIiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJtaW4kMyIsIm1heCQzIiwidW5zaWduZWRfZGl2IiwicSIsInVuc2lnbmVkX3JlbSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibG9nbm90JDEiLCJtYXhfaW50JDMiLCJ1bnNpZ25lZF90b19pbnQkMCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQxMSIsImVxdWFsJDEyIiwidW5zaWduZWRfY29tcGFyZSQwIiwibWluJDQiLCJtYXgkNCIsInVuc2lnbmVkX2RpdiQwIiwidW5zaWduZWRfcmVtJDAiLCJ6ZXJvJDMiLCJvbmUkMyIsIm1pbnVzX29uZSQzIiwic3VjYyQzIiwicHJlZCQzIiwiYWJzJDMiLCJtaW5faW50JDMiLCJtYXhfaW50JDQiLCJsb2dub3QkMiIsInVuc2lnbmVkX3RvX2ludCQxIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDEyIiwiZXF1YWwkMTMiLCJ1bnNpZ25lZF9jb21wYXJlJDEiLCJtaW4kNSIsIm1heCQ1IiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiYXJnJDEiLCJjbWQkMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJpc19lbXB0eSIsIm1lbSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ2JDEiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDIiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDMiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsIm1hcCQ4IiwibWFwX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDIiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyIsIm9mX2J5dGVzJDAiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyQwIiwic3ViJDMiLCJibGl0JDMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwiYWRkX3V0Zl84X3VjaGFyIiwicG9zJDAiLCJwb3MkMSIsImFkZF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwiYWxyZWFkeV9yZWFkIiwidG9fcmVhZCIsImFscmVhZHlfcmVhZCQwIiwidG9fcmVhZCQwIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwiayQwIiwiayQxIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwidG9fc2VxJDgiLCJ0b19zZXFpJDMiLCJhZGRfc2VxJDEiLCJvZl9zZXEkNiIsImFkZF9pbnQ4IiwiYWRkX2ludDE2X25lIiwiYWRkX2ludDMyX25lIiwiYWRkX2ludDY0X25lIiwiYWRkX2ludDE2X2xlIiwiYWRkX2ludDE2X2JlIiwiYWRkX2ludDMyX2xlIiwiYWRkX2ludDMyX2JlIiwiYWRkX2ludDY0X2xlIiwiYWRkX2ludDY0X2JlIiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWR0eSQwIiwiYnByaW50X3ByZWNpc2lvbiIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsInN1Yl9mbXR0eSIsInN1Yl9mbXR0eSQwIiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXQkMSIsImNociQwIiwic3RyJDEiLCJpc19hbG9uZSQwIiwiaXNfYWxvbmUiLCJhZnRlciIsImJlZm9yZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsInRyYW5zIiwicmVzdDIiLCJyZXN0MiQwIiwicmVzdDIkMSIsInJlc3QyJDIiLCJyZXN0MiQzIiwicmVzdDIkNCIsInJlc3QyJDUiLCJyZXN0MiQ2IiwicmVzdDIkNyIsInR5MiQwIiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZm10dHlfcmVsX2RldCIsImY0IiwiZjIiLCJyZXN0MiQ5IiwicmVzdDIkMTAiLCJyZXN0MiQxMSIsInJlc3QyJDEyIiwicmVzdDIkMTMiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsImpkIiwiZGoiLCJnYSIsImFnIiwiZGUkOSIsImVkJDkiLCJhZiQ5IiwiZmEkOSIsImRlJDEwIiwiZWQkMTAiLCJhZiQxMCIsImZhJDEwIiwiZGUkMTEiLCJlZCQxMSIsImFmJDExIiwiZmEkMTEiLCJkZSQxMiIsImVkJDEyIiwiYWYkMTIiLCJmYSQxMiIsImRlJDEzIiwiZWQkMTMiLCJhZiQxMyIsImZhJDEzIiwiZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJmbXR0eV9vZl9mbXQiLCJ0eV9yZXN0IiwicHJlY190eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsInR5JDAiLCJmbXR0eSQ0IiwiZm10dHkkNSIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJ0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGkiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwiZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJmbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQzIiwiZm10JDIiLCJzdWJfZm10dHlfcmVzdCQ0IiwiZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkNSIsImZtdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNiIsImZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDciLCJmbXQkNCIsInN1Yl9mbXR0eV9yZXN0JDgiLCJmbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ5IiwiZm10JDUiLCJzdWJfZm10dHlfcmVzdCQxMCIsImZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDExIiwiZm10JDYiLCJzdWJfZm10dHlfcmVzdCQxMiIsImZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwiZm10JDciLCJzdWJfZm10dHlfcmVzdCQxNCIsImZtdHR5X3Jlc3QkNyIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsImZtdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJmbXR0eV9yZXN0JDgiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJmbXQkOSIsInN1Yl9mbXR0eV9yZXN0JDE4IiwiZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJmbXQkMTAiLCJzdWJfZm10dHlfcmVzdCQyMCIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQyMSIsImZtdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwiZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIzIiwiZm10JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJmbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJmbXQkMTMiLCJzdWJfZm10dHlfcmVzdCQyNiIsImZtdF9yZXN0IiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXRfcmVzdCQyIiwiZm10X3Jlc3QkMyIsImZtdF9yZXN0JDQiLCJmbXRfcmVzdCQ1IiwicHJlYyQ0IiwiZm10dHkkNiIsImZtdF9yZXN0JDYiLCJwcmVjJDUiLCJwcmVjJDYiLCJmbXR0eSQ3IiwiZm10X3Jlc3QkNyIsInByZWMkNyIsInByZWMkOCIsImZtdHR5JDgiLCJmbXRfcmVzdCQ4IiwiZm10dHkkOSIsImZtdF9yZXN0JDkiLCJmbXR0eSQxMCIsImZtdF9yZXN0JDEwIiwiZm10dHkkMTEiLCJmbXRfcmVzdCQxMSIsImZtdHR5JDEyIiwiZm10X3Jlc3QkMTIiLCJmbXR0eSQxMyIsInN1Yl9mbXR0eTEiLCJmbXRfcmVzdCQxMyIsInN1Yl9mbXR0eSQxIiwiZm10dHkkMTQiLCJmbXQkMTQiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10X3Jlc3QkMTUiLCJmbXR0eSQxNiIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTciLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZvcm1hdHRpbmdfZ2VuIiwiZm10dHkzIiwiZm10MyIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxOCIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE5IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMjAiLCJmbXQkMjAiLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsImZtdHR5JDIyIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJ0eXBlX2Zvcm1hdCIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwid2lkdGgkMCIsImZpeF9pbnRfcHJlY2lzaW9uIiwicmVzJDEiLCJzdHJpbmdfdG9fY2FtbF9zdHJpbmciLCJmb3JtYXRfb2ZfZmNvbnYiLCJzeW1iIiwidHJhbnNmb3JtX2ludF9hbHQiLCJkaWdpdHMiLCJwdXQiLCJjb252ZXJ0X2ludCIsImNvbnZlcnRfaW50MzIiLCJjb252ZXJ0X25hdGl2ZWludCIsImNvbnZlcnRfaW50NjQiLCJjb252ZXJ0X2Zsb2F0IiwiaGV4Iiwic2lnbiIsImNhbWxfc3BlY2lhbF92YWwiLCJzdHJpbmdfb2ZfZm10dHkiLCJtYWtlX3ByaW50ZiQwIiwibmV3X2FjYyIsIm1ha2VfcHJpbnRmIiwibWFrZV9wYWRkaW5nIiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJwJDAiLCJwJDEiLCJhY2MkMyIsImFjYyQ0IiwiayQzIiwia2FjYyIsImskNCIsIm1ha2VfaWdub3JlZF9wYXJhbSQwIiwibWFrZV9jdXN0b20kMCIsIm1ha2VfaW52YWxpZF9hcmciLCJtYWtlX2Zyb21fZm10dHkkMCIsIm1ha2VfZnJvbV9mbXR0eSIsIm1ha2VfY3VzdG9tIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwibWFrZV9pcHJpbnRmJDAiLCJtYWtlX2lwcmludGYiLCJmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiIsImtvYyIsInJlc3QkMjQiLCJyZXN0JDI1IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQyIiwicCQzIiwicCQ0IiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJwYXJzZV9sd29yZCIsInBhcnNlX2ludCIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0Iiwic2l6ZSIsInBhcnNlX3Bvc2l0aXZlIiwic3RyX2luZCQwIiwic3RyX2luZCQxIiwicGFyc2VfaW50ZWdlciIsIm5leHRfaW5kIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJwY3RfaW5kIiwib3B0aW9uIiwic3ViZm10IiwiY29tcHV0ZV9pbnRfY29udiIsInBsdXMiLCJzcGFjZSIsInBsdXMkMCIsInNwYWNlJDAiLCJzZWFyY2hfc3ViZm9ybWF0X2VuZCIsInN1Yl9lbmQiLCJzdHJfaW5kJDIiLCJzdWJfZW5kJDAiLCJzdHJfaW5kJDMiLCJzdWJfZW5kJDEiLCJzdHJfaW5kJDQiLCJzdHJfaW5kJDUiLCJzdWJfZW5kJDIiLCJzdHJfaW5kJDYiLCJzdHJfaW5kJDciLCJwYXJzZV9tYWdpY19zaXplIiwic3RyX2luZF8xIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwicGFyc2UiLCJwYXJzZV9nb29kX2JyZWFrIiwiZm9ybWF0dGluZ19saXQkMCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInBhcnNlX3RhZyIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mbXQiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwicGFyc2VfZmxhZ3MiLCJtaW51cyIsInNldF9mbGFnIiwibmV3X2luZCIsInBhcnNlX2FmdGVyX3BhZGRpbmciLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwic3ltYiQwIiwibWludXMkMCIsInBhcnNlX2NvbnZlcnNpb24iLCJwYXJzZV9jb252IiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQxIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0IiwiaWdub3JlZCQyIiwiY291bnRlciQwIiwiaWdub3JlZCQ2IiwiaWdub3JlZCQ3IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyJDAiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsImNoYXJfc2V0JDEiLCJpZ25vcmVkJDkiLCJjaGFyX2Zvcm1hdCIsImZtdF9yZXN0JDIxIiwiZm10X3Jlc3QkMjIiLCJwYWQkOSIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwicGFkJDEwIiwiZm10X3Jlc3QkMjUiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJpZ25vcmVkJDUiLCJpZ25vcmVkJDgiLCJzcGFjZSQxIiwiaGFzaCQxIiwicGx1cyQyIiwia2luZCIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDEiLCJpZ24kMCIsImZvcm1hdF9vZl9zdHJpbmdfZm10dHkiLCJmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCIsImtmcHJpbnRmIiwia2JwcmludGYiLCJpa2ZwcmludGYiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwiaWJwcmludGYiLCJwcmludGYiLCJlcHJpbnRmIiwia3NwcmludGYiLCJzcHJpbnRmIiwiYXNzb2MzIiwieTIiLCJ5MSIsInNwbGl0JDEiLCJtYWtlX3N5bWxpc3QiLCJoZWxwX2FjdGlvbiIsImFkZF9oZWxwIiwic3BlY2xpc3QiLCJhZGQyIiwidXNhZ2VfYiIsImVycm1zZyIsImRvYyIsInNwZWMiLCJrZXkiLCJ1c2FnZV9zdHJpbmciLCJ1c2FnZSIsImJvb2xfb2Zfc3RyaW5nX29wdCQwIiwiaW50X29mX3N0cmluZ19vcHQkMCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY18iLCJhbGxvd19leHBhbmQiLCJhcmd2IiwiYW5vbmZ1biIsImluaXRwb3MiLCJjb252ZXJ0X2Vycm9yIiwicHJvZ25hbWUiLCJmb2xsb3ckMCIsImFjdGlvbiIsImtleXdvcmQiLCJub19hcmckMCIsImZvbGxvdyIsIm5vX2FyZyIsImdldF9hcmckMCIsImdldF9hcmciLCJjb25zdW1lX2FyZyQwIiwiY29uc3VtZV9hcmciLCJ0cmVhdF9hY3Rpb24kMCIsInRyZWF0X2FjdGlvbiIsImYkMCIsImYkMSIsInIkMSIsImYkMiIsInIkMiIsImFyZyQyIiwiZiQzIiwiYXJnJDMiLCJ4JDEiLCJyJDMiLCJhcmckNCIsIngkMiIsInNwZWNzIiwiZiQ0IiwiYXJnJDUiLCJmJDUiLCJmJDYiLCJmJDciLCJhcmckNiIsIm5ld2FyZyIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIiwicGFyc2VfYXJndl9keW5hbWljIiwiY3VycmVudCQwIiwicGFyc2VfYXJndiIsIm1zZyQwIiwibXNnJDEiLCJwYXJzZV9keW5hbWljIiwicGFyc2VfZXhwYW5kIiwic2Vjb25kX3dvcmQiLCJsb29wIiwibWF4X2FyZ19sZW4iLCJrd2QiLCJyZXBsYWNlX2xlYWRpbmdfdGFiIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJ0cmltIiwiZmlsZSIsIndvcmRzIiwic3Rhc2giLCJ3b3JkIiwicmVhZF9hcmciLCJyZWFkX2FyZzAiLCJ3cml0ZV9hdXgiLCJhcmdzIiwid3JpdGVfYXJnIiwid3JpdGVfYXJnMCIsInByaW50ZXJzIiwiZmllbGQiLCJvdGhlcl9maWVsZHMiLCJ1c2VfcHJpbnRlcnMiLCJjb252IiwidG9fc3RyaW5nX2RlZmF1bHQiLCJjaGFyJDAiLCJsaW5lIiwiY2hhciQxIiwibGluZSQwIiwiZmlsZSQwIiwiY2hhciQyIiwibGluZSQxIiwiZmlsZSQxIiwiY29uc3RydWN0b3IiLCJ0b19zdHJpbmckNiIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsInJhd19iYWNrdHJhY2VfZW50cmllcyIsImJ0IiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lIiwiYmFja3RyYWNlX3Nsb3RzIiwiYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSIsImVudHJ5IiwicmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwib2xkX3ByaW50ZXJzIiwibmV3X3ByaW50ZXJzIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJlcnJvcnMiLCJkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW4iLCJzdGF0dXMiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsImVtcHR5X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9leGNlcHRpb24iLCJkZWJ1Z2dlcl9pbl91c2UiLCJleG4kMCIsInJhd19iYWNrdHJhY2UkMCIsImNvbnN0JDAiLCJmbGlwIiwibmVnYXRlIiwicHJvdGVjdCIsImZpbmFsbHkkMCIsIndvcmsiLCJmaW5hbGx5X25vX2V4biIsIndvcmtfZXhuIiwid29ya19idCIsInByaW50X3N0YXQiLCJhbGxvY2F0ZWRfYnl0ZXMiLCJtYSIsInBybyIsIm1pIiwiY3JlYXRlX2FsYXJtIiwiZGVsZXRlX2FsYXJtIiwibnVsbF90cmFja2VyIiwic2FtcGxpbmdfcmF0ZSIsInRyYWNrZXIiLCJjYWxsc3RhY2tfc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwic3Vic3RyaW5nIiwic3ViYnl0ZXMiLCJmaWxlbmFtZSIsIm91dHB1dCQwIiwiZGlnZXN0IiwiaW5wdXQkMCIsImNoYXJfaGV4IiwidG9faGV4IiwiZnJvbV9oZXgiLCJkaWdpdCIsIm5ld19zdGF0ZSIsImFzc2lnbiIsInN0MSIsInN0MiIsImZ1bGxfaW5pdCIsInNlZWQiLCJzZWVkJDAiLCJtYWtlJDMiLCJtYWtlX3NlbGZfaW5pdCIsImNvcHkkNSIsImJpdHMiLCJjdXJ2YWwiLCJuZXd2YWwiLCJuZXd2YWwzMCIsImludGF1eCIsImludCQwIiwiYm91bmQiLCJmdWxsX2ludCIsImIxIiwiYjIiLCJicG9zIiwiYjMiLCJicG9zJDAiLCJpbnQzMiIsImludDY0IiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJiaXRzJDAiLCJpbnQkMSIsImZ1bGxfaW50JDAiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJwb3dlcl8yX2Fib3ZlIiwiY3JlYXRlJDMiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ2IiwibGVuZ3RoJDQiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoIiwibWF0Y2gkMCIsInJlc2l6ZSQwIiwib3NpemUiLCJpdGVyJDEwIiwiZG9fYnVja2V0Iiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiZm9sZCQ0IiwiYiQwIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJ0b19zZXEkOSIsInRibF9kYXRhIiwiYnVjayIsImJ1Y2skMCIsImJ1Y2skMSIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsImtleV9pbmRleCIsImJ1Y2tldCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9hbGwiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJyZXBsYWNlX3NlcSIsImNvcHkiLCJzeiIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsImFkZCQwIiwiZmluZCQwIiwiZmluZF9vcHQkMSIsImZpbmRfYWxsJDAiLCJtZW0kMiIsImFkZF9zZXEkMiIsIm9mX3NlcSQ3IiwicmVidWlsZCIsIndlYWtfY3JlYXRlIiwibGVuZ3RoJDUiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCQwIiwic2V0JDAiLCJnZXQkMSIsImdldF9jb3B5IiwiY2hlY2skMCIsImJsaXQkNCIsImZpbGwkMiIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJzeiQwIiwic3okMSIsImNvdW50X2J1Y2tldCIsImFkZF9hdXgiLCJzZXR0ZXIiLCJpbmRleCIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQkMCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXdidWNrZXQiLCJuZXd0Iiwib2IiLCJvaCIsInNldHRlciQwIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2J5dGVzIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInZhbGlkYXRlX2dlb21ldHJ5IiwibWFyZ2luIiwibWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Z1bGxfZ2VvbWV0cnkiLCJwcF9zZXRfZ2VvbWV0cnkiLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3VwZGF0ZV9nZW9tZXRyeSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2luZGVudCIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2IiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwib3Blbl9zdGFnIiwiY2xvc2Vfc3RhZyIsInByaW50X2FzIiwicHJpbnRfc3RyaW5nJDAiLCJwcmludF9ieXRlcyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfZ2VvbWV0cnkiLCJzYWZlX3NldF9nZW9tZXRyeSIsImdldF9nZW9tZXRyeSIsInVwZGF0ZV9nZW9tZXRyeSIsInNldF9tYXhfYm94ZXMiLCJnZXRfbWF4X2JveGVzIiwib3Zlcl9tYXhfYm94ZXMiLCJzZXRfZWxsaXBzaXNfdGV4dCIsImdldF9lbGxpcHNpc190ZXh0Iiwic2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsInNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwidnMiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwicHBfcHJpbnRfZWl0aGVyIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiaWZwcmludGYkMCIsImZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia2RwcmludGYiLCJkcHJpbnRmIiwia3ByaW50ZiIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiY2hhcl9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiY3JlYXRlJDQiLCJpbmFtZSIsImZyb21fc3RyaW5nJDEiLCJmcm9tX2Z1bmN0aW9uJDAiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJzdGRpYiIsIm9wZW5faW5fZmlsZSIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4iLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMyIsImNvbXBhcmUkMTQiLCJjb21wYXJlJDE1IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRfbW9kX2Jsb2NrIiwiY29tcHMkMCIsIm1vZHUiLCJzaGFwZSIsImZuJDAiLCJjb21wcyIsImluaXRfbW9kIiwidXBkYXRlX21vZF9ibG9jayIsImNsIiwidXBkYXRlX21vZCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJjb21tZW50IiwiZXNjYXBlIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsIm1heWJlX2NvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX2YiLCJxdW90ZSIsInF1b3RlX2NvbW1hbmQiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwiY2hvcF9zdWZmaXhfb3B0JDAiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNvbmNhdCQ0IiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwicHJuZyQwIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJ0cnlfbmFtZSIsImNvdW50ZXIkMSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwiYWRkJDEiLCJzdWIkNCIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJmbG9hdDMyIiwiZmxvYXQ2NCIsImludDhfc2lnbmVkIiwiaW50OF91bnNpZ25lZCIsImludDE2X3NpZ25lZCIsImludDE2X3Vuc2lnbmVkIiwiaW50MzIkMSIsImludDY0JDEiLCJpbnQkMiIsIm5hdGl2ZWludCQxIiwiY29tcGxleDMyIiwiY29tcGxleDY0Iiwia2luZF9zaXplX2luX2J5dGVzIiwiY19sYXlvdXQiLCJmb3J0cmFuX2xheW91dCIsImNsb29wIiwiaWR4IiwiY29sIiwiZmxvb3AiLCJpbml0JDUiLCJsYXlvdXQiLCJkaW1zIiwiZGxlbiIsInNpemVfaW5fYnl0ZXMiLCJjcmVhdGUkOCIsImdldCQyIiwic2V0JDEiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQ5IiwiZGltIiwic2l6ZV9pbl9ieXRlcyQxIiwic2xpY2UiLCJpbml0JDYiLCJvZl9hcnJheSIsImJhIiwiY3JlYXRlJDEwIiwiZGltMSIsImRpbTIiLCJzaXplX2luX2J5dGVzJDIiLCJzbGljZV9sZWZ0Iiwic2xpY2VfcmlnaHQiLCJpbml0JDciLCJvZl9hcnJheSQwIiwicm93IiwiY3JlYXRlJDExIiwiZGltMyIsInNpemVfaW5fYnl0ZXMkMyIsInNsaWNlX2xlZnRfMSIsInNsaWNlX3JpZ2h0XzEiLCJzbGljZV9sZWZ0XzIiLCJzbGljZV9yaWdodF8yIiwiaW5pdCQ4Iiwib2ZfYXJyYXkkMSIsImFycmF5MF9vZl9nZW5hcnJheSIsImFycmF5MV9vZl9nZW5hcnJheSIsImFycmF5Ml9vZl9nZW5hcnJheSIsImFycmF5M19vZl9nZW5hcnJheSIsInJlc2hhcGVfMCIsInJlc2hhcGVfMSIsInJlc2hhcGVfMiIsInJlc2hhcGVfMyIsImdsb2JhbFRoaXMiLCJTeW1ib2wiLCJudWxsIiwidW5kZWZpbmVkIiwiZXhuIiwiam9vX2dsb2JhbF9vYmplY3QiLCJudWxsIiwidW5kZWZpbmVkIiwiZXhuIiwiZXZlbnQiLCJzeW1ib2wiLCJzeW1ib2wkMCIsInN5bWJvbCQxIiwic3ltYm9sJDIiLCJzeW1ib2wkMyIsInN5bWJvbCQ0IiwiYSIsImIiLCJzeW1ib2wkNSIsIm1vZCIsImxhbmQiLCJsb3IiLCJseG9yIiwibHNsIiwibHNyIiwiY29tcGFyZSIsIm1heF9pbnQiLCJ6ZXJvIiwib25lIiwiZXF1YWwiLCJ4IiwieSIsImxlIiwiYWRkIiwic3ViIiwibXVsIiwiZGl2IiwicmVtIiwic3VjYyIsInByZWQiLCJsb2dhbmQiLCJsb2dvciIsImxvZ3hvciIsInNoaWZ0X2xlZnQiLCJzaGlmdF9yaWdodCIsIm9mX2ludCIsIm9mX2NoYXIiLCJjIiwidG9fY2hhciIsInQiLCJzaG93IiwiY29tcGFyZSQwIiwibWF4X2ludCQwIiwiemVybyQwIiwib25lJDAiLCJlcXVhbCQwIiwibGUkMCIsImFkZCQwIiwic3ViJDAiLCJtdWwkMCIsImRpdiQwIiwicmVtJDAiLCJzdWNjJDAiLCJwcmVkJDAiLCJsb2dhbmQkMCIsImxvZ29yJDAiLCJsb2d4b3IkMCIsInNoaWZ0X2xlZnQkMCIsInNoaWZ0X3JpZ2h0JDAiLCJvZl9pbnQkMCIsInNob3ckMCIsInN5bWJvbCQ2Iiwic3ltYm9sJDciLCJzeW1ib2wkOCIsInN5bWJvbCQ5Iiwic3ltYm9sJDEwIiwic3ltYm9sJDExIiwic3ltYm9sJDEyIiwibW9kJDAiLCJsYW5kJDAiLCJsb3IkMCIsImx4b3IkMCIsImxzbCQwIiwibHNyJDAiLCJvZl91aW50OCIsInRvX3VpbnQ4Iiwib2ZfYnl0ZSIsIm9mX2ludCQxIiwiaXNfbmVnIiwiYWJzIiwidG9faW50Iiwic2hvdyQxIiwic2hvd190eXBlIiwic2hvdyQyIiwiY3JlYXRlIiwiaWVfYWRkciIsImlmX2FkZHIiLCJ1cGRhdGUiLCJzdGF0ZSIsInR5cGUiLCJyZXF1ZXN0IiwiY2xlYXIiLCJjbGVhcl9hbGwiLCJuZXh0IiwiYWNjZXB0cyIsImFkZHIiLCJieXRlX29mX3N0YXRlIiwicyIsInJlYWRfYnl0ZSIsInN0YXRlX29mX2J5dGUiLCJiMCIsImIxIiwiYjIiLCJiMyIsImI0Iiwid3JpdGVfYnl0ZSIsImRhdGEiLCJjcmVhdGUkMCIsImRpdl9hZGRyIiwidGltYV9hZGRyIiwidG1hX2FkZHIiLCJ0YWNfYWRkciIsImljIiwicnVuIiwibWN5Y2xlcyIsImJlZm9yZV9tY3ljbGVfY291bnQiLCJhZnRlcl9tY3ljbGVfY291bnQiLCJxdW90aWVudF9kaWZmIiwiZGl2aWRlciIsInF1b3RpZW50X2RpZmYkMCIsImJlZm9yZV90aW1hX2NvdW50ZXIiLCJhZnRlcl90aW1hX2NvdW50ZXIiLCJhY2NlcHRzJDAiLCJyZWFkX2J5dGUkMCIsImVuYWJsZV9iaXQiLCJ3cml0ZV9ieXRlJDAiLCJieXRlJDAiLCJnZXRfdGltYV9jb3VudCIsImNyZWF0ZSQxIiwiYXJlYTBfc3RhcnRfYWRkciIsImFyZWEwX2VuZF9hZGRyIiwiYXJlYTFfc3RhcnRfYWRkciIsImFyZWExX2VuZF9hZGRyIiwiZ2V0X3RpbGVfaW5kZXgiLCJhcmVhIiwiYWNjZXB0cyQxIiwicmVhZF9ieXRlJDEiLCJvZmZzZXQiLCJvZmZzZXQkMCIsIndyaXRlX2J5dGUkMSIsImJpdGZsYWdzX29mX2J5dGUiLCJieXRlX29mX2JpdGZsYWdzIiwiYjciLCJiNiIsImI1IiwiYml0YXJyYXlfb2ZfYnl0ZSIsImJ5dGVfb2ZfYml0YXJyYXkiLCJhY2MiLCJpIiwib2ZfYml0cyIsImhpIiwibG8iLCJ0b19pbnQkMCIsInNldF9iaXQiLCJjbGVhcl9iaXQiLCJnZXRfYml0IiwiY3JlYXRlJDIiLCJzdGFydF9hZGRyIiwiZW5kX2FkZHIiLCJ0aWxlcyIsImdldF9yb3dfcGl4ZWxzIiwiaW5kZXgiLCJyb3ciLCJzaWduZWRfaW5kZXgiLCJpbmRleCQwIiwiZ2V0X3BpeGVsIiwiY29sIiwicm93JDAiLCJnZXRfZnVsbF9waXhlbHMiLCJwcmludF9mdWxsX3BpeGVscyIsImNvbG9yX2lkcyIsImFjY2VwdHMkMiIsInJlYWRfYnl0ZSQyIiwiaGlfb3JfbG8iLCJpZCIsIndyaXRlX2J5dGUkMiIsImRhdGFfYml0cyIsImNvbG9yc19pbl9yb3ciLCJjcmVhdGUkMyIsInN0cmluZyIsImJ5dGVzIiwiYWNjZXB0cyQzIiwicmVhZF9ieXRlJDMiLCJ3cml0ZV9ieXRlJDMiLCJjcmVhdGUkNCIsInRhcmdldCIsInRhcmdldF9zdGFydCIsInNoYWRvd19zdGFydCIsInNoYWRvd19lbmQiLCJhY2NlcHRzJDQiLCJyZWFkX2J5dGUkNCIsIndyaXRlX2J5dGUkNCIsImNyZWF0ZSQ1Iiwib3B0Iiwic3RoIiwiZGVmYXVsdCQwIiwiYWNjZXB0cyQ1IiwicmVhZF9ieXRlJDUiLCJ3cml0ZV9ieXRlJDUiLCJwZWVrIiwiY3JlYXRlJDYiLCJzYiIsInNjIiwicHJpbnRfc2VyaWFsX3BvcnQiLCJyZWFkX2J5dGUkNiIsIndyaXRlX2J5dGUkNiIsImFjY2VwdHMkNiIsImNyZWF0ZSQ3IiwicmVhZF9yIiwicmVhZF9yciIsInJyIiwid3JpdGVfciIsInIiLCJ3cml0ZV9yciIsIngkMCIsImhpZ2giLCJsb3ciLCJyZWFkX2ZsYWciLCJmbGFnIiwiZiIsIm1hc2tfMGIwMDAxMDAwMCIsIm1hc2tfMGIxMTEwMDAwMCIsIm1hc2tfMGIwMDEwMDAwMCIsIm1hc2tfMGIxMTAxMDAwMCIsIm1hc2tfMGIwMTAwMDAwMCIsIm1hc2tfMGIxMDExMDAwMCIsIm1hc2tfMGIxMDAwMDAwMCIsIm1hc2tfMGIwMTExMDAwMCIsIm1hc2tfMGIxMTEwMTExMSIsIm1hc2tfMGIxMTAxMTExMSIsIm1hc2tfMGIxMDExMTExMSIsIm1hc2tfMGIwMTExMTExMSIsInNldF9mbGFnIiwic2V0X2ZsYWdzIiwic3RoJDAiLCJoIiwic3RoJDEiLCJuIiwic3RoJDIiLCJ6IiwidW5zZXRfZmxhZyIsImNsZWFyX2ZsYWdzIiwic2hvd19yIiwic2hvd19yciIsInNob3ckMyIsInJvbV9maWxlX25hbWUiLCJyb21faW4iLCJyb21fbGVuIiwicm9tX3N0cmluZyIsImNyZWF0ZSQ4IiwibG9va3VwIiwiY29sb3JfaWQiLCJhY2NlcHRzJDciLCJyZWFkX2J5dGUkNyIsImJpdHNfb2ZfY29sb3IiLCJ3cml0ZV9ieXRlJDciLCJjb2xvcl9vZl9iaXRzIiwiZGF0YSQwIiwic2hvd19zcHJpdGUiLCJjcmVhdGUkOSIsImRlZmF1bHRfc3ByaXRlIiwic3ByaXRlcyIsInJlYWRfYnl0ZSQ4Iiwic3ByaXRlIiwid3JpdGVfYnl0ZSQ4Iiwic3ByaXRlX2luZGV4IiwieF9mbGlwIiwieV9mbGlwIiwicHJpb3JpdHkiLCJwYWxsZXRlIiwidGlsZV92cmFtX2JhbmsiLCJwYWxsZXRlX251bSIsImFjY2VwdHMkOCIsImdldF9hbGxfc3ByaXRlcyIsIndyaXRlX3dpdGhfb2Zmc2V0IiwidG9faW50JDEiLCJjcmVhdGUkMTAiLCJnZXRfbGNkX2VuYWJsZSIsImdldF93aW5kb3dfdGlsZV9tYXBfYXJlYSIsImdldF93aW5kb3dfZW5hYmxlIiwiZ2V0X3RpbGVfZGF0YV9hcmVhIiwiZ2V0X2JnX3RpbGVfbWFwX2FyZWEiLCJnZXRfb2JqX3NpemUiLCJnZXRfb2JqX2VuYWJsZSIsImdldF9iZ193aW5kb3dfZGlzcGxheSIsImFjY2VwdHMkOSIsInJlYWRfYnl0ZSQ5Iiwid3JpdGVfYnl0ZSQ5IiwiY3JlYXRlJDExIiwic2N5X2FkZHIiLCJzY3hfYWRkciIsImx5X2FkZHIiLCJseWNfYWRkciIsInd5X2FkZHIiLCJ3eF9hZGRyIiwiZ2V0X3NjeSIsImdldF9zY3giLCJnZXRfbHkiLCJpbmNyX2x5IiwicmVzZXRfbHkiLCJnZXRfbHljIiwiZ2V0X3d5IiwiZ2V0X3d4IiwiYWNjZXB0cyQxMCIsInJlZ2lzdGVyX29mX2FkZHIiLCJyZWFkX2J5dGUkMTAiLCJ3cml0ZV9ieXRlJDEwIiwiY3JlYXRlJDEyIiwiaXNfZW5hYmxlZCIsImdldF9seWNfZXFfbHlfZmxhZyIsInNldF9seWNfZXFfbHlfZmxhZyIsImdldF9ncHVfbW9kZSIsInNldF9ncHVfbW9kZSIsIm1vZGUiLCJhY2NlcHRzJDExIiwicmVhZF9ieXRlJDExIiwid3JpdGVfYnl0ZSQxMSIsInBlZWskMCIsImhhbmRsZV9seV9lcV9seWMiLCJseSIsImx5YyIsImx5X2VxX2x5YyIsInNjcmVlbl93Iiwic2NyZWVuX2giLCJjcmVhdGUkMTMiLCJ0aWxlX2RhdGEiLCJ0aWxlX21hcCIsIm9hbSIsImJncCIsIm9icDAiLCJvYnAxIiwibGNkX3N0YXQiLCJsY2RfY29udHJvbCIsImxjZF9wb3NpdGlvbiIsInNldF9tY3ljbGVzX2luX21vZGUiLCJtY3ljbGVzX2luX21vZGUiLCJnZXRfZnJhbWVfYnVmZmVyIiwicnVuJDAiLCJpbmNyX2x5JDAiLCJ0aWxlX2RhdGFfYXJlYSIsInNjeSIsInNjeCIsImJnX3RpbGVfbWFwX2FyZWEiLCJyb3dfaW5fdGlsZSIsImx4IiwiY29sX2luX3RpbGUiLCJ0aWxlX2luZGV4IiwidGlsZV9waXhlbF9yb3ciLCJsZW4iLCJjb2xvciIsInd5Iiwid3giLCJ3aW5kb3dfdGlsZV9tYXBfYXJlYSIsInlfaW5fdyIsInJvd19pbl90aWxlJDAiLCJ3eCQwIiwibHgkMCIsInhfaW5fdyIsInRpbGVfaW5kZXgkMCIsInRpbGVfcGl4ZWxfcm93JDAiLCJsZW4kMCIsImkkMCIsImNvbG9yJDAiLCJ5X3Nwcml0ZV9zaXplIiwibHkkMCIsImx5JDEiLCJhY2NlcHRzJDEyIiwicmVhZF9ieXRlJDEyIiwid3JpdGVfYnl0ZSQxMiIsImxjZF9lbmFibGVfYmVmb3JlIiwibGNkX2VuYWJsZV9hZnRlciIsIndyaXRlX29hbV93aXRoX29mZnNldCIsInJ1biQxIiwibW9kZV9iZWZvcmUiLCJtb2RlX2FmdGVyIiwic2hvdyQ0IiwiaW50JDAiLCJpbnRlcnJ1cHRfc3RyIiwiZ2V0X21jeWNsZXNfaW5fbW9kZSIsImNyZWF0ZSQxNCIsInByZXNzIiwia2V5IiwicmVsZWFzZSIsInJlYWRfYnl0ZSQxMyIsIndyaXRlX2J5dGUkMTMiLCJhY2NlcHRzJDEzIiwiY2FydHJpZGdlIiwid3JhbSIsImdwdSIsInplcm9fcGFnZSIsInNoYWRvd19yYW0iLCJqb3lwYWQiLCJzZXJpYWxfcG9ydCIsInRpbWVyIiwiZG1hX3RyYW5zZmVyIiwic291cmNlIiwicmVhZF93b3JkIiwid3JpdGVfd29yZCIsInNob3dfYXJnIiwibiQwIiwicnIkMCIsIm4kMiIsIm4kMyIsIm4kMSIsInNob3dfY29uZGl0aW9uIiwic2hvdyQ1IiwieSQwIiwieSQxIiwieCQxIiwieSQyIiwieCQyIiwieSQzIiwieSQ0IiwieCQzIiwieSQ1IiwieCQ0IiwieSQ2IiwieCQ1IiwieSQ3IiwieCQ2IiwieSQ4IiwieCQ3IiwieSQ5IiwieCQ4IiwieSQxMCIsIngkOSIsIngkMTAiLCJ4JDExIiwieCQxMiIsIngkMTMiLCJ4JDE0IiwieCQxNSIsIngkMTYiLCJ4JDE3IiwieCQxOCIsIngkMTkiLCJ4JDIwIiwieCQyMSIsIngkMjIiLCJ4JDIzIiwieCQyNCIsIngkMjUiLCJ4JDI2IiwiYyQwIiwieCQyNyIsImMkMSIsIngkMjgiLCJjJDIiLCJ4MDAiLCJ4MDgiLCJ4MTAiLCJ4MTgiLCJ4MjAiLCJ4MjgiLCJ4MzAiLCJ4MzgiLCJsMSIsImwyIiwibDMiLCJtbXUiLCJwYyIsImFkZHJfYWZ0ZXJfcGMiLCJuZXh0X2J5dGUiLCJuZXh0X3dvcmQiLCJvcCIsIm9wJDAiLCJzaG93JDYiLCJjcmVhdGUkMTUiLCJyb21fYnl0ZXMiLCJjYXJ0cmlkZ2VfdHlwZSIsInJvbV9iYW5rX2NvdW50IiwicmFtX2JhbmtfY291bnQiLCJnZXRfY2FydHJpZGdlX3R5cGUiLCJnZXRfcm9tX2JhbmtfY291bnQiLCJnZXRfcmFtX2JhbmtfY291bnQiLCJjcmVhdGUkMTYiLCJyb21fYmFua19zaXplIiwicmFtX2Jhbmtfc2l6ZSIsInJhbV9ieXRlcyIsInJhbV9hZGRyX29mX2FkZHIiLCJyZWFkX2J5dGUkMTQiLCJhZGRyJDAiLCJ6ZXJvX2JhbmtfbnVtIiwiYml0NSIsImhpZ2hfYmFua19udW0iLCJiaXQ1NiIsIndyaXRlX2J5dGUkMTQiLCJyb21fYmFua19udW0iLCJyYW1fYWRkciIsImFjY2VwdHMkMTQiLCJjcmVhdGUkMTciLCJyZWFkX2J5dGUkMTUiLCJ3cml0ZV9ieXRlJDE1IiwiYWNjZXB0cyQxNSIsImYkMCIsInJlZ2lzdGVycyIsInNwIiwiaGFsdGVkIiwiaW1lIiwiZXhlY3V0ZSIsImluc3QiLCJzZXRfZmxhZ3MkMCIsInJlYWQiLCJhcmciLCJhZGRyJDEiLCJhZGRyJDIiLCJhZGRyJDMiLCJhZGRyJDQiLCJhZGRyJDUiLCJjaGVja19jb25kaXRpb24iLCJuX2ZsYWciLCJjX2ZsYWciLCJoX2ZsYWciLCJjX2ZsYWckMCIsImhfZmxhZyQwIiwibmV4dF9wYyIsImEkMCIsImEkMSIsIm9sZF9jIiwibmV3X2MiLCJhJDIiLCJhJDMiLCJvbGRfYyQwIiwibmV3X2MkMCIsIm4kNCIsIm4kNSIsIm4kNiIsIm4kNyIsInkkMTEiLCJjJDMiLCJ5JDEyIiwibiQ4IiwieSQxMyIsIm4kOSIsInkkMTQiLCJuJDEwIiwieSQxNSIsIm4kMTEiLCJ5JDE2IiwieSQxNyIsIm4kMTIiLCJuJDEzIiwibiQxNCIsIm4kMTUiLCJjJDQiLCJuJDE2Iiwib2xkX2MkMSIsIm4kMTciLCJuZXdfYyQxIiwieCQyOSIsIngkMzAiLCJjJDUiLCJuJDE4IiwieCQzMSIsIngkMzIiLCJvbGRfYyQyIiwibiQxOSIsIngkMzMiLCJ4JDM0IiwibiQyMCIsIngkMzUiLCJ4JDM2IiwibiQyMSIsIngkMzciLCJ4JDM4IiwibiQyMiIsIngkMzkiLCJuJDIzIiwieCQ0MCIsIm4kMjQiLCJ4JDQxIiwibiQyNSIsIm1hc2siLCJ4JDQyIiwiYyQ2IiwieCQ0MyIsImMkNyIsIngkNDQiLCJjJDgiLCJ4JDQ1IiwiYyQ5IiwiYnJhbmNoZWRfbWN5Y2xlIiwibm90X2JyYW5jaGVkX21jeWNsZSIsInJ1bl9pbnN0cnVjdGlvbiIsImluc3RfbWN5Y2xlcyIsImludGVycnVwdF9tY3ljbGVzIiwicHJldl9pbnN0IiwiY3JlYXRlJDE4IiwicmVhZF9ieXRlJDE2Iiwid3JpdGVfYnl0ZSQxNiIsImFjY2VwdHMkMTYiLCJsY2Rfc3RhdF9hZGRyIiwiY3JlYXRlX3dpdGhfcm9tIiwib2FtX3RhYmxlIiwiY3B1IiwicmVnIiwicHJlc3MkMCIsInJlbGVhc2UkMCIsImdldF9sY2Rfc3RhdCIsInJvbV9vcHRpb25zIiwiZ2JfdyIsImdiX2giLCJhbGVydCIsInYiLCJmaW5kX2VsX2J5X2lkIiwiaWQiLCJkcmF3X2ZyYW1lYnVmZmVyIiwiY3R4IiwiaW1hZ2VfZGF0YSIsImZiIiwiZCIsInkiLCJ4Iiwib2ZmIiwicnVuX2lkIiwia2V5X2Rvd25fbGlzdGVuZXIiLCJrZXlfdXBfbGlzdGVuZXIiLCJzZXRfbGlzdGVuZXIiLCJkb3duIiwidXAiLCJjbGVhciIsInRpbWVyX2lkIiwibGlzdGVyIiwibGlzdGVyJDAiLCJzZXRfdXBfa2V5Ym9hcmQiLCJDIiwidCIsImV2Iiwia2V5X25hbWUiLCJzZXRfdXBfam95cGFkIiwicmlnaHRfZWwiLCJsZWZ0X2VsIiwiZG93bl9lbCIsInVwX2VsIiwiYl9lbCIsImFfZWwiLCJzZWxlY3RfZWwiLCJzdGFydF9lbCIsInByZXNzIiwia2V5IiwicmVsZWFzZSIsImxpc3Rlbl9vcHMiLCJ0aHJvdHRsZWQiLCJydW5fcm9tX2J5dGVzIiwicm9tX2J5dGVzIiwiY2FydHJpZGdlIiwiY250Iiwic3RhcnRfdGltZSIsIm1haW5fbG9vcCIsImVuZF90aW1lIiwic2VjX3Blcl82MF9mcmFtZSIsImZwcyIsImZwc19zdHIiLCJmcHNfZWwiLCJydW5fcm9tX2Jsb2IiLCJyb21fYmxvYiIsInJlc3VsdCIsImJ1ZiIsImUiLCJvbl9sb2FkX3JvbSIsImlucHV0X2VsIiwiZmlsZSIsInJ1bl9zZWxlY3RlZF9yb20iLCJyb21fcGF0aCIsInJlc3BvbnNlIiwiYmxvYiIsInNldF91cF9yb21fc2VsZWN0b3IiLCJzZWxlY3Rvcl9lbCIsInJvbV9vcHRpb24iLCJvbl9jaGFuZ2UiLCJvbl9jaGVja2JveF9jaGFuZ2UiLCJjaGVja2JveF9lbCIsImNoZWNrZWQiLCJjYW52YXMiLCJyb20iLCJmdXQiXSwic291cmNlcyI6WyIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL2JpZ3N0cmluZ2FmL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9idWlsdGluLytpbnRzLmpzIiwiL2J1aWx0aW4vK2hhc2guanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvdWNoYXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEF0b21pYy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvc3RkbGliLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9wZXJ2YXNpdmVzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL29wdGlvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvZWl0aGVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2Jvb2wubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvaW50Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC91bml0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9tYXJzaGFsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2FycmF5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9tYXAubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL3N0YWNrLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9mdW4ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2djLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2Zvcm1hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxPTy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTW9kLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX29wYW0vbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fb3BhbS9saWIvb2NhbWwvYmlnYXJyYXkubWwiLCIiLCIiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL3V0aWxzL3VpbnRzL3VpbnRzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19idWlsZC9kZWZhdWx0L2xpYi9pbnRlcnJ1cHRfY29udHJvbGxlci9pbnRlcnJ1cHRfY29udHJvbGxlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvdGltZXIvdGltZXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2dwdS90aWxlX21hcC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvdXRpbHMvYml0X3V0aWwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2dwdS9jb2xvcl9pZC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvZ3B1L3RpbGVfZGF0YS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvc2hhcmVkL3JhbS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvbW11L3NoYWRvd19yYW0ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL3NoYXJlZC9tbWFwX3JlZ2lzdGVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19idWlsZC9kZWZhdWx0L2xpYi9zZXJpYWxfcG9ydC9zZXJpYWxfcG9ydC5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY3B1L3JlZ2lzdGVycy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvdXRpbHMvcmVhZF9yb21fZmlsZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvZ3B1L3BhbGxldGUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2dwdS9vYW1fdGFibGUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2dwdS9ncHVfbW9kZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvZ3B1L2xjZF9jb250cm9sLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19idWlsZC9kZWZhdWx0L2xpYi9ncHUvbGNkX3Bvc2l0aW9uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19idWlsZC9kZWZhdWx0L2xpYi9ncHUvbGNkX3N0YXQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2dwdS9ncHUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2pveXBhZC9qb3lwYWQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL21tdS9tbXUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2NwdS9pbnN0cnVjdGlvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY3B1L2ZldGNoX2FuZF9kZWNvZGUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2NhcnRyaWRnZS9jYXJ0cmlkZ2VfdHlwZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY2FydHJpZGdlL2NhcnRyaWRnZV9oZWFkZXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2NhcnRyaWRnZS9jYXJ0cmlkZ2VfbWJjMS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY2FydHJpZGdlL2NhcnRyaWRnZV9yb21fb25seS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY2FydHJpZGdlL2RldGVjdF9jYXJ0cmlkZ2UubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2NwdS9jcHUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9DQU1MQk9ZL0NBTUxCT1kvX2J1aWxkL2RlZmF1bHQvbGliL2NhcnRyaWRnZS9jYXJ0cmlkZ2VfbWJjMy5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9saWIvY2FtbGJveS5tbCIsIi9ob21lL3J1bm5lci93b3JrL0NBTUxCT1kvQ0FNTEJPWS9fYnVpbGQvZGVmYXVsdC9iaW4vd2ViL2luZGV4Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvQ0FNTEJPWS9DQU1MQk9ZL19vcGFtL2xpYi9vY2FtbC9zdGRfZXhpdC5tbCJdLCJtYXBwaW5ncyI6Ijs7OztJQTBPQSxTQUFTQSxtQkFBbUJDLEdBQUssU0FBUSxVQUFZO0lDekxyRCxTQUFTQyxnQkFBZ0JDLEVBQUdDO01BQzFCLEdBQUdELE9BQVE7TUFDWCxHQUFJQyxTQUFVLE9BQVEsU0FBU0Q7TUFDL0IsSUFBTSxLQUFRO01BQ2Q7T0FBUSxDQUNOLEdBQUlBLE1BQU9FLEtBQUtEO1FBQ2hCRDtRQUNBLEdBQUlBLE9BQVEsT0FBT0U7UUFDbkJELEtBQUtBO1FBQ0xFO1FBQ0EsR0FBSUEsT0FBUSxhQU1oQjtJRDdDQSxJQUFJQyxrQkFBb0I7SUVBeEIsU0FBU0Usb0JBQXFCQyxLQUFPLE1BQU1BLEdBQUs7SUMyQ2hELElBQUlDO0lETEosU0FBU0M7TUFDUCxvQkFBb0JELGtDQUN0QjtJRnBDQSxTQUFT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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VTs7Ozs7OztJd0J0VkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2tCS0M7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FtSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ285RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2xsRmRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDc0VFQztLQUNBQztLQUNBQztLQUNBQzs7O0tBL0VZQztLQW1IWkM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQW1JQUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQ3hQRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQ0NDQztJREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUNDQ0MsS0RERCxHQ0NDQztJREREOzs7Ozs7O2VDQ0NIO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bURDQ1lJLEtBQU8sTUFBTUEsR0FBdkIsSURERjs7Ozs7aUJDQ0NIO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNDQ0k7S0RERDtnQkNDQ0M7S0RERCxJQ0NDQztJREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkNDWUMsS0FBTyxNQUFNQSxHQUF2Qjs7MEJEREY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkNDQ0MsTURERDs7Ozs7Ozs7Ozt5QkNDQ0EsTURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNDa0I7O09BRVhDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO2VBQ0FDLFNBQWNDLEVBQUVDLEdBQVMsMkJBQVhELEVBQUVDLEVBQW9COztPQUNwQ0M7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7O2NBWkFkO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FHO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO2NBQ0FDO0lB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QzZEO0lBQWpFLHVDQURJQTtJQUdjLElBQWRPLFlBQWM7SUFDbEIsb0JBYkk1RCxJQUVBQyxXQVVBMkQ7SUFBYztLQUdSLDhCQTNPUnBFO0tBNE9RLHFCQWhCTlEsSUFFQUMsV0FhQWtFO0lBQ00sb0JBQ2UsUUFBRTtJQUEzQixrQkFESUM7SUFDSjs7O09BalBFM0U7T0FDQUM7T0FHQUY7T0FVQUc7T0FJQUU7T0FFQUU7O09BdURBa0I7T0FpQ0FLO09BMEJBYTtPQUVBQztPQXFDQVc7T0FjQUs7T0FLQUc7T0FZQUk7T0FhQUk7SUF3QkY7VUR6UEg7Ozs7Ozs7SUNBQTs7OztJQ2tCUzs7O1VEbEJUIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSxiLGMsZCxlKSB7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmdzIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyAodGFnLCBhcmdzKSB7IHRocm93IFswLCB0YWddLmNvbmNhdChhcmdzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgLy9GSVhNRSwgY2FuIGhhcHBlbiB3aXRoIHRvbyBtYW55IGFyZ3VtZW50c1xuICBpZih0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZjtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmKG4gPT09IDApIHJldHVybiBmLmFwcGx5KG51bGwsYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKSxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCl7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYnVmZmVyKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5leHBtMSh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9leHAyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cDJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5wb3coMiwgeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cxcCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cyKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7IHJldHVybiBNYXRoLmh5cG90KHgsIHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmxvZzEwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Fjb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Fjb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFjb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5zaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2FzaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2FzaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFzaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC50YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2F0YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2F0YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmF0YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NicnRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2JydF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jYnJ0KHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2VyZl9mbG9hdCh4KSB7XG4gIHZhciBhMSA9IDAuMjU0ODI5NTkyO1xuICB2YXIgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIHZhciBhMyA9IDEuNDIxNDEzNzQxO1xuICB2YXIgYTQgPSAtMS40NTMxNTIwMjc7XG4gIHZhciBhNSA9IDEuMDYxNDA1NDI5O1xuICB2YXIgcCA9IDAuMzI3NTkxMTtcblxuICB2YXIgc2lnbiA9IDE7XG4gIGlmICh4IDwgMCkge1xuICAgIHNpZ24gPSAtMTtcbiAgfVxuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHZhciB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcbiAgdmFyIHkgPSAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm1hX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZtYV9mbG9hdCh4LCB5LCB6KSB7XG4gIHZhciBTUExJVCA9IE1hdGgucG93KDIsIDI3KSArIDE7XG4gIHZhciBNSU5fVkFMVUUgPSBNYXRoLnBvdygyLCAtMTAyMik7XG4gIHZhciBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgdmFyIEMgPSA0MTY7XG4gIHZhciBBID0gTWF0aC5wb3coMiwgK0MpO1xuICB2YXIgQiA9IE1hdGgucG93KDIsIC1DKTtcblxuICBmdW5jdGlvbiBtdWx0aXBseSAoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9ICgoYWhpICogYmhpIC0gcCkgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkpICsgYWxvICogYmxvO1xuICAgIHJldHVybiB7XG4gICAgICBwOiBwLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgdiA9IHMgLSBhO1xuICAgIHZhciBlID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IHMsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGp1c3QgKHgsIHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCAmJiB5ICE9PSAwICYmIFNQTElUICogeCAtIChTUExJVCAqIHggLSB4KSA9PT0geCA/IHggKiAoMSArICh4IDwgMCA/IC0xIDogKzEpICogKHkgPCAwID8gLTEgOiArMSkgKiBFUFNJTE9OKSA6IHg7XG4gIH07XG5cbiAgaWYgKHggPT09IDAgfHwgeCAhPT0geCB8fCB4ID09PSArMSAvIDAgfHwgeCA9PT0gLTEgLyAwIHx8XG4gICAgICB5ID09PSAwIHx8IHkgIT09IHkgfHwgeSA9PT0gKzEgLyAwIHx8IHkgPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKHogIT09IHogfHwgeiA9PT0gKzEgLyAwIHx8IHogPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMTtcbiAgd2hpbGUgKE1hdGguYWJzKHgpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeCAqPSBCO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHkgKj0gQjtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICogc2NhbGU7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHgpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeCAqPSBBO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHkgKj0gQTtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciB4cyA9IHg7XG4gIHZhciB5cyA9IHk7XG4gIHZhciB6cyA9IHogLyBzY2FsZTtcblxuICBpZiAoTWF0aC5hYnMoenMpID4gTWF0aC5hYnMoeHMgKiB5cykgKiA0IC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCBNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04gLyA0ICogRVBTSUxPTiAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKXtcbiAgcmV0dXJuIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpID8gKG5hbWUgKyBcIi9cIikgOiBuYW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5pZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCl7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCJ9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9IGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHwgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKSB7XG4gIGZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykgcmV0dXJuIFtcIlwiLCBwYXRoLnN1YnN0cmluZygxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgIHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYykpIHtcbiAgICAgIHZhciByb290ID0gKHJlc3VsdFsxXSB8fCAnJyk7XG4gICAgICB2YXIgc2VwID0gKHJlc3VsdFsyXSB8fCAnJyk7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc3Vic3RyaW5nKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG4gIH1cbiAgZWxzZSByZXR1cm4gcG9zaXhcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYoICFwYXRoX2lzX2Fic29sdXRlKG5hbWUpIClcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLnVuc2hpZnQoY29tcDBbMF0pO1xuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOlwiL3N0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoXCIvc3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSk7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICBpZiggIXJlcykge1xuICAgIHZhciByb290ID0gY2FtbF9nZXRfcm9vdChuYW1lKTtcbiAgICBpZiAocm9vdCAmJiByb290Lm1hdGNoKC9eW2EtekEtWl06XFwvJC8pKXtcbiAgICAgIHZhciBtID0ge3BhdGg6cm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShyb290KX07XG4gICAgICBqc29vX21vdW50X3BvaW50LnB1c2gobSk7XG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICAgIH1cbiAgfVxuICBpZiggcmVzICkgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9zeXNfbWtkaXIobmFtZSwgcGVybSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCxwZXJtKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm90X2FfZGlyXG5mdW5jdGlvbiBjYW1sX3N5c19ybWRpcihuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZigham9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXApIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1qb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUgPSBjYW1sX2NyZWF0ZV9maWxlO1xuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIGNvbnRlbnQgPSAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTpjb250ZW50O1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldERhdGUoKSwgZC5nZXRNb250aCgpLCBkLmdldEZ1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiB1bml4X2lzYXR0eVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHVuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG4gICAgcmV0dXJuIHR0eS5pc2F0dHkoZmlsZURlc2NyaXB0b3IpPzE6MDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBtYWtlX3VuaXhfZXJyX2FyZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgdW5peF9lcnJvciA9IFtcbiAgLyogPT09VW5peC5lcnJvcj09PVxuICAgKlxuICAgKiBUaGlzIGFycmF5IGlzIGluIG9yZGVyIG9mIHRoZSB2YXJpYW50IGluIE9DYW1sXG4gICAqL1xuICBcIkUyQklHXCIsIFwiRUFDQ0VTXCIsIFwiRUFHQUlOXCIsIFwiRUJBREZcIiwgXCJFQlVTWVwiLCBcIkVDSElMRFwiLCBcIkVERUFETEtcIiwgXCJFRE9NXCIsXG4gIFwiRUVYSVNUXCIsIFwiRUZBVUxUXCIsIFwiRUZCSUdcIiwgXCJFSU5UUlwiLCBcIkVJTlZBTFwiLCBcIkVJT1wiLCBcIkVJU0RJUlwiLCBcIkVNRklMRVwiLFxuICBcIkVNTElOS1wiLCBcIkVOQU1FVE9PTE9OR1wiLCBcIkVORklMRVwiLCBcIkVOT0RFVlwiLCBcIkVOT0VOVFwiLCBcIkVOT0VYRUNcIiwgXCJFTk9MQ0tcIixcbiAgXCJFTk9NRU1cIiwgXCJFTk9TUENcIiwgXCJFTk9TWVNcIiwgXCJFTk9URElSXCIsIFwiRU5PVEVNUFRZXCIsIFwiRU5PVFRZXCIsIFwiRU5YSU9cIixcbiAgXCJFUEVSTVwiLCBcIkVQSVBFXCIsIFwiRVJBTkdFXCIsIFwiRVJPRlNcIiwgXCJFU1BJUEVcIiwgXCJFU1JDSFwiLCBcIkVYREVWXCIsIFwiRVdPVUxEQkxPQ0tcIixcbiAgXCJFSU5QUk9HUkVTU1wiLCBcIkVBTFJFQURZXCIsIFwiRU5PVFNPQ0tcIiwgXCJFREVTVEFERFJSRVFcIiwgXCJFTVNHU0laRVwiLFxuICBcIkVQUk9UT1RZUEVcIiwgXCJFTk9QUk9UT09QVFwiLCBcIkVQUk9UT05PU1VQUE9SVFwiLCBcIkVTT0NLVE5PU1VQUE9SVFwiLFxuICBcIkVPUE5PVFNVUFBcIiwgXCJFUEZOT1NVUFBPUlRcIiwgXCJFQUZOT1NVUFBPUlRcIiwgXCJFQUREUklOVVNFXCIsIFwiRUFERFJOT1RBVkFJTFwiLFxuICBcIkVORVRET1dOXCIsIFwiRU5FVFVOUkVBQ0hcIiwgXCJFTkVUUkVTRVRcIiwgXCJFQ09OTkFCT1JURURcIiwgXCJFQ09OTlJFU0VUXCIsIFwiRU5PQlVGU1wiLFxuICBcIkVJU0NPTk5cIiwgXCJFTk9UQ09OTlwiLCBcIkVTSFVURE9XTlwiLCBcIkVUT09NQU5ZUkVGU1wiLCBcIkVUSU1FRE9VVFwiLCBcIkVDT05OUkVGVVNFRFwiLFxuICBcIkVIT1NURE9XTlwiLCBcIkVIT1NUVU5SRUFDSFwiLCBcIkVMT09QXCIsIFwiRU9WRVJGTE9XXCJcbl07XG5mdW5jdGlvbiBtYWtlX3VuaXhfZXJyX2FyZ3MoY29kZSwgc3lzY2FsbCwgcGF0aCwgZXJybm8pIHtcbiAgdmFyIHZhcmlhbnQgPSB1bml4X2Vycm9yLmluZGV4T2YoY29kZSk7XG4gIGlmICh2YXJpYW50IDwgMCkge1xuICAgIC8vIERlZmF1bHQgaWYgdW5kZWZpbmVkXG4gICAgaWYgKGVycm5vID09IG51bGwpIHtcbiAgICAgIGVycm5vID0gLTk5OTlcbiAgICB9XG4gICAgLy8gSWYgbm9uZSBvZiB0aGUgYWJvdmUgdmFyaWFudHMsIGZhbGxiYWNrIHRvIEVVTktOT1dORVJSKGludClcbiAgICB2YXJpYW50ID0gQkxPQ0soMCwgZXJybm8pO1xuICB9XG4gIHZhciBhcmdzID0gW1xuICAgIHZhcmlhbnQsXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoc3lzY2FsbCB8fCBcIlwiKSxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoIHx8IFwiXCIpXG4gIF07XG4gIHJldHVybiBhcmdzO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3N0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3N0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9zdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3N0YXRfNjRcbi8vUmVxdWlyZXM6IHVuaXhfc3RhdFxudmFyIHVuaXhfc3RhdF82NCA9IHVuaXhfc3RhdDtcblxuLy9Qcm92aWRlczogdW5peF9sc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfbHN0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmxzdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfbHN0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubHN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xzdGF0XzY0XG4vL1JlcXVpcmVzOiB1bml4X2xzdGF0XG52YXIgdW5peF9sc3RhdF82NCA9IHVuaXhfbHN0YXQ7XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X21rZGlyKG5hbWUsIHBlcm0pIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ta2Rpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X21rZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCwgcGVybSwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfcm1kaXIobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJtZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfcm1kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3N5bWxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3N5bWxpbmsodG9fZGlyLCBzcmMsIGRzdCkge1xuICB2YXIgc3JjX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShzcmMpO1xuICB2YXIgZHN0X3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkc3QpO1xuICBpZihzcmNfcm9vdC5kZXZpY2UgIT0gZHN0X3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3N5bWxpbms6IGNhbm5vdCBzeW1saW5rIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1zXCIpO1xuICBpZiAoIXNyY19yb290LmRldmljZS5zeW1saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfc3ltbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiBzcmNfcm9vdC5kZXZpY2Uuc3ltbGluayh0b19kaXIsIHNyY19yb290LnJlc3QsIGRzdF9yb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfcmVhZGxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3JlYWRsaW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5yZWFkbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3JlYWRsaW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJlYWRsaW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF91bmxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3VubGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudW5saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfdW5saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ2V0dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuZnVuY3Rpb24gdW5peF9nZXR1aWQodW5pdCkge1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuZ2V0dWlkKXtcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5nZXR1aWQoKTtcbiAgfVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dldHB3dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuZnVuY3Rpb24gdW5peF9nZXRwd3VpZCh1bml0KSB7XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKClcbn1cblxuLy9Qcm92aWRlczogdW5peF9oYXNfc3ltbGlua1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHVuaXhfaGFzX3N5bWxpbmsodW5pdCkge1xuICByZXR1cm4gZnNfbm9kZV9zdXBwb3J0ZWQoKT8xOjBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgaGFuZGxlcihlcnIsZmFsc2UpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG1zZyA9IGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgdmFyIGF0X2V4aXQgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIpO1xuICAgICAgaWYoYXRfZXhpdCkgeyBhdF9leGl0KDApIH1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiICsgbXNnICsgXCJcXG5cIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIlVuaXhcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiBvc190eXBlID09IFwiV2luMzJcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJDeWd3aW5cIiA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBvc190eXBlXG52YXIgb3NfdHlwZSA9IChqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmXG4gICAgICAgICAgICAgICBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnBsYXRmb3JtID09IFwid2luMzJcIikgPyBcIkN5Z3dpblwiIDogXCJVbml4XCI7XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhvc190eXBlKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG5cbi8vQWx3YXlzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5vbikge1xuICAgIGcucHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBmdW5jdGlvbiAoZXJyLCBvcmlnaW4pIHtcbiAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycik7XG4gICAgICBnLnByb2Nlc3MuZXhpdCAoMik7XG4gICAgfSlcbiAgfVxuICBlbHNlIGlmKGcuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGlmKGV2ZW50LmVycm9yKXtcbiAgICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2FycmF5LCBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVzXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3NcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNyZWF0ZV9kaXJfaWZfbmVlZGVkID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvbXAubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICByZXMgKz0gY29tcFtpXSArIFwiL1wiO1xuICAgIGlmKHRoaXMuY29udGVudFtyZXNdKSBjb250aW51ZTtcbiAgICB0aGlzLmNvbnRlbnRbcmVzXSA9IFN5bWJvbChcImRpcmVjdG9yeVwiKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5zbGFzaCA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gL1xcLyQvLnRlc3QobmFtZSk/bmFtZToobmFtZSArIFwiL1wiKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5yb290KSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB7XG4gICAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgICAgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHJlc1sxXSkpO1xuICAgIH1cbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lX3NsYXNoXSkgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsbW9kZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIGlmKHRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVFWElTVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IEZpbGUgZXhpc3RzXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgcGFyZW50ID0gL14oLiopXFwvW14vXSsvLmV4ZWMobmFtZSk7XG4gIHBhcmVudCA9IChwYXJlbnQgJiYgcGFyZW50WzFdKSB8fCAnJztcbiAgaWYoIXRoaXMuZXhpc3RzKHBhcmVudCkpe1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKHBhcmVudCkpe1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URElSXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZCh0aGlzLnNsYXNoKG5hbWUpKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URElSXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgaWYobi5tYXRjaChyKSkge1xuICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVEVNUFRZXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiOiBEaXJlY3Rvcnkgbm90IGVtcHR5XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVfc2xhc2hdO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gIH1cbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10rKVwiKTtcbiAgdmFyIHNlZW4gPSB7fVxuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0gJiYgIXNlZW5bbVsxXV0pIHtzZWVuW21bMV1dID0gdHJ1ZTsgYS5wdXNoKG1bMV0pfVxuICB9XG4gIHJldHVybiBhO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKG5hbWUgPT0gXCJcIikgIHJldHVybiB0cnVlO1xuICB2YXIgbmFtZV9zbGFzaCA9IHRoaXMuc2xhc2gobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIHZhciBmaWxlO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgaWYoZmlsZSl7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBmaWxlO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9zdHJpbmcoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obywgbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHRvX2RpciwgdGFyZ2V0LCBwYXRoLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5zeW1saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCksIHRvX2RpciA/ICdkaXInIDogJ2ZpbGUnKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbGluayA9IHRoaXMuZnMucmVhZGxpbmtTeW5jKHRoaXMubm0obmFtZSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX2J5dGVzKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgIC8qIE1hcnNoYWwuQ29tcGF0XzMyIGlzIHJlZHVuZGFudCBzaW5jZSBpbnRlZ2VycyBhcmUgMzItYml0IGFueXdheSAqL1xuXG4gICAgaWYgKGNsb3N1cmVzKVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS53YXJuKFwiaW4gY2FtbF9vdXRwdXRfdmFsOiBmbGFnIE1hcnNoYWwuQ2xvc3VyZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlciAoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaW50ZXJuX29ial90YWJsZSA9IG5vX3NoYXJpbmcgPyBudWxsIDogbmV3IE1sT2JqZWN0VGFibGUoKTtcblxuICAgIGZ1bmN0aW9uIG1lbW8odikge1xuICAgICAgaWYgKG5vX3NoYXJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBleGlzdGluZ19vZmZzZXQgPSBpbnRlcm5fb2JqX3RhYmxlLnJlY2FsbCh2KTtcbiAgICAgIGlmIChleGlzdGluZ19vZmZzZXQpIHsgd3JpdGVyLndyaXRlX3NoYXJlZChleGlzdGluZ19vZmZzZXQpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IGludGVybl9vYmpfdGFibGUuc3RvcmUodik7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2LmNhbWxfY3VzdG9tKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBuYW1lID0gdi5jYW1sX2N1c3RvbTtcbiAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tuYW1lXTtcbiAgICAgICAgdmFyIHN6XzMyXzY0ID0gWzAsMF07XG4gICAgICAgIGlmKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmKGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDEyIC8qY3N0LkNPREVfQ1VTVE9NKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgfSBlbHNlIGlmKG9wcy5maXhlZF9sZW5ndGggPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTggLypjc3QuQ09ERV9DVVNUT01fTEVOKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIGhlYWRlcl9wb3MgPSB3cml0ZXIucG9zICgpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MsIDMyLCBzel8zMl82NFswXSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA0LCAzMiwgMCk7IC8vIHplcm9cbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDgsIDMyLCBzel8zMl82NFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSB3cml0ZXIucG9zKCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICBpZiAob3BzLmZpeGVkX2xlbmd0aCAhPSB3cml0ZXIucG9zKCkgLSBvbGRfcG9zKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogaW5jb3JyZWN0IGZpeGVkIHNpemVzIHNwZWNpZmllZCBieSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDIgKyAoKHN6XzMyXzY0WzBdICsgMykgPj4gMik7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDIgKyAoKHN6XzMyXzY0WzFdICsgNykgPj4gMyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjUxKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEFic3RyYWN0KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodi5sZW5ndGggPiAxICYmIG1lbW8odikpIHJldHVybjtcbiAgICAgICAgaWYgKHZbMF0gPCAxNiAmJiB2Lmxlbmd0aCAtIDEgPCA4KVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSk8PDQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLCAoKHYubGVuZ3RoLTEpIDw8IDEwKSB8IHZbMF0pO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSB2Lmxlbmd0aDtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEpIHN0YWNrLnB1c2ggKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICAgIGlmKCEoY2FtbF9pc19tbF9ieXRlcyhjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpKSkpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBbQnl0ZXMudF0gY2Fubm90IHNhZmVseSBiZSBtYXJzaGFsZWQgd2l0aCBbLS1lbmFibGUgdXNlLWpzLXN0cmluZ11cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPSAodnwwKSl7XG4gICAgICAgICAgdmFyIHR5cGVfb2ZfdiA9IHR5cGVvZiB2O1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgLy8gKEpzX29mX29jYW1sIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIHR5cGUgb2YgYW4gaW50ZWdlciBudW1iZXIgaXNcbiAgICAgICAgICAvLyBmbG9hdCBvciBpbnRlZ2VyLikgVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgY3Jhc2hlcyB3aGVuXG4gICAgICAgICAgLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS4gSXQgc2VlbXMgYmV0dGVyIHRvXG4gICAgICAgICAgLy8gc3lzdGVtYXRpY2FsbHkgZmFpbCBvbiBtYXJzaGFsbGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAgIGlmKHR5cGVfb2ZfdiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuICAgICAgICAgIC8vICAgICAgICAgIHZhciB0ID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQodikpO1xuICAgICAgICAgIC8vICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgwQiAvKmNzdC5DT0RFX0RPVUJMRV9CSUcqLyk7XG4gICAgICAgICAgLy8gICAgICAgICAgZm9yKHZhciBpID0gMDsgaTw4OyBpKyspe3dyaXRlci53cml0ZSg4LHRbaV0pfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMFg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8ICgxIDw8IDcpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAoMSA8PCAxNSkpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgxNiwgMHgwMSAvKmNzdC5DT0RFX0lOVDE2Ki8sIHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyAodik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wICgpO1xuICAgICAgdmFyIHYgPSBzdGFjay5wb3AgKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCAodiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyAodltpXSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSB3cml0ZXIub2JqX2NvdW50ZXIgPSBpbnRlcm5fb2JqX3RhYmxlLm9ianMubGVuZ3RoO1xuICAgIHdyaXRlci5maW5hbGl6ZSgpO1xuICAgIHJldHVybiB3cml0ZXIuY2h1bms7XG4gIH1cbn0gKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIgKHMsIG9mcywgbGVuLCB2LCBmbGFncykge1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHQsIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIGRlbGV0ZSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zdGRfb3V0cHV0KGNoYW5pZCxzKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBzdHIgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpO1xuICB2YXIgc2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5vZmZzZXQsIHN0ciwgMCwgc2xlbik7XG4gIGNoYW4ub2Zmc2V0ICs9IHNsZW47XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsTWxGYWtlRmlsZVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyLCBqc19wcmludF9zdGRvdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoaWR4LG91dHB1dCxmaWxlLGZsYWdzKSB7XG4gIGlmKGNhbWxfZ2xvYmFsX2RhdGEuZmRzID09PSB1bmRlZmluZWQpIGNhbWxfZ2xvYmFsX2RhdGEuZmRzID0gbmV3IEFycmF5KCk7XG4gIGZsYWdzPWZsYWdzP2ZsYWdzOnt9O1xuICB2YXIgaW5mbyA9IHt9O1xuICBpbmZvLmZpbGUgPSBmaWxlO1xuICBpbmZvLm9mZnNldCA9IGZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjA7XG4gIGluZm8uZmxhZ3MgPSBmbGFncztcbiAgaW5mby5vdXRwdXQgPSBvdXRwdXQ7XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2lkeF0gPSBpbmZvO1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCB8fCBpZHggPiBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4KVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggPSBpZHg7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuIChuYW1lLCBmbGFncywgX3Blcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlKGZsYWdzKXtcbiAgICBzd2l0Y2goZmxhZ3NbMV0pe1xuICAgIGNhc2UgMDogZi5yZG9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMTogZi53cm9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMjogZi5hcHBlbmQgPSAxO2JyZWFrO1xuICAgIGNhc2UgMzogZi5jcmVhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNDogZi50cnVuY2F0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA1OiBmLmV4Y2wgPSAxOyBicmVhaztcbiAgICBjYXNlIDY6IGYuYmluYXJ5ID0gMTticmVhaztcbiAgICBjYXNlIDc6IGYudGV4dCA9IDE7YnJlYWs7XG4gICAgY2FzZSA4OiBmLm5vbmJsb2NrID0gMTticmVhaztcbiAgICB9XG4gICAgZmxhZ3M9ZmxhZ3NbMl07XG4gIH1cbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICB2YXIgaWR4ID0gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeD9jYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4OjA7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChpZHgrMSxjYW1sX3N0ZF9vdXRwdXQsZmlsZSxmKTtcbn1cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMCxjYW1sX3N0ZF9vdXRwdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkaW5cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMSxqc19wcmludF9zdGRvdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3Rkb3V0XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDIsanNfcHJpbnRfc3RkZXJyLCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGVyclxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKCkge1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcjpcIlwiXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3lzX29wZW4sY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgaWYoZmQgPT0gMCAmJiBmc19ub2RlX3N1cHBvcnRlZCgpKXtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIHJlZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhmcy5yZWFkRmlsZVN5bmMoMCwgJ3V0ZjgnKSl9O1xuICB9XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpyZWZpbGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG52YXIgd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsID0gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3JcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgaWYgKHN0cl9sZW4gPT0gMCkgY2hhbi5yZWZpbGwgPSBudWxsO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5maWxlLmxlbmd0aCgpLCBzdHIsIDAsIHN0cl9sZW4pO1xuICByZXR1cm4gc3RyX2xlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCA9PSBudWxsKSByZXR1cm47XG4gIGlmIChjaGFuLmZpbGUubGVuZ3RoKCkgIT0gY2hhbi5vZmZzZXQpIHJldHVybjtcbiAgY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dCAoY2hhbmlkLCBzLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbDIgPSBjaGFuLmZpbGUubGVuZ3RoKCkgLSBjaGFuLm9mZnNldDtcbiAgaWYgKGwyID09IDAgJiYgY2hhbi5yZWZpbGwgIT0gbnVsbCkgbDIgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgaWYgKGwyIDwgbCkgbCA9IGwyO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCwgcywgaSwgbCk7XG4gIGNoYW4ub2Zmc2V0ICs9IGw7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIHZhciBieXRlcztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgYnl0ZXMgPSBidWZmZXI7XG4gIGVsc2Uge1xuICAgIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoYnVmZmVyLG9mZnNldCxieXRlcywwLGxlbik7XG4gIH1cbiAgdmFyIHN0cmluZyA9IGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKTtcbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXRcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3Jlc3VtZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3Jfc2xpY2VcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3Jfc2xpY2Uod29yaykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2J1Y2tldFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfYnVja2V0KG4pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIga2luZDtcbiAgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTcgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX2JsaXRfdG9fYnl0ZXMoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhzcmMsc3JjX29mZixkc3QsZHN0X29mZixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF90b19iaWdzdHJpbmcoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF9mcm9tX2J5dGVzKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9tZW1jbXBfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2ludF9jb21wYXJlXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jbXBfYmlnc3RyaW5nKGJhMSwgYmExX29mZiwgYmEyLCBiYTJfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gY2FtbF9pbnRfY29tcGFyZShjYW1sX2JhX2dldF8xKGJhMSwgYmExX29mZiArIGkpLCBjYW1sX2JhX2dldF8xKGJhMiwgYmEyX29mZiArIGkpKTtcbiAgICBpZiAoYyAhPSAwKSByZXR1cm4gY1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jbXBfc3RyaW5nKGJhLCBiYV9vZmYsIHN0ciwgc3RyX29mZiwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGNhbWxfaW50X2NvbXBhcmUoY2FtbF9iYV9nZXRfMShiYSwgYmFfb2ZmICsgaSksIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQoc3RyLCBzdHJfb2ZmICsgaSkpO1xuICAgIGlmIChjICE9IDApIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNoclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nYWZfbWVtY2hyKGJhLCBiYV9vZmYsIGNociwgbGVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY2FtbF9iYV9nZXRfMShiYSwgYmFfb2ZmICsgaSkgPT0gY2hyKSB7XG4gICAgICByZXR1cm4gKGJhX29mZiArIGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZih0eXBlb2YgZy5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuWE1MSHR0cFJlcXVlc3QgfSBjYXRjaCAoZSkgeyB9O1xuICB9XG4gIGlmKHR5cGVvZiBnLmFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICBzd2l0Y2ggKHYudCAmIDYpIHtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzICh2KTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgdi5jKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCB2LmMpO1xuICB9XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaGFzaCAoY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTsgcmQgPSAwOyB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSl7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGhoID0gY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2godik7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludCAoaCwgaGgpO1xuICAgICAgICBudW0gLS07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICt2KSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCx2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGFcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobyxpKSB7IHJldHVybiBvW2krMV0gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8saSx2KSB7IHJldHVybiBvW2krMV0gPSB2IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXG5mdW5jdGlvbiBjYW1sX29ial9yZWFjaGFibGVfd29yZHMobykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9hZGRfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX29ial9hZGRfb2Zmc2V0KHYsb2Zmc2V0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJPYmouYWRkX29mZnNldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG52YXIgY2FtbF9tZDVfYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgfCBJbnRfQ2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2lcbiAgfCBJbnRfQ2kgLT4gJ2knIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X29cbiAgfCBJbnRfQ28gLT4gJ28nIHwgSW50X3UgfCBJbnRfQ3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG4oKiBgY0YnIHdpbGwgYmUgJ0YnIGZvciBkaXNwbGF5aW5nIGZvcm1hdCBhbmQgJ2cnIHRvIGNhbGwgbGliYyBwcmludGYgKilcbmxldCBjaGFyX29mX2Zjb252ID8oY0Y9J0YnKSBmY29udiA9IG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiAtPiAnZicgfCBGbG9hdF9lIC0+ICdlJ1xuICB8IEZsb2F0X0UgLT4gJ0UnIHwgRmxvYXRfZyAtPiAnZydcbiAgfCBGbG9hdF9HIC0+ICdHJyB8IEZsb2F0X0YgLT4gY0ZcbiAgfCBGbG9hdF9oIC0+ICdoJyB8IEZsb2F0X0ggLT4gJ0gnXG4gIHwgRmxvYXRfQ0YgLT4gJ0YnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgYW5kL29yICcjJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPVxuICBiZWdpbiBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpIGVuZDtcbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9DRiAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HXG4gIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBGb3JtYXR0aW5nX2xpdC4gKilcbigqIFVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGZtdGluZ19nZW4gd2l0aFxuICAgICAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAe1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkBbXCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIGVuZDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZyb20gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IH5jRjonZycgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxubGV0IHRyYW5zZm9ybV9pbnRfYWx0IGljb252IHMgPVxuICBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgbGV0IGRpZ2l0cyA9XG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICB8ICcwJy4uJzknIC0+IGluY3IgblxuICAgICAgICB8IF8gLT4gKClcbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgKGRpZ2l0cyAtIDEpIC8gMykgaW5cbiAgICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgICBsZXQgcHV0IGMgPSBCeXRlcy5zZXQgYnVmICFwb3MgYzsgaW5jciBwb3MgaW5cbiAgICBsZXQgbGVmdCA9IHJlZiAoKGRpZ2l0cyAtIDEpIG1vZCAzICsgMSkgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJzAnLi4nOScgYXMgYyAtPlxuICAgICAgICAgIGlmICFsZWZ0ID0gMCB0aGVuIChwdXQgJ18nOyBsZWZ0IDo9IDMpOyBkZWNyIGxlZnQ7IHB1dCBjXG4gICAgICB8IGMgLT4gcHV0IGNcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gIHwgXyAtPiBzXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG4pXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG4pXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBsZXQgaGV4ICgpID1cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgbGV0IGFkZF9kb3RfaWZfbmVlZGVkIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpIGluXG4gICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiIGluXG4gIGxldCBjYW1sX3NwZWNpYWxfdmFsIHN0ciA9IG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPiBzdHJcbiAgICB8IEZQX2luZmluaXRlIC0+IGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgfCBGUF9uYW4gLT4gXCJuYW5cIiBpblxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggLT4gaGV4ICgpXG4gIHwgRmxvYXRfSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIChoZXggKCkpXG4gIHwgRmxvYXRfQ0YgLT4gY2FtbF9zcGVjaWFsX3ZhbCAoaGV4ICgpKVxuICB8IEZsb2F0X0YgLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGNhbWxfc3BlY2lhbF92YWwgKGFkZF9kb3RfaWZfbmVlZGVkIHN0cilcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyAtPlxuICAgIGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHhcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIF8gLT4gayBvKSAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+XG4gIHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IEF0b21pYy5tYWtlIFtdXG5cbmxldCBsb2NmbXQgPSBmb3JtYXRfb2Zfc3RyaW5nIFwiRmlsZSBcXFwiJXNcXFwiLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOiAlc1wiXG5cbmxldCBmaWVsZCB4IGkgPVxuICBsZXQgZiA9IE9iai5maWVsZCB4IGkgaW5cbiAgaWYgbm90IChPYmouaXNfYmxvY2sgZikgdGhlblxuICAgIHNwcmludGYgXCIlZFwiIChPYmoubWFnaWMgZiA6IGludCkgICAgICAgICAgICgqIGNhbiBhbHNvIGJlIGEgY2hhciAqKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5zdHJpbmdfdGFnIHRoZW5cbiAgICBzcHJpbnRmIFwiJVNcIiAoT2JqLm1hZ2ljIGYgOiBzdHJpbmcpXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLmRvdWJsZV90YWcgdGhlblxuICAgIHN0cmluZ19vZl9mbG9hdCAoT2JqLm1hZ2ljIGYgOiBmbG9hdClcbiAgZWxzZVxuICAgIFwiX1wiXG5cbmxldCByZWMgb3RoZXJfZmllbGRzIHggaSA9XG4gIGlmIGkgPj0gT2JqLnNpemUgeCB0aGVuIFwiXCJcbiAgZWxzZSBzcHJpbnRmIFwiLCAlcyVzXCIgKGZpZWxkIHggaSkgKG90aGVyX2ZpZWxkcyB4IChpKzEpKVxuXG5sZXQgZmllbGRzIHggPVxuICBtYXRjaCBPYmouc2l6ZSB4IHdpdGhcbiAgfCAwIC0+IFwiXCJcbiAgfCAxIC0+IFwiXCJcbiAgfCAyIC0+IHNwcmludGYgXCIoJXMpXCIgKGZpZWxkIHggMSlcbiAgfCBfIC0+IHNwcmludGYgXCIoJXMlcylcIiAoZmllbGQgeCAxKSAob3RoZXJfZmllbGRzIHggMilcblxubGV0IHVzZV9wcmludGVycyB4ID1cbiAgbGV0IHJlYyBjb252ID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCBoZCB4IHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IGV4Y2VwdGlvbiBfIC0+IGNvbnYgdGxcbiAgICAgICAgIHwgU29tZSBzIC0+IFNvbWUgcylcbiAgICB8IFtdIC0+IE5vbmUgaW5cbiAgY29udiAoQXRvbWljLmdldCBwcmludGVycylcblxubGV0IHRvX3N0cmluZ19kZWZhdWx0ID0gZnVuY3Rpb25cbiAgfCBPdXRfb2ZfbWVtb3J5IC0+IFwiT3V0IG9mIG1lbW9yeVwiXG4gIHwgU3RhY2tfb3ZlcmZsb3cgLT4gXCJTdGFjayBvdmVyZmxvd1wiXG4gIHwgTWF0Y2hfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNSkgXCJQYXR0ZXJuIG1hdGNoaW5nIGZhaWxlZFwiXG4gIHwgQXNzZXJ0X2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiQXNzZXJ0aW9uIGZhaWxlZFwiXG4gIHwgVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiVW5kZWZpbmVkIHJlY3Vyc2l2ZSBtb2R1bGVcIlxuICB8IHggLT5cbiAgICAgIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICAgICAgaWYgT2JqLnRhZyB4IDw+IDAgdGhlblxuICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgeCAwKSA6IHN0cmluZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGNvbnN0cnVjdG9yID1cbiAgICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgKE9iai5maWVsZCB4IDApIDApIDogc3RyaW5nKSBpblxuICAgICAgICBjb25zdHJ1Y3RvciBeIChmaWVsZHMgeClcblxubGV0IHRvX3N0cmluZyBlID1cbiAgbWF0Y2ggdXNlX3ByaW50ZXJzIGUgd2l0aFxuICB8IFNvbWUgcyAtPiBzXG4gIHwgTm9uZSAtPiB0b19zdHJpbmdfZGVmYXVsdCBlXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VfZW50cnkgPSBwcml2YXRlIGludFxudHlwZSByYXdfYmFja3RyYWNlID0gcmF3X2JhY2t0cmFjZV9lbnRyeSBhcnJheVxuXG5sZXQgcmF3X2JhY2t0cmFjZV9lbnRyaWVzIGJ0ID0gYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgICAgZGVmbmFtZSAgICAgOiBzdHJpbmc7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZTsgZGVmbmFtZSA9IFwiXCIgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzICVzIGluIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5kZWZuYW1lIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfXG4gIHwgS25vd25fbG9jYXRpb24geyBkZWZuYW1lID0gXCJcIiB9IC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IFNvbWUgbC5kZWZuYW1lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IGVudHJ5ID1cbiAgYmFja3RyYWNlX3Nsb3RzIFt8IGVudHJ5IHxdXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuICBsZXQgbmFtZSA9IGJhY2t0cmFjZV9zbG90X2RlZm5hbWVcbmVuZFxuXG5sZXQgcmF3X2JhY2t0cmFjZV9sZW5ndGggYnQgPSBBcnJheS5sZW5ndGggYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVjIHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBsZXQgb2xkX3ByaW50ZXJzID0gQXRvbWljLmdldCBwcmludGVycyBpblxuICBsZXQgbmV3X3ByaW50ZXJzID0gZm4gOjogb2xkX3ByaW50ZXJzIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBwcmludGVycyBvbGRfcHJpbnRlcnMgbmV3X3ByaW50ZXJzIGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gcmVnaXN0ZXJfcHJpbnRlciBmblxuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuZXh0ZXJuYWwgZ2V0X2RlYnVnX2luZm9fc3RhdHVzIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXNcIlxuXG4oKiBEZXNjcmlwdGlvbnMgZm9yIGVycm9ycyBpbiBzdGFydHVwLmguIFNlZSBhbHNvIGJhY2t0cmFjZS5jICopXG5sZXQgZXJyb3JzID0gW3wgXCJcIjtcbiAgKCogRklMRV9OT1RfRk9VTkQgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIG5vdCBmb3VuZClcIjtcbiAgKCogQkFEX0JZVEVDT0RFICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHQpXCI7XG4gICgqIFdST05HX01BR0lDICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyKVwiO1xuICAoKiBOT19GRFMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGNhbm5vdCBiZSBvcGVuZWQ7XFxuIFxcXG4gICAgICAtLSB0b28gbWFueSBvcGVuIGZpbGVzLiBUcnkgcnVubmluZyB3aXRoIE9DQU1MUlVOUEFSQU09Yj0yKVwiXG58XVxuXG5sZXQgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZSA9XG4gIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBsZXQgc3RhdHVzID0gZ2V0X2RlYnVnX2luZm9fc3RhdHVzICgpIGluXG4gIGlmIHN0YXR1cyA8IDAgdGhlblxuICAgIHByZXJyX2VuZGxpbmUgZXJyb3JzLihhYnMgc3RhdHVzKTtcbiAgZmx1c2ggc3RkZXJyXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IFt8IHxdXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIHRyeVxuICAgICAgIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgd2l0aCBleG4nIC0+XG4gICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1ICAgICAgICgqICAlI2QgfCAlI2kgfCAlI3UgKilcblxuKCogRmxvYXQgY29udmVyc2lvbi4gKilcbnR5cGUgZmxvYXRfZmxhZ19jb252ID1cbiAgfCBGbG9hdF9mbGFnXyAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3AgICAgICAgICAgICAgICAgICAgKCogJStbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19zICAgICAgICAgICAgICAgICAgICgqICUgW2ZlRWdHRmhIXSAqKVxudHlwZSBmbG9hdF9raW5kX2NvbnYgPVxuICB8IEZsb2F0X2YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FICAgICAgICAgICAgICAgICAgICAgICAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGIHwgJStGIHwgJSBGICAqKVxuICB8IEZsb2F0X2ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlSCB8ICUrSCB8ICUgSCAgKilcbiAgfCBGbG9hdF9DRiAgICAgICAgICAgICAgICAgICAgICAgKCogICUjRnwgJSsjRnwgJSAjRiAqKVxudHlwZSBmbG9hdF9jb252ID0gZmxvYXRfZmxhZ19jb252ICogZmxvYXRfa2luZF9jb252XG5cbigqKiopXG5cbigqIENoYXIgc2V0cyAoc2VlICVbLi4uXSkgYXJlIGJpdG1hcHMgaW1wbGVtZW50ZWQgYXMgMzItY2hhciBzdHJpbmdzLiAqKVxudHlwZSBjaGFyX3NldCA9IHN0cmluZ1xuXG4oKioqKVxuXG4oKiBDb3VudGVyIHVzZWQgaW4gU2NhbmYuICopXG50eXBlIGNvdW50ZXIgPVxuICB8IExpbmVfY291bnRlciAgICAgKCogICVsICAgICAgKilcbiAgfCBDaGFyX2NvdW50ZXIgICAgICgqICAlbiAgICAgICopXG4gIHwgVG9rZW5fY291bnRlciAgICAoKiAgJU4sICVMICAqKVxuXG4oKioqKVxuXG4oKiBQYWRkaW5nIG9mIHN0cmluZ3MgYW5kIG51bWJlcnMuICopXG50eXBlICgnYSwgJ2IpIHBhZGRpbmcgPVxuICAoKiBObyBwYWRkaW5nIChleDogXCIlZFwiKSAqKVxuICB8IE5vX3BhZGRpbmcgIDogKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBMaXRlcmFsIHBhZGRpbmcgKGV4OiBcIiU4ZFwiKSAqKVxuICB8IExpdF9wYWRkaW5nIDogcGFkdHkgKiBpbnQgLT4gKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBQYWRkaW5nIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKmRcIikgKilcbiAgfCBBcmdfcGFkZGluZyA6IHBhZHR5IC0+IChpbnQgLT4gJ2EsICdhKSBwYWRkaW5nXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2QsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcGFkZGluZyBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwYWRfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBQcmVjaXNpb24gb2YgZmxvYXRzIGFuZCAnMCctcGFkZGluZyBvZiBpbnRlZ2Vycy4gKilcbnR5cGUgKCdhLCAnYikgcHJlY2lzaW9uID1cbiAgKCogTm8gcHJlY2lzaW9uIChleDogXCIlZlwiKSAqKVxuICB8IE5vX3ByZWNpc2lvbiA6ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBMaXRlcmFsIHByZWNpc2lvbiAoZXg6IFwiJS4zZlwiKSAqKVxuICB8IExpdF9wcmVjaXNpb24gOiBpbnQgLT4gKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIFByZWNpc2lvbiBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKSAqKVxuICB8IEFyZ19wcmVjaXNpb24gOiAoaW50IC0+ICdhLCAnYSkgcHJlY2lzaW9uXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2YsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcHJlY2lzaW9uIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHByZWNfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBzZWUgdGhlIEN1c3RvbSBmb3JtYXQgY29tYmluYXRvciAqKVxudHlwZSAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5ID1cbiAgfCBDdXN0b21femVybyA6ICgnYSwgc3RyaW5nLCAnYSkgY3VzdG9tX2FyaXR5XG4gIHwgQ3VzdG9tX3N1Y2MgOiAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5IC0+XG4gICAgKCdhLCAneCAtPiAnYiwgJ3ggLT4gJ2MpIGN1c3RvbV9hcml0eVxuXG4oKioqKVxuXG4oKiAgICAgICAgUmVsYXRpb25hbCBmb3JtYXQgdHlwZXNcblxuSW4gdGhlIGZpcnN0IGZvcm1hdCtnYWR0cyBpbXBsZW1lbnRhdGlvbiwgdGhlIHR5cGUgZm9yICUoLi4lKSBpbiB0aGVcbmZtdCBHQURUIHdhcyBhcyBmb2xsb3dzOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICogKCdkMSwgJ3ExLCAnZDIsICdxMikgcmVhZGVyX25iX3VuaWZpZXIgKlxuICAgICgneCwgJ2IsICdjLCAnZDEsICdxMSwgJ3UpIGZtdHR5ICpcbiAgICAoJ3UsICdiLCAnYywgJ3ExLCAnZTEsICdmKSBmbXQgLT5cbiAgICAgICgoJ3gsICdiLCAnYywgJ2QyLCAncTIsICd1KSBmb3JtYXQ2IC0+ICd4LCAnYiwgJ2MsICdkMSwgJ2UxLCAnZikgZm10XG5cbk5vdGljZSB0aGF0IHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2YgcG9zaXRpb24gaW4gdGhlIGZvcm1hdCBhcmd1bWVudFxuKCgneCwgLi4sICd1KSBmb3JtYXQ2IC0+IC4uKSBpcyBlcXVhbCB0byB0aGUgJ3UgcGFyYW1ldGVyIGluICdhXG5wb3NpdGlvbiBpbiB0aGUgZm9ybWF0IHRhaWwgKCgndSwgLi4sICdmKSBmbXQpLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG50eXBlIG9mIHRoZSBleHBlY3RlZCBmb3JtYXQgcGFyYW1ldGVyIGRlcGVuZHMgb2Ygd2hlcmUgdGhlICUoLi4uJSlcbmFyZSBpbiB0aGUgZm9ybWF0IHN0cmluZzpcblxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpXCJcbiAgLSA6ICh1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiB1bml0XG4gID0gPGZ1bj5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKSVkXCJcbiAgLSA6IChpbnQgLT4gdW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCBpbnQgLT4gdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IGludCAtPiB1bml0XG4gID0gPGZ1bj5cblxuT24gdGhlIGNvbnRyYXJ5LCB0aGUgbGVnYWN5IHR5cGVyIGdpdmVzIGEgY2xldmVyIHR5cGUgdGhhdCBkb2VzIG5vdFxuZGVwZW5kIG9uIHRoZSBwb3NpdGlvbiBvZiAlKC4uJSkgaW4gdGhlIGZvcm1hdCBzdHJpbmcuIEZvciBleGFtcGxlLFxuJSglKSB3aWxsIGhhdmUgdGhlIHBvbHltb3JwaGljIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpOiBpdCBjYW5cbmJlIGNvbmNhdGVuYXRlZCB0byBhbnkgZm9ybWF0IHR5cGUsIGFuZCBvbmx5IGVuZm9yY2VzIHRoZSBjb25zdHJhaW50XG50aGF0IGl0cyAnYSBhbmQgJ2YgcGFyYW1ldGVycyBhcmUgZXF1YWwgKG5vIGZvcm1hdCBhcmd1bWVudHMpIGFuZCAnZFxuYW5kICdlIGFyZSBlcXVhbCAobm8gcmVhZGVyIGFyZ3VtZW50KS5cblxuVGhlIHdlYWtlbmluZyBvZiB0aGlzIHBhcmFtZXRlciB0eXBlIGluIHRoZSBHQURUIHZlcnNpb24gYnJva2UgdXNlclxuY29kZSAoaW4gZmFjdCBpdCBlc3NlbnRpYWxseSBtYWRlICUoLi4uJSkgdW51c2FibGUgZXhjZXB0IGF0IHRoZSBsYXN0XG5wb3NpdGlvbiBvZiBhIGZvcm1hdCkuIEluIHBhcnRpY3VsYXIsIHRoZSBmb2xsb3dpbmcgd291bGQgbm90IHdvcmtcbmFueW1vcmU6XG5cbiAgZnVuIHNlcCAtPlxuICAgIEZvcm1hdC5wcmludGYgXCJmb28lKCUpYmFyJSglKWJhelwiIHNlcCBzZXBcblxuQXMgdGhlIHR5cGUtY2hlY2tlciB3b3VsZCByZXF1aXJlIHR3byAqaW5jb21wYXRpYmxlKiB0eXBlcyBmb3IgdGhlICUoJSlcbmluIGRpZmZlcmVudCBwb3NpdGlvbnMuXG5cblRoZSBzb2x1dGlvbiB0byByZWdhaW4gYSBnZW5lcmFsIHR5cGUgZm9yICUoLi4lKSBpcyB0byBnZW5lcmFsaXplIHRoaXNcbnRlY2huaXF1ZSwgbm90IG9ubHkgb24gdGhlICdkLCAnZSBwYXJhbWV0ZXJzLCBidXQgb24gYWxsIHNpeFxucGFyYW1ldGVycyBvZiBhIGZvcm1hdDogd2UgaW50cm9kdWNlIGEgXCJyZWxhdGlvbmFsXCIgdHlwZVxuICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxud2hvc2UgdmFsdWVzIGFyZSBwcm9vZnMgdGhhdCAoJ2ExLCAuLiwgJ2YxKSBhbmQgKCdhMiwgLi4sICdmMikgbW9yYWxseVxuY29ycmVzcG9uZCB0byB0aGUgc2FtZSBmb3JtYXQgdHlwZTogJ2ExIGlzIG9idGFpbmVkIGZyb20gJ2YxLCdiMSwnYzFcbmluIHRoZSBleGFjdCBzYW1lIHdheSB0aGF0ICdhMiBpcyBvYnRhaW5lZCBmcm9tICdmMiwnYjIsJ2MyLCBldGMuXG5cbkZvciBleGFtcGxlLCB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gZm9ybWF0IHR5cGVzIGJlZ2lubmluZyB3aXRoIGEgQ2hhclxucGFyYW1ldGVyIGlzIGFzIGZvbGxvd3M6XG5cbnwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5JbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgdGVybSBzdHJ1Y3R1cmUgb2YgZm10dHlfcmVsIGlzIChhbG1vc3RbMV0pXG5pc29tb3JwaGljIHRvIHRoZSBmbXR0eSBvZiB0aGUgcHJldmlvdXMgaW1wbGVtZW50YXRpb246IGV2ZXJ5XG5jb25zdHJ1Y3RvciBpcyByZS1yZWFkIHdpdGggYSBiaW5hcnksIHJlbGF0aW9uYWwgdHlwZSwgaW5zdGVhZCBvZiB0aGVcbnByZXZpb3VzIHVuYXJ5IHR5cGluZy4gZm10dHkgY2FuIHRoZW4gYmUgcmUtZGVmaW5lZCBhcyB0aGUgZGlhZ29uYWwgb2ZcbmZtdHR5X3JlbDpcblxuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuXG5PbmNlIHdlIGhhdmUgdGhpcyBmbXR0eV9yZWwgdHlwZSBpbiBwbGFjZSwgd2UgY2FuIGdpdmUgdGhlIG1vcmVcbmdlbmVyYWwgdHlwZSB0byAlKC4uLiUpOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuV2UgYWNjZXB0IGFueSBmb3JtYXQgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2KSAodGhpcyBpc1xuY29tcGxldGVseSB1bnJlbGF0ZWQgdG8gdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgZm9ybWF0KSwgYnV0IGFsc29cbnJlcXVpcmUgYSBwcm9vZiB0aGF0IHRoaXMgZm9ybWF0IGlzIGluIHJlbGF0aW9uIHRvIGFub3RoZXIgZm9ybWF0IHRoYXRcbmlzIGNvbmNhdGVuYWJsZSB0byB0aGUgZm9ybWF0IHRhaWwuIFdoZW4gZXhlY3V0aW5nIGEgJSguLi4lKSBmb3JtYXRcbihpbiBjYW1saW50ZXJuYWxGb3JtYXQubWw6bWFrZV9wcmludGYgb3Igc2NhbmYubWw6bWFrZV9zY2FuZiksIHdlXG50cmFuc3R5cGUgdGhlIGZvcm1hdCBhbG9uZyB0aGlzIHJlbGF0aW9uIHVzaW5nIHRoZSAncmVjYXN0JyBmdW5jdGlvblxudG8gdHJhbnNwb3NlIGJldHdlZW4gcmVsYXRlZCBmb3JtYXQgdHlwZXMuXG5cbiAgdmFsIHJlY2FzdCA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxKSBmbXRcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdFxuXG5OT1RFIFsxXTogdGhlIHR5cGluZyBvZiBGb3JtYXRfc3Vic3RfdHkgcmVxdWlyZXMgbm90IG9uZSBmb3JtYXQgdHlwZSwgYnV0XG50d28sIG9uZSB0byBlc3RhYmxpc2ggdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0IGFyZ3VtZW50IGFuZCB0aGVcbmZpcnN0IHNpeCBwYXJhbWV0ZXJzLCBhbmQgdGhlIG90aGVyIGZvciB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXRcbmFyZ3VtZW50IGFuZCB0aGUgbGFzdCBzaXggcGFyYW1ldGVycy5cblxufCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbldoZW4gd2UgZ2VuZXJhdGUgYSBmb3JtYXQgQVNULCB3ZSBnZW5lcmF0ZSBleGFjdGx5IHRoZSBzYW1lIHdpdG5lc3NcbmZvciBib3RoIHJlbGF0aW9ucywgYW5kIHRoZSB3aXRuZXNzLWNvbnZlcnNpb24gZnVuY3Rpb25zIGluXG5jYW1saW50ZXJuYWxGb3JtYXQgZG8gcmVseSBvbiB0aGlzIGludmFyaWFudC4gRm9yIGV4YW1wbGUsIHRoZVxuZnVuY3Rpb24gdGhhdCBwcm92ZXMgdGhhdCB0aGUgcmVsYXRpb24gaXMgdHJhbnNpdGl2ZVxuXG4gIHZhbCB0cmFucyA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG5cbmRvZXMgYXNzdW1lIHRoYXQgdGhlIHR3byBpbnB1dHMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHRlcm0gc3RydWN0dXJlXG4oYW5kIGlzIG9ubHkgZXZlcnkgdXNlZCBmb3IgYXJndW1lbnQgd2l0bmVzc2VzIG9mIHRoZVxuRm9ybWF0X3N1YnN0X3R5IGNvbnN0cnVjdG9yKS5cbiopXG5cbigqIFR5cGUgb2YgYSBibG9jayB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggICAoKiBIb3Jpem9udGFsIGJsb2NrIG5vIGxpbmUgYnJlYWtpbmcgKilcbiAgfCBQcF92Ym94ICAgKCogVmVydGljYWwgYmxvY2sgZWFjaCBicmVhayBsZWFkcyB0byBhIG5ldyBsaW5lICopXG4gIHwgUHBfaHZib3ggICgqIEhvcml6b250YWwtdmVydGljYWwgYmxvY2s6IHNhbWUgYXMgdmJveCwgZXhjZXB0IGlmIHRoaXMgYmxvY2tcbiAgICAgICAgICAgICAgICAgaXMgc21hbGwgZW5vdWdoIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lICopXG4gIHwgUHBfaG92Ym94ICgqIEhvcml6b250YWwgb3IgVmVydGljYWwgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrICopXG4gIHwgUHBfYm94ICAgICgqIEhvcml6b250YWwgb3IgSW5kZW50IGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jaywgb3JcbiAgICAgICAgICAgICAgICAgd2hlbiBpdCBsZWFkcyB0byBhIG5ldyBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBsaW5lICopXG4gIHwgUHBfZml0cyAgICgqIEludGVybmFsIHVzYWdlOiB3aGVuIGEgYmxvY2sgZml0cyBvbiBhIHNpbmdsZSBsaW5lICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGZvcm1hdHRpbmdfbGl0ID1cbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF0gICAqKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAfSAgICopXG4gIHwgQnJlYWsgb2Ygc3RyaW5nICogaW50ICogaW50ICAgICAgICAgICgqIEAsIHwgQCAgfCBAOyB8IEA7PD4gKilcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQD8gICAqKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXFxuICAqKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBALiAgICopXG4gIHwgTWFnaWNfc2l6ZSBvZiBzdHJpbmcgKiBpbnQgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA8bj4gKilcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQEAgICAqKVxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAJSUgICopXG4gIHwgU2Nhbl9pbmRpYyBvZiBjaGFyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBYICAgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuID1cbiAgfCBPcGVuX3RhZyA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQHsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuICB8IE9wZW5fYm94IDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAWyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IHR5cGUgZWxlbWVudHMuICopXG4oKiBJbiBwYXJ0aWN1bGFyIHVzZWQgdG8gcmVwcmVzZW50ICUoLi4uJSkgYW5kICV7Li4uJX0gY29udGVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcbmFuZCAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsID1cbiAgfCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBTdHJpbmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChzdHJpbmcgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBzdHJpbmcgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVkICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDMyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDMyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50MzIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgTmF0aXZlaW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAobmF0aXZlaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgbmF0aXZlaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDY0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDY0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50NjQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgRmxvYXRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVmICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoZmxvYXQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBmbG9hdCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBCb29sX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChib29sIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgYm9vbCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEZvcm1hdF9hcmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcbiAgfCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9ycy4gKilcbiAgfCBBbHBoYV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICd4IC0+ICdjMSkgLT4gJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICd4IC0+ICdjMikgLT4gJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgVGhldGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAnYzEpIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAnYzIpIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEFueV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVXNlZCBmb3IgY3VzdG9tIGZvcm1hdHMgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgUmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEVuZF9vZl9mbXR0eSA6XG4gICAgICAoJ2YxLCAnYjEsICdjMSwgJ2QxLCAnZDEsICdmMSxcbiAgICAgICAnZjIsICdiMiwgJ2MyLCAnZDIsICdkMiwgJ2YyKSBmbXR0eV9yZWxcblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgZWxlbWVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCA9XG4gIHwgQ2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50MzIgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBOYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbltkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIG5hdGl2ZWludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50NjQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnRvdXQsIElOUklBIFBhcmlzLVNhY2xheSAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2FtbGludGVybmFsQXRvbWljIGlzIGEgZGVwZW5kZW5jeSBvZiBTdGRsaWIsIHNvIGl0IGlzIGNvbXBpbGVkIHdpdGhcbiAgIC1ub3BlcnZhc2l2ZXMuICopXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogV2UgYXJlIG5vdCByZXVzaW5nICgnYSByZWYpIGRpcmVjdGx5IHRvIG1ha2UgaXQgZWFzaWVyIHRvIHJlYXNvblxuICAgYWJvdXQgYXRvbWljaXR5IGlmIHdlIHdpc2ggdG86IGV2ZW4gaW4gYSBzZXF1ZW50aWFsIGltcGxlbWVudGF0aW9uLFxuICAgc2lnbmFscyBhbmQgb3RoZXIgYXN5bmNocm9ub3VzIGNhbGxiYWNrcyBtaWdodCBicmVhayBhdG9taWNpdHkuICopXG50eXBlICdhIHQgPSB7bXV0YWJsZSB2OiAnYX1cblxubGV0IG1ha2UgdiA9IHt2fVxubGV0IGdldCByID0gci52XG5sZXQgc2V0IHIgdiA9IHIudiA8LSB2XG5cbigqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBzZXQgdG8gbmV2ZXIgYmUgaW5saW5lZDogRmxhbWJkYSBpc1xuICAgYWxsb3dlZCB0byBtb3ZlIHN1cnJvdW5kaW5nIGNvZGUgaW5zaWRlIHRoZSBjcml0aWNhbCBzZWN0aW9uLFxuICAgaW5jbHVkaW5nIGFsbG9jYXRpb25zLiAqKVxuXG5sZXRbQGlubGluZSBuZXZlcl0gZXhjaGFuZ2UgciB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIHY7XG4gICgqIEVORCBBVE9NSUMgKilcbiAgY3VyXG5cbmxldFtAaW5saW5lIG5ldmVyXSBjb21wYXJlX2FuZF9zZXQgciBzZWVuIHYgPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICBpZiBjdXIgPT0gc2VlbiB0aGVuIChcbiAgICByLnYgPC0gdjtcbiAgICAoKiBFTkQgQVRPTUlDICopXG4gICAgdHJ1ZVxuICApIGVsc2VcbiAgICBmYWxzZVxuXG5sZXRbQGlubGluZSBuZXZlcl0gZmV0Y2hfYW5kX2FkZCByIG4gPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICByLnYgPC0gKGN1ciArIG4pO1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXQgaW5jciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgMSlcbmxldCBkZWNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAoLTEpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeGNlcHRpb25zICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgKCogZm9yIHJ1bnRpbWUvZmFpbF9uYXQuYyAqKVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuYXJyYXlfYm91bmRfZXJyb3JcIlxuICAgIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcblxubGV0IGZhaWx3aXRoIHMgPSByYWlzZShGYWlsdXJlIHMpXG5sZXQgaW52YWxpZF9hcmcgcyA9IHJhaXNlKEludmFsaWRfYXJndW1lbnQgcylcblxuZXhjZXB0aW9uIEV4aXRcbmV4Y2VwdGlvbiBNYXRjaF9mYWlsdXJlID0gTWF0Y2hfZmFpbHVyZVxuZXhjZXB0aW9uIEFzc2VydF9mYWlsdXJlID0gQXNzZXJ0X2ZhaWx1cmVcbmV4Y2VwdGlvbiBJbnZhbGlkX2FyZ3VtZW50ID0gSW52YWxpZF9hcmd1bWVudFxuZXhjZXB0aW9uIEZhaWx1cmUgPSBGYWlsdXJlXG5leGNlcHRpb24gTm90X2ZvdW5kID0gTm90X2ZvdW5kXG5leGNlcHRpb24gT3V0X29mX21lbW9yeSA9IE91dF9vZl9tZW1vcnlcbmV4Y2VwdGlvbiBTdGFja19vdmVyZmxvdyA9IFN0YWNrX292ZXJmbG93XG5leGNlcHRpb24gU3lzX2Vycm9yID0gU3lzX2Vycm9yXG5leGNlcHRpb24gRW5kX29mX2ZpbGUgPSBFbmRfb2ZfZmlsZVxuZXhjZXB0aW9uIERpdmlzaW9uX2J5X3plcm8gPSBEaXZpc2lvbl9ieV96ZXJvXG5leGNlcHRpb24gU3lzX2Jsb2NrZWRfaW8gPSBTeXNfYmxvY2tlZF9pb1xuZXhjZXB0aW9uIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlID0gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcblxuKCogQ29tcG9zaXRpb24gb3BlcmF0b3JzICopXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4oKiBEZWJ1Z2dpbmcgKilcblxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fRlVOQ1RJT05fXyA6IHN0cmluZyA9IFwiJWxvY19GVU5DVElPTlwiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NoX2Zsb2F0XCIgXCJjYW1sX2Fjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gQ2FtbGludGVybmFsQXRvbWljLm1ha2UgZmx1c2hfYWxsXG5cbmxldCByZWMgYXRfZXhpdCBmID1cbiAgbGV0IG1vZHVsZSBBdG9taWMgPSBDYW1saW50ZXJuYWxBdG9taWMgaW5cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX3lldF90b19ydW4gPSBBdG9taWMubWFrZSB0cnVlIGluXG4gIGxldCBvbGRfZXhpdCA9IEF0b21pYy5nZXQgZXhpdF9mdW5jdGlvbiBpblxuICBsZXQgbmV3X2V4aXQgKCkgPVxuICAgIGlmIEF0b21pYy5jb21wYXJlX2FuZF9zZXQgZl95ZXRfdG9fcnVuIHRydWUgZmFsc2UgdGhlbiBmICgpIDtcbiAgICBvbGRfZXhpdCAoKVxuICBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgZXhpdF9mdW5jdGlvbiBvbGRfZXhpdCBuZXdfZXhpdCBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIGF0X2V4aXQgZlxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9IChDYW1saW50ZXJuYWxBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24pICgpXG5cbmxldCBleGl0IHJldGNvZGUgPVxuICBkb19hdF9leGl0ICgpO1xuICBzeXNfZXhpdCByZXRjb2RlXG5cbmxldCBfID0gcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIiBkb19hdF9leGl0XG5cbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWRcIlxubGV0ICgpID0gaWYgbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCAoKSB0aGVuIGF0X2V4aXQgbWFqb3JcblxuKCpNT0RVTEVfQUxJQVNFUyopXG5tb2R1bGUgQXJnICAgICAgICAgID0gQXJnXG5tb2R1bGUgQXJyYXkgICAgICAgID0gQXJyYXlcbm1vZHVsZSBBcnJheUxhYmVscyAgPSBBcnJheUxhYmVsc1xubW9kdWxlIEF0b21pYyAgICAgICA9IEF0b21pY1xubW9kdWxlIEJpZ2FycmF5ICAgICA9IEJpZ2FycmF5XG5tb2R1bGUgQm9vbCAgICAgICAgID0gQm9vbFxubW9kdWxlIEJ1ZmZlciAgICAgICA9IEJ1ZmZlclxubW9kdWxlIEJ5dGVzICAgICAgICA9IEJ5dGVzXG5tb2R1bGUgQnl0ZXNMYWJlbHMgID0gQnl0ZXNMYWJlbHNcbm1vZHVsZSBDYWxsYmFjayAgICAgPSBDYWxsYmFja1xubW9kdWxlIENoYXIgICAgICAgICA9IENoYXJcbm1vZHVsZSBDb21wbGV4ICAgICAgPSBDb21wbGV4XG5tb2R1bGUgRGlnZXN0ICAgICAgID0gRGlnZXN0XG5tb2R1bGUgRWl0aGVyICAgICAgID0gRWl0aGVyXG5tb2R1bGUgRXBoZW1lcm9uICAgID0gRXBoZW1lcm9uXG5tb2R1bGUgRmlsZW5hbWUgICAgID0gRmlsZW5hbWVcbm1vZHVsZSBGbG9hdCAgICAgICAgPSBGbG9hdFxubW9kdWxlIEZvcm1hdCAgICAgICA9IEZvcm1hdFxubW9kdWxlIEZ1biAgICAgICAgICA9IEZ1blxubW9kdWxlIEdjICAgICAgICAgICA9IEdjXG5tb2R1bGUgR2VubGV4ICAgICAgID0gR2VubGV4XG5tb2R1bGUgSGFzaHRibCAgICAgID0gSGFzaHRibFxubW9kdWxlIEludCAgICAgICAgICA9IEludFxubW9kdWxlIEludDMyICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgID0gSW50NjRcbm1vZHVsZSBMYXp5ICAgICAgICAgPSBMYXp5XG5tb2R1bGUgTGV4aW5nICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgID0gTGlzdFxubW9kdWxlIExpc3RMYWJlbHMgICA9IExpc3RMYWJlbHNcbm1vZHVsZSBNYXAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgPSBNYXJzaGFsXG5tb2R1bGUgTW9yZUxhYmVscyAgID0gTW9yZUxhYmVsc1xubW9kdWxlIE5hdGl2ZWludCAgICA9IE5hdGl2ZWludFxubW9kdWxlIE9iaiAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICA9IE9vXG5tb2R1bGUgT3B0aW9uICAgICAgID0gT3B0aW9uXG5tb2R1bGUgUGFyc2luZyAgICAgID0gUGFyc2luZ1xubW9kdWxlIFBlcnZhc2l2ZXMgICA9IFBlcnZhc2l2ZXNcbm1vZHVsZSBQcmludGV4YyAgICAgPSBQcmludGV4Y1xubW9kdWxlIFByaW50ZiAgICAgICA9IFByaW50ZlxubW9kdWxlIFF1ZXVlICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgID0gUmFuZG9tXG5tb2R1bGUgUmVzdWx0ICAgICAgID0gUmVzdWx0XG5tb2R1bGUgU2NhbmYgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZXEgICAgICAgICAgPSBTZXFcbm1vZHVsZSBTZXQgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTdGFjayAgICAgICAgPSBTdGFja1xubW9kdWxlIFN0ZExhYmVscyAgICA9IFN0ZExhYmVsc1xubW9kdWxlIFN0cmVhbSAgICAgICA9IFN0cmVhbVxubW9kdWxlIFN0cmluZyAgICAgICA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ0xhYmVscyA9IFN0cmluZ0xhYmVsc1xubW9kdWxlIFN5cyAgICAgICAgICA9IFN5c1xubW9kdWxlIFVjaGFyICAgICAgICA9IFVjaGFyXG5tb2R1bGUgVW5pdCAgICAgICAgID0gVW5pdFxubW9kdWxlIFdlYWsgICAgICAgICA9IFdlYWtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIEBkZXByZWNhdGVkIFVzZSB7IVN0ZGxpYn0gKilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5sZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xubGV0IGZhaWx3aXRoID0gZmFpbHdpdGhcbmV4Y2VwdGlvbiBFeGl0XG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBtaW4gPSBtaW5cbmxldCBtYXggPSBtYXhcbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICgmJikgaW5zdGVhZC5cIl1cbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAofHwpIGluc3RlYWQuXCJdXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5sZXQgYWJzID0gYWJzXG5sZXQgbWF4X2ludCA9IG1heF9pbnRcbmxldCBtaW5faW50ID0gbWluX2ludFxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsbm90ID0gbG5vdFxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmxldCBpbmZpbml0eSA9IGluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gbmVnX2luZmluaXR5XG5sZXQgbmFuID0gbmFuXG5sZXQgbWF4X2Zsb2F0ID0gbWF4X2Zsb2F0XG5sZXQgbWluX2Zsb2F0ID0gbWluX2Zsb2F0XG5sZXQgZXBzaWxvbl9mbG9hdCA9IGVwc2lsb25fZmxvYXRcbnR5cGUgbm9ucmVjIGZwY2xhc3MgPSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5sZXQgKCBeICkgPSAoIF4gKVxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCA9IGNoYXJfb2ZfaW50XG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcbmxldCBzdHJpbmdfb2ZfYm9vbCA9IHN0cmluZ19vZl9ib29sXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBib29sX29mX3N0cmluZ1xubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGJvb2xfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9pbnQgPSBzdHJpbmdfb2ZfaW50XG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBpbnRfb2Zfc3RyaW5nX29wdCA9IGludF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2Zsb2F0ID0gc3RyaW5nX29mX2Zsb2F0XG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0ID0gZmxvYXRfb2Zfc3RyaW5nX29wdFxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcbmxldCAoIEAgKSAgPSAoIEAgKVxudHlwZSBub25yZWMgaW5fY2hhbm5lbCA9IGluX2NoYW5uZWxcbnR5cGUgbm9ucmVjIG91dF9jaGFubmVsID0gb3V0X2NoYW5uZWxcbmxldCBzdGRpbiA9IHN0ZGluXG5sZXQgc3Rkb3V0ID0gc3Rkb3V0XG5sZXQgc3RkZXJyID0gc3RkZXJyXG5sZXQgcHJpbnRfY2hhciA9IHByaW50X2NoYXJcbmxldCBwcmludF9zdHJpbmcgPSBwcmludF9zdHJpbmdcbmxldCBwcmludF9ieXRlcyA9IHByaW50X2J5dGVzXG5sZXQgcHJpbnRfaW50ID0gcHJpbnRfaW50XG5sZXQgcHJpbnRfZmxvYXQgPSBwcmludF9mbG9hdFxubGV0IHByaW50X2VuZGxpbmUgPSBwcmludF9lbmRsaW5lXG5sZXQgcHJpbnRfbmV3bGluZSA9IHByaW50X25ld2xpbmVcbmxldCBwcmVycl9jaGFyID0gcHJlcnJfY2hhclxubGV0IHByZXJyX3N0cmluZyA9IHByZXJyX3N0cmluZ1xubGV0IHByZXJyX2J5dGVzID0gcHJlcnJfYnl0ZXNcbmxldCBwcmVycl9pbnQgPSBwcmVycl9pbnRcbmxldCBwcmVycl9mbG9hdCA9IHByZXJyX2Zsb2F0XG5sZXQgcHJlcnJfZW5kbGluZSA9IHByZXJyX2VuZGxpbmVcbmxldCBwcmVycl9uZXdsaW5lID0gcHJlcnJfbmV3bGluZVxubGV0IHJlYWRfbGluZSA9IHJlYWRfbGluZVxubGV0IHJlYWRfaW50ID0gcmVhZF9pbnRcbmxldCByZWFkX2ludF9vcHQgPSByZWFkX2ludF9vcHRcbmxldCByZWFkX2Zsb2F0ID0gcmVhZF9mbG9hdFxubGV0IHJlYWRfZmxvYXRfb3B0ID0gcmVhZF9mbG9hdF9vcHRcbnR5cGUgbm9ucmVjIG9wZW5fZmxhZyA9IG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcbmxldCBvcGVuX291dCA9IG9wZW5fb3V0XG5sZXQgb3Blbl9vdXRfYmluID0gb3Blbl9vdXRfYmluXG5sZXQgb3Blbl9vdXRfZ2VuID0gb3Blbl9vdXRfZ2VuXG5sZXQgZmx1c2ggPSBmbHVzaFxubGV0IGZsdXNoX2FsbCA9IGZsdXNoX2FsbFxubGV0IG91dHB1dF9jaGFyID0gb3V0cHV0X2NoYXJcbmxldCBvdXRwdXRfc3RyaW5nID0gb3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IG91dHB1dF9ieXRlc1xubGV0IG91dHB1dCA9IG91dHB1dFxubGV0IG91dHB1dF9zdWJzdHJpbmcgPSBvdXRwdXRfc3Vic3RyaW5nXG5sZXQgb3V0cHV0X2J5dGUgPSBvdXRwdXRfYnl0ZVxubGV0IG91dHB1dF9iaW5hcnlfaW50ID0gb3V0cHV0X2JpbmFyeV9pbnRcbmxldCBvdXRwdXRfdmFsdWUgPSBvdXRwdXRfdmFsdWVcbmxldCBzZWVrX291dCA9IHNlZWtfb3V0XG5sZXQgcG9zX291dCA9IHBvc19vdXRcbmxldCBvdXRfY2hhbm5lbF9sZW5ndGggPSBvdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZV9vdXQgPSBjbG9zZV9vdXRcbmxldCBjbG9zZV9vdXRfbm9lcnIgPSBjbG9zZV9vdXRfbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfb3V0ID0gc2V0X2JpbmFyeV9tb2RlX291dFxubGV0IG9wZW5faW4gPSBvcGVuX2luXG5sZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2JpblxubGV0IG9wZW5faW5fZ2VuID0gb3Blbl9pbl9nZW5cbmxldCBpbnB1dF9jaGFyID0gaW5wdXRfY2hhclxubGV0IGlucHV0X2xpbmUgPSBpbnB1dF9saW5lXG5sZXQgaW5wdXQgPSBpbnB1dFxubGV0IHJlYWxseV9pbnB1dCA9IHJlYWxseV9pbnB1dFxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgPSByZWFsbHlfaW5wdXRfc3RyaW5nXG5sZXQgaW5wdXRfYnl0ZSA9IGlucHV0X2J5dGVcbmxldCBpbnB1dF9iaW5hcnlfaW50ID0gaW5wdXRfYmluYXJ5X2ludFxubGV0IGlucHV0X3ZhbHVlID0gaW5wdXRfdmFsdWVcbmxldCBzZWVrX2luID0gc2Vla19pblxubGV0IHBvc19pbiA9IHBvc19pblxubGV0IGluX2NoYW5uZWxfbGVuZ3RoID0gaW5fY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZV9pbiA9IGNsb3NlX2luXG5sZXQgY2xvc2VfaW5fbm9lcnIgPSBjbG9zZV9pbl9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9pbiA9IHNldF9iaW5hcnlfbW9kZV9pblxubW9kdWxlIExhcmdlRmlsZSA9IExhcmdlRmlsZVxudHlwZSBub25yZWMgJ2EgcmVmID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxudHlwZSBub25yZWMgKCdhLCdiKSByZXN1bHQgPSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxubGV0IHN0cmluZ19vZl9mb3JtYXQgPSBzdHJpbmdfb2ZfZm9ybWF0XG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5sZXQgKCBeXiApID0gKCBeXiApXG5sZXQgZXhpdCA9IGV4aXRcbmxldCBhdF9leGl0ID0gYXRfZXhpdFxubGV0IHZhbGlkX2Zsb2F0X2xleGVtID0gdmFsaWRfZmxvYXRfbGV4ZW1cbmxldCBkb19hdF9leGl0ID0gZG9fYXRfZXhpdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIEludC5tYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG4gIGxldCByZWMgaW50NjNhdXggcyBuID1cbiAgICBsZXQgbWF4X2ludF8zMiA9ICgxIGxzbCAzMCkgKyAweDNGRkZGRkZGIGluICgqIDB4N0ZGRkZGRkYgKilcbiAgICBsZXQgYjEgPSBiaXRzIHMgaW5cbiAgICBsZXQgYjIgPSBiaXRzIHMgaW5cbiAgICBsZXQgKHIsIG1heF9pbnQpID1cbiAgICAgIGlmIG4gPD0gbWF4X2ludF8zMiB0aGVuXG4gICAgICAgICgqIDMxIHJhbmRvbSBiaXRzIG9uIGJvdGggNjQtYml0IE9DYW1sIGFuZCBKYXZhU2NyaXB0LlxuICAgICAgICAgICBVc2UgdXBwZXIgMTUgYml0cyBvZiBiMSBhbmQgMTYgYml0cyBvZiBiMi4gKilcbiAgICAgICAgbGV0IGJwb3MgPVxuICAgICAgICAgICgoKGIyIGxhbmQgMHgzRkZGQzAwMCkgbHNsIDEpIGxvciAoYjEgbHNyIDE1KSlcbiAgICAgICAgaW5cbiAgICAgICAgICAoYnBvcywgbWF4X2ludF8zMilcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGIzID0gYml0cyBzIGluXG4gICAgICAgICgqIDYyIHJhbmRvbSBiaXRzIG9uIDY0LWJpdCBPQ2FtbDsgdW5yZWFjaGFibGUgb24gSmF2YVNjcmlwdC5cbiAgICAgICAgICAgVXNlIHVwcGVyIDIwIGJpdHMgb2YgYjEgYW5kIDIxIGJpdHMgb2YgYjIgYW5kIGIzLiAqKVxuICAgICAgICBsZXQgYnBvcyA9XG4gICAgICAgICAgKCgoKGIzIGxhbmQgMHgzRkZGRkUwMCkgbHNsIDEyKSBsb3IgKGIyIGxzciA5KSkgbHNsIDIwKVxuICAgICAgICAgICAgbG9yIChiMSBsc3IgMTApXG4gICAgICAgIGluXG4gICAgICAgICAgKGJwb3MsIG1heF9pbnQpXG4gICAgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IG1heF9pbnQgLSBuICsgMSB0aGVuIGludDYzYXV4IHMgbiBlbHNlIHZcblxuICBsZXQgZnVsbF9pbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5mdWxsX2ludFwiXG4gICAgZWxzZSBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgdGhlblxuICAgICAgaW50NjNhdXggcyBib3VuZFxuICAgIGVsc2VcbiAgICAgIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBTdGRsaWIuZmxvYXQgdi4oaTApICouIFN0ZGxpYi5mbG9hdCB2LihpMClcbiAgZWxzZSBzdW1zcSB2IGkwICgoaTAraTEpLzIpICsuIHN1bXNxIHYgKChpMCtpMSkvMikgaTFcblxuXG5sZXQgY2hpc3F1YXJlIGcgbiByID1cbiAgaWYgbiA8PSAxMCAqIHIgdGhlbiBpbnZhbGlkX2FyZyBcImNoaXNxdWFyZVwiO1xuICBsZXQgZiA9IEFycmF5Lm1ha2UgciAwIGluXG4gIGZvciBpID0gMSB0byBuIGRvXG4gICAgbGV0IHQgPSBnIHIgaW5cbiAgICBmLih0KSA8LSBmLih0KSArIDFcbiAgZG9uZTtcbiAgbGV0IHQgPSBzdW1zcSBmIDAgclxuICBhbmQgciA9IFN0ZGxpYi5mbG9hdCByXG4gIGFuZCBuID0gU3RkbGliLmZsb2F0IG4gaW5cbiAgbGV0IHNyID0gMi4wICouIHNxcnQgciBpblxuICAociAtLiBzciwgICAociAqLiB0IC8uIG4pIC0uIG4sICAgciArLiBzcilcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIGxpbmVhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbSBudW1iZXJzLlxuKilcbmxldCBzdCA9IHJlZiAwXG5sZXQgaW5pdF9kaWZmIHIgPSBzdCA6PSBpbnQgclxubGV0IGRpZmYgciA9XG4gIGxldCB4MSA9ICFzdFxuICBhbmQgeDIgPSBpbnQgclxuICBpblxuICBzdCA6PSB4MjtcbiAgaWYgeDEgPj0geDIgdGhlblxuICAgIHgxIC0geDJcbiAgZWxzZVxuICAgIHIgKyB4MSAtIHgyXG5cblxubGV0IHN0MSA9IHJlZiAwXG5hbmQgc3QyID0gcmVmIDBcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIHF1YWRyYXRpYyBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbVxuICAgbnVtYmVycy5cbiopXG5sZXQgaW5pdF9kaWZmMiByID0gc3QxIDo9IGludCByOyBzdDIgOj0gaW50IHJcbmxldCBkaWZmMiByID1cbiAgbGV0IHgxID0gIXN0MVxuICBhbmQgeDIgPSAhc3QyXG4gIGFuZCB4MyA9IGludCByXG4gIGluXG4gIHN0MSA6PSB4MjtcbiAgc3QyIDo9IHgzO1xuICAoeDMgLSB4MiAtIHgyICsgeDEgKyAyKnIpIG1vZCByXG5cblxuKioqKioqKioqKioqKioqKioqKiopXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBsaXN0cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGxpc3QgPSBbXSB8ICg6Oikgb2YgJ2EgKiAnYSBsaXN0XG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXQgcmVjIGluaXRfdGFpbHJlY19hdXggYWNjIGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gYWNjXG4gIGVsc2UgaW5pdF90YWlscmVjX2F1eCAoZiBpIDo6IGFjYykgKGkrMSkgbiBmXG5cbmxldCByZWMgaW5pdF9hdXggaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHIgPSBmIGkgaW5cbiAgICByIDo6IGluaXRfYXV4IChpKzEpIG4gZlxuXG5sZXQgcmV2X2luaXRfdGhyZXNob2xkID1cbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgU3lzLk5hdGl2ZSB8IFN5cy5CeXRlY29kZSAtPiAxMF8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQnc1xuICAgICBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgcmVjIGZpbmRfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIGYgbFxuICAgICBlbmRcblxubGV0IGZpbmRfYWxsIHAgPVxuICBsZXQgcmVjIGZpbmQgYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY3VcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gZmluZCAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCBhY2N1IGwgaW5cbiAgZmluZCBbXVxuXG5sZXQgZmlsdGVyID0gZmluZF9hbGxcblxubGV0IGZpbHRlcmkgcCBsID1cbiAgbGV0IHJlYyBhdXggaSBhY2MgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2NcbiAgfCB4OjpsIC0+IGF1eCAoaSArIDEpIChpZiBwIGkgeCB0aGVuIHg6OmFjYyBlbHNlIGFjYykgbFxuICBpblxuICBhdXggMCBbXSBsXG5cbmxldCBmaWx0ZXJfbWFwIGYgPVxuICBsZXQgcmVjIGF1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGF1eCBhY2N1IGxcbiAgICAgICAgfCBTb21lIHYgLT4gYXV4ICh2IDo6IGFjY3UpIGxcbiAgaW5cbiAgYXV4IFtdXG5cbmxldCBjb25jYXRfbWFwIGYgbCA9XG4gIGxldCByZWMgYXV4IGYgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IHggOjogbCAtPlxuICAgICAgIGxldCB4cyA9IGYgeCBpblxuICAgICAgIGF1eCBmIChyZXZfYXBwZW5kIHhzIGFjYykgbFxuICBpbiBhdXggZiBbXSBsXG5cbmxldCBmb2xkX2xlZnRfbWFwIGYgYWNjdSBsID1cbiAgbGV0IHJlYyBhdXggYWNjdSBsX2FjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdSwgcmV2IGxfYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIGxldCBhY2N1LCB4ID0gZiBhY2N1IHggaW5cbiAgICAgICAgYXV4IGFjY3UgKHggOjogbF9hY2N1KSBsIGluXG4gIGF1eCBhY2N1IFtdIGxcblxubGV0IHBhcnRpdGlvbiBwIGwgPVxuICBsZXQgcmVjIHBhcnQgeWVzIG5vID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IHllcywgcmV2IG5vKVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBwYXJ0ICh4IDo6IHllcykgbm8gbCBlbHNlIHBhcnQgeWVzICh4IDo6IG5vKSBsIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcGFydGl0aW9uX21hcCBwIGwgPVxuICBsZXQgcmVjIHBhcnQgbGVmdCByaWdodCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiBsZWZ0LCByZXYgcmlnaHQpXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIHAgeCB3aXRoXG4gICAgICAgfCBFaXRoZXIuTGVmdCB2IC0+IHBhcnQgKHYgOjogbGVmdCkgcmlnaHQgbFxuICAgICAgIHwgRWl0aGVyLlJpZ2h0IHYgLT4gcGFydCBsZWZ0ICh2IDo6IHJpZ2h0KSBsXG4gICAgIGVuZFxuICBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHJlYyBzcGxpdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKFtdLCBbXSlcbiAgfCAoeCx5KTo6bCAtPlxuICAgICAgbGV0IChyeCwgcnkpID0gc3BsaXQgbCBpbiAoeDo6cngsIHk6OnJ5KVxuXG5sZXQgcmVjIGNvbWJpbmUgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IChhMSwgYTIpIDo6IGNvbWJpbmUgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmNvbWJpbmVcIlxuXG4oKiogc29ydGluZyAqKVxuXG5sZXQgcmVjIG1lcmdlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiBoMSA6OiBtZXJnZSBjbXAgdDEgbDJcbiAgICAgIGVsc2UgaDIgOjogbWVyZ2UgY21wIGwxIHQyXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqIE5vdGU6IG9uIGEgbGlzdCBvZiBsZW5ndGggYmV0d2VlbiBhYm91dCAxMDAwMDAgKGRlcGVuZGluZyBvbiB0aGUgbWlub3JcbiAgIGhlYXAgc2l6ZSBhbmQgdGhlIHR5cGUgb2YgdGhlIGxpc3QpIGFuZCBTeXMubWF4X2FycmF5X3NpemUsIGl0IGlzXG4gICBhY3R1YWxseSBmYXN0ZXIgdG8gdXNlIHRoZSBmb2xsb3dpbmcsIGJ1dCBpdCBtaWdodCBhbHNvIHVzZSBtb3JlIG1lbW9yeVxuICAgYmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZGVhbGxvY2F0ZWQgaW5jcmVtZW50YWxseS5cblxuICAgQWxzbywgdGhlcmUgc2VlbXMgdG8gYmUgYSBidWcgaW4gdGhpcyBjb2RlIG9yIGluIHRoZVxuICAgaW1wbGVtZW50YXRpb24gb2Ygb2JqX3RydW5jYXRlLlxuXG5leHRlcm5hbCBvYmpfdHJ1bmNhdGUgOiAnYSBhcnJheSAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuXG5sZXQgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhID1cbiAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBuIHAgPVxuICAgIGlmIHAgPD0gMCB0aGVuIGFjY3UgZWxzZSBiZWdpblxuICAgICAgaWYgcCA9IG4gdGhlbiBiZWdpblxuICAgICAgICBvYmpfdHJ1bmNhdGUgYSBwO1xuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIChuLTEwMDApIChwLTEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIG4gKHAtMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpblxuICBsb29wIFtdIChsLTEwMDApIGxcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICBBcnJheS5zdGFibGVfc29ydCBjbXAgYTtcbiAgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhXG5cbiopXG5cblxuKCoqIHNvcnRpbmcgKyByZW1vdmluZyBkdXBsaWNhdGVzICopXG5cbmxldCBzb3J0X3VuaXEgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2UgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlX3JldiB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhzIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IF8gOjogbDEsIF8gOjogbDIgLT4gY29tcGFyZV9sZW5ndGhzIGwxIGwyXG47O1xuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCBuID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBpZiBuID0gMCB0aGVuIDAgZWxzZVxuICAgICAgaWYgbiA+IDAgdGhlbiAtMSBlbHNlIDFcbiAgfCBfIDo6IGwgLT5cbiAgICBpZiBuIDw9IDAgdGhlbiAxIGVsc2VcbiAgICAgIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCAobi0xKVxuOztcblxuKCoqIHsxIENvbXBhcmlzb259ICopXG5cbigqIE5vdGU6IHdlIGFyZSAqbm90KiBzaG9ydGN1dHRpbmcgdGhlIGxpc3QgYnkgdXNpbmdcbiAgIFtMaXN0LmNvbXBhcmVfbGVuZ3Roc10gZmlyc3Q7IHRoaXMgbWF5IGJlIHNsb3dlciBvbiBsb25nIGxpc3RzXG4gICBpbW1lZGlhdGVseSBzdGFydCB3aXRoIGRpc3RpbmN0IGVsZW1lbnRzLiBJdCBpcyBhbHNvIGluY29ycmVjdCBmb3JcbiAgIFtjb21wYXJlXSBiZWxvdywgYW5kIGl0IGlzIGJldHRlciAocHJpbmNpcGxlIG9mIGxlYXN0IHN1cnByaXNlKSB0b1xuICAgdXNlIHRoZSBzYW1lIGFwcHJvYWNoIGZvciBib3RoIGZ1bmN0aW9ucy4gKilcbmxldCByZWMgZXF1YWwgZXEgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiB0cnVlXG4gIHwgW10sIF86Ol8gfCBfOjpfLCBbXSAtPiBmYWxzZVxuICB8IGExOjpsMSwgYTI6OmwyIC0+IGVxIGExIGEyICYmIGVxdWFsIGVxIGwxIGwyXG5cbmxldCByZWMgY29tcGFyZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF86Ol8gLT4gLTFcbiAgfCBfOjpfLCBbXSAtPiAxXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT5cbiAgICBsZXQgYyA9IGNtcCBhMSBhMiBpblxuICAgIGlmIGMgPD4gMCB0aGVuIGNcbiAgICBlbHNlIGNvbXBhcmUgY21wIGwxIGwyXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgbCA9XG4gIGxldCByZWMgYXV4IGwgKCkgPSBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFNlcS5OaWxcbiAgICB8IHggOjogdGFpbCAtPiBTZXEuQ29ucyAoeCwgYXV4IHRhaWwpXG4gIGluXG4gIGF1eCBsXG5cbmxldCBvZl9zZXEgc2VxID1cbiAgbGV0IHJlYyBkaXJlY3QgZGVwdGggc2VxIDogXyBsaXN0ID1cbiAgICBpZiBkZXB0aD0wXG4gICAgdGhlblxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gc2VxXG4gICAgICB8PiByZXYgKCogdGFpbHJlYyAqKVxuICAgIGVsc2UgbWF0Y2ggc2VxKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFtdXG4gICAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPiB4IDo6IGRpcmVjdCAoZGVwdGgtMSkgbmV4dFxuICBpblxuICBkaXJlY3QgNTAwIHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgY29uY2F0IHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgIGFwcGVuZCB4IChjb25jYXQgbmV4dCkgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgYXBwZW5kIChmIHgpIChmbGF0X21hcCBmIG5leHQpICgpXG5cbmxldCBjb25jYXRfbWFwID0gZmxhdF9tYXBcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gTmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IENvbnMgKHgsIHVuZm9sZCBmIHUnKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYVxuXG5sZXQgbm9uZSA9IE5vbmVcbmxldCBzb21lIHYgPSBTb21lIHZcbmxldCB2YWx1ZSBvIH5kZWZhdWx0ID0gbWF0Y2ggbyB3aXRoIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBkZWZhdWx0XG5sZXQgZ2V0ID0gZnVuY3Rpb24gU29tZSB2IC0+IHYgfCBOb25lIC0+IGludmFsaWRfYXJnIFwib3B0aW9uIGlzIE5vbmVcIlxubGV0IGJpbmQgbyBmID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBmIHZcbmxldCBqb2luID0gZnVuY3Rpb24gU29tZSBvIC0+IG8gfCBOb25lIC0+IE5vbmVcbmxldCBtYXAgZiBvID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBTb21lIChmIHYpXG5sZXQgZm9sZCB+bm9uZSB+c29tZSA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBzb21lIHYgfCBOb25lIC0+IG5vbmVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHYgLT4gZiB2IHwgTm9uZSAtPiAoKVxubGV0IGlzX25vbmUgPSBmdW5jdGlvbiBOb25lIC0+IHRydWUgfCBTb21lIF8gLT4gZmFsc2VcbmxldCBpc19zb21lID0gZnVuY3Rpb24gTm9uZSAtPiBmYWxzZSB8IFNvbWUgXyAtPiB0cnVlXG5cbmxldCBlcXVhbCBlcSBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gZXEgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiB0cnVlXG58IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgY21wIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBjbXAgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiAwXG58IE5vbmUsIFNvbWUgXyAtPiAtMVxufCBTb21lIF8sIE5vbmUgLT4gMVxuXG5sZXQgdG9fcmVzdWx0IH5ub25lID0gZnVuY3Rpb24gTm9uZSAtPiBFcnJvciBub25lIHwgU29tZSB2IC0+IE9rIHZcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBOb25lIC0+IFNlcS5lbXB0eSB8IFNvbWUgdiAtPiBTZXEucmV0dXJuIHZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFyc2lmYWwsIElOUklBIFNhY2xheSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdiKSB0ID0gTGVmdCBvZiAnYSB8IFJpZ2h0IG9mICdiXG5cbmxldCBsZWZ0IHYgPSBMZWZ0IHZcbmxldCByaWdodCB2ID0gUmlnaHQgdlxuXG5sZXQgaXNfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiB0cnVlXG58IFJpZ2h0IF8gLT4gZmFsc2VcblxubGV0IGlzX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IGZhbHNlXG58IFJpZ2h0IF8gLT4gdHJ1ZVxuXG5sZXQgZmluZF9sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IFNvbWUgdlxufCBSaWdodCBfIC0+IE5vbmVcblxubGV0IGZpbmRfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gTm9uZVxufCBSaWdodCB2IC0+IFNvbWUgdlxuXG5sZXQgbWFwX2xlZnQgZiA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChmIHYpXG58IFJpZ2h0IF8gYXMgZSAtPiBlXG5cbmxldCBtYXBfcmlnaHQgZiA9IGZ1bmN0aW9uXG58IExlZnQgXyBhcyBlIC0+IGVcbnwgUmlnaHQgdiAtPiBSaWdodCAoZiB2KVxuXG5sZXQgbWFwIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChsZWZ0IHYpXG58IFJpZ2h0IHYgLT4gUmlnaHQgKHJpZ2h0IHYpXG5cbmxldCBmb2xkIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBsZWZ0IHZcbnwgUmlnaHQgdiAtPiByaWdodCB2XG5cbmxldCBpdGVyID0gZm9sZFxuXG5sZXQgZm9yX2FsbCA9IGZvbGRcblxubGV0IGVxdWFsIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIHwgUmlnaHQgXywgTGVmdCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIC0+ICgtMSlcbnwgUmlnaHQgXywgTGVmdCBfIC0+IDFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnZVxuXG5sZXQgb2sgdiA9IE9rIHZcbmxldCBlcnJvciBlID0gRXJyb3IgZVxubGV0IHZhbHVlIHIgfmRlZmF1bHQgPSBtYXRjaCByIHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBkZWZhdWx0XG5sZXQgZ2V0X29rID0gZnVuY3Rpb24gT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBFcnJvciBfXCJcbmxldCBnZXRfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGUgfCBPayBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIE9rIF9cIlxubGV0IGJpbmQgciBmID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBqb2luID0gZnVuY3Rpb24gT2sgciAtPiByIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXAgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gT2sgKGYgdikgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcF9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBFcnJvciAoZiBlKSB8IE9rIF8gYXMgdiAtPiB2XG5sZXQgZm9sZCB+b2sgfmVycm9yID0gZnVuY3Rpb24gT2sgdiAtPiBvayB2IHwgRXJyb3IgZSAtPiBlcnJvciBlXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gT2sgdiAtPiBmIHYgfCBFcnJvciBfIC0+ICgpXG5sZXQgaXRlcl9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBmIGUgfCBPayBfIC0+ICgpXG5sZXQgaXNfb2sgPSBmdW5jdGlvbiBPayBfIC0+IHRydWUgfCBFcnJvciBfIC0+IGZhbHNlXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBfIC0+IHRydWUgfCBPayBfIC0+IGZhbHNlXG5cbmxldCBlcXVhbCB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBfLCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IE9rIF8sIEVycm9yIF8gLT4gLTFcbnwgRXJyb3IgXywgT2sgXyAtPiAxXG5cbmxldCB0b19vcHRpb24gPSBmdW5jdGlvbiBPayB2IC0+IFNvbWUgdiB8IEVycm9yIF8gLT4gTm9uZVxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBPayB2IC0+IFt2XSB8IEVycm9yIF8gLT4gW11cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBPayB2IC0+IFNlcS5yZXR1cm4gdiB8IEVycm9yIF8gLT4gU2VxLmVtcHR5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGJvb2wgPSBmYWxzZSB8IHRydWVcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxubGV0IGVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmV4dGVybmFsIHRvX2ludCA6IGJvb2wgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb24gZmFsc2UgLT4gMC4gfCB0cnVlIC0+IDEuXG5cbigqXG5sZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbnwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbnwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG58IF8gLT4gTm9uZVxuKilcblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uIGZhbHNlIC0+IFwiZmFsc2VcIiB8IHRydWUgLT4gXCJ0cnVlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGNociBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiQ2hhci5jaHJcIiBlbHNlIHVuc2FmZV9jaHIgblxuXG5leHRlcm5hbCBieXRlc19jcmVhdGU6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0IGVzY2FwZWQgPSBmdW5jdGlvblxuICB8ICdcXCcnIC0+IFwiXFxcXCdcIlxuICB8ICdcXFxcJyAtPiBcIlxcXFxcXFxcXCJcbiAgfCAnXFxuJyAtPiBcIlxcXFxuXCJcbiAgfCAnXFx0JyAtPiBcIlxcXFx0XCJcbiAgfCAnXFxyJyAtPiBcIlxcXFxyXCJcbiAgfCAnXFxiJyAtPiBcIlxcXFxiXCJcbiAgfCAnICcgLi4gJ34nIGFzIGMgLT5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDEgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwIGM7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcbiAgfCBjIC0+XG4gICAgICBsZXQgbiA9IGNvZGUgYyBpblxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgNCBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgJ1xcXFwnO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDEgKHVuc2FmZV9jaHIgKDQ4ICsgbiAvIDEwMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDIgKHVuc2FmZV9jaHIgKDQ4ICsgKG4gLyAxMCkgbW9kIDEwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMyAodW5zYWZlX2NociAoNDggKyBuIG1vZCAxMCkpO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG5cbmxldCBsb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWidcbiAgfCAnXFwxOTInIC4uICdcXDIxNCdcbiAgfCAnXFwyMTYnIC4uICdcXDIyMicgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneidcbiAgfCAnXFwyMjQnIC4uICdcXDI0NidcbiAgfCAnXFwyNDgnIC4uICdcXDI1NCcgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gSW50Lm1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IEludC5taW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbigqIFRoZSBnZXRfIGZ1bmN0aW9ucyBhcmUgYWxsIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgZW1wdHkgPSBcIlwiXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgb2ZfYnl0ZXMgPSBCLnRvX3N0cmluZ1xubGV0IHRvX2J5dGVzID0gQi5vZl9zdHJpbmdcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgPSAoIF4gKVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IGZvbGRfcmlnaHQgZiB4IGEgPVxuICBCLmZvbGRfcmlnaHQgZiAoYm9zIHgpIGFcbmxldCBmb2xkX2xlZnQgZiBhIHggPVxuICBCLmZvbGRfbGVmdCBmIGEgKGJvcyB4KVxubGV0IGV4aXN0cyBmIHMgPVxuICBCLmV4aXN0cyBmIChib3MgcylcbmxldCBmb3JfYWxsIGYgcyA9XG4gIEIuZm9yX2FsbCBmIChib3MgcylcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgcmVjIGVzY2FwZV9pZl9uZWVkZWQgcyBuIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIHMgZWxzZVxuICAgICAgbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFwwMDAnLi4nXFwwMzEnIHwgJ1xcMTI3Jy4uICdcXDI1NScgLT5cbiAgICAgICAgICBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfc3RyaW5nX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX3N0cmluZ19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9zdHJpbmdfZ2V0NjRcIlxuXG5sZXQgZ2V0X2ludDggcyBpID0gQi5nZXRfaW50OCAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2xlIHMgaSA9IEIuZ2V0X3VpbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2JlIHMgaSA9IEIuZ2V0X3VpbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbmUgcyBpID0gQi5nZXRfaW50MTZfbmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2xlIHMgaSA9IEIuZ2V0X2ludDE2X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9iZSBzIGkgPSBCLmdldF9pbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfbGUgcyBpID0gQi5nZXRfaW50MzJfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2JlIHMgaSA9IEIuZ2V0X2ludDMyX2JlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9sZSBzIGkgPSBCLmdldF9pbnQ2NF9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfYmUgcyBpID0gQi5nZXRfaW50NjRfYmUgKGJvcyBzKSBpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG50eXBlIHJhd19kYXRhID0gbmF0aXZlaW50XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIHJhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBhcnJheXMuICopXG50eXBlICdhIHQgPSAnYSBhcnJheVxuXG4oKiBBcnJheSBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5leHRlcm5hbCBnZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5leHRlcm5hbCBtYWtlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIGNyZWF0ZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCB1bnNhZmVfc3ViIDogJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9zdWJcIlxuZXh0ZXJuYWwgYXBwZW5kX3ByaW0gOiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9hcHBlbmRcIlxuZXh0ZXJuYWwgY29uY2F0IDogJ2EgYXJyYXkgbGlzdCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9jb25jYXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfZmlsbFwiXG5leHRlcm5hbCBjcmVhdGVfZmxvYXQ6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxubGV0IG1ha2VfZmxvYXQgPSBjcmVhdGVfZmxvYXRcblxubW9kdWxlIEZsb2F0YXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGZsb2F0YXJyYXkgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiBmbG9hdGFycmF5IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmxldCBpbml0IGwgZiA9XG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlXG4gIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgKCogU2VlICM2NTc1LiBXZSBjb3VsZCBhbHNvIGNoZWNrIGZvciBtYXhpbXVtIGFycmF5IHNpemUsIGJ1dCB0aGlzIGRlcGVuZHNcbiAgICAgb24gd2hldGhlciB3ZSBjcmVhdGUgYSBmbG9hdCBhcnJheSBvciBhIHJlZ3VsYXIgb25lLi4uICopXG4gIGVsc2VcbiAgIGxldCByZXMgPSBjcmVhdGUgbCAoZiAwKSBpblxuICAgZm9yIGkgPSAxIHRvIHByZWQgbCBkb1xuICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICBkb25lO1xuICAgcmVzXG5cbmxldCBtYWtlX21hdHJpeCBzeCBzeSBpbml0ID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzeCBbfHxdIGluXG4gIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgdW5zYWZlX3NldCByZXMgeCAoY3JlYXRlIHN5IGluaXQpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgY3JlYXRlX21hdHJpeCA9IG1ha2VfbWF0cml4XG5cbmxldCBjb3B5IGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIHVuc2FmZV9zdWIgYSAwIGxcblxubGV0IGFwcGVuZCBhMSBhMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICBpZiBsMSA9IDAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbGVuZ3RoIGEyID0gMCB0aGVuIHVuc2FmZV9zdWIgYTEgMCBsMVxuICBlbHNlIGFwcGVuZF9wcmltIGExIGEyXG5cbmxldCBzdWIgYSBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5zdWJcIlxuICBlbHNlIHVuc2FmZV9zdWIgYSBvZnMgbGVuXG5cbmxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG5sZXQgYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIGExIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBhMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlblxuXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGl0ZXIyIGYgYSBiID1cbiAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG5sZXQgbWFwIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXAyIGYgYSBiID1cbiAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgaWYgbGEgPD4gbGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlIGJlZ2luXG4gICAgaWYgbGEgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSAoZiAodW5zYWZlX2dldCBhIDApICh1bnNhZmVfZ2V0IGIgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBtYXBpIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmIDAgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQgcmVjIHRvbGlzdCBpIHJlcyA9XG4gICAgaWYgaSA8IDAgdGhlbiByZXMgZWxzZSB0b2xpc3QgKGkgLSAxKSAodW5zYWZlX2dldCBhIGkgOjogcmVzKSBpblxuICB0b2xpc3QgKGxlbmd0aCBhIC0gMSkgW11cblxuKCogQ2Fubm90IHVzZSBMaXN0Lmxlbmd0aCBoZXJlIGJlY2F1c2UgdGhlIExpc3QgbW9kdWxlIGRlcGVuZHMgb24gQXJyYXkuICopXG5sZXQgcmVjIGxpc3RfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY3VcbiAgfCBfOjp0IC0+IGxpc3RfbGVuZ3RoIChzdWNjIGFjY3UpIHRcblxubGV0IG9mX2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGEgPSBjcmVhdGUgKGxpc3RfbGVuZ3RoIDAgbCkgaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpKzEpIHRsIGluXG4gICAgICBmaWxsIDEgdGxcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX2xlZnRfbWFwIGYgYWNjIGlucHV0X2FycmF5ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dF9hcnJheSBpblxuICBpZiBsZW4gPSAwIHRoZW4gKGFjYywgW3x8XSkgZWxzZSBiZWdpblxuICAgIGxldCBhY2MsIGVsdCA9IGYgYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IDApIGluXG4gICAgbGV0IG91dHB1dF9hcnJheSA9IGNyZWF0ZSBsZW4gZWx0IGluXG4gICAgbGV0IGFjYyA9IHJlZiBhY2MgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGFjYycsIGVsdCA9IGYgIWFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSBpKSBpblxuICAgICAgYWNjIDo9IGFjYyc7XG4gICAgICB1bnNhZmVfc2V0IG91dHB1dF9hcnJheSBpIGVsdDtcbiAgICBkb25lO1xuICAgICFhY2MsIG91dHB1dF9hcnJheVxuICBlbmRcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZvcl9hbGwyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZXhpc3RzMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZXhpc3RzMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtcSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiB4ID09ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9vcHQgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgaWYgcCB4IHRoZW4gU29tZSB4XG4gICAgICBlbHNlIGxvb3AgKHN1Y2MgaSlcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX21hcCBmIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBtYXRjaCBmICh1bnNhZmVfZ2V0IGEgaSkgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKHN1Y2MgaSlcbiAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICBpblxuICBsb29wIDBcblxubGV0IHNwbGl0IHggPVxuICBpZiB4ID0gW3x8XSB0aGVuIFt8fF0sIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCBhMCwgYjAgPSB1bnNhZmVfZ2V0IHggMCBpblxuICAgIGxldCBuID0gbGVuZ3RoIHggaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBuIGEwIGluXG4gICAgbGV0IGIgPSBjcmVhdGUgbiBiMCBpblxuICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgbGV0IGFpLCBiaSA9IHVuc2FmZV9nZXQgeCBpIGluXG4gICAgICB1bnNhZmVfc2V0IGEgaSBhaTtcbiAgICAgIHVuc2FmZV9zZXQgYiBpIGJpXG4gICAgZG9uZTtcbiAgICBhLCBiXG4gIGVuZFxuXG5sZXQgY29tYmluZSBhIGIgPVxuICBsZXQgbmEgPSBsZW5ndGggYSBpblxuICBsZXQgbmIgPSBsZW5ndGggYiBpblxuICBpZiBuYSA8PiBuYiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuY29tYmluZVwiO1xuICBpZiBuYSA9IDAgdGhlbiBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgeCA9IGNyZWF0ZSBuYSAodW5zYWZlX2dldCBhIDAsIHVuc2FmZV9nZXQgYiAwKSBpblxuICAgIGZvciBpID0gMSB0byBuYSAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgeCBpICh1bnNhZmVfZ2V0IGEgaSwgdW5zYWZlX2dldCBiIGkpXG4gICAgZG9uZTtcbiAgICB4XG4gIGVuZFxuXG5leGNlcHRpb24gQm90dG9tIG9mIGludFxubGV0IHNvcnQgY21wIGEgPVxuICBsZXQgbWF4c29uIGwgaSA9XG4gICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAheFxuICAgIGVuZCBlbHNlXG4gICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgIHRoZW4gaTMxKzFcbiAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgaW5cbiAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICBidWJibGVkb3duIGwgalxuICBpblxuICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gIGRvbmU7XG4gIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cblxubGV0IGN1dG9mZiA9IDVcbmxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgZW5kXG4gICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gIGluXG4gIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgIGRlY3IgajtcbiAgICAgIGRvbmU7XG4gICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgZG9uZTtcbiAgaW5cbiAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgIGxldCB0ID0gbWFrZSBsMiAoZ2V0IGEgMCkgaW5cbiAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgZW5kXG5cblxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3Jldl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBsZW4gPSBsaXN0X2xlbmd0aCAwIGwgaW5cbiAgICAgIGxldCBhID0gY3JlYXRlIGxlbiBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICAgIGluXG4gICAgICBmaWxsIChsZW4tMikgdGxcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gIG9mX3Jldl9saXN0IGxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemUgd2l0aFxuICB8IDMyIC0+XG4gICAgICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICAgICAgZnVuIG4gLT5cbiAgICAgICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgICAgICBTb21lICh0b19pbnQgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcbiAgfCA2NCAtPlxuICAgICAgKCogU28gdGhhdCBpdCBjb21waWxlcyBpbiAzMi1iaXQgKilcbiAgICAgIGxldCBtYXNrID0gMHhGRkZGIGxzbCAxNiBsb3IgMHhGRkZGIGluXG4gICAgICBmdW4gbiAtPiBTb21lICh0b19pbnQgbiBsYW5kIG1hc2spXG4gIHwgXyAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmcgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzIgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IGludDMyXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsXG4gICBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0cyB0YWcgY291bGQgaGF2ZVxuICAgICAgIGNoYW5nZWQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSlcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcblxuXG5sZXQgbWFwIGYgeCA9XG4gIGxhenkgKGYgKGZvcmNlIHgpKVxuXG5sZXQgbWFwX3ZhbCBmIHggPVxuICBpZiBpc192YWwgeFxuICB0aGVuIGxhenlfZnJvbV92YWwgKGYgKGZvcmNlIHgpKVxuICBlbHNlIGxhenkgKGYgKGZvcmNlIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPlxuICAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgIGlmIGIubGVuID09IDAgdGhlbiBzLmRhdGEgPC0gU2VtcHR5XG4gICAgICBlbHNlIChzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kKVxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbMCA8PSBiLnBvc2l0aW9uIDw9IGIubGVuZ3RoXVxuICAgLSBbYi5sZW5ndGggPSBCeXRlcy5sZW5ndGggYi5idWZmZXJdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmJ1ZmZlcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmxlbmd0aF0uXG5cbiAgIEluIHBhcnRpY3VsYXIsIGFmdGVyIFtyZXNpemUgYiBtb3JlXSBpcyBjYWxsZWQsIGEgZGlyZWN0IGFjY2VzcyBvZlxuICAgc2l6ZSBbbW9yZV0gYXQgW2IucG9zaXRpb25dIHdpbGwgYWx3YXlzIGJlIGluLWJvdW5kcywgc28gdGhhdFxuICAgKHVuc2FmZV97Z2V0LHNldH0pIG1heSBiZSB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlbjtcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gIGFzc2VydCAob2xkX3BvcyArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICAoKVxuICAoKiBOb3RlOiB0aGVyZSBhcmUgdmFyaW91cyBzaXR1YXRpb25zIChwcmVlbXB0aXZlIHRocmVhZHMsIHNpZ25hbHMgYW5kXG4gICAgIGdjIGZpbmFsaXplcnMpIHdoZXJlIE9DYW1sIGNvZGUgbWF5IGJlIHJ1biBhc3luY2hyb25vdXNseTsgaW5cbiAgICAgcGFydGljdWxhciwgdGhlcmUgbWF5IGJlIGEgcmFjZSB3aXRoIGFub3RoZXIgdXNlciBvZiBbYl0sIGNoYW5naW5nXG4gICAgIGl0cyBtdXRhYmxlIGZpZWxkcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBbcmVzaXplXSBjYWxsLiBUaGUgQnVmZmVyXG4gICAgIG1vZHVsZSBkb2VzIG5vdCBwcm92aWRlIGFueSBjb3JyZWN0bmVzcyBndWFyYW50ZWUgaWYgdGhhdCBoYXBwZW5zLFxuICAgICBidXQgd2UgbXVzdCBzdGlsbCBlbnN1cmUgdGhhdCB0aGUgZGF0YXN0cnVjdHVyZSBpbnZhcmlhbnRzIGhvbGQgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgLS0gYXMgd2UgcGxhbiB0byB1c2UgW3Vuc2FmZV97Z2V0LHNldH1dLlxuXG4gICAgIFRoZXJlIGFyZSB0d28gcG90ZW50aWFsIGFsbG9jYXRpb24gcG9pbnRzIGluIHRoaXMgZnVuY3Rpb24sXG4gICAgIFtyZWZdIGFuZCBbQnl0ZXMuY3JlYXRlXSwgYnV0IGFsbCByZWFkcyBhbmQgd3JpdGVzIHRvIHRoZSBmaWVsZHNcbiAgICAgb2YgW2JdIGhhcHBlbiBiZWZvcmUgYm90aCBvZiB0aGVtIG9yIGFmdGVyIGJvdGggb2YgdGhlbS5cblxuICAgICBXZSB0aGVyZWZvcmUgYXNzdW1lIHRoYXQgW2IucG9zaXRpb25dIG1heSBjaGFuZ2UgYXQgdGhlc2UgYWxsb2NhdGlvbnMsXG4gICAgIGFuZCBjaGVjayB0aGF0IHRoZSBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIHBvc3Rjb25kaXRpb25cbiAgICAgaG9sZHMgZm9yIGJvdGggdmFsdWVzIG9mIFtiLnBvc2l0aW9uXSwgYmVmb3JlIG9yIGFmdGVyIHRoZSBmdW5jdGlvblxuICAgICBpcyBjYWxsZWQuIE1vcmUgcHJlY2lzZWx5LCB0aGUgZm9sbG93aW5nIGludmFyaWFudHMgbXVzdCBob2xkIGlmIHRoZVxuICAgICBmdW5jdGlvbiByZXR1cm5zIGNvcnJlY3RseSwgaW4gYWRkaXRpb24gdG8gdGhlIHVzdWFsIGJ1ZmZlciBpbnZhcmlhbnRzOlxuICAgICAtIFtvbGQoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW25ldyhiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbb2xkKGIubGVuZ3RoKSA8PSBuZXcoYi5sZW5ndGgpXVxuXG4gICAgIE5vdGU6IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBvbGQoYi5sZW5ndGgpXSBkb2VzICpub3QqXG4gICAgIGhvbGQgaW4gZ2VuZXJhbCwgYXMgaXQgaXMgcHJlY2lzZWx5IHRoZSBjYXNlIHdoZXJlIHlvdSBuZWVkXG4gICAgIHRvIGNhbGwgW3Jlc2l6ZV0gdG8gaW5jcmVhc2UgW2IubGVuZ3RoXS5cblxuICAgICBOb3RlOiBbYXNzZXJ0XSBhYm92ZSBkb2VzIG5vdCBtZWFuIHRoYXQgd2Uga25vdyB0aGUgY29uZGl0aW9uc1xuICAgICBhbHdheXMgaG9sZCwgYnV0IHRoYXQgdGhlIGZ1bmN0aW9uIG1heSByZXR1cm4gY29ycmVjdGx5XG4gICAgIG9ubHkgaWYgdGhleSBob2xkLlxuXG4gICAgIE5vdGU6IHRoZSBvdGhlciBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgZG9lcyBub3QgbmVlZFxuICAgICB0byBiZSBjaGVja2VkIHdpdGggdGhpcyBsZXZlbCBvZiBzY3J1dGlueSwgZ2l2ZW4gdGhhdCB0aGV5XG4gICAgIHJlYWQvd3JpdGUgdGhlIGJ1ZmZlciBpbW1lZGlhdGVseSBhZnRlciBjaGVja2luZyB0aGF0XG4gICAgIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZCBvciBjYWxsaW5nIFtyZXNpemVdLlxuICAqKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbiBsZXQgYWRkX3V0Zl84X3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICBhZGRfY2hhciBiIChDaGFyLnVuc2FmZV9jaHIgdSlcbiB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4QzAgbG9yICh1IGxzciA2KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMyA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMztcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEUwIGxvciAodSBsc3IgMTIpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDNcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhGMCBsb3IgKHUgbHNyIDE4KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMylcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogdGhpcyAocHJpdmF0ZSkgZnVuY3Rpb24gY291bGQgbW92ZSBpbnRvIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG5sZXQgcmVhbGx5X2lucHV0X3VwX3RvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWQgPVxuICAgIGlmIHRvX3JlYWQgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBpbnB1dCBpYyBidWYgb2ZzIHRvX3JlYWQgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBhbHJlYWR5X3JlYWQgPSBhbHJlYWR5X3JlYWQgKyByIGluXG4gICAgICAgIGxldCBvZnMgPSBvZnMgKyByIGluXG4gICAgICAgIGxldCB0b19yZWFkID0gdG9fcmVhZCAtIHIgaW5cbiAgICAgICAgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW4gbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZDowIH5vZnMgfnRvX3JlYWQ6bGVuXG5cblxubGV0IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiA9XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgbGV0IG4gPSByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgKCogVGhlIGFzc2VydGlvbiBiZWxvdyBtYXkgZmFpbCBpbiB3ZWlyZCBzY2VuYXJpbyB3aGVyZVxuICAgICB0aHJlYWRlZC9maW5hbGl6ZXIgY29kZSwgcnVuIGFzeW5jaHJvbm91c2x5IGR1cmluZyB0aGVcbiAgICAgW3JlYWxseV9pbnB1dF91cF90b10gY2FsbCwgcmFjZXMgb24gdGhlIGJ1ZmZlcjsgd2UgZG9uJ3QgZW5zdXJlXG4gICAgIGNvcnJlY3RuZXNzIGluIHRoaXMgY2FzZSwgYnV0IG5lZWQgdG8gcHJlc2VydmUgdGhlIGludmFyaWFudHMgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgKHNlZSBkaXNjdXNzaW9uIG9mIFtyZXNpemVdKS4gKilcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbiA8PSBiLmxlbmd0aCk7XG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IGFkZF9zZXEgYiBzZXEgPSBTZXEuaXRlciAoYWRkX2NoYXIgYikgc2VxXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBiID0gY3JlYXRlIDMyIGluXG4gIGFkZF9zZXEgYiBpO1xuICBiXG5cbigqKiB7NiBCaW5hcnkgZW5jb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMSBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIHVuc2FmZV9zZXRfaW50OCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgdW5zYWZlX3NldF9pbnQxNiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MzJfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgdW5zYWZlX3NldF9pbnQzMiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50NjRfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgODtcbiAgdW5zYWZlX3NldF9pbnQ2NCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbGUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDE2X2JlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMTYgeClcblxubGV0IGFkZF9pbnQzMl9sZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MzJfYmUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAzMiB4KVxuXG5sZXQgYWRkX2ludDY0X2xlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQ2NF9iZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDY0IHgpXG5cbmxldCBhZGRfdWludDggPSBhZGRfaW50OFxubGV0IGFkZF91aW50MTZfbmUgPSBhZGRfaW50MTZfbmVcbmxldCBhZGRfdWludDE2X2xlID0gYWRkX2ludDE2X2xlXG5sZXQgYWRkX3VpbnQxNl9iZSA9IGFkZF9pbnQxNl9iZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IFJlc3RfYWxsIGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBhY2MgPSByZWYgW10gaW5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgQXJyYXkubGVuZ3RoICFhcmd2IC0gMSBkb1xuICAgICAgICAgICAgICBhY2MgOj0gIWFyZ3YuKCFjdXJyZW50ICsgMSkgOjogIWFjYztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgZiAoTGlzdC5yZXYgIWFjYylcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9XG4gICAgICAgICAgICAgIEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuXG4gICAgZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IEludC5tYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChJbnQubWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IEludC5taW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgQEAgZnVuY3Rpb25cbnwgRmluYWxseV9yYWlzZWQgZXhuIC0+IFNvbWUgKFwiRnVuLkZpbmFsbHlfcmFpc2VkOiBcIiBeIFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG58IF8gLT4gTm9uZVxuXG5sZXQgcHJvdGVjdCB+KGZpbmFsbHkgOiB1bml0IC0+IHVuaXQpIHdvcmsgPVxuICBsZXQgZmluYWxseV9ub19leG4gKCkgPVxuICAgIHRyeSBmaW5hbGx5ICgpIHdpdGggZSAtPlxuICAgICAgbGV0IGJ0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIChGaW5hbGx5X3JhaXNlZCBlKSBidFxuICBpblxuICBtYXRjaCB3b3JrICgpIHdpdGhcbiAgfCByZXN1bHQgLT4gZmluYWxseV9ub19leG4gKCkgOyByZXN1bHRcbiAgfCBleGNlcHRpb24gd29ya19leG4gLT5cbiAgICAgIGxldCB3b3JrX2J0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGZpbmFsbHlfbm9fZXhuICgpIDtcbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIHdvcmtfZXhuIHdvcmtfYnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgSmFjcXVlcy1IZW5yaSBKb3VyZGFuLCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUGFyaXMgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYtMjAxNiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlICAgKilcbigqICAgICBldCBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG4gIGZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG11dGFibGUgbWlub3JfaGVhcF9zaXplIDogaW50O1xuICBtdXRhYmxlIG1ham9yX2hlYXBfaW5jcmVtZW50IDogaW50O1xuICBtdXRhYmxlIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHZlcmJvc2UgOiBpbnQ7XG4gIG11dGFibGUgbWF4X292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHN0YWNrX2xpbWl0IDogaW50O1xuICBtdXRhYmxlIGFsbG9jYXRpb25fcG9saWN5IDogaW50O1xuICB3aW5kb3dfc2l6ZSA6IGludDtcbiAgY3VzdG9tX21ham9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9tYXhfc2l6ZSA6IGludDtcbn1cblxuZXh0ZXJuYWwgc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19zdGF0XCJcbmV4dGVybmFsIHF1aWNrX3N0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2NfcXVpY2tfc3RhdFwiXG5leHRlcm5hbCBjb3VudGVycyA6IHVuaXQgLT4gKGZsb2F0ICogZmxvYXQgKiBmbG9hdCkgPSBcImNhbWxfZ2NfY291bnRlcnNcIlxuZXh0ZXJuYWwgbWlub3Jfd29yZHMgOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKVxuICA9IFwiY2FtbF9nY19taW5vcl93b3Jkc1wiIFwiY2FtbF9nY19taW5vcl93b3Jkc191bmJveGVkXCJcbmV4dGVybmFsIGdldCA6IHVuaXQgLT4gY29udHJvbCA9IFwiY2FtbF9nY19nZXRcIlxuZXh0ZXJuYWwgc2V0IDogY29udHJvbCAtPiB1bml0ID0gXCJjYW1sX2djX3NldFwiXG5leHRlcm5hbCBtaW5vciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19taW5vclwiXG5leHRlcm5hbCBtYWpvcl9zbGljZSA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2NfbWFqb3Jfc2xpY2VcIlxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgZnVsbF9tYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19mdWxsX21ham9yXCJcbmV4dGVybmFsIGNvbXBhY3QgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfY29tcGFjdGlvblwiXG5leHRlcm5hbCBnZXRfbWlub3JfZnJlZSA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9taW5vcl9mcmVlXCJcbmV4dGVybmFsIGdldF9idWNrZXQgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9idWNrZXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZ2V0X2NyZWRpdCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9jcmVkaXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHVnZV9mYWxsYmFja19jb3VudCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcGF1c2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcGF1c2VcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcmVzdW1lIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3Jlc3VtZVwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcImNvbXBhY3Rpb25zOiAgICAgICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcImZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5mb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcblxubW9kdWxlIE1lbXByb2YgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGFsbG9jYXRpb25fc291cmNlID0gTm9ybWFsIHwgTWFyc2hhbCB8IEN1c3RvbVxuICAgIHR5cGUgYWxsb2NhdGlvbiA9XG4gICAgICB7IG5fc2FtcGxlcyA6IGludDtcbiAgICAgICAgc2l6ZSA6IGludDtcbiAgICAgICAgc291cmNlIDogYWxsb2NhdGlvbl9zb3VyY2U7XG4gICAgICAgIGNhbGxzdGFjayA6IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgfVxuXG4gICAgdHlwZSAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vcjogYWxsb2NhdGlvbiAtPiAnbWlub3Igb3B0aW9uO1xuICAgICAgYWxsb2NfbWFqb3I6IGFsbG9jYXRpb24gLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIHByb21vdGU6ICdtaW5vciAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgZGVhbGxvY19taW5vcjogJ21pbm9yIC0+IHVuaXQ7XG4gICAgICBkZWFsbG9jX21ham9yOiAnbWFqb3IgLT4gdW5pdDtcbiAgICB9XG5cbiAgICBsZXQgbnVsbF90cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBhbGxvY19tYWpvciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIHByb21vdGUgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBkZWFsbG9jX21pbm9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICAgIGRlYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgIH1cblxuICAgIGV4dGVybmFsIGNfc3RhcnQgOlxuICAgICAgZmxvYXQgLT4gaW50IC0+ICgnbWlub3IsICdtYWpvcikgdHJhY2tlciAtPiB1bml0XG4gICAgICA9IFwiY2FtbF9tZW1wcm9mX3N0YXJ0XCJcblxuICAgIGxldCBzdGFydFxuICAgICAgfnNhbXBsaW5nX3JhdGVcbiAgICAgID8oY2FsbHN0YWNrX3NpemUgPSBtYXhfaW50KVxuICAgICAgdHJhY2tlciA9XG4gICAgICBjX3N0YXJ0IHNhbXBsaW5nX3JhdGUgY2FsbHN0YWNrX3NpemUgdHJhY2tlclxuXG4gICAgZXh0ZXJuYWwgc3RvcCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9tZW1wcm9mX3N0b3BcIlxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG5sZXQgcmVidWlsZCA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZylcbiAgICBlbHNlIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5zZWVkXG4gICAgZWxzZSAwIGluXG4gIGxldCBoJyA9IHtcbiAgICBzaXplID0gaC5zaXplO1xuICAgIGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHk7XG4gICAgc2VlZCA9IHNlZWQ7XG4gICAgaW5pdGlhbF9zaXplID0gaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLmluaXRpYWxfc2l6ZSBlbHNlIHNcbiAgfSBpblxuICBpbnNlcnRfYWxsX2J1Y2tldHMgKGtleV9pbmRleCBoJykgZmFsc2UgaC5kYXRhIGgnLmRhdGE7XG4gIGgnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IEludC5taW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIEludC5taW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG5sZXQgaWQgeCA9IHhcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbm1vZHVsZSBTaXplIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaXNfa25vd24gOiB0IC0+IGJvb2xcbmVuZCAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHRvX2ludCA9IGlkXG4gIGxldCBvZl9pbnQgPSBpZFxuICBsZXQgemVybyA9IDBcbiAgbGV0IHVua25vd24gPSAtMVxuICBsZXQgaXNfa25vd24gbiA9IG4gPj0gMFxuZW5kXG5cblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiB7ICAgICAgICAgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICAgICAgZml0czogc3RyaW5nICogaW50ICogc3RyaW5nOyAgICgqIGxpbmUgaXMgbm90IHNwbGl0ICopXG4gICAgICBicmVha3M6IHN0cmluZyAqIGludCAqIHN0cmluZzsgKCogbGluZSBpcyBzcGxpdCAqKVxuICAgIH1cbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHN0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCBzdGFnID0gLi5cblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxudHlwZSB0YWcgPSBzdHJpbmdcbnR5cGUgc3RhZyArPSBTdHJpbmdfdGFnIG9mIHRhZ1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIHNpemUgOiBTaXplLnQ7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIFF1ZXVlLnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0ge1xuICBsZWZ0X3RvdGFsIDogaW50OyAoKiBWYWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGVucXVldWVkLiAqKVxuICBxdWV1ZV9lbGVtIDogcHBfcXVldWVfZWxlbVxufVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSB7IGJveF90eXBlIDogYm94X3R5cGU7IHdpZHRoIDogaW50IH1cblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG4gIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX2VsZW0gU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2suICopXG4gIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9lbGVtIFN0YWNrLnQ7XG4gIHBwX3Rib3hfc3RhY2sgOiB0Ym94IFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrLiAqKVxuICBwcF90YWdfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gIHBwX21hcmtfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fc3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyB0b2tlbi5sZW5ndGg7XG4gIFF1ZXVlLmFkZCB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgUXVldWUuY2xlYXIgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogRm9ybWF0IGEgdGV4dHVhbCB0b2tlbiAqKVxubGV0IGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgdGV4dCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgdGV4dDtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuKCogRm9ybWF0IGEgc3RyaW5nIGJ5IGl0cyBsZW5ndGgsIGlmIG5vdCBlbXB0eSAqKVxubGV0IGZvcm1hdF9zdHJpbmcgc3RhdGUgcyA9XG4gIGlmIHMgPD4gXCJcIiB0aGVuIGZvcm1hdF9wcF90ZXh0IHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIChiZWZvcmUsIG9mZnNldCwgYWZ0ZXIpIHdpZHRoID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBJbnQubWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbmxldCBwcF9wcmludF9ieXRlcyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKEJ5dGVzLmxlbmd0aCBzKSAoQnl0ZXMudG9fc3RyaW5nIHMpXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgSW50Lm1heCAoSW50Lm1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2J5dGVzID0gcHBfcHJpbnRfYnl0ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHVwZGF0ZV9nZW9tZXRyeSA9IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHJlYyBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG5sZXQgcHBfcHJpbnRfZWl0aGVyIH5sZWZ0IH5yaWdodCBwcGYgPSBmdW5jdGlvblxufCBFaXRoZXIuTGVmdCBsIC0+IGxlZnQgcHBmIGxcbnwgRWl0aGVyLlJpZ2h0IHIgLT4gcmlnaHQgcHBmIHJcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFN0ZGxpYiBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBTdGRsaWIuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtTdGRsaWIuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBTdGRsaWIuc3RkaW4pKSBTdGRsaWIuc3RkaW5cblxuXG4gIGxldCBzdGRpYiA9IHN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuXG4gICgqXG4gICAgIE9ic29sZXRlOiBhIG1lbW8gW2Zyb21fY2hhbm5lbF0gdmVyc2lvbiB0byBidWlsZCBhIFtTY2FubmluZy5pbl9jaGFubmVsXVxuICAgICBzY2FubmluZyBidWZmZXIgb3V0IG9mIGEgW1N0ZGxpYi5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtTdGRsaWIuaW5fY2hhbm5lbF0gaW5wdXQgY2hhbm5lbFxuICAgICBbaWNdLCBzaW1wbHkgZGVmaW5lIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIGZvcm1hdHRlZCBpbnB1dCBjaGFubmVsIGFzIGluXG4gICAgIFtsZXQgaWIgPSBTY2FubmluZy5mcm9tX2NoYW5uZWwgaWNdLCB0aGVuIHVzZSBbU2NhbmYuYnNjYW5mIGliXSBhcyB1c3VhbC5cbiAgKilcbiAgbGV0IG1lbW9fZnJvbV9pYyA9XG4gICAgbGV0IG1lbW8gPSByZWYgW10gaW5cbiAgICAoZnVuIHNjYW5fY2xvc2VfaWMgaWMgLT5cbiAgICAgdHJ5IExpc3QuYXNzcSBpYyAhbWVtbyB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGliID1cbiAgICAgICAgIGZyb21faWMgc2Nhbl9jbG9zZV9pYyAoRnJvbV9jaGFubmVsIGljKSBpYyBpblxuICAgICAgIG1lbW8gOj0gKGljLCBpYikgOjogIW1lbW87XG4gICAgICAgaWIpXG5cblxuICAoKiBPYnNvbGV0ZTogc2VlIHshbWVtb19mcm9tX2ljfSBhYm92ZS4gKilcbiAgbGV0IG1lbW9fZnJvbV9jaGFubmVsID0gbWVtb19mcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBTdGRsaWIuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHNoYXBlID1cbiAgfCBGdW5jdGlvblxuICB8IExhenlcbiAgfCBDbGFzc1xuICB8IE1vZHVsZSBvZiBzaGFwZSBhcnJheVxuICB8IFZhbHVlIG9mIE9iai50XG5cbmxldCByZWMgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBzaGFwZSA9XG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgfCBGdW5jdGlvbiAtPlxuICAgICAgIGxldCByZWMgZm4gKHggOiAnYSkgPVxuICAgICAgICAgbGV0IGZuJyA6ICdhIC0+ICdiID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgIGlmIGZuID09IGZuJyB0aGVuXG4gICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGZuJyB4IGluXG4gICAgICAgT2JqLnJlcHIgZm5cbiAgICB8IExhenkgLT5cbiAgICAgICBsZXQgcmVjIGwgPVxuICAgICAgICAgbGF6eSAoXG4gICAgICAgICAgIGxldCBsJyA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICAgIGlmIGwgPT0gbCcgdGhlblxuICAgICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICBMYXp5LmZvcmNlIGwnKSBpblxuICAgICAgIE9iai5yZXByIGxcbiAgICB8IENsYXNzIC0+XG4gICAgICAgT2JqLnJlcHIgKENhbWxpbnRlcm5hbE9PLmR1bW15X2NsYXNzIGxvYylcbiAgICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gICAgfCBWYWx1ZSB2IC0+IHZcbiAgaW5cbiAgT2JqLnNldF9maWVsZCBtb2R1IGkgaW5pdFxuXG5hbmQgaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzID1cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCBjb21wcyBpblxuICBsZXQgbW9kdSA9IE9iai5uZXdfYmxvY2sgMCBsZW5ndGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIGNvbXBzLihpKVxuICBkb25lO1xuICBtb2R1XG5cbmxldCBpbml0X21vZCBsb2Mgc2hhcGUgPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC5pbml0X21vZDogbm90IGEgbW9kdWxlXCJcblxubGV0IHJlYyB1cGRhdGVfbW9kX2ZpZWxkIG1vZHUgaSBzaGFwZSBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IEZ1bmN0aW9uIHwgTGF6eSAtPlxuICAgICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBuXG4gIHwgVmFsdWUgXyAtPlxuICAgICAoKSAoKiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB0aGVyZSAqKVxuICB8IENsYXNzIC0+XG4gICAgIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID0gNCk7XG4gICAgIGxldCBjbCA9IE9iai5maWVsZCBtb2R1IGkgaW5cbiAgICAgZm9yIGogPSAwIHRvIDMgZG9cbiAgICAgICBPYmouc2V0X2ZpZWxkIGNsIGogKE9iai5maWVsZCBuIGopXG4gICAgIGRvbmVcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyAoT2JqLmZpZWxkIG1vZHUgaSkgblxuXG5hbmQgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG4gPVxuICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA+PSBBcnJheS5sZW5ndGggY29tcHMpO1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNvbXBzIC0gMSBkb1xuICAgIHVwZGF0ZV9tb2RfZmllbGQgbyBpIGNvbXBzLihpKSAoT2JqLmZpZWxkIG4gaSlcbiAgZG9uZVxuXG5sZXQgdXBkYXRlX21vZCBzaGFwZSBvIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC51cGRhdGVfbW9kOiBub3QgYSBtb2R1bGVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNlZWRlZFNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhXG4gICAgICBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIG1hdGNoIEFycmF5Lmxlbmd0aCBkaW1zLCBsYXlvdXQgd2l0aFxuICAgIHwgMCwgXyAtPiBhcnJcbiAgICB8IGRsZW4sIENfbGF5b3V0IC0+IGNsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDApIGYgMCBkaW1zOyBhcnJcbiAgICB8IGRsZW4sIEZvcnRyYW5fbGF5b3V0IC0+IGZsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDEpIGYgKHByZWQgZGxlbikgZGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclxuXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG4gIGxldCBpbml0ID0gb2ZfdmFsdWVcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAxIHRvIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbSBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICBmb3IgayA9IDAgdG8gcHJlZCBkaW0zIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBrID0gMSB0byBkaW0zIGRvXG4gICAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsbnVsbCxudWxsLCJtb2R1bGUgTWFrZUluZml4IChCIDogVWludHNfaW50Zi5CYXNpY3MpIDogVWludHNfaW50Zi5JbmZpeCB3aXRoIHR5cGUgdCA6PSBCLnQgPSBzdHJ1Y3RcbiAgb3BlbiBCXG4gIGxldCAoICsgKSA9IGFkZFxuICBsZXQgKCAtICkgPSBzdWJcbiAgbGV0ICggKiApID0gbXVsXG4gIGxldCAoIC8gKSA9IGRpdlxuICBsZXQgKCA9ICkgPSBlcXVhbFxuICBsZXQgKCA8PiApID0gKGZ1biBhIGIgLT4gbm90IChlcXVhbCBhIGIpKVxuICBsZXQgKCA8PSApID0gbGVcbiAgbGV0ICggbW9kICkgPSByZW1cbiAgbGV0ICggbGFuZCApID0gbG9nYW5kXG4gIGxldCAoIGxvciApID0gbG9nb3JcbiAgbGV0ICggbHhvciApID0gbG9neG9yXG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0XG5lbmRcblxubW9kdWxlIFVpbnQ4ID0gc3RydWN0XG4gIG1vZHVsZSBCID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50XG5cbiAgICBsZXQgbWF4X2ludCA9IDB4RkZcbiAgICBsZXQgemVybyA9IDBcbiAgICBsZXQgb25lID0gMVxuXG4gICAgKCogVG9EbzogQmVuY2ggbWFyayB3aXRoIHBvbHltb3JwaGljIGNvbXBhcmUqKVxuICAgIGxldCBjb21wYXJlID0gSW50LmNvbXBhcmVcbiAgICBsZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG4gICAgbGV0IGxlIHggeSA9ICh4IDw9IHkpXG4gICAgbGV0IGFkZCB4IHkgPSAoeCArIHkpIGxhbmQgbWF4X2ludFxuICAgIGxldCBzdWIgeCB5ID0gKHggLSB5KSBsYW5kIG1heF9pbnRcbiAgICBsZXQgbXVsIHggeSA9ICh4ICogeSkgbGFuZCBtYXhfaW50XG4gICAgbGV0IGRpdiB4IHkgPSAoeCAvIHkpIGxhbmQgbWF4X2ludFxuICAgIGxldCByZW0geCB5ID0gKHggbW9kIHkpIGxhbmQgbWF4X2ludFxuICAgIGxldCBzdWNjIHggPSBhZGQgeCBvbmVcbiAgICBsZXQgcHJlZCB4ID0gc3ViIHggb25lXG4gICAgbGV0IGxvZ2FuZCB4IHkgPSAoeCBsYW5kIHkpXG4gICAgbGV0IGxvZ29yIHggeSA9ICh4IGxvciB5KVxuICAgIGxldCBsb2d4b3IgPSAobHhvcilcbiAgICBsZXQgc2hpZnRfbGVmdCB4IHkgPSAoeCBsc2wgeSkgbGFuZCBtYXhfaW50XG4gICAgbGV0IHNoaWZ0X3JpZ2h0ID0gKGxzcilcbiAgICBsZXQgb2ZfaW50IHggPSB4IGxhbmQgbWF4X2ludFxuICAgIGxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xuICAgIGxldCB0b19jaGFyIHQgPSBDaGFyLnVuc2FmZV9jaHIgdFxuICAgIGV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG4gICAgbGV0IHNob3cgPSBQcmludGYuc3ByaW50ZiBcIiQlMDJYXCJcbiAgZW5kXG4gIGluY2x1ZGUgQlxuXG4gIG1vZHVsZSBJbmZpeCA9IE1ha2VJbmZpeChCKVxuICBpbmNsdWRlIEluZml4XG5lbmRcblxubW9kdWxlIFVpbnQxNiA9IHN0cnVjdFxuICBtb2R1bGUgQiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludFxuXG4gICAgbGV0IG1heF9pbnQgPSAweEZGRkZcbiAgICBsZXQgemVybyA9IDBcbiAgICBsZXQgb25lID0gMVxuXG4gICAgbGV0IGNvbXBhcmUgPSBJbnQuY29tcGFyZVxuICAgIGxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcbiAgICBsZXQgbGUgeCB5ID0gKHggPD0geSlcbiAgICBsZXQgYWRkIHggeSA9ICh4ICsgeSkgbGFuZCBtYXhfaW50XG4gICAgbGV0IHN1YiB4IHkgPSAoeCAtIHkpIGxhbmQgbWF4X2ludFxuICAgIGxldCBtdWwgeCB5ID0gKHggKiB5KSBsYW5kIG1heF9pbnRcbiAgICBsZXQgZGl2IHggeSA9ICh4IC8geSkgbGFuZCBtYXhfaW50XG4gICAgbGV0IHJlbSB4IHkgPSAoeCBtb2QgeSkgbGFuZCBtYXhfaW50XG4gICAgbGV0IHN1Y2MgeCA9IGFkZCB4IG9uZVxuICAgIGxldCBwcmVkIHggPSBzdWIgeCBvbmVcbiAgICBsZXQgbG9nYW5kIHggeSA9ICh4IGxhbmQgeSlcbiAgICBsZXQgbG9nb3IgeCB5ID0gKHggbG9yIHkpXG4gICAgbGV0IGxvZ3hvciA9IChseG9yKVxuICAgIGxldCBzaGlmdF9sZWZ0IHggeSA9ICh4IGxzbCB5KSBsYW5kIG1heF9pbnRcbiAgICBsZXQgc2hpZnRfcmlnaHQgPSAobHNyKVxuICAgIGxldCBvZl9pbnQgeCA9IHggbGFuZCBtYXhfaW50XG4gICAgZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbiAgICBsZXQgc2hvdyA9IFByaW50Zi5zcHJpbnRmIFwiJCUwNFhcIlxuICBlbmRcbiAgaW5jbHVkZSBCXG5cbiAgbW9kdWxlIEluZml4ID0gTWFrZUluZml4KEIpXG4gIGluY2x1ZGUgSW5maXhcblxuICBsZXQgb2ZfdWludDggeCA9IHggfD4gVWludDgudG9faW50IHw+IG9mX2ludFxuICBsZXQgdG9fdWludDggeCA9IHggfD4gdG9faW50IHw+IFVpbnQ4Lm9mX2ludFxuZW5kXG5cbm1vZHVsZSBJbnQ4ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuICBsZXQgb2ZfYnl0ZSBiID0gYlxuICBsZXQgb2ZfaW50IHggPVxuICAgIGlmIHggPCAwIHRoZW5cbiAgICAgICh4IGxhbmQgMHhGRikgbG9yIDBiMTAwMDAwMDBcbiAgICBlbHNlXG4gICAgICAoeCBsYW5kIDB4RkYpXG4gIGxldCBpc19uZWcgdCA9IHQgbGFuZCAoMSBsc2wgNykgPD4gMFxuICBsZXQgYWJzIHQgPVxuICAgIGlmIGlzX25lZyB0IHRoZW5cbiAgICAgICh0IC0gMSkgbHhvciAwYjExMTExMTExXG4gICAgZWxzZVxuICAgICAgdFxuICBsZXQgdG9faW50IHQgPVxuICAgIGlmIGlzX25lZyB0IHRoZW5cbiAgICAgIC0oYWJzIHQpXG4gICAgZWxzZVxuICAgICAgdFxuICBsZXQgc2hvdyB0ID1cbiAgICBpZiB0IGxhbmQgKDEgbHNsIDcpIDw+IDAgdGhlblxuICAgICAgUHJpbnRmLnNwcmludGYgXCItJWRcIiAoSW50LmFicyBAQCB0IC0gMHgxMDApXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIlZFwiIHRcbmVuZFxuXG50eXBlIHVpbnQ4ID0gVWludDgudFxuXG50eXBlIHVpbnQxNiA9IFVpbnQxNi50XG5cbnR5cGUgaW50OCA9IEludDgudFxuIiwib3BlbiBVaW50c1xuXG50eXBlIHQgPSB7XG4gIG11dGFibGUgaWU6IHN0YXRlO1xuICBtdXRhYmxlIGlmXyA6IHN0YXRlO1xufVxuXG5hbmQgc3RhdGUgPSB7XG4gIGFkZHIgOiB1aW50MTY7XG4gIHZibGFuayA6IGJvb2w7XG4gIGxjZF9zdGF0IDogYm9vbDtcbiAgdGltZXIgOiBib29sO1xuICBzZXJpYWxfcG9ydCA6IGJvb2w7XG4gIGpveXBhZCA6IGJvb2w7XG59XG5cbnR5cGUgdHlwZV8gPVxuICB8IFZCbGFua1xuICB8IExDRF9zdGF0XG4gIHwgVGltZXJcbiAgfCBTZXJpYWxfcG9ydFxuICB8IEpveXBhZFxuXG5sZXQgc2hvd190eXBlXyA9IGZ1bmN0aW9uXG4gIHwgVkJsYW5rICAgICAgLT4gXCJWQmxhbmtcIlxuICB8IExDRF9zdGF0ICAgIC0+IFwiTENEX3N0YXRcIlxuICB8IFRpbWVyICAgICAgIC0+IFwiVGltZXJcIlxuICB8IFNlcmlhbF9wb3J0IC0+IFwiU2VyaWFsX3BvcnRcIlxuICB8IEpveXBhZCAgICAgIC0+IFwiSm95cGFkXCJcblxubGV0IHNob3cgdCA9XG4gIGxldCBvcGVuIEJvb2wgaW5cbiAgUHJpbnRmLnNwcmludGZcbiAgICBcImllOih2Ymxhbms6JWQsIGxjZF9zdGF0OiVkLCB0aW1lcjolZCwgc2VyaWFsX3BvcnQ6JWQsIGpveXBhZDolZCksIFxcXG4gICAgIGlmOih2Ymxhbms6JWQsIGxjZF9zdGF0OiVkLCB0aW1lcjolZCwgc2VyaWFsX3BvcnQ6JWQsIGpveXBhZDolZClcIlxuICAgICh0b19pbnQgdC5pZS52YmxhbmspICh0b19pbnQgdC5pZS5sY2Rfc3RhdClcbiAgICAodG9faW50IHQuaWUudGltZXIpICh0b19pbnQgdC5pZS5zZXJpYWxfcG9ydCkgKHRvX2ludCB0LmllLmpveXBhZClcbiAgICAodG9faW50IHQuaWZfLnZibGFuaykgKHRvX2ludCB0LmlmXy5sY2Rfc3RhdClcbiAgICAodG9faW50IHQuaWZfLnRpbWVyKSAodG9faW50IHQuaWZfLnNlcmlhbF9wb3J0KSAodG9faW50IHQuaWZfLmpveXBhZClcblxubGV0IGNyZWF0ZSB+aWVfYWRkciB+aWZfYWRkciA9IHtcbiAgaWUgID0ge2FkZHIgPSBpZV9hZGRyOyB2YmxhbmsgPSBmYWxzZTsgbGNkX3N0YXQgPSBmYWxzZTsgdGltZXIgPSBmYWxzZTsgc2VyaWFsX3BvcnQgPSBmYWxzZTsgam95cGFkID0gZmFsc2V9O1xuICBpZl8gPSB7YWRkciA9IGlmX2FkZHI7IHZibGFuayA9IGZhbHNlOyBsY2Rfc3RhdCA9IGZhbHNlOyB0aW1lciA9IGZhbHNlOyBzZXJpYWxfcG9ydCA9IGZhbHNlOyBqb3lwYWQgPSBmYWxzZX07XG59XG5cbmxldCB1cGRhdGUgc3RhdGUgdHlwZV8gYiA9XG4gIG1hdGNoIHR5cGVfIHdpdGhcbiAgfCBWQmxhbmsgICAgICAtPiB7c3RhdGUgd2l0aCB2YmxhbmsgPSBifVxuICB8IExDRF9zdGF0ICAgIC0+IHtzdGF0ZSB3aXRoIGxjZF9zdGF0ID0gYn1cbiAgfCBUaW1lciAgICAgICAtPiB7c3RhdGUgd2l0aCB0aW1lciA9IGJ9XG4gIHwgU2VyaWFsX3BvcnQgLT4ge3N0YXRlIHdpdGggc2VyaWFsX3BvcnQgPSBifVxuICB8IEpveXBhZCAgICAgIC0+IHtzdGF0ZSB3aXRoIGpveXBhZCA9IGJ9XG5cblxubGV0IHJlcXVlc3QgdCB0eXBlXyA9IHQuaWZfIDwtIHVwZGF0ZSB0LmlmXyB0eXBlXyB0cnVlXG5cbmxldCBjbGVhciB0IHR5cGVfID0gdC5pZl8gPC0gdXBkYXRlIHQuaWZfIHR5cGVfIGZhbHNlXG5cbmxldCBjbGVhcl9hbGwgdCA9XG4gIFtWQmxhbms7IExDRF9zdGF0OyBUaW1lcjsgU2VyaWFsX3BvcnQ7IEpveXBhZF1cbiAgfD4gTGlzdC5pdGVyIChmdW4gdHlwZV8gLT4gY2xlYXIgdCB0eXBlXylcblxubGV0IG5leHQgdCA9XG4gIGlmIHQuaWUudmJsYW5rICYmIHQuaWZfLnZibGFuayB0aGVuXG4gICAgU29tZSBWQmxhbmtcbiAgZWxzZSBpZiB0LmllLmxjZF9zdGF0ICYmIHQuaWZfLmxjZF9zdGF0IHRoZW5cbiAgICBTb21lIExDRF9zdGF0XG4gIGVsc2UgaWYgdC5pZS50aW1lciAmJiB0LmlmXy50aW1lciB0aGVuXG4gICAgU29tZSBUaW1lclxuICBlbHNlIGlmIHQuaWUuc2VyaWFsX3BvcnQgJiYgdC5pZl8uc2VyaWFsX3BvcnQgdGhlblxuICAgIFNvbWUgU2VyaWFsX3BvcnRcbiAgZWxzZSBpZiB0LmllLmpveXBhZCAmJiB0LmlmXy5qb3lwYWQgdGhlblxuICAgIFNvbWUgSm95cGFkXG4gIGVsc2VcbiAgICBOb25lXG5cbmxldCBhY2NlcHRzIHQgYWRkciA9IFVpbnQxNi4odC5pZS5hZGRyID0gYWRkciB8fCB0LmlmXy5hZGRyID0gYWRkcilcblxubGV0IGJ5dGVfb2Zfc3RhdGUgcyA9XG4gIChpZiBzLnZibGFuayB0aGVuIDBiMDAwMDEgZWxzZSAwKVxuICBsb3IgKGlmIHMubGNkX3N0YXQgICAgdGhlbiAwYjAwMDEwIGVsc2UgMClcbiAgbG9yIChpZiBzLnRpbWVyICAgICAgIHRoZW4gMGIwMDEwMCBlbHNlIDApXG4gIGxvciAoaWYgcy5zZXJpYWxfcG9ydCB0aGVuIDBiMDEwMDAgZWxzZSAwKVxuICBsb3IgKGlmIHMuam95cGFkICAgICAgdGhlbiAwYjEwMDAwIGVsc2UgMClcbiAgfD4gVWludDgub2ZfaW50XG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgaWYgVWludDE2LihhZGRyID0gdC5pZS5hZGRyKSB0aGVuXG4gICAgYnl0ZV9vZl9zdGF0ZSB0LmllXG4gIGVsc2UgaWYgVWludDE2LihhZGRyID0gdC5pZl8uYWRkcikgdGhlblxuICAgICgqIHVudXNlZCBiaXRzIGFsd2F5cyByZXR1cm4gMSAqKVxuICAgIFVpbnQ4LihvZl9pbnQgMGIxMTEwMDAwMCBsb3IgYnl0ZV9vZl9zdGF0ZSB0LmlmXylcbiAgZWxzZVxuICAgIGFzc2VydCBmYWxzZVxuXG5sZXQgc3RhdGVfb2ZfYnl0ZSBiIGFkZHIgPVxuICBsZXQgYm9vbHNfb2ZfYnl0ZSAobiA6IHVpbnQ4KSA6IGJvb2wgKiBib29sICogYm9vbCAqIGJvb2wgKiBib29sID1cbiAgICBsZXQgb3BlbiBVaW50OCBpblxuICAgIChcbiAgICAgIG4gbGFuZCBvZl9pbnQgMGIxMDAwMCA8PiBvZl9pbnQgMCxcbiAgICAgIG4gbGFuZCBvZl9pbnQgMGIwMTAwMCA8PiBvZl9pbnQgMCxcbiAgICAgIG4gbGFuZCBvZl9pbnQgMGIwMDEwMCA8PiBvZl9pbnQgMCxcbiAgICAgIG4gbGFuZCBvZl9pbnQgMGIwMDAxMCA8PiBvZl9pbnQgMCxcbiAgICAgIG4gbGFuZCBvZl9pbnQgMGIwMDAwMSA8PiBvZl9pbnQgMFxuICAgIClcbiAgaW5cbiAgbGV0IChiNCwgYjMsIGIyLCBiMSwgYjApID0gYm9vbHNfb2ZfYnl0ZSBiIGluXG4gIHtcbiAgICBhZGRyO1xuICAgIHZibGFuayA9IGIwO1xuICAgIGxjZF9zdGF0ID0gYjE7XG4gICAgdGltZXIgPSBiMjtcbiAgICBzZXJpYWxfcG9ydCA9IGIzO1xuICAgIGpveXBhZCA9IGI0O1xuICB9XG5cbmxldCB3cml0ZV9ieXRlIHQgfmFkZHIgfmRhdGEgPVxuICBpZiBhZGRyID0gdC5pZS5hZGRyIHRoZW4gYmVnaW5cbiAgICB0LmllIDwtIHN0YXRlX29mX2J5dGUgZGF0YSB0LmllLmFkZHJcbiAgZW5kXG4gIGVsc2UgaWYgYWRkciA9IHQuaWZfLmFkZHIgdGhlbiBiZWdpblxuICAgIHQuaWZfIDwtIHN0YXRlX29mX2J5dGUgZGF0YSB0LmlmXy5hZGRyXG4gIGVuZCBlbHNlXG4gICAgYXNzZXJ0IGZhbHNlXG4iLCIoKiBSZWY6IGh0dHBzOi8vaGFja3RpeG1lLmdhL0dCRURHL3RpbWVycy8gKilcbm9wZW4gVWludHNcblxudHlwZSBmcmVxdWVuY3kgPVxuICB8IEZfNDA5Nkh6XG4gIHwgRl8yNjIxNDRIelxuICB8IEZfNjU1MzZIelxuICB8IEZfMTYzODRIelxuXG50eXBlIHQgPSB7XG4gIGRpdl9hZGRyICA6IHVpbnQxNjtcbiAgdGltYV9hZGRyIDogdWludDE2O1xuICB0bWFfYWRkciAgOiB1aW50MTY7XG4gIHRhY19hZGRyICA6IHVpbnQxNjtcbiAgaWMgICAgICAgIDogSW50ZXJydXB0X2NvbnRyb2xsZXIudDtcbiAgbXV0YWJsZSBpbnRlcm5hbF9tY3ljbGVfY291bnQgOiBpbnQ7XG4gIG11dGFibGUgZGl2X2NvdW50ZXIgICAgICAgICAgIDogaW50O1xuICBtdXRhYmxlIHRpbWFfZW5hYmxlZCAgICAgICAgICA6IGJvb2w7XG4gIG11dGFibGUgdGltYV9mcmVxdWVuY3kgICAgICAgIDogZnJlcXVlbmN5O1xuICBtdXRhYmxlIHRpbWFfdG1hICAgICAgICAgICAgICA6IGludDtcbiAgbXV0YWJsZSB0aW1hX2NvdW50ZXIgICAgICAgICAgOiBpbnQ7XG59XG5cbmxldCBjcmVhdGUgfmRpdl9hZGRyIH50aW1hX2FkZHIgfnRtYV9hZGRyIH50YWNfYWRkciB+aWMgPSB7XG4gIGRpdl9hZGRyO1xuICB0aW1hX2FkZHI7XG4gIHRtYV9hZGRyO1xuICB0YWNfYWRkcjtcbiAgaWM7XG4gIGludGVybmFsX21jeWNsZV9jb3VudCA9IDA7XG4gIGRpdl9jb3VudGVyICAgICAgICAgICA9IDA7XG4gIHRpbWFfZW5hYmxlZCAgICAgICAgICA9IGZhbHNlO1xuICB0aW1hX2ZyZXF1ZW5jeSAgICAgICAgPSBGXzQwOTZIejtcbiAgdGltYV9jb3VudGVyICAgICAgICAgID0gMDtcbiAgdGltYV90bWEgICAgICAgICAgICAgID0gMDtcbn1cblxubGV0IHJ1biB0IH5tY3ljbGVzID1cbiAgbGV0IGJlZm9yZV9tY3ljbGVfY291bnQgPSB0LmludGVybmFsX21jeWNsZV9jb3VudCBpblxuICBsZXQgYWZ0ZXJfbWN5Y2xlX2NvdW50ID0gYmVmb3JlX21jeWNsZV9jb3VudCArIG1jeWNsZXMgaW5cbiAgdC5pbnRlcm5hbF9tY3ljbGVfY291bnQgPC0gYWZ0ZXJfbWN5Y2xlX2NvdW50IG1vZCAweDEwMDAwO1xuICBsZXQgcXVvdGllbnRfZGlmZiA9IChhZnRlcl9tY3ljbGVfY291bnQgLyA2NCAtIGJlZm9yZV9tY3ljbGVfY291bnQgLyA2NCkgaW5cbiAgdC5kaXZfY291bnRlciA8LSAodC5kaXZfY291bnRlciArIHF1b3RpZW50X2RpZmYpIG1vZCAweDEwMDtcbiAgaWYgdC50aW1hX2VuYWJsZWQgdGhlbiBiZWdpblxuICAgIGxldCBkaXZpZGVyID0gbWF0Y2ggdC50aW1hX2ZyZXF1ZW5jeSB3aXRoXG4gICAgICB8IEZfNDA5Nkh6ICAgLT4gMjU2XG4gICAgICB8IEZfMjYyMTQ0SHogLT4gNFxuICAgICAgfCBGXzY1NTM2SHogIC0+IDE2XG4gICAgICB8IEZfMTYzODRIeiAgLT4gNjRcbiAgICBpblxuICAgIGxldCBxdW90aWVudF9kaWZmID0gKGFmdGVyX21jeWNsZV9jb3VudCAvIGRpdmlkZXIgLSBiZWZvcmVfbWN5Y2xlX2NvdW50IC8gZGl2aWRlcikgaW5cbiAgICBsZXQgYmVmb3JlX3RpbWFfY291bnRlciA9IHQudGltYV9jb3VudGVyIGluXG4gICAgdC50aW1hX2NvdW50ZXIgPC0gKHQudGltYV9jb3VudGVyICsgcXVvdGllbnRfZGlmZikgbW9kIDB4MTAwO1xuICAgIGxldCBhZnRlcl90aW1hX2NvdW50ZXIgPSB0LnRpbWFfY291bnRlciBpblxuICAgIGlmIChhZnRlcl90aW1hX2NvdW50ZXIgPCBiZWZvcmVfdGltYV9jb3VudGVyKSB0aGVuIGJlZ2luXG4gICAgICBJbnRlcnJ1cHRfY29udHJvbGxlci5yZXF1ZXN0IHQuaWMgVGltZXI7XG4gICAgICB0LnRpbWFfY291bnRlciA8LSB0LnRpbWFfdG1hO1xuICAgIGVuZFxuICBlbmRcbjs7XG5cbmxldCBhY2NlcHRzIHQgYWRkciA9XG4gIGFkZHIgPSB0LmRpdl9hZGRyIHx8IGFkZHIgPSB0LnRpbWFfYWRkciB8fCBhZGRyID0gdC50bWFfYWRkciB8fCBhZGRyID0gdC50YWNfYWRkclxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGxldCBieXRlX29mX2ZyZXF1ZW5jeSA9IGZ1bmN0aW9uXG4gICAgfCBGXzQwOTZIeiAgIC0+IFVpbnQ4Lm9mX2ludCAwYjAwXG4gICAgfCBGXzI2MjE0NEh6IC0+IFVpbnQ4Lm9mX2ludCAwYjAxXG4gICAgfCBGXzY1NTM2SHogIC0+IFVpbnQ4Lm9mX2ludCAwYjEwXG4gICAgfCBGXzE2Mzg0SHogIC0+IFVpbnQ4Lm9mX2ludCAwYjExXG4gIGluXG4gIG1hdGNoIGFkZHIgd2l0aFxuICB8IF8gd2hlbiBhZGRyID0gdC5kaXZfYWRkciAtPlxuICAgIHQuZGl2X2NvdW50ZXIgfD4gVWludDgub2ZfaW50XG4gIHwgXyB3aGVuIGFkZHIgPSB0LnRpbWFfYWRkciAtPlxuICAgIHQudGltYV9jb3VudGVyIHw+IFVpbnQ4Lm9mX2ludFxuICB8IF8gd2hlbiBhZGRyID0gdC50bWFfYWRkciAtPlxuICAgIHQudGltYV90bWEgfD4gVWludDgub2ZfaW50XG4gIHwgXyB3aGVuIGFkZHIgPSB0LnRhY19hZGRyIC0+XG4gICAgbGV0IGVuYWJsZV9iaXQgPSAoaWYgdC50aW1hX2VuYWJsZWQgdGhlbiAwYjEwMCBlbHNlIDBiMDAwKSB8PiBVaW50OC5vZl9pbnQgaW5cbiAgICBVaW50OC4oZW5hYmxlX2JpdCBsYW5kIGJ5dGVfb2ZfZnJlcXVlbmN5IHQudGltYV9mcmVxdWVuY3kpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBmcmVxdWVuY3lfb2ZfYnl0ZSBieXRlID1cbiAgICBsZXQgYnl0ZSA9IFVpbnQ4LnRvX2ludCBieXRlIGluXG4gICAgbWF0Y2ggYnl0ZSBsYW5kIDBiMTEgd2l0aFxuICAgIHwgMGIwMCAtPiBGXzQwOTZIelxuICAgIHwgMGIwMSAtPiBGXzI2MjE0NEh6XG4gICAgfCAwYjEwIC0+IEZfNjU1MzZIelxuICAgIHwgMGIxMSAtPiBGXzE2Mzg0SHpcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIG1hdGNoIGFkZHIgd2l0aFxuICB8IF8gd2hlbiBhZGRyID0gdC5kaXZfYWRkciAtPlxuICAgIHQuZGl2X2NvdW50ZXIgPC0gMDtcbiAgICB0LmludGVybmFsX21jeWNsZV9jb3VudCA8LSAwO1xuICB8IF8gd2hlbiBhZGRyID0gdC50aW1hX2FkZHIgLT5cbiAgICB0LnRpbWFfY291bnRlciA8LSAoVWludDgudG9faW50IGRhdGEpXG4gIHwgXyB3aGVuIGFkZHIgPSB0LnRtYV9hZGRyIC0+XG4gICAgdC50aW1hX3RtYSA8LSAoVWludDgudG9faW50IGRhdGEpXG4gIHwgXyB3aGVuIGFkZHIgPSB0LnRhY19hZGRyIC0+XG4gICAgaWYgVWludDguKGRhdGEgbGFuZCBvZl9pbnQgMGIxMDAgPD4gVWludDguemVybykgdGhlblxuICAgICAgdC50aW1hX2VuYWJsZWQgPC0gdHJ1ZTtcbiAgICB0LnRpbWFfZnJlcXVlbmN5IDwtIGZyZXF1ZW5jeV9vZl9ieXRlIGRhdGFcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5tb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gIGxldCBnZXRfdGltYV9jb3VudCB0ID0gdC50aW1hX2NvdW50ZXIgfD4gVWludDgub2ZfaW50XG5lbmRcbiIsIm9wZW4gVWludHNcblxudHlwZSB0ID0ge1xuICBhcmVhMF9tYXAgOiB1aW50OCBhcnJheSBhcnJheTtcbiAgYXJlYTFfbWFwIDogdWludDggYXJyYXkgYXJyYXk7XG4gIGFyZWEwX3N0YXJ0X2FkZHIgOiB1aW50MTY7XG4gIGFyZWEwX2VuZF9hZGRyICAgOiB1aW50MTY7XG4gIGFyZWExX3N0YXJ0X2FkZHIgOiB1aW50MTY7XG4gIGFyZWExX2VuZF9hZGRyICAgOiB1aW50MTY7XG59XG5cbnR5cGUgYXJlYSA9XG4gIHwgQXJlYTBcbiAgfCBBcmVhMVxuXG5sZXQgY3JlYXRlIH5hcmVhMF9zdGFydF9hZGRyIH5hcmVhMF9lbmRfYWRkciB+YXJlYTFfc3RhcnRfYWRkciB+YXJlYTFfZW5kX2FkZHIgPSB7XG4gIGFyZWEwX21hcCA9IEFycmF5Lm1ha2VfbWF0cml4IDMyIDMyIFVpbnQ4Lnplcm87XG4gIGFyZWExX21hcCA9IEFycmF5Lm1ha2VfbWF0cml4IDMyIDMyIFVpbnQ4Lnplcm87XG4gIGFyZWEwX3N0YXJ0X2FkZHI7XG4gIGFyZWEwX2VuZF9hZGRyO1xuICBhcmVhMV9zdGFydF9hZGRyO1xuICBhcmVhMV9lbmRfYWRkcjtcbn1cblxubGV0IGdldF90aWxlX2luZGV4IHQgfmFyZWEgfnkgfnggPVxuICBtYXRjaCBhcmVhIHdpdGhcbiAgfCBBcmVhMCAtPiB0LmFyZWEwX21hcC4oeSAvIDgpLih4IC8gOClcbiAgfCBBcmVhMSAtPiB0LmFyZWExX21hcC4oeSAvIDgpLih4IC8gOClcblxubGV0IGFjY2VwdHMgdCBhZGRyID1cbiAgVWludDE2Lih0LmFyZWEwX3N0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuYXJlYTBfZW5kX2FkZHJcbiAgICAgICAgICB8fCB0LmFyZWExX3N0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuYXJlYTFfZW5kX2FkZHIpXG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgaWYgVWludDE2Lih0LmFyZWEwX3N0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuYXJlYTBfZW5kX2FkZHIpIHRoZW5cbiAgICBsZXQgb2Zmc2V0ID0gVWludDE2Lih0b19pbnQgKGFkZHIgLSB0LmFyZWEwX3N0YXJ0X2FkZHIpKSBpblxuICAgIHQuYXJlYTBfbWFwLihvZmZzZXQgLyAzMikuKG9mZnNldCBtb2QgMzIpXG4gIGVsc2UgaWYgVWludDE2Lih0LmFyZWExX3N0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuYXJlYTFfZW5kX2FkZHIpIHRoZW5cbiAgICBsZXQgb2Zmc2V0ID0gVWludDE2Lih0b19pbnQgKGFkZHIgLSB0LmFyZWExX3N0YXJ0X2FkZHIpKSBpblxuICAgIHQuYXJlYTFfbWFwLihvZmZzZXQgLyAzMikuKG9mZnNldCBtb2QgMzIpXG4gIGVsc2VcbiAgICByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IChQcmludGYuc3ByaW50ZiBcIkFkZHJlc3Mgb3V0IG9mIHJhbmdlOiAlc1wiIChVaW50MTYuc2hvdyBhZGRyKSlcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGlmIFVpbnQxNi4odC5hcmVhMF9zdGFydF9hZGRyIDw9IGFkZHIgJiYgYWRkciA8PSB0LmFyZWEwX2VuZF9hZGRyKSB0aGVuXG4gICAgbGV0IG9mZnNldCA9IFVpbnQxNi4odG9faW50IChhZGRyIC0gdC5hcmVhMF9zdGFydF9hZGRyKSkgaW5cbiAgICB0LmFyZWEwX21hcC4ob2Zmc2V0IC8gMzIpLihvZmZzZXQgbW9kIDMyKSA8LSBkYXRhXG4gIGVsc2UgaWYgVWludDE2Lih0LmFyZWExX3N0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuYXJlYTFfZW5kX2FkZHIpIHRoZW5cbiAgICBsZXQgb2Zmc2V0ID0gVWludDE2Lih0b19pbnQgKGFkZHIgLSB0LmFyZWExX3N0YXJ0X2FkZHIpKSBpblxuICAgIHQuYXJlYTFfbWFwLihvZmZzZXQgLyAzMikuKG9mZnNldCBtb2QgMzIpIDwtIGRhdGFcbiAgZWxzZVxuICAgIHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgKFByaW50Zi5zcHJpbnRmIFwiQWRkcmVzcyBvdXQgb2YgcmFuZ2U6ICVzXCIgKFVpbnQxNi5zaG93IGFkZHIpKVxuIiwib3BlbiBVaW50c1xub3BlbiBTdGRMYWJlbHNcblxubGV0IGJpdGZsYWdzX29mX2J5dGUgeCA9XG4gIGxldCBvcGVuIFVpbnQ4IGluXG4gIChcbiAgICAoeCBsYW5kIG9mX2ludCAwYjEwMDAwMDAwKSA8PiB6ZXJvLFxuICAgICh4IGxhbmQgb2ZfaW50IDBiMDEwMDAwMDApIDw+IHplcm8sXG4gICAgKHggbGFuZCBvZl9pbnQgMGIwMDEwMDAwMCkgPD4gemVybyxcbiAgICAoeCBsYW5kIG9mX2ludCAwYjAwMDEwMDAwKSA8PiB6ZXJvLFxuICAgICh4IGxhbmQgb2ZfaW50IDBiMDAwMDEwMDApIDw+IHplcm8sXG4gICAgKHggbGFuZCBvZl9pbnQgMGIwMDAwMDEwMCkgPD4gemVybyxcbiAgICAoeCBsYW5kIG9mX2ludCAwYjAwMDAwMDEwKSA8PiB6ZXJvLFxuICAgICh4IGxhbmQgb2ZfaW50IDBiMDAwMDAwMDEpIDw+IHplcm9cbiAgKVxuXG5sZXQgYnl0ZV9vZl9iaXRmbGFncyBiNyBiNiBiNSBiNCBiMyBiMiBiMSBiMCA9XG4gIEJvb2wudG9faW50IGIwXG4gIGxvciAoQm9vbC50b19pbnQgYjEgbHNsIDEpXG4gIGxvciAoQm9vbC50b19pbnQgYjIgbHNsIDIpXG4gIGxvciAoQm9vbC50b19pbnQgYjMgbHNsIDMpXG4gIGxvciAoQm9vbC50b19pbnQgYjQgbHNsIDQpXG4gIGxvciAoQm9vbC50b19pbnQgYjUgbHNsIDUpXG4gIGxvciAoQm9vbC50b19pbnQgYjYgbHNsIDYpXG4gIGxvciAoQm9vbC50b19pbnQgYjcgbHNsIDcpXG4gIHw+IFVpbnQ4Lm9mX2ludFxuXG5sZXQgYml0YXJyYXlfb2ZfYnl0ZSB4ID1cbiAgbGV0IG9wZW4gVWludDggaW5cbiAgW3xcbiAgICAoeCBsYW5kIG9mX2ludCAwYjEwMDAwMDAwKSA8PiB6ZXJvO1xuICAgICh4IGxhbmQgb2ZfaW50IDBiMDEwMDAwMDApIDw+IHplcm87XG4gICAgKHggbGFuZCBvZl9pbnQgMGIwMDEwMDAwMCkgPD4gemVybztcbiAgICAoeCBsYW5kIG9mX2ludCAwYjAwMDEwMDAwKSA8PiB6ZXJvO1xuICAgICh4IGxhbmQgb2ZfaW50IDBiMDAwMDEwMDApIDw+IHplcm87XG4gICAgKHggbGFuZCBvZl9pbnQgMGIwMDAwMDEwMCkgPD4gemVybztcbiAgICAoeCBsYW5kIG9mX2ludCAwYjAwMDAwMDEwKSA8PiB6ZXJvO1xuICAgICh4IGxhbmQgb2ZfaW50IDBiMDAwMDAwMDEpIDw+IHplcm9cbiAgfF1cblxubGV0IGJ5dGVfb2ZfYml0YXJyYXkgYSA9XG4gIFt8IDA7IDE7IDI7IDM7IDQ7IDU7IDY7IDcgfF1cbiAgfD4gQXJyYXkuZm9sZF9sZWZ0IH5pbml0OjAgfmY6KGZ1biBhY2MgaSAtPlxuICAgICAgYWNjIGxvciAoQm9vbC50b19pbnQgYS4oaSkgbHNsICg3IC0gaSkpKVxuICB8PiBVaW50OC5vZl9pbnRcbiIsInR5cGUgdCA9XG4gIHwgSURfMDBcbiAgfCBJRF8wMVxuICB8IElEXzEwXG4gIHwgSURfMTFcblxubGV0IG9mX2JpdHMgfmhpIH5sbyA9XG4gIG1hdGNoIGhpLCBsbyB3aXRoXG4gIHwgZmFsc2UsIGZhbHNlIC0+IElEXzAwXG4gIHwgZmFsc2UsIHRydWUgIC0+IElEXzAxXG4gIHwgdHJ1ZSwgZmFsc2UgIC0+IElEXzEwXG4gIHwgdHJ1ZSwgdHJ1ZSAgIC0+IElEXzExXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IElEXzAwIC0+IDBcbiAgfCBJRF8wMSAtPiAxXG4gIHwgSURfMTAgLT4gMlxuICB8IElEXzExIC0+IDNcblxubGV0IHNldF9iaXQgdCA9IGZ1bmN0aW9uXG4gIHwgYExvIC0+XG4gICAgYmVnaW4gbWF0Y2ggdCB3aXRoXG4gICAgICB8IElEXzAwIC0+IElEXzAxXG4gICAgICB8IElEXzAxIC0+IElEXzAxXG4gICAgICB8IElEXzEwIC0+IElEXzExXG4gICAgICB8IElEXzExIC0+IElEXzExXG4gICAgZW5kXG4gIHwgYEhpIC0+XG4gICAgYmVnaW4gbWF0Y2ggdCB3aXRoXG4gICAgICB8IElEXzAwIC0+IElEXzEwXG4gICAgICB8IElEXzAxIC0+IElEXzExXG4gICAgICB8IElEXzEwIC0+IElEXzEwXG4gICAgICB8IElEXzExIC0+IElEXzExXG4gICAgZW5kXG5cbmxldCBjbGVhcl9iaXQgdCA9IGZ1bmN0aW9uXG4gIHwgYExvIC0+XG4gICAgYmVnaW4gbWF0Y2ggdCB3aXRoXG4gICAgICB8IElEXzAwIC0+IElEXzAwXG4gICAgICB8IElEXzAxIC0+IElEXzAwXG4gICAgICB8IElEXzEwIC0+IElEXzEwXG4gICAgICB8IElEXzExIC0+IElEXzEwXG4gICAgZW5kXG4gIHwgYEhpIC0+XG4gICAgYmVnaW4gbWF0Y2ggdCB3aXRoXG4gICAgICB8IElEXzAwIC0+IElEXzAwXG4gICAgICB8IElEXzAxIC0+IElEXzAxXG4gICAgICB8IElEXzEwIC0+IElEXzAwXG4gICAgICB8IElEXzExIC0+IElEXzAxXG4gICAgZW5kXG5cbmxldCBnZXRfYml0IHQgPSBmdW5jdGlvblxuICB8IGBMbyAtPlxuICAgIGJlZ2luIG1hdGNoIHQgd2l0aFxuICAgICAgfCBJRF8wMCB8IElEXzEwIC0+IGZhbHNlXG4gICAgICB8IElEXzAxIHwgSURfMTEgLT4gdHJ1ZVxuICAgIGVuZFxuICB8IGBIaSAtPlxuICAgIGJlZ2luIG1hdGNoIHQgd2l0aFxuICAgICAgfCBJRF8wMCB8IElEXzAxIC0+IGZhbHNlXG4gICAgICB8IElEXzEwIHwgSURfMTEgLT4gdHJ1ZVxuICAgIGVuZFxuIiwib3BlbiBVaW50c1xuXG50eXBlIGFyZWEgPSBBcmVhMSB8IEFyZWEwXG5cbnR5cGUgdCA9IHtcbiAgKCogdGlsZXMuKGkpLihyb3cpLihjb2wpIDogKHJvdywgY29sKSBvZiB0aGUgaS10aCB0aWxlICopXG4gIHRpbGVzIDogQ29sb3JfaWQudCBhcnJheSBhcnJheSBhcnJheTtcbiAgc3RhcnRfYWRkciA6IHVpbnQxNjtcbiAgZW5kX2FkZHIgOiB1aW50MTY7XG59XG5cbmxldCBjcmVhdGUgfnN0YXJ0X2FkZHIgfmVuZF9hZGRyID1cbiAgbGV0IHRpbGVzID0gQXJyYXkuaW5pdCAzODQgKGZ1biBfIC0+IEFycmF5Lm1ha2VfbWF0cml4IDggOCBDb2xvcl9pZC5JRF8wMCkgaW5cbiAge1xuICAgIHRpbGVzO1xuICAgIHN0YXJ0X2FkZHI7XG4gICAgZW5kX2FkZHI7XG4gIH1cblxubGV0IGdldF9yb3dfcGl4ZWxzIHQgfmFyZWEgfihpbmRleDp1aW50OCkgfnJvdyA9XG4gIGxldCBpbmRleCA9IG1hdGNoIGFyZWEgd2l0aFxuICAgIHwgQXJlYTEgLT5cbiAgICAgIFVpbnQ4LnRvX2ludCBpbmRleFxuICAgIHwgQXJlYTAgLT5cbiAgICAgICgqIGludGVycHJldCB1bnNpZ25lZCBpbnQ4IGJ5dGUgYXMgc2lnbmVkIGludDggKilcbiAgICAgIGxldCBzaWduZWRfaW5kZXggPSBpbmRleCB8PiBJbnQ4Lm9mX2J5dGUgfD4gSW50OC50b19pbnQgaW5cbiAgICAgIHNpZ25lZF9pbmRleCArIDI1NlxuICBpblxuICBpZiByb3cgPj0gOCB0aGVuXG4gICAgdC50aWxlcy4oaW5kZXggKyAxKS4ocm93IC0gOClcbiAgZWxzZVxuICAgIHQudGlsZXMuKGluZGV4KS4ocm93KVxuXG4oKiBUT0RPOiBuYXBraW4tbWF0aCB3aHkgdGhpcyAoYW5kIG9hbSBmZXRjaCkgd2FzIHRoZSBib3R0bGUgbmVjayAqKVxubGV0IGdldF9waXhlbCB0IH5hcmVhIH4oaW5kZXg6dWludDgpIH5yb3cgfmNvbCA9XG4gIGxldCByb3cgPSBnZXRfcm93X3BpeGVscyB0IH5hcmVhIH5pbmRleCB+cm93IGluXG4gIHJvdy4oY29sKVxuXG5sZXQgZ2V0X2Z1bGxfcGl4ZWxzIHQgfmFyZWEgfmluZGV4ID1cbiAgW3wgMDsgMTsgMjsgMzsgNDsgNTsgNjsgNyB8XVxuICB8PiBBcnJheS5tYXAgKGZ1biByb3ctPiBnZXRfcm93X3BpeGVscyB0IH5hcmVhIH5pbmRleCB+cm93KVxuXG5sZXQgcHJpbnRfZnVsbF9waXhlbHMgdCB+YXJlYSB+aW5kZXggPVxuICBnZXRfZnVsbF9waXhlbHMgdCB+YXJlYSB+aW5kZXhcbiAgfD4gQXJyYXkuaXRlciAoZnVuIGNvbG9yX2lkcyAtPlxuICAgICAgY29sb3JfaWRzXG4gICAgICB8PiBBcnJheS5tYXAgKENvbG9yX2lkLnRvX2ludClcbiAgICAgIHw+IEFycmF5Lml0ZXIgKHByaW50X2ludCk7XG4gICAgICBwcmludF9uZXdsaW5lICgpKVxuXG5sZXQgYWNjZXB0cyB0IGFkZHIgPSBVaW50MTYuKHQuc3RhcnRfYWRkciA8PSBhZGRyICYmIGFkZHIgPD0gdC5lbmRfYWRkcilcblxubGV0IHJlYWRfYnl0ZSB0IGFkZHIgPVxuICBsZXQgb2Zmc2V0ID0gVWludDE2LihhZGRyIC0gdC5zdGFydF9hZGRyKSB8PiBVaW50MTYudG9faW50IGluXG4gIGxldCBpbmRleCA9IG9mZnNldCAvIDE2IGluXG4gIGxldCByb3cgPSAob2Zmc2V0IG1vZCAxNikgLyAyIGluXG4gIGxldCBoaV9vcl9sbyA9IGlmIG9mZnNldCBtb2QgMiA9IDAgdGhlbiBgTG8gZWxzZSBgSGkgaW5cbiAgdC50aWxlcy4oaW5kZXgpLihyb3cpXG4gIHw+IEFycmF5Lm1hcCAoZnVuIGlkIC0+IENvbG9yX2lkLmdldF9iaXQgaWQgaGlfb3JfbG8pXG4gIHw+IEJpdF91dGlsLmJ5dGVfb2ZfYml0YXJyYXlcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBkYXRhX2JpdHMgPSBCaXRfdXRpbC5iaXRhcnJheV9vZl9ieXRlIGRhdGEgaW5cbiAgbGV0IG9mZnNldCA9IFVpbnQxNi4oYWRkciAtIHQuc3RhcnRfYWRkcikgfD4gVWludDE2LnRvX2ludCBpblxuICBsZXQgaW5kZXggPSBvZmZzZXQgLyAxNiBpblxuICBsZXQgcm93ID0gKG9mZnNldCBtb2QgMTYpIC8gMiBpblxuICAoKiBQcmludGYucHJpbnRmIFwib2Zmc2V0PSVkLCBpbmRleD0lZCwgcm93PSVkXFxuXCIgb2Zmc2V0IGluZGV4IHJvdzsgKilcbiAgbGV0IGNvbG9yc19pbl9yb3cgPSB0LnRpbGVzLihpbmRleCkuKHJvdykgaW5cbiAgbGV0IGhpX29yX2xvID0gaWYgb2Zmc2V0IG1vZCAyID0gMCB0aGVuIGBMbyBlbHNlIGBIaSBpblxuICB0LnRpbGVzLihpbmRleCkuKHJvdykgPC1cbiAgICBkYXRhX2JpdHNcbiAgICB8PiBBcnJheS5tYXBpIChmdW4gaSBiIC0+XG4gICAgICAgIGxldCBpZCA9IGNvbG9yc19pbl9yb3cuKGkpIGluXG4gICAgICAgIGlmIGIgdGhlblxuICAgICAgICAgIENvbG9yX2lkLnNldF9iaXQgaWQgaGlfb3JfbG9cbiAgICAgICAgZWxzZVxuICAgICAgICAgIENvbG9yX2lkLmNsZWFyX2JpdCBpZCBoaV9vcl9sbylcbiIsIm9wZW4gVWludHNcblxudHlwZSB0ID0ge1xuICBieXRlcyA6IEJpZ3N0cmluZ2FmLnQ7XG4gIHN0YXJ0X2FkZHIgOiB1aW50MTY7XG4gIGVuZF9hZGRyIDogdWludDE2O1xufVxuXG5sZXQgY3JlYXRlIH5zdGFydF9hZGRyIH5lbmRfYWRkciA9XG4gIGxldCBzdHJpbmcgPSBTdHJpbmcuaW5pdCBVaW50MTYuKHRvX2ludCBAQCBlbmRfYWRkciAtIHN0YXJ0X2FkZHIgKyBvbmUpIChmdW4gXyAtPiBDaGFyLmNociAwKSBpblxuICBsZXQgYnl0ZXMgPSBCaWdzdHJpbmdhZi5vZl9zdHJpbmcgfm9mZjowIH5sZW46KFN0cmluZy5sZW5ndGggc3RyaW5nKSBzdHJpbmcgaW5cbiAge1xuICAgIGJ5dGVzO1xuICAgIHN0YXJ0X2FkZHI7XG4gICAgZW5kX2FkZHI7XG4gIH1cblxubGV0IGFjY2VwdHMgdCBhZGRyID0gVWludDE2Lih0LnN0YXJ0X2FkZHIgPD0gYWRkciAmJiBhZGRyIDw9IHQuZW5kX2FkZHIpXG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgbGV0IG9mZnNldCA9IFVpbnQxNi4oYWRkciAtIHQuc3RhcnRfYWRkcikgfD4gVWludDE2LnRvX2ludCBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQuYnl0ZXMgb2Zmc2V0IHw+IFVpbnQ4Lm9mX2NoYXJcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBvZmZzZXQgPSBVaW50MTYuKGFkZHIgLSB0LnN0YXJ0X2FkZHIpIHw+IFVpbnQxNi50b19pbnQgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX3NldCB0LmJ5dGVzIG9mZnNldCAoVWludDgudG9fY2hhciBkYXRhKVxuIiwib3BlbiBVaW50c1xuXG50eXBlIHQgPSB7XG4gIHRhcmdldCA6IFJhbS50O1xuICB0YXJnZXRfc3RhcnQgOiB1aW50MTY7XG4gIHNoYWRvd19zdGFydCA6IHVpbnQxNjtcbiAgc2hhZG93X2VuZCA6IHVpbnQxNjtcbn1cblxubGV0IGNyZWF0ZSB+dGFyZ2V0IH50YXJnZXRfc3RhcnQgfnNoYWRvd19zdGFydCB+c2hhZG93X2VuZCA9IHtcbiAgdGFyZ2V0O1xuICB0YXJnZXRfc3RhcnQ7XG4gIHNoYWRvd19zdGFydDtcbiAgc2hhZG93X2VuZDtcbn1cblxubGV0IGFjY2VwdHMgdCBhZGRyID1cbiAgVWludDE2Lih0LnNoYWRvd19zdGFydCA8PSBhZGRyICYmIGFkZHIgPD0gdC5zaGFkb3dfZW5kKVxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGlmIG5vdCBAQCBhY2NlcHRzIHQgYWRkciB0aGVuXG4gICAgcmFpc2UgQEAgSW52YWxpZF9hcmd1bWVudCAoUHJpbnRmLnNwcmludGYgXCJBZGRyZXNzIG91dCBvZiByYW5nZTogJXNcIiAoVWludDE2LnNob3cgYWRkcikpXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgb3BlbiBVaW50MTYgaW5cbiAgICBsZXQgb2Zmc2V0ID0gYWRkciAtIHQuc2hhZG93X3N0YXJ0IGluXG4gICAgUmFtLnJlYWRfYnl0ZSB0LnRhcmdldCAodC50YXJnZXRfc3RhcnQgKyBvZmZzZXQpXG4gIGVuZFxuXG5sZXQgd3JpdGVfYnl0ZSB0IH5hZGRyIH5kYXRhID1cbiAgaWYgbm90IEBAIGFjY2VwdHMgdCBhZGRyIHRoZW5cbiAgICByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IChQcmludGYuc3ByaW50ZiBcIkFkZHJlc3Mgb3V0IG9mIHJhbmdlOiAlc1wiIChVaW50MTYuc2hvdyBhZGRyKSlcbiAgZWxzZSBiZWdpblxuICAgIGxldCBvcGVuIFVpbnQxNiBpblxuICAgIGxldCBvZmZzZXQgPSBhZGRyIC0gdC5zaGFkb3dfc3RhcnQgaW5cbiAgICBSYW0ud3JpdGVfYnl0ZSB0LnRhcmdldCB+YWRkcjoodC50YXJnZXRfc3RhcnQgKyBvZmZzZXQpIH5kYXRhXG4gIGVuZFxuIiwib3BlbiBVaW50c1xuXG50eXBlIHQgPSB7XG4gIGFkZHIgOiB1aW50MTY7XG4gIG11dGFibGUgZGF0YSA6IHVpbnQ4O1xuICBjYW5fcmVhZCA6IGJvb2w7XG4gIGNhbl93cml0ZSA6IGJvb2w7XG59XG5cbmxldCBjcmVhdGUgfmFkZHIgfnR5cGVfID8oZGVmYXVsdCA9IFVpbnQ4Lnplcm8pICgpID1cbiAgbWF0Y2ggdHlwZV8gd2l0aFxuICB8IGBSVyAtPiB7YWRkcjsgZGF0YSA9IGRlZmF1bHQ7IGNhbl9yZWFkID0gdHJ1ZTsgY2FuX3dyaXRlID0gdHJ1ZX1cbiAgfCBgUiAgLT4ge2FkZHI7IGRhdGEgPSBkZWZhdWx0OyBjYW5fcmVhZCA9IHRydWU7IGNhbl93cml0ZSA9IGZhbHNlfVxuICB8IGBXICAtPiB7YWRkcjsgZGF0YSA9IGRlZmF1bHQ7IGNhbl9yZWFkID0gZmFsc2U7IGNhbl93cml0ZSA9IHRydWV9XG5cbmxldCBhY2NlcHRzIHQgYWRkciA9IFVpbnQxNi4oYWRkciA9IHQuYWRkcilcblxubGV0IHJlYWRfYnl0ZSB0IGFkZHIgPVxuICBpZiBub3QgQEAgdC5jYW5fcmVhZCB0aGVuXG4gICAgZmFpbHdpdGggXCJjYW5ub3QgcmVhZFwiXG4gIGVsc2UgaWYgbm90IEBAIGFjY2VwdHMgdCBhZGRyIHRoZW5cbiAgICBmYWlsd2l0aCBcImludmFsaWQgYWRkclwiXG4gIGVsc2VcbiAgICB0LmRhdGFcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGlmIG5vdCBAQCB0LmNhbl9yZWFkIHRoZW5cbiAgICBmYWlsd2l0aCBcImNhbm5vdCB3cml0ZVwiXG4gIGVsc2UgaWYgbm90IEBAIGFjY2VwdHMgdCBhZGRyIHRoZW5cbiAgICBmYWlsd2l0aCBcImludmFsaWQgYWRkclwiXG4gIGVsc2VcbiAgICB0LmRhdGEgPC0gZGF0YVxuXG5sZXQgcGVlayB0ID0gdC5kYXRhXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgdCA9IHtcbiAgc2IgOiBNbWFwX3JlZ2lzdGVyLnQ7ICAgICAgICAgKCogU2VyaWFsIHRyYW5zZmVyIGRhdGEgKilcbiAgc2MgOiBNbWFwX3JlZ2lzdGVyLnQ7ICAgICAgICAgKCogU2VyaWFsIHRyYW5zZmVyIGNvbnRyb2wgKilcbiAgcHJpbnRfc2VyaWFsX3BvcnQgOiBib29sO1xufVxuXG5sZXQgY3JlYXRlIH5zYiB+c2MgPyhwcmludF9zZXJpYWxfcG9ydCA9IGZhbHNlKSAoKSA9IHtzYjsgc2M7IHByaW50X3NlcmlhbF9wb3J0O31cblxubGV0IHJlYWRfYnl0ZSB0IGFkZHIgPVxuICBtYXRjaCBhZGRyIHdpdGhcbiAgfCBfIHdoZW4gTW1hcF9yZWdpc3Rlci5hY2NlcHRzIHQuc2IgYWRkciAtPiBNbWFwX3JlZ2lzdGVyLnJlYWRfYnl0ZSB0LnNiIGFkZHJcbiAgfCBfIHdoZW4gTW1hcF9yZWdpc3Rlci5hY2NlcHRzIHQuc2MgYWRkciAtPiBNbWFwX3JlZ2lzdGVyLnJlYWRfYnl0ZSB0LnNjIGFkZHJcbiAgfCBfIC0+IGZhaWx3aXRoIFwiaW52YWxpZCBhZGRyXCJcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIG1hdGNoIGFkZHIgd2l0aFxuICB8IF8gd2hlbiBNbWFwX3JlZ2lzdGVyLmFjY2VwdHMgdC5zYiBhZGRyIC0+IE1tYXBfcmVnaXN0ZXIud3JpdGVfYnl0ZSB0LnNiIH5hZGRyIH5kYXRhXG4gIHwgXyB3aGVuIE1tYXBfcmVnaXN0ZXIuYWNjZXB0cyB0LnNjIGFkZHIgLT5cbiAgICBNbWFwX3JlZ2lzdGVyLndyaXRlX2J5dGUgdC5zYyB+YWRkciB+ZGF0YTtcbiAgICBpZiB0LnByaW50X3NlcmlhbF9wb3J0ICYmIFVpbnQ4LihkYXRhID0gb2ZfaW50IDB4ODEpIHRoZW4gYmVnaW5cbiAgICAgIFByaW50Zi5wcmludGYgXCIlY1wiIFVpbnQ4LihNbWFwX3JlZ2lzdGVyLnBlZWsgdC5zYiB8PiB0b19pbnQgfD4gQ2hhci51bnNhZmVfY2hyKTtcbiAgICAgIGZsdXNoX2FsbCAoKTtcbiAgICBlbmRcbiAgfCBfIC0+IGZhaWx3aXRoIFwiaW52YWxpZCBhZGRyXCJcblxubGV0IGFjY2VwdHMgdCBhZGRyID1cbiAgTW1hcF9yZWdpc3Rlci5hY2NlcHRzIHQuc2IgYWRkciB8fCBNbWFwX3JlZ2lzdGVyLmFjY2VwdHMgdC5zYyBhZGRyXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgdCA9IHtcbiAgbXV0YWJsZSBhIDogdWludDg7XG4gIG11dGFibGUgYiA6IHVpbnQ4O1xuICBtdXRhYmxlIGMgOiB1aW50ODtcbiAgbXV0YWJsZSBkIDogdWludDg7XG4gIG11dGFibGUgZSA6IHVpbnQ4O1xuICBtdXRhYmxlIGYgOiB1aW50ODtcbiAgbXV0YWJsZSBoIDogdWludDg7XG4gIG11dGFibGUgbCA6IHVpbnQ4O1xufVxuXG50eXBlIHIgPVxuICB8IEFcbiAgfCBCXG4gIHwgQ1xuICB8IERcbiAgfCBFXG4gIHwgRlxuICB8IEhcbiAgfCBMXG5cbnR5cGUgcnIgPVxuICB8IEFGXG4gIHwgQkNcbiAgfCBERVxuICB8IEhMXG5cbnR5cGUgZmxhZyA9XG4gIHwgQ2FycnkgICAgICAgICAgICAgICAgICAgICAgICgqIGMgKilcbiAgfCBIYWxmX2NhcnJ5ICAgICAgICAgICAgICAgICAgKCogaCAqKVxuICB8IFN1YnRyYWN0aW9uICAgICAgICAgICAgICAgICAoKiBuICopXG4gIHwgWmVybyAgICAgICAgICAgICAgICAgICAgICAgICgqIHogKilcblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgYSA9IFVpbnQ4Lnplcm87XG4gIGIgPSBVaW50OC56ZXJvO1xuICBjID0gVWludDguemVybztcbiAgZCA9IFVpbnQ4Lnplcm87XG4gIGUgPSBVaW50OC56ZXJvO1xuICBmID0gVWludDguemVybztcbiAgaCA9IFVpbnQ4Lnplcm87XG4gIGwgPSBVaW50OC56ZXJvO1xufVxuXG5sZXQgcmVhZF9yIHQgPSBmdW5jdGlvblxuICB8IEEgLT4gdC5hXG4gIHwgQiAtPiB0LmJcbiAgfCBDIC0+IHQuY1xuICB8IEQgLT4gdC5kXG4gIHwgRSAtPiB0LmVcbiAgfCBGIC0+IHQuZlxuICB8IEggLT4gdC5oXG4gIHwgTCAtPiB0LmxcblxubGV0IHJlYWRfcnIgdCByciA9XG4gIGxldCBvcGVuIFVpbnQxNiBpblxuICBtYXRjaCByciB3aXRoXG4gIHwgQUYgLT4gKG9mX3VpbnQ4IHQuYSBsc2wgOCkgbG9yIG9mX3VpbnQ4IHQuZlxuICB8IEJDIC0+IChvZl91aW50OCB0LmIgbHNsIDgpIGxvciBvZl91aW50OCB0LmNcbiAgfCBERSAtPiAob2ZfdWludDggdC5kIGxzbCA4KSBsb3Igb2ZfdWludDggdC5lXG4gIHwgSEwgLT4gKG9mX3VpbnQ4IHQuaCBsc2wgOCkgbG9yIG9mX3VpbnQ4IHQubFxuXG5sZXQgd3JpdGVfciB0IHIgeCA9IG1hdGNoIHIgd2l0aFxuICB8IEEgLT4gdC5hIDwtIHhcbiAgfCBCIC0+IHQuYiA8LSB4XG4gIHwgQyAtPiB0LmMgPC0geFxuICB8IEQgLT4gdC5kIDwtIHhcbiAgfCBFIC0+IHQuZSA8LSB4XG4gIHwgRiAtPlxuICAgICgqIEJvdHRvbSA0IGJpdHMgb2YgdGhlIGZsYWcgcmVnaXN0ZXIgaXMgYWx3YXlzIHplcm8gKilcbiAgICB0LmYgPC0gVWludDguKHggbGFuZCBvZl9pbnQgMHhGMClcbiAgfCBIIC0+IHQuaCA8LSB4XG4gIHwgTCAtPiB0LmwgPC0geFxuXG5sZXQgd3JpdGVfcnIgdCByciB4ID1cbiAgbGV0IHggPSBVaW50MTYudG9faW50IHggaW5cbiAgbGV0IGhpZ2ggPSAoeCBsYW5kIDB4RkYwMCkgbHNyIDggfD4gVWludDgub2ZfaW50IGluXG4gIGxldCBsb3cgID0gIHggbGFuZCAweDAwRkYgICAgICAgIHw+IFVpbnQ4Lm9mX2ludCBpblxuICBtYXRjaCByciB3aXRoXG4gIHwgQUYgLT5cbiAgICB0LmEgPC0gaGlnaDtcbiAgICAoKiBCb3R0b20gNCBiaXRzIG9mIHRoZSBmbGFnIHJlZ2lzdGVyIGlzIGFsd2F5cyB6ZXJvICopXG4gICAgdC5mIDwtIFVpbnQ4Lihsb3cgbGFuZCBvZl9pbnQgMHhGMClcbiAgfCBCQyAtPiB0LmIgPC0gaGlnaDsgdC5jIDwtIGxvd1xuICB8IERFIC0+IHQuZCA8LSBoaWdoOyB0LmUgPC0gbG93XG4gIHwgSEwgLT4gdC5oIDwtIGhpZ2g7IHQubCA8LSBsb3dcblxubGV0IHJlYWRfZmxhZyB0IGZsYWcgPVxuICBsZXQgZiA9IHQuZiB8PiBVaW50OC50b19pbnQgaW5cbiAgbWF0Y2ggZmxhZyB3aXRoXG4gIHwgQ2FycnkgICAgICAgLT4gZiBsYW5kIDBiMDAwMTAwMDAgPD4gMFxuICB8IEhhbGZfY2FycnkgIC0+IGYgbGFuZCAwYjAwMTAwMDAwIDw+IDBcbiAgfCBTdWJ0cmFjdGlvbiAtPiBmIGxhbmQgMGIwMTAwMDAwMCA8PiAwXG4gIHwgWmVybyAgICAgICAgLT4gZiBsYW5kIDBiMTAwMDAwMDAgPD4gMFxuXG4oKiBQcmVjb21wdXRlIHVpbnQ4IG1hc2tzIHRvIHJlZHVjZSBjYWxscyB0byBVaW50OC5vZl9pbnQuXG4gKiBJbXByb3ZlcyBwZXJmb3JtYW5jZSBvZiB3aG9sZSBlbXVsYXRvciBieSB+MSUgKilcbmxldCBtYXNrXzBiMDAwMTAwMDAgPSBVaW50OC5vZl9pbnQgMGIwMDAxMDAwMFxubGV0IG1hc2tfMGIxMTEwMDAwMCA9IFVpbnQ4Lm9mX2ludCAwYjExMTAwMDAwXG5sZXQgbWFza18wYjAwMTAwMDAwID0gVWludDgub2ZfaW50IDBiMDAxMDAwMDBcbmxldCBtYXNrXzBiMTEwMTAwMDAgPSBVaW50OC5vZl9pbnQgMGIxMTAxMDAwMFxubGV0IG1hc2tfMGIwMTAwMDAwMCA9IFVpbnQ4Lm9mX2ludCAwYjAxMDAwMDAwXG5sZXQgbWFza18wYjEwMTEwMDAwID0gVWludDgub2ZfaW50IDBiMTAxMTAwMDBcbmxldCBtYXNrXzBiMTAwMDAwMDAgPSBVaW50OC5vZl9pbnQgMGIxMDAwMDAwMFxubGV0IG1hc2tfMGIwMTExMDAwMCA9IFVpbnQ4Lm9mX2ludCAwYjAxMTEwMDAwXG5sZXQgbWFza18wYjExMTAxMTExID0gVWludDgub2ZfaW50IDBiMTExMDExMTFcbmxldCBtYXNrXzBiMTEwMTExMTEgPSBVaW50OC5vZl9pbnQgMGIxMTAxMTExMVxubGV0IG1hc2tfMGIxMDExMTExMSA9IFVpbnQ4Lm9mX2ludCAwYjEwMTExMTExXG5sZXQgbWFza18wYjAxMTExMTExID0gVWludDgub2ZfaW50IDBiMDExMTExMTFcblxubGV0IHNldF9mbGFnIHQgZmxhZyA9XG4gIGxldCBvcGVuIFVpbnQ4IGluXG4gIG1hdGNoIGZsYWcgd2l0aFxuICB8IENhcnJ5ICAgICAgIC0+IHQuZiA8LSB0LmYgbG9yIG1hc2tfMGIwMDAxMDAwMFxuICB8IEhhbGZfY2FycnkgIC0+IHQuZiA8LSB0LmYgbG9yIG1hc2tfMGIwMDEwMDAwMFxuICB8IFN1YnRyYWN0aW9uIC0+IHQuZiA8LSB0LmYgbG9yIG1hc2tfMGIwMTAwMDAwMFxuICB8IFplcm8gICAgICAgIC0+IHQuZiA8LSB0LmYgbG9yIG1hc2tfMGIxMDAwMDAwMFxuXG5sZXQgc2V0X2ZsYWdzIHRcbiAgICA/KGMgPSByZWFkX2ZsYWcgdCBDYXJyeSlcbiAgICA/KGggPSByZWFkX2ZsYWcgdCBIYWxmX2NhcnJ5KVxuICAgID8obiA9IHJlYWRfZmxhZyB0IFN1YnRyYWN0aW9uKVxuICAgID8oeiA9IHJlYWRfZmxhZyB0IFplcm8pXG4gICAgKCkgPVxuICBsZXQgb3BlbiBVaW50OCBpblxuICBpZiBjIHRoZW4gdC5mIDwtIHQuZiBsb3IgbWFza18wYjAwMDEwMDAwIGVsc2UgdC5mIDwtIHQuZiBsYW5kIG1hc2tfMGIxMTEwMDAwMDtcbiAgaWYgaCB0aGVuIHQuZiA8LSB0LmYgbG9yIG1hc2tfMGIwMDEwMDAwMCBlbHNlIHQuZiA8LSB0LmYgbGFuZCBtYXNrXzBiMTEwMTAwMDA7XG4gIGlmIG4gdGhlbiB0LmYgPC0gdC5mIGxvciBtYXNrXzBiMDEwMDAwMDAgZWxzZSB0LmYgPC0gdC5mIGxhbmQgbWFza18wYjEwMTEwMDAwO1xuICBpZiB6IHRoZW4gdC5mIDwtIHQuZiBsb3IgbWFza18wYjEwMDAwMDAwIGVsc2UgdC5mIDwtIHQuZiBsYW5kIG1hc2tfMGIwMTExMDAwMFxuXG5sZXQgdW5zZXRfZmxhZyB0IGZsYWcgPVxuICBsZXQgb3BlbiBVaW50OCBpblxuICBtYXRjaCBmbGFnIHdpdGhcbiAgfCBDYXJyeSAgICAgICAtPiB0LmYgPC0gdC5mIGxhbmQgbWFza18wYjExMTAxMTExXG4gIHwgSGFsZl9jYXJyeSAgLT4gdC5mIDwtIHQuZiBsYW5kIG1hc2tfMGIxMTAxMTExMVxuICB8IFN1YnRyYWN0aW9uIC0+IHQuZiA8LSB0LmYgbGFuZCBtYXNrXzBiMTAxMTExMTFcbiAgfCBaZXJvICAgICAgICAtPiB0LmYgPC0gdC5mIGxhbmQgbWFza18wYjAxMTExMTExXG5cbmxldCBjbGVhcl9mbGFncyB0ID0gdC5mIDwtIFVpbnQ4Lnplcm9cblxubGV0IHNob3dfciA9IGZ1bmN0aW9uXG4gIHwgQSAtPiBcIkFcIlxuICB8IEIgLT4gXCJCXCJcbiAgfCBDIC0+IFwiQ1wiXG4gIHwgRCAtPiBcIkRcIlxuICB8IEUgLT4gXCJFXCJcbiAgfCBGIC0+IFwiRlwiXG4gIHwgSCAtPiBcIkhcIlxuICB8IEwgLT4gXCJMXCJcblxubGV0IHNob3dfcnIgPSBmdW5jdGlvblxuICB8IEFGIC0+IFwiQUZcIlxuICB8IEJDIC0+IFwiQkNcIlxuICB8IERFIC0+IFwiREVcIlxuICB8IEhMIC0+IFwiSExcIlxuXG5sZXQgc2hvd19mIGYgPVxuICBsZXQgZiA9IFVpbnQ4LnRvX2ludCBmIGluXG4gIGxldCB6ID0gaWYgZiBsYW5kIDBiMTAwMDAwMDAgPD4gMCB0aGVuICdaJyBlbHNlICctJyBpblxuICBsZXQgbiA9IGlmIGYgbGFuZCAwYjAxMDAwMDAwIDw+IDAgdGhlbiAnTicgZWxzZSAnLScgaW5cbiAgbGV0IGggPSBpZiBmIGxhbmQgMGIwMDEwMDAwMCA8PiAwIHRoZW4gJ0gnIGVsc2UgJy0nIGluXG4gIGxldCBjID0gaWYgZiBsYW5kIDBiMDAwMTAwMDAgPD4gMCB0aGVuICdDJyBlbHNlICctJyBpblxuICBQcmludGYuc3ByaW50ZiBcIiVjJWMlYyVjXCIgeiBuIGggY1xuXG4oKiBBOiQxMSBGOlotSEMgQkM6JDAwMTMgREU6JDAwRDggJEhMOjAxNEQgICopXG5sZXQgc2hvdyB0ID1cbiAgUHJpbnRmLnNwcmludGYgXCJBOiVzIEY6JXMgQkM6JXMgREU6JXMgSEw6JXNcIlxuICAgIChyZWFkX3IgdCBBIHw+IFVpbnQ4LnNob3cpXG4gICAgKHNob3dfZiB0LmYpXG4gICAgKHJlYWRfcnIgdCBCQyB8PiBVaW50MTYuc2hvdylcbiAgICAocmVhZF9yciB0IERFIHw+IFVpbnQxNi5zaG93KVxuICAgIChyZWFkX3JyIHQgSEwgfD4gVWludDE2LnNob3cpXG4iLCJsZXQgZiAocm9tX2ZpbGVfbmFtZSA6IHN0cmluZykgPVxuICBsZXQgcm9tX2luID0gb3Blbl9pbiByb21fZmlsZV9uYW1lIGluXG4gIGxldCByb21fbGVuID0gaW5fY2hhbm5lbF9sZW5ndGggcm9tX2luIGluXG4gIGxldCByb21fc3RyaW5nID0gcmVhbGx5X2lucHV0X3N0cmluZyByb21faW4gcm9tX2xlbiBpblxuICBCaWdzdHJpbmdhZi5vZl9zdHJpbmcgfm9mZjowIH5sZW46cm9tX2xlbiByb21fc3RyaW5nXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgY29sb3IgPSBbYFdoaXRlIHwgYExpZ2h0X2dyYXkgfCBgRGFya19ncmF5IHwgYEJsYWNrIF1cblxudHlwZSB0ID0ge1xuICBhZGRyIDogdWludDE2O1xuICBtdXRhYmxlIGlkXzAwIDogY29sb3I7XG4gIG11dGFibGUgaWRfMDEgOiBjb2xvcjtcbiAgbXV0YWJsZSBpZF8xMCA6IGNvbG9yO1xuICBtdXRhYmxlIGlkXzExIDogY29sb3I7XG59XG5cbmxldCBjcmVhdGUgfmFkZHIgPSB7XG4gIGFkZHI7XG4gIGlkXzAwID0gYFdoaXRlO1xuICBpZF8wMSA9IGBMaWdodF9ncmF5O1xuICBpZF8xMCA9IGBEYXJrX2dyYXk7XG4gIGlkXzExID0gYEJsYWNrO1xufVxuXG5sZXQgbG9va3VwIHQgY29sb3JfaWQgPVxuICBsZXQgb3BlbiBDb2xvcl9pZCBpblxuICBtYXRjaCBjb2xvcl9pZCB3aXRoXG4gIHwgSURfMDAgLT4gdC5pZF8wMFxuICB8IElEXzAxIC0+IHQuaWRfMDFcbiAgfCBJRF8xMCAtPiB0LmlkXzEwXG4gIHwgSURfMTEgLT4gdC5pZF8xMVxuXG5sZXQgYWNjZXB0cyB0IGFkZHIgPSBVaW50MTYuKGFkZHIgPSB0LmFkZHIpXG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgbGV0IGJpdHNfb2ZfY29sb3IgPSBmdW5jdGlvblxuICAgIHwgYFdoaXRlIC0+IDBiMDBcbiAgICB8IGBMaWdodF9ncmF5IC0+IDBiMDFcbiAgICB8IGBEYXJrX2dyYXkgLT4gMGIxMFxuICAgIHwgYEJsYWNrIC0+IDBiMTFcbiAgaW5cbiAgaWYgYWNjZXB0cyB0IGFkZHIgdGhlblxuICAgIChiaXRzX29mX2NvbG9yIHQuaWRfMDApXG4gICAgbG9yIChiaXRzX29mX2NvbG9yIHQuaWRfMDEgbHNsIDIpXG4gICAgbG9yIChiaXRzX29mX2NvbG9yIHQuaWRfMTAgbHNsIDQpXG4gICAgbG9yIChiaXRzX29mX2NvbG9yIHQuaWRfMTEgbHNsIDYpXG4gICAgfD4gVWludDgub2ZfaW50XG4gIGVsc2VcbiAgICByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IFwiQWRkcmVzcyBvdXQgb2YgYm91bmRzXCJcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBjb2xvcl9vZl9iaXRzID0gZnVuY3Rpb25cbiAgICB8IDBiMDAgLT4gYFdoaXRlXG4gICAgfCAwYjAxIC0+IGBMaWdodF9ncmF5XG4gICAgfCAwYjEwIC0+IGBEYXJrX2dyYXlcbiAgICB8IDBiMTEgLT4gYEJsYWNrXG4gICAgfCBfICAgIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsZXQgZGF0YSA9IFVpbnQ4LnRvX2ludCBkYXRhIGluXG4gIGlmIGFjY2VwdHMgdCBhZGRyIHRoZW4gYmVnaW5cbiAgICB0LmlkXzAwIDwtIGNvbG9yX29mX2JpdHMgQEAgZGF0YSBsYW5kIDBiMDAwMDAwMTE7XG4gICAgdC5pZF8wMSA8LSBjb2xvcl9vZl9iaXRzIEBAIChkYXRhIGxhbmQgMGIwMDAwMTEwMCkgbHNyIDI7XG4gICAgdC5pZF8xMCA8LSBjb2xvcl9vZl9iaXRzIEBAIChkYXRhIGxhbmQgMGIwMDExMDAwMCkgbHNyIDQ7XG4gICAgdC5pZF8xMSA8LSBjb2xvcl9vZl9iaXRzIEBAIChkYXRhIGxhbmQgMGIxMTAwMDAwMCkgbHNyIDY7XG4gIGVuZCBlbHNlXG4gICAgcmFpc2UgQEAgSW52YWxpZF9hcmd1bWVudCBcIkFkZHJlc3Mgb3V0IG9mIGJvdW5kc1wiXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgc3ByaXRlID0ge1xuICB5X3BvcyA6IGludDtcbiAgeF9wb3MgOiBpbnQ7XG4gIHRpbGVfaW5kZXggOiB1aW50ODtcbiAgcHJpb3JpdHkgOiBbYFNwcml0ZV90b3AgfCBgU3ByaXRlX2JvdHRvbV07XG4gIHlfZmxpcCA6IGJvb2w7XG4gIHhfZmxpcCA6IGJvb2w7XG4gIHBhbGxldGUgOiBbYE9CUDAgfCBgT0JQMV07XG4gIHRpbGVfdnJhbV9iYW5rIDogW2BCYW5rMCB8IGBCYW5rMV07XG4gIHBhbGxldGVfbnVtIDogaW50O1xufVxuXG5sZXQgc2hvd19zcHJpdGUgcyA9XG4gIFByaW50Zi5zcHJpbnRmIFwieV9wb3M6JWQsIHhfcG9zOiVkLCB0aWxlX2luZGV4OiVzLCBwcmlvcml0eTolcywgeV9mbGlwOiViLCB4X2ZsaXA6JWIsIHBhbGxldGU6JXMsIHRpbGVfdnJhbV9iYW5rOiVzLCBwYWxsZXRlX251bTolZFxcblwiXG4gICAgcy55X3Bvc1xuICAgIHMueF9wb3NcbiAgICAoVWludDguc2hvdyBzLnRpbGVfaW5kZXgpXG4gICAgKG1hdGNoIHMucHJpb3JpdHkgd2l0aCBgU3ByaXRlX3RvcCAtPiBcImBTcHJpdGVfdG9wXCIgfCBgU3ByaXRlX2JvdHRvbSAtPiBcImBTcHJpdGVfYm90dG9tXCIpXG4gICAgcy55X2ZsaXBcbiAgICBzLnhfZmxpcFxuICAgIChtYXRjaCBzLnBhbGxldGUgd2l0aCBgT0JQMCAtPiBcImBPQlAwXCIgfCBgT0JQMSAtPiBcImBPQlAxXCIpXG4gICAgKG1hdGNoIHMudGlsZV92cmFtX2Jhbmsgd2l0aCBgQmFuazAgLT4gXCJgQmFuazBcIiB8IGBCYW5rMSAtPiBcImBCYW5rMVwiKVxuICAgIHMucGFsbGV0ZV9udW1cblxudHlwZSB0ID0ge1xuICBzcHJpdGVzIDogc3ByaXRlIGFycmF5O1xuICBzdGFydF9hZGRyIDogdWludDE2O1xuICBlbmRfYWRkciA6IHVpbnQxNjtcbn1cblxubGV0IGNyZWF0ZSB+c3RhcnRfYWRkciB+ZW5kX2FkZHIgPVxuICBsZXQgZGVmYXVsdF9zcHJpdGUgPSB7XG4gICAgeV9wb3MgPSAwO1xuICAgIHhfcG9zID0gMDtcbiAgICB0aWxlX2luZGV4ID0gVWludDguemVybztcbiAgICBwcmlvcml0eSA9IGBTcHJpdGVfdG9wO1xuICAgIHlfZmxpcCA9IGZhbHNlO1xuICAgIHhfZmxpcCA9IGZhbHNlO1xuICAgIHBhbGxldGUgPSBgT0JQMDtcbiAgICB0aWxlX3ZyYW1fYmFuayA9IGBCYW5rMDtcbiAgICBwYWxsZXRlX251bSA9IDA7IH1cbiAgaW5cbiAgbGV0IHNwcml0ZXMgPSBBcnJheS5tYWtlIDQwIGRlZmF1bHRfc3ByaXRlIGluXG4gIHsgc3ByaXRlcztcbiAgICBzdGFydF9hZGRyO1xuICAgIGVuZF9hZGRyOyB9XG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgbGV0IG9mZnNldCA9IFVpbnQxNi50b19pbnQgYWRkciAtIChVaW50MTYudG9faW50IHQuc3RhcnRfYWRkcikgaW5cbiAgbGV0IHNwcml0ZSA9IHQuc3ByaXRlcy4ob2Zmc2V0IC8gNCkgaW5cbiAgbWF0Y2ggb2Zmc2V0IG1vZCA0IHdpdGhcbiAgfCAwIC0+IHNwcml0ZS55X3BvcyArIDE2IHw+IFVpbnQ4Lm9mX2ludFxuICB8IDEgLT4gc3ByaXRlLnhfcG9zICsgIDggfD4gVWludDgub2ZfaW50XG4gIHwgMiAtPiBzcHJpdGUudGlsZV9pbmRleFxuICB8IDMgLT5cbiAgICBCaXRfdXRpbC5ieXRlX29mX2JpdGZsYWdzXG4gICAgICAoc3ByaXRlLnByaW9yaXR5ID0gYFNwcml0ZV9ib3R0b20pXG4gICAgICBzcHJpdGUueV9mbGlwXG4gICAgICBzcHJpdGUueF9mbGlwXG4gICAgICAoc3ByaXRlLnBhbGxldGUgPSBgT0JQMSlcbiAgICAgIChzcHJpdGUudGlsZV92cmFtX2JhbmsgPSBgQmFuazEpXG4gICAgICAoc3ByaXRlLnBhbGxldGVfbnVtIGxhbmQgMGIxMDAgPD4gMClcbiAgICAgIChzcHJpdGUucGFsbGV0ZV9udW0gbGFuZCAwYjAxMCA8PiAwKVxuICAgICAgKHNwcml0ZS5wYWxsZXRlX251bSBsYW5kIDBiMDAxIDw+IDApXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBvZmZzZXQgPSBVaW50MTYudG9faW50IGFkZHIgLSAoVWludDE2LnRvX2ludCB0LnN0YXJ0X2FkZHIpIGluXG4gIGxldCBkYXRhJyA9IFVpbnQ4LnRvX2ludCBkYXRhIGluXG4gIGxldCBzcHJpdGVfaW5kZXggPSBvZmZzZXQgLyA0IGluXG4gIG1hdGNoIG9mZnNldCBtb2QgNCB3aXRoXG4gIHwgMCAtPlxuICAgIHQuc3ByaXRlcy4oc3ByaXRlX2luZGV4KSA8LSB7dC5zcHJpdGVzLihzcHJpdGVfaW5kZXgpIHdpdGggeV9wb3MgPSAoZGF0YScgLSAxNil9XG4gIHwgMSAtPlxuICAgIHQuc3ByaXRlcy4oc3ByaXRlX2luZGV4KSA8LSB7dC5zcHJpdGVzLihzcHJpdGVfaW5kZXgpIHdpdGggeF9wb3MgPSAoZGF0YScgLSA4KX1cbiAgfCAyIC0+XG4gICAgdC5zcHJpdGVzLihzcHJpdGVfaW5kZXgpIDwtIHt0LnNwcml0ZXMuKHNwcml0ZV9pbmRleCkgd2l0aCB0aWxlX2luZGV4ID0gZGF0YX1cbiAgfCAzIC0+XG4gICAgbGV0IChiNywgeV9mbGlwLCB4X2ZsaXAsIGI0LCBiMywgYjIsIGIxLCBiMCkgPSBkYXRhIHw+IEJpdF91dGlsLmJpdGZsYWdzX29mX2J5dGUgaW5cbiAgICBsZXQgcHJpb3JpdHkgPSBpZiBiNyB0aGVuIGBTcHJpdGVfYm90dG9tIGVsc2UgYFNwcml0ZV90b3AgaW5cbiAgICBsZXQgcGFsbGV0ZSA9IGlmIGI0IHRoZW4gYE9CUDEgZWxzZSBgT0JQMCBpblxuICAgIGxldCB0aWxlX3ZyYW1fYmFuayA9IGlmIGIzIHRoZW4gYEJhbmsxIGVsc2UgYEJhbmswIGluXG4gICAgbGV0IHBhbGxldGVfbnVtID0gKEJvb2wudG9faW50IGIyIGxzbCAyKSBsb3IgKEJvb2wudG9faW50IGIxIGxzbCAxKSBsb3IgKEJvb2wudG9faW50IGIwKSBpblxuICAgIHQuc3ByaXRlcy4oc3ByaXRlX2luZGV4KSA8LVxuICAgICAgeyB0LnNwcml0ZXMuKHNwcml0ZV9pbmRleCkgd2l0aFxuICAgICAgICB5X2ZsaXA7IHhfZmxpcDsgcHJpb3JpdHk7IHBhbGxldGU7IHRpbGVfdnJhbV9iYW5rOyBwYWxsZXRlX251bTsgfVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhY2NlcHRzIHQgYWRkciA9IFVpbnQxNi4odC5zdGFydF9hZGRyIDw9IGFkZHIgJiYgYWRkciA8PSB0LmVuZF9hZGRyKVxuXG5sZXQgZ2V0X2FsbF9zcHJpdGVzIHQgPSB0LnNwcml0ZXNcblxubGV0IHdyaXRlX3dpdGhfb2Zmc2V0IHQgfm9mZnNldCB+ZGF0YSA9XG4gIHdyaXRlX2J5dGUgdCB+YWRkcjpVaW50MTYuKHQuc3RhcnRfYWRkciArIG9mX2ludCBvZmZzZXQpIH5kYXRhXG4iLCJ0eXBlIHQgPVxuICB8IE9BTV9zZWFyY2ggICAgICgqIE1vZGUgMi4gU2VhcmNoIE9BTSBmb3Igc3ByaXRlcyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBvbiBjdXJyZW50IHNjYW5saW5lICopXG4gIHwgUGl4ZWxfdHJhbnNmZXIgKCogTW9kZSAzLiBUcmFuc2ZlciBwaXhlcyB0byBMQ0QgKilcbiAgfCBIQmxhbmsgICAgICAgICAoKiBNb2RlIDAuIEhvcml6b250YWwgYmxhbmsgKilcbiAgfCBWQmxhbmsgICAgICAgICAoKiBNb2RlIDEuIFZlcnRpY2FsIGJsYW5rICopXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IE9BTV9zZWFyY2ggLT4gMlxuICB8IFBpeGVsX3RyYW5zZmVyIC0+IDNcbiAgfCBIQmxhbmsgLT4gMFxuICB8IFZCbGFuayAtPiAxXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgdCA9IHtcbiAgYWRkciA6IHVpbnQxNjtcbiAgKCogYml0IDcgKilcbiAgbXV0YWJsZSBsY2RfZW5hYmxlIDogYm9vbDtcbiAgKCogYml0IDYgKilcbiAgbXV0YWJsZSB3aW5kb3dfdGlsZV9tYXBfYXJlYSA6IFRpbGVfbWFwLmFyZWE7XG4gICgqIGJpdCA1ICopXG4gIG11dGFibGUgd2luZG93X2VuYWJsZSA6IGJvb2w7XG4gICgqIGJpdCA0ICopXG4gIG11dGFibGUgdGlsZV9kYXRhX2FyZWEgOiAgVGlsZV9kYXRhLmFyZWE7XG4gICgqIGJpdCAzICopXG4gIG11dGFibGUgYmdfdGlsZV9tYXBfYXJlYSA6IFRpbGVfbWFwLmFyZWE7XG4gICgqIGJpdCAyICopXG4gIG11dGFibGUgb2JqX3NpemUgOiBbYF84eDggfCBgXzh4MTZdO1xuICAoKiBiaXQgMSAqKVxuICBtdXRhYmxlIG9ial9lbmFibGUgOiBib29sO1xuICAoKiBiaXQgMCAqKVxuICBtdXRhYmxlIGJnX3dpbmRvd19kaXNwbGF5IDogYm9vbDtcbn1cblxubGV0IGNyZWF0ZSB+YWRkciA9IHtcbiAgYWRkcjtcbiAgbGNkX2VuYWJsZSA9IHRydWU7XG4gIHdpbmRvd190aWxlX21hcF9hcmVhID0gVGlsZV9tYXAuQXJlYTA7XG4gIHdpbmRvd19lbmFibGUgPSBmYWxzZTtcbiAgdGlsZV9kYXRhX2FyZWEgPSBUaWxlX2RhdGEuQXJlYTE7XG4gIGJnX3RpbGVfbWFwX2FyZWEgPSBUaWxlX21hcC5BcmVhMDtcbiAgb2JqX3NpemUgPSBgXzh4ODtcbiAgb2JqX2VuYWJsZSA9IGZhbHNlO1xuICBiZ193aW5kb3dfZGlzcGxheSA9IHRydWU7XG59XG5cbmxldCBnZXRfbGNkX2VuYWJsZSB0ID0gdC5sY2RfZW5hYmxlXG5cbmxldCBnZXRfd2luZG93X3RpbGVfbWFwX2FyZWEgdCA9IHQud2luZG93X3RpbGVfbWFwX2FyZWFcblxubGV0IGdldF93aW5kb3dfZW5hYmxlIHQgPSB0LndpbmRvd19lbmFibGVcblxubGV0IGdldF90aWxlX2RhdGFfYXJlYSB0ID0gdC50aWxlX2RhdGFfYXJlYVxuXG5sZXQgZ2V0X2JnX3RpbGVfbWFwX2FyZWEgdCA9IHQuYmdfdGlsZV9tYXBfYXJlYVxuXG5sZXQgZ2V0X29ial9zaXplIHQgPSB0Lm9ial9zaXplXG5cbmxldCBnZXRfb2JqX2VuYWJsZSB0ID0gdC5vYmpfZW5hYmxlXG5cbmxldCBnZXRfYmdfd2luZG93X2Rpc3BsYXkgdCA9IHQuYmdfd2luZG93X2Rpc3BsYXlcblxubGV0IGFjY2VwdHMgdCBhZGRyID0gVWludDE2LihhZGRyID0gdC5hZGRyKVxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGlmIGFjY2VwdHMgdCBhZGRyIHRoZW4gYmVnaW5cbiAgICBCaXRfdXRpbC5ieXRlX29mX2JpdGZsYWdzXG4gICAgICB0LmxjZF9lbmFibGVcbiAgICAgICh0LndpbmRvd190aWxlX21hcF9hcmVhID0gVGlsZV9tYXAuQXJlYTEpXG4gICAgICB0LndpbmRvd19lbmFibGVcbiAgICAgICh0LnRpbGVfZGF0YV9hcmVhID0gVGlsZV9kYXRhLkFyZWExKVxuICAgICAgKHQuYmdfdGlsZV9tYXBfYXJlYSA9IFRpbGVfbWFwLkFyZWExKVxuICAgICAgKHQub2JqX3NpemUgPSBgXzh4MTYpXG4gICAgICB0Lm9ial9lbmFibGVcbiAgICAgIHQuYmdfd2luZG93X2Rpc3BsYXlcbiAgZW5kIGVsc2VcbiAgICByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IFwiQWRkcmVzcyBvdXQgb2YgYm91bmRzXCJcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGlmIGFjY2VwdHMgdCBhZGRyIHRoZW4gYmVnaW5cbiAgICBsZXQgKGI3LCBiNiwgYjUsIGI0LCBiMywgYjIsIGIxLCBiMCkgPSBCaXRfdXRpbC5iaXRmbGFnc19vZl9ieXRlIGRhdGEgaW5cbiAgICB0LmxjZF9lbmFibGUgPC0gYjc7XG4gICAgdC53aW5kb3dfdGlsZV9tYXBfYXJlYSA8LSBpZiBiNiB0aGVuIEFyZWExIGVsc2UgQXJlYTA7XG4gICAgdC53aW5kb3dfZW5hYmxlIDwtIGI1O1xuICAgIHQudGlsZV9kYXRhX2FyZWEgPC0gaWYgYjQgdGhlbiBBcmVhMSBlbHNlIEFyZWEwO1xuICAgIHQuYmdfdGlsZV9tYXBfYXJlYSA8LSBpZiBiMyB0aGVuIEFyZWExIGVsc2UgQXJlYTA7XG4gICAgdC5vYmpfc2l6ZSA8LSBpZiBiMiB0aGVuIGBfOHgxNiBlbHNlIGBfOHg4O1xuICAgIHQub2JqX2VuYWJsZSA8LSBiMTtcbiAgICB0LmJnX3dpbmRvd19kaXNwbGF5IDwtIGIwO1xuICBlbmQgZWxzZVxuICAgIHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgXCJBZGRyZXNzIG91dCBvZiBib3VuZHNcIlxuIiwib3BlbiBVaW50c1xuXG50eXBlIHJlZ2lzdGVyID0ge1xuICBhZGRyICA6IHVpbnQxNjtcbiAgbXV0YWJsZSB2YWx1ZSA6IGludDtcbn1cblxudHlwZSB0ID0ge1xuICBzY3kgOiByZWdpc3RlcjtcbiAgc2N4IDogcmVnaXN0ZXI7XG4gIGx5ICA6IHJlZ2lzdGVyO1xuICBseWMgOiByZWdpc3RlcjtcbiAgd3kgIDogcmVnaXN0ZXI7XG4gIHd4ICA6IHJlZ2lzdGVyO1xufVxuXG5sZXQgY3JlYXRlIH5zY3lfYWRkciB+c2N4X2FkZHIgfmx5X2FkZHIgfmx5Y19hZGRyIH53eV9hZGRyIH53eF9hZGRyID0ge1xuICBzY3kgPSB7IGFkZHIgPSBzY3lfYWRkcjsgdmFsdWUgPSAwIH07XG4gIHNjeCA9IHsgYWRkciA9IHNjeF9hZGRyOyB2YWx1ZSA9IDAgfTtcbiAgbHkgID0geyBhZGRyID0gIGx5X2FkZHI7IHZhbHVlID0gMCB9O1xuICBseWMgPSB7IGFkZHIgPSBseWNfYWRkcjsgdmFsdWUgPSAwIH07XG4gIHd5ICA9IHsgYWRkciA9ICB3eV9hZGRyOyB2YWx1ZSA9IDAgfTtcbiAgd3ggID0geyBhZGRyID0gIHd4X2FkZHI7IHZhbHVlID0gMCB9O1xufVxuXG5sZXQgZ2V0X3NjeSB0ID0gdC5zY3kudmFsdWVcbmxldCBnZXRfc2N4IHQgPSB0LnNjeC52YWx1ZVxubGV0IGdldF9seSB0ID0gdC5seS52YWx1ZVxubGV0IGluY3JfbHkgdCA9IHQubHkudmFsdWUgPC0gdC5seS52YWx1ZSArIDFcbmxldCByZXNldF9seSB0ID0gdC5seS52YWx1ZSA8LSAwXG5sZXQgZ2V0X2x5YyB0ID0gdC5seWMudmFsdWVcbmxldCBnZXRfd3kgdCA9IHQud3kudmFsdWVcbmxldCBnZXRfd3ggdCA9IHQud3gudmFsdWVcblxuXG5sZXQgYWNjZXB0cyB0IGFkZHIgPVxuICBbdC5zY3kuYWRkcjsgdC5zY3guYWRkcjsgdC5seS5hZGRyOyB0Lmx5Yy5hZGRyOyB0Lnd5LmFkZHI7IHQud3guYWRkcl1cbiAgfD4gTGlzdC5leGlzdHMgKGZ1biB4IC0+IFVpbnQxNi4oYWRkciA9IHgpKVxuXG5sZXQgcmVnaXN0ZXJfb2ZfYWRkciB0IGFkZHIgPVxuICBsZXQgb3BlbiBVaW50MTYgaW5cbiAgbWF0Y2ggYWRkciB3aXRoXG4gIHwgXyB3aGVuIGFkZHIgPSB0LnNjeS5hZGRyIC0+IHQuc2N5XG4gIHwgXyB3aGVuIGFkZHIgPSB0LnNjeC5hZGRyIC0+IHQuc2N4XG4gIHwgXyB3aGVuIGFkZHIgPSB0Lmx5LmFkZHIgIC0+IHQubHlcbiAgfCBfIHdoZW4gYWRkciA9IHQubHljLmFkZHIgLT4gdC5seWNcbiAgfCBfIHdoZW4gYWRkciA9IHQud3guYWRkciAgLT4gdC53eFxuICB8IF8gd2hlbiBhZGRyID0gdC53eS5hZGRyICAtPiB0Lnd5XG4gIHwgXyAtPiByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IChQcmludGYuc3ByaW50ZiBcIkFkZHJlc3Mgb3V0IG9mIHJhbmdlOiAlc1wiIChVaW50MTYuc2hvdyBhZGRyKSlcblxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGxldCByID0gcmVnaXN0ZXJfb2ZfYWRkciB0IGFkZHIgaW5cbiAgci52YWx1ZSB8PiBVaW50OC5vZl9pbnRcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGlmIFVpbnQxNi4oYWRkciA9IHQubHkuYWRkcikgdGhlblxuICAgICgqIEFueSB3cml0ZSB0byBMWSByZXNldHMgaXQgdG8gMCAqKVxuICAgIHQubHkudmFsdWUgPC0gMFxuICBlbHNlXG4gICAgbGV0IHIgPSByZWdpc3Rlcl9vZl9hZGRyIHQgYWRkciBpblxuICAgIHIudmFsdWUgPC0gVWludDgudG9faW50IGRhdGFcbiIsIm9wZW4gVWludHNcblxudHlwZSB0ID0ge1xuICBhZGRyIDogdWludDE2O1xuICBtdXRhYmxlIGx5Y19lcV9seV9pbnRfZW5hYmxlZCA6IGJvb2w7XG4gIG11dGFibGUgb2FtX2ludF9lbmFibGVkICAgICAgIDogYm9vbDtcbiAgbXV0YWJsZSB2YmxhbmtfaW50X2VuYWJsZWQgICAgOiBib29sO1xuICBtdXRhYmxlIGhibGFua19pbnRfZW5hYmxlZCAgICA6IGJvb2w7XG4gIG11dGFibGUgbHljX2VxX2x5X2ZsYWcgICAgICAgIDogYm9vbDtcbiAgbXV0YWJsZSBncHVfbW9kZSAgICAgICAgICAgICAgOiBHcHVfbW9kZS50O1xufVxuXG50eXBlIHN0YXRfaW50ZXJ1cHRfc291cmNlID1cbiAgfCBMWUNfZXFfTFlcbiAgfCBPQU1cbiAgfCBWQmxhbmtcbiAgfCBIQmxhbmtcblxubGV0IGNyZWF0ZSB+YWRkciA9IHtcbiAgYWRkcjtcbiAgbHljX2VxX2x5X2ludF9lbmFibGVkID0gZmFsc2U7XG4gIG9hbV9pbnRfZW5hYmxlZCAgICAgICA9IGZhbHNlO1xuICB2YmxhbmtfaW50X2VuYWJsZWQgICAgPSBmYWxzZTtcbiAgaGJsYW5rX2ludF9lbmFibGVkICAgID0gZmFsc2U7XG4gIGx5Y19lcV9seV9mbGFnICAgICAgICA9IGZhbHNlO1xuICBncHVfbW9kZSAgICAgICAgICAgICAgPSBPQU1fc2VhcmNoO1xufVxuXG5sZXQgaXNfZW5hYmxlZCB0ID0gZnVuY3Rpb25cbiAgfCBMWUNfZXFfTFkgLT4gdC5seWNfZXFfbHlfaW50X2VuYWJsZWRcbiAgfCBPQU0gICAgICAgLT4gdC5vYW1faW50X2VuYWJsZWRcbiAgfCBWQmxhbmsgICAgLT4gdC52YmxhbmtfaW50X2VuYWJsZWRcbiAgfCBIQmxhbmsgICAgLT4gdC5oYmxhbmtfaW50X2VuYWJsZWRcblxubGV0IGdldF9seWNfZXFfbHlfZmxhZyB0ID0gdC5seWNfZXFfbHlfZmxhZ1xuXG5sZXQgc2V0X2x5Y19lcV9seV9mbGFnIHQgYiA9IHQubHljX2VxX2x5X2ZsYWcgPC0gYlxuXG5sZXQgZ2V0X2dwdV9tb2RlIHQgPSB0LmdwdV9tb2RlXG5cbmxldCBzZXRfZ3B1X21vZGUgdCBtb2RlID0gdC5ncHVfbW9kZSA8LSBtb2RlXG5cbmxldCBhY2NlcHRzIHQgYWRkciA9IFVpbnQxNi4oYWRkciA9IHQuYWRkcilcblxubGV0IHJlYWRfYnl0ZSB0IGFkZHIgPVxuICBpZiBhY2NlcHRzIHQgYWRkciB0aGVuIGJlZ2luXG4gICAgbGV0IChiMSwgYjApID0gbWF0Y2ggdC5ncHVfbW9kZSB3aXRoXG4gICAgICB8IEhCbGFuayAtPiAoZmFsc2UsIGZhbHNlKVxuICAgICAgfCBWQmxhbmsgLT4gKGZhbHNlLCB0cnVlKVxuICAgICAgfCBPQU1fc2VhcmNoIC0+ICh0cnVlLCBmYWxzZSlcbiAgICAgIHwgUGl4ZWxfdHJhbnNmZXIgLT4gKHRydWUsIHRydWUpXG4gICAgaW5cbiAgICBCaXRfdXRpbC5ieXRlX29mX2JpdGZsYWdzXG4gICAgICB0cnVlICgqIGJpdCA3IGlzIGFsd2F5cyB0cnVlICopXG4gICAgICAoaXNfZW5hYmxlZCB0IExZQ19lcV9MWSlcbiAgICAgIChpc19lbmFibGVkIHQgT0FNKVxuICAgICAgKGlzX2VuYWJsZWQgdCBWQmxhbmspXG4gICAgICAoaXNfZW5hYmxlZCB0IEhCbGFuaylcbiAgICAgIHQubHljX2VxX2x5X2ZsYWdcbiAgICAgIGIxXG4gICAgICBiMFxuICBlbmQgZWxzZVxuICAgIHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgXCJBZGRyZXNzIG91dCBvZiBib3VuZHNcIlxuXG5sZXQgd3JpdGVfYnl0ZSB0IH5hZGRyIH5kYXRhID1cbiAgaWYgYWNjZXB0cyB0IGFkZHIgdGhlbiBiZWdpblxuICAgIGxldCAoXywgYjYsIGI1LCBiNCwgYjMsIF8sIF8sIF8pID0gQml0X3V0aWwuYml0ZmxhZ3Nfb2ZfYnl0ZSBkYXRhIGluXG4gICAgdC5seWNfZXFfbHlfaW50X2VuYWJsZWQgPC0gYjY7XG4gICAgdC5vYW1faW50X2VuYWJsZWQgPC0gYjU7XG4gICAgdC52YmxhbmtfaW50X2VuYWJsZWQgPC0gYjQ7XG4gICAgdC5oYmxhbmtfaW50X2VuYWJsZWQgPC0gYjNcbiAgZW5kIGVsc2VcbiAgICByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IFwiQWRkcmVzcyBvdXQgb2YgYm91bmRzXCJcblxubGV0IHBlZWsgdCA9IHJlYWRfYnl0ZSB0IHQuYWRkclxuIiwib3BlbiBVaW50c1xub3BlbiBTdGRMYWJlbHNcblxudHlwZSBzdGF0ZSA9XG4gIHwgRW5hYmxlZFxuICB8IERpc2FibGVkXG4gIHwgSEJsYW5rX2FmdGVyX2VuYWJsZWRcblxudHlwZSB0ID0ge1xuICB0ZCA6IFRpbGVfZGF0YS50O1xuICB0bSA6IFRpbGVfbWFwLnQ7XG4gIG9hbSA6IE9hbV90YWJsZS50O1xuICBiZ3AgOiBQYWxsZXRlLnQ7ICgqIEJHIHBhbGV0dGUgZGF0YSAqKVxuICBvYnAwIDogUGFsbGV0ZS50OyAoKiBPQkogcGFsbGV0ZSAwIGRhdGEgICopXG4gIG9icDEgOiBQYWxsZXRlLnQ7ICgqIE9CSiBwYWxsZXRlIDEgZGF0YSAgKilcbiAgbHMgOiBMY2Rfc3RhdC50O1xuICBsYyA6IExjZF9jb250cm9sLnQ7XG4gIGxwIDogTGNkX3Bvc2l0aW9uLnQ7XG4gIGljIDogSW50ZXJydXB0X2NvbnRyb2xsZXIudDtcbiAgbXV0YWJsZSBtY3ljbGVzX2luX21vZGUgOiBpbnQ7ICgqIG51bWJlciBvZiBteWN5Y2xlcyBjb25zdW1lZCBpbiBjdXJyZW50IG1vZGUgKilcbiAgbXV0YWJsZSBzdGF0ZSA6IHN0YXRlO1xuICBmcmFtZV9idWZmZXIgOiBbYFdoaXRlIHwgYExpZ2h0X2dyYXkgfCBgRGFya19ncmF5IHwgYEJsYWNrIF0gYXJyYXkgYXJyYXk7ICgqIGZyYW1lX2J1ZmZlci4oeSkuKHgpIDo9ICBjb2xvciBvZiB5dGggcm93IGFuZCB4dGggY29sdW1uKilcbn1cblxuKCogY2hlY2sgaWYgTFk9TFlDIGFuZCBzZXQgbGNkX3N0YXQgYW5kIHJlcXVlc3QgaW50ZXJydXB0IGFjY29yZGluZ2x5KilcbmxldCBoYW5kbGVfbHlfZXFfbHljIHQgPVxuICBsZXQgbHkgPSBMY2RfcG9zaXRpb24uZ2V0X2x5IHQubHAgaW5cbiAgbGV0IGx5YyA9IExjZF9wb3NpdGlvbi5nZXRfbHljIHQubHAgaW5cbiAgbGV0IGx5X2VxX2x5YyA9IGx5ID0gbHljIGluXG4gIExjZF9zdGF0LnNldF9seWNfZXFfbHlfZmxhZyB0LmxzIGx5X2VxX2x5YztcbiAgaWYgbHlfZXFfbHljICYmIExjZF9zdGF0LmlzX2VuYWJsZWQgdC5scyBMWUNfZXFfTFkgdGhlblxuICAgIEludGVycnVwdF9jb250cm9sbGVyLnJlcXVlc3QgdC5pYyBMQ0Rfc3RhdFxuXG5sZXQgc2NyZWVuX3cgPSAxNjBcbmxldCBzY3JlZW5faCA9IDE0NFxubGV0IGJnX3doID0gMjU2XG5sZXQgd2luZG93X3doID0gMjU2XG5cbmxldCBjcmVhdGVcbiAgICB+dGlsZV9kYXRhXG4gICAgfnRpbGVfbWFwXG4gICAgfm9hbVxuICAgIH5iZ3BcbiAgICB+b2JwMFxuICAgIH5vYnAxXG4gICAgfmxjZF9zdGF0XG4gICAgfmxjZF9jb250cm9sXG4gICAgfmxjZF9wb3NpdGlvblxuICAgIH5pY1xuICA9XG4gIGxldCB0ID0ge1xuICAgIHRkID0gdGlsZV9kYXRhO1xuICAgIHRtID0gdGlsZV9tYXA7XG4gICAgb2FtO1xuICAgIGJncDtcbiAgICBvYnAwO1xuICAgIG9icDE7XG4gICAgbHMgPSBsY2Rfc3RhdDtcbiAgICBsYyA9IGxjZF9jb250cm9sO1xuICAgIGxwID0gbGNkX3Bvc2l0aW9uO1xuICAgIG1jeWNsZXNfaW5fbW9kZSA9IDA7XG4gICAgc3RhdGUgPSBFbmFibGVkO1xuICAgIGljO1xuICAgIGZyYW1lX2J1ZmZlciA9IEFycmF5Lm1ha2VfbWF0cml4IH5kaW14OnNjcmVlbl9oIH5kaW15OnNjcmVlbl93IGBXaGl0ZTsgfVxuICBpblxuICBoYW5kbGVfbHlfZXFfbHljIHQ7XG4gIHRcblxubGV0IHNldF9tY3ljbGVzX2luX21vZGUgdCBtY3ljbGVzX2luX21vZGUgPSB0Lm1jeWNsZXNfaW5fbW9kZSA8LSBtY3ljbGVzX2luX21vZGVcblxubGV0IGdldF9mcmFtZV9idWZmZXIgdCA9IHQuZnJhbWVfYnVmZmVyXG5cbmxldCByZW5kZXJfYmdfd2luZG93X2xpbmUgdCBseSA9XG4gIGxldCByZW5kZXJfYmdfbGluZSB0IGx5IHRpbGVfZGF0YV9hcmVhID1cbiAgICBsZXQgc2N5ID0gTGNkX3Bvc2l0aW9uLmdldF9zY3kgdC5scCBpblxuICAgIGxldCBzY3ggPSBMY2RfcG9zaXRpb24uZ2V0X3NjeCB0LmxwIGluXG4gICAgbGV0IHkgPSAoc2N5ICsgbHkpIG1vZCBiZ193aCBpblxuICAgIGxldCBiZ190aWxlX21hcF9hcmVhICA9IExjZF9jb250cm9sLmdldF9iZ190aWxlX21hcF9hcmVhIHQubGMgaW5cbiAgICBsZXQgcm93X2luX3RpbGUgPSB5IG1vZCA4IGluXG4gICAgbGV0IGx4ID0gcmVmIDAgaW5cbiAgICB3aGlsZSAhbHggPCBzY3JlZW5fdyBkb1xuICAgICAgbGV0IHggPSAoc2N4ICsgIWx4KSBtb2QgYmdfd2ggaW5cbiAgICAgIGxldCBjb2xfaW5fdGlsZSA9IHggbW9kIDggaW5cbiAgICAgIGxldCB0aWxlX2luZGV4ID0gVGlsZV9tYXAuZ2V0X3RpbGVfaW5kZXggdC50bSB+YXJlYTpiZ190aWxlX21hcF9hcmVhIH55IH54IGluXG4gICAgICBsZXQgdGlsZV9waXhlbF9yb3cgPSBUaWxlX2RhdGEuZ2V0X3Jvd19waXhlbHMgdC50ZFxuICAgICAgICAgIH5pbmRleDp0aWxlX2luZGV4XG4gICAgICAgICAgfmFyZWE6dGlsZV9kYXRhX2FyZWFcbiAgICAgICAgICB+cm93OnJvd19pbl90aWxlXG4gICAgICBpblxuICAgICAgbGV0IGxlbiA9XG4gICAgICAgIGlmIGNvbF9pbl90aWxlID4gMCB0aGVuICgqIGxlZnQgZWRnZSBvZiB0aGUgdmlldyBwb3J0ICopXG4gICAgICAgICAgOCAtIGNvbF9pbl90aWxlXG4gICAgICAgIGVsc2UgaWYgc2NyZWVuX3cgLSAhbHggPCA4IHRoZW4gKCogcmlnaHQgZWRnZSBvZiB0aGUgdmlldyBwb3J0ICopXG4gICAgICAgICAgc2NyZWVuX3cgLSAhbHhcbiAgICAgICAgZWxzZVxuICAgICAgICAgIDhcbiAgICAgIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSAgZG9cbiAgICAgICAgbGV0IGNvbG9yID0gUGFsbGV0ZS5sb29rdXAgdC5iZ3AgdGlsZV9waXhlbF9yb3cuKGNvbF9pbl90aWxlICsgaSkgaW5cbiAgICAgICAgdC5mcmFtZV9idWZmZXIuKGx5KS4oIWx4ICsgaSkgPC0gY29sb3JcbiAgICAgIGRvbmU7XG4gICAgICBseCA6PSAhbHggKyBsZW47XG4gICAgZG9uZVxuICBpblxuICBsZXQgcmVuZGVyX3dpbmRvd19saW5lIHQgbHkgdGlsZV9kYXRhX2FyZWEgPVxuICAgIGxldCB3eSA9IExjZF9wb3NpdGlvbi5nZXRfd3kgdC5scCBpblxuICAgIGxldCB3eCA9IExjZF9wb3NpdGlvbi5nZXRfd3ggdC5scCAtIDcgaW5cbiAgICBpZiB3eSA8PSBseSAmJiBseSA8PSB3eSArIHdpbmRvd193aCAmJiB3eCA8PSBzY3JlZW5fdyB0aGVuXG4gICAgICBsZXQgd2luZG93X3RpbGVfbWFwX2FyZWEgPSBMY2RfY29udHJvbC5nZXRfd2luZG93X3RpbGVfbWFwX2FyZWEgdC5sYyBpblxuICAgICAgbGV0IHlfaW5fdyA9IChJbnQuYWJzIChseSAtIHd5KSkgaW5cbiAgICAgIGxldCByb3dfaW5fdGlsZSA9IHlfaW5fdyBtb2QgOCBpblxuICAgICAgbGV0IGx4ID0gcmVmIChpZiB3eCA8IDAgdGhlbiAwIGVsc2Ugd3gpIGluXG4gICAgICB3aGlsZSAhbHggPCBzY3JlZW5fdyBkb1xuICAgICAgICBsZXQgeF9pbl93ID0gSW50LmFicyAoIWx4IC0gd3gpIGluXG4gICAgICAgIGxldCB0aWxlX2luZGV4ID0gVGlsZV9tYXAuZ2V0X3RpbGVfaW5kZXggdC50bVxuICAgICAgICAgICAgfmFyZWE6d2luZG93X3RpbGVfbWFwX2FyZWFcbiAgICAgICAgICAgIH55OnlfaW5fd1xuICAgICAgICAgICAgfng6eF9pbl93XG4gICAgICAgIGluXG4gICAgICAgIGxldCB0aWxlX3BpeGVsX3JvdyA9IFRpbGVfZGF0YS5nZXRfcm93X3BpeGVscyB0LnRkXG4gICAgICAgICAgICB+aW5kZXg6dGlsZV9pbmRleFxuICAgICAgICAgICAgfmFyZWE6dGlsZV9kYXRhX2FyZWFcbiAgICAgICAgICAgIH5yb3c6cm93X2luX3RpbGVcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGxlbiA9IGlmIHNjcmVlbl93IC0gIWx4IDwgOCB0aGVuIHNjcmVlbl93IC0gIWx4IGVsc2UgOCBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSAgZG9cbiAgICAgICAgICBsZXQgY29sb3IgPSBQYWxsZXRlLmxvb2t1cCB0LmJncCB0aWxlX3BpeGVsX3Jvdy4oaSkgaW5cbiAgICAgICAgICB0LmZyYW1lX2J1ZmZlci4obHkpLighbHggKyBpKSA8LSBjb2xvclxuICAgICAgICBkb25lO1xuICAgICAgICBseCA6PSAhbHggKyBsZW47XG4gICAgICBkb25lXG4gIGluXG4gIGxldCB0aWxlX2RhdGFfYXJlYSA9IExjZF9jb250cm9sLmdldF90aWxlX2RhdGFfYXJlYSB0LmxjIGluXG4gIHJlbmRlcl9iZ19saW5lIHQgbHkgdGlsZV9kYXRhX2FyZWE7XG4gIGlmIExjZF9jb250cm9sLmdldF93aW5kb3dfZW5hYmxlIHQubGMgdGhlblxuICAgIHJlbmRlcl93aW5kb3dfbGluZSB0IGx5IHRpbGVfZGF0YV9hcmVhXG5cblxubGV0IHJlbmRlcl9zcHJpdGVfbGluZSB0IGx5ID1cbiAgbGV0IG9wZW4gT2FtX3RhYmxlIGluXG4gIGxldCB5X3Nwcml0ZV9zaXplID0gbWF0Y2ggTGNkX2NvbnRyb2wuZ2V0X29ial9zaXplIHQubGMgd2l0aFxuICAgIHwgYF84eDggIC0+IDhcbiAgICB8IGBfOHgxNiAtPiAxNlxuICBpblxuICBPYW1fdGFibGUuZ2V0X2FsbF9zcHJpdGVzIHQub2FtXG4gIHw+IEFycmF5Lml0ZXIgfmY6KGZ1biBzcHJpdGUgLT5cbiAgICAgIGlmIHNwcml0ZS55X3BvcyA8PSBseSAmJiBseSA8PSBzcHJpdGUueV9wb3MgKyB5X3Nwcml0ZV9zaXplIC0gMSB0aGVuXG4gICAgICAgIGxldCByb3cgPSBseSAtIHNwcml0ZS55X3BvcyBpblxuICAgICAgICBsZXQgcGFsbGV0ZSA9IG1hdGNoIHNwcml0ZS5wYWxsZXRlIHdpdGhcbiAgICAgICAgICB8IGBPQlAwIC0+IHQub2JwMFxuICAgICAgICAgIHwgYE9CUDEgLT4gdC5vYnAxXG4gICAgICAgIGluXG4gICAgICAgIGZvciBjb2wgPSAwIHRvIDcgZG9cbiAgICAgICAgICBsZXQgbHggPSBzcHJpdGUueF9wb3MgKyBjb2wgaW5cbiAgICAgICAgICBpZiBseCA8IDAgfHwgbHggPj0gc2NyZWVuX3cgdGhlblxuICAgICAgICAgICAgKClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgY29sb3JfaWQgPSBUaWxlX2RhdGEuZ2V0X3BpeGVsIHQudGRcbiAgICAgICAgICAgICAgICB+YXJlYTpBcmVhMVxuICAgICAgICAgICAgICAgIH5pbmRleDpzcHJpdGUudGlsZV9pbmRleFxuICAgICAgICAgICAgICAgIH5yb3c6KGlmIHNwcml0ZS55X2ZsaXAgdGhlbiB5X3Nwcml0ZV9zaXplIC0gcm93IC0gMSBlbHNlIHJvdylcbiAgICAgICAgICAgICAgICB+Y29sOihpZiBzcHJpdGUueF9mbGlwIHRoZW4gNyAtIGNvbCBlbHNlIGNvbClcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBtYXRjaCBjb2xvcl9pZCB3aXRoXG4gICAgICAgICAgICB8IElEXzAwIC0+XG4gICAgICAgICAgICAgICgpICgqIHRyYW5zcGFyYW50ICopXG4gICAgICAgICAgICB8IElEXzAxIHwgSURfMTAgfCBJRF8xMSAtPlxuICAgICAgICAgICAgICBtYXRjaCBzcHJpdGUucHJpb3JpdHksIHQuZnJhbWVfYnVmZmVyLihseSkuKGx4KSB3aXRoXG4gICAgICAgICAgICAgIHwgYFNwcml0ZV90b3AsIF9cbiAgICAgICAgICAgICAgfCBfLCBgV2hpdGUgLT5cbiAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBQYWxsZXRlLmxvb2t1cCBwYWxsZXRlIGNvbG9yX2lkIGluXG4gICAgICAgICAgICAgICAgdC5mcmFtZV9idWZmZXIuKGx5KS4obHgpIDwtIGNvbG9yXG4gICAgICAgICAgICAgIHwgYFNwcml0ZV9ib3R0b20sIGBCbGFja1xuICAgICAgICAgICAgICB8IGBTcHJpdGVfYm90dG9tLCBgRGFya19ncmF5XG4gICAgICAgICAgICAgIHwgYFNwcml0ZV9ib3R0b20sIGBMaWdodF9ncmF5IC0+XG4gICAgICAgICAgICAgICAgKClcbiAgICAgICAgZG9uZSlcblxubGV0IHJlbmRlcl9saW5lIHQgPVxuICBsZXQgbHkgPSBMY2RfcG9zaXRpb24uZ2V0X2x5IHQubHAgaW5cbiAgaWYgTGNkX2NvbnRyb2wuZ2V0X2JnX3dpbmRvd19kaXNwbGF5IHQubGMgdGhlbiBiZWdpblxuICAgIHJlbmRlcl9iZ193aW5kb3dfbGluZSB0IGx5O1xuICBlbmQ7XG4gIGlmIExjZF9jb250cm9sLmdldF9vYmpfZW5hYmxlIHQubGMgdGhlblxuICAgIHJlbmRlcl9zcHJpdGVfbGluZSB0IGx5XG5cbnR5cGUgcnVuX3Jlc3VsdCA9XG4gIHwgSW5fZnJhbWVcbiAgfCBGcmFtZV9lbmRlZCBvZiBbYFdoaXRlIHwgYExpZ2h0X2dyYXkgfCBgRGFya19ncmF5IHwgYEJsYWNrIF0gYXJyYXkgYXJyYXlcblxubGV0IHJ1biB0IH5tY3ljbGVzID1cbiAgbGV0IGluY3JfbHkgdCA9XG4gICAgTGNkX3Bvc2l0aW9uLmluY3JfbHkgdC5scDtcbiAgICBMY2RfcG9zaXRpb24uZ2V0X2x5IHQubHBcbiAgaW5cbiAgbGV0IG9hbV9zZWFyY2hfbWN5Y2xlcyA9IDIwIGluICAgICAoKiAgODAgLyA0ICopXG4gIGxldCBwaXhlbF90cmFuc2Zlcl9tY3ljbGVzID0gNDMgaW4gKCogMTcyIC8gNCAqKVxuICBsZXQgaGJsYW5rX21jeWNsZXMgPSA1MSBpbiAgICAgICAgICgqIDIwNCAvIDQgKilcbiAgbGV0IG9uZV9saW5lX21jeWNsZSA9IG9hbV9zZWFyY2hfbWN5Y2xlcyArIHBpeGVsX3RyYW5zZmVyX21jeWNsZXMgKyBoYmxhbmtfbWN5Y2xlcyBpbiAoKiAxMTQgKilcbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgRGlzYWJsZWQgLT4gSW5fZnJhbWVcbiAgfCBFbmFibGVkIC0+XG4gICAgdC5tY3ljbGVzX2luX21vZGUgPC0gdC5tY3ljbGVzX2luX21vZGUgKyBtY3ljbGVzO1xuICAgIGJlZ2luIG1hdGNoIExjZF9zdGF0LmdldF9ncHVfbW9kZSB0LmxzIHdpdGhcbiAgICAgIHwgT0FNX3NlYXJjaCAtPlxuICAgICAgICBpZiB0Lm1jeWNsZXNfaW5fbW9kZSA+PSBvYW1fc2VhcmNoX21jeWNsZXMgdGhlbiBiZWdpblxuICAgICAgICAgIHQubWN5Y2xlc19pbl9tb2RlIDwtIHQubWN5Y2xlc19pbl9tb2RlIG1vZCBvYW1fc2VhcmNoX21jeWNsZXM7XG4gICAgICAgICAgTGNkX3N0YXQuc2V0X2dwdV9tb2RlIHQubHMgUGl4ZWxfdHJhbnNmZXI7XG4gICAgICAgIGVuZDtcbiAgICAgICAgSW5fZnJhbWVcbiAgICAgIHwgUGl4ZWxfdHJhbnNmZXIgLT5cbiAgICAgICAgaWYgdC5tY3ljbGVzX2luX21vZGUgPj0gcGl4ZWxfdHJhbnNmZXJfbWN5Y2xlcyB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5tY3ljbGVzX2luX21vZGUgPC0gdC5tY3ljbGVzX2luX21vZGUgbW9kIHBpeGVsX3RyYW5zZmVyX21jeWNsZXM7XG4gICAgICAgICAgTGNkX3N0YXQuc2V0X2dwdV9tb2RlIHQubHMgSEJsYW5rO1xuICAgICAgICAgIGlmIExjZF9zdGF0LmlzX2VuYWJsZWQgdC5scyBIQmxhbmsgdGhlblxuICAgICAgICAgICAgSW50ZXJydXB0X2NvbnRyb2xsZXIucmVxdWVzdCB0LmljIExDRF9zdGF0O1xuICAgICAgICAgIHJlbmRlcl9saW5lIHQ7XG4gICAgICAgIGVuZDtcbiAgICAgICAgSW5fZnJhbWVcbiAgICAgIHwgSEJsYW5rIC0+XG4gICAgICAgIGlmIHQubWN5Y2xlc19pbl9tb2RlID49IGhibGFua19tY3ljbGVzIHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm1jeWNsZXNfaW5fbW9kZSA8LSB0Lm1jeWNsZXNfaW5fbW9kZSBtb2QgaGJsYW5rX21jeWNsZXM7XG4gICAgICAgICAgbGV0IGx5ID0gaW5jcl9seSB0IGluXG4gICAgICAgICAgaGFuZGxlX2x5X2VxX2x5YyB0O1xuICAgICAgICAgIGlmIGx5ID0gc2NyZWVuX2ggdGhlbiBiZWdpblxuICAgICAgICAgICAgTGNkX3N0YXQuc2V0X2dwdV9tb2RlIHQubHMgVkJsYW5rO1xuICAgICAgICAgICAgaWYgTGNkX3N0YXQuaXNfZW5hYmxlZCB0LmxzIFZCbGFuayB0aGVuXG4gICAgICAgICAgICAgIEludGVycnVwdF9jb250cm9sbGVyLnJlcXVlc3QgdC5pYyBMQ0Rfc3RhdDtcbiAgICAgICAgICAgIEludGVycnVwdF9jb250cm9sbGVyLnJlcXVlc3QgdC5pYyBWQmxhbms7XG4gICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIExjZF9zdGF0LnNldF9ncHVfbW9kZSB0LmxzIE9BTV9zZWFyY2g7XG4gICAgICAgICAgICBpZiBMY2Rfc3RhdC5pc19lbmFibGVkIHQubHMgT0FNIHRoZW5cbiAgICAgICAgICAgICAgSW50ZXJydXB0X2NvbnRyb2xsZXIucmVxdWVzdCB0LmljIExDRF9zdGF0O1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbmQ7XG4gICAgICAgIEluX2ZyYW1lXG4gICAgICB8IFZCbGFuayAtPlxuICAgICAgICBpZiB0Lm1jeWNsZXNfaW5fbW9kZSA8IG9uZV9saW5lX21jeWNsZSB0aGVuXG4gICAgICAgICAgSW5fZnJhbWVcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIHQubWN5Y2xlc19pbl9tb2RlIDwtIHQubWN5Y2xlc19pbl9tb2RlIG1vZCBvbmVfbGluZV9tY3ljbGU7XG4gICAgICAgICAgbGV0IGx5ID0gaW5jcl9seSB0IGluXG4gICAgICAgICAgaGFuZGxlX2x5X2VxX2x5YyB0O1xuICAgICAgICAgIGlmIGx5IDwgMTU0IHRoZW5cbiAgICAgICAgICAgIEluX2ZyYW1lXG4gICAgICAgICAgZWxzZSBiZWdpbiAoKiAxNTQgPSBzY3JlZW5faCArIDEwICopXG4gICAgICAgICAgICBMY2RfcG9zaXRpb24ucmVzZXRfbHkgdC5scDtcbiAgICAgICAgICAgIGhhbmRsZV9seV9lcV9seWMgdDtcbiAgICAgICAgICAgIExjZF9zdGF0LnNldF9ncHVfbW9kZSB0LmxzIE9BTV9zZWFyY2g7XG4gICAgICAgICAgICBpZiBMY2Rfc3RhdC5pc19lbmFibGVkIHQubHMgT0FNIHRoZW5cbiAgICAgICAgICAgICAgSW50ZXJydXB0X2NvbnRyb2xsZXIucmVxdWVzdCB0LmljIExDRF9zdGF0O1xuICAgICAgICAgICAgRnJhbWVfZW5kZWQgKHQuZnJhbWVfYnVmZmVyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICBlbmRcbiAgfCBIQmxhbmtfYWZ0ZXJfZW5hYmxlZCAtPlxuICAgICgqIFRoZSBIQmxhbmsgYWZ0ZXIgdHJhbnNpdGlvbmluZyBmcm9tIGVuYWJsZWQgdG8gZGlzYWJsZWRcbiAgICAgKiBzZWVtcyB0byBoYXZlIHR3byBkaWZmZXJlbmNlcyBmcm9tIG5vcm1hbCBIQkxhbmsgKGJhc2VkIG9uIGluc3BlY3RpbmcgQkdCKTpcbiAgICAgKiAxLiBUaGUgbW9kZSBvbmx5IGhhcyAzMyBtY3lsY2VzIHJlbWFpbmluZyAoc3RhcnRzIHdpdGggKzE4IG1jeWNsZXMpXG4gICAgICogMi4gTFkgZG9lcyBub3QgaW5jcmVtZW50IHdoZW4gSEJMYW5rIGVuZHMgKilcbiAgICB0Lm1jeWNsZXNfaW5fbW9kZSA8LSB0Lm1jeWNsZXNfaW5fbW9kZSArIG1jeWNsZXM7XG4gICAgaWYgdC5tY3ljbGVzX2luX21vZGUgPj0gaGJsYW5rX21jeWNsZXMgdGhlbiBiZWdpblxuICAgICAgdC5tY3ljbGVzX2luX21vZGUgPC0gdC5tY3ljbGVzX2luX21vZGUgbW9kIGhibGFua19tY3ljbGVzO1xuICAgICAgdC5zdGF0ZSA8LSBFbmFibGVkO1xuICAgICAgaGFuZGxlX2x5X2VxX2x5YyB0O1xuICAgICAgTGNkX3N0YXQuc2V0X2dwdV9tb2RlIHQubHMgT0FNX3NlYXJjaDtcbiAgICAgIGlmIExjZF9zdGF0LmlzX2VuYWJsZWQgdC5scyBPQU0gdGhlblxuICAgICAgICBJbnRlcnJ1cHRfY29udHJvbGxlci5yZXF1ZXN0IHQuaWMgTENEX3N0YXQ7XG4gICAgZW5kO1xuICAgIEluX2ZyYW1lXG5cblxubGV0IGFjY2VwdHMgdCBhZGRyID1cbiAgVGlsZV9tYXAuYWNjZXB0cyB0LnRtIGFkZHJcbiAgfHwgVGlsZV9kYXRhLmFjY2VwdHMgdC50ZCBhZGRyXG4gIHx8IE9hbV90YWJsZS5hY2NlcHRzIHQub2FtIGFkZHJcbiAgfHwgUGFsbGV0ZS5hY2NlcHRzIHQuYmdwIGFkZHJcbiAgfHwgUGFsbGV0ZS5hY2NlcHRzIHQub2JwMCBhZGRyXG4gIHx8IFBhbGxldGUuYWNjZXB0cyB0Lm9icDEgYWRkclxuICB8fCBMY2Rfc3RhdC5hY2NlcHRzIHQubHMgYWRkclxuICB8fCBMY2RfY29udHJvbC5hY2NlcHRzIHQubGMgYWRkclxuICB8fCBMY2RfcG9zaXRpb24uYWNjZXB0cyB0LmxwIGFkZHJcblxubGV0IHJlYWRfYnl0ZSB0IGFkZHIgPVxuICBtYXRjaCBhZGRyIHdpdGhcbiAgfCBfIHdoZW4gVGlsZV9kYXRhLmFjY2VwdHMgdC50ZCBhZGRyIC0+IChcbiAgICAgICgqIFZSQU0gaXMgbm90IGFjY2Vzc2FibGUgZHVyaW5nIHBpeGVsIHRyYW5zZmVyICopXG4gICAgICBtYXRjaCBMY2Rfc3RhdC5nZXRfZ3B1X21vZGUgdC5scyB3aXRoXG4gICAgICB8IFBpeGVsX3RyYW5zZmVyIC0+IFVpbnQ4Lm9mX2ludCAweEZGXG4gICAgICB8IE9BTV9zZWFyY2ggfCBIQmxhbmsgfCBWQmxhbmsgLT4gVGlsZV9kYXRhLnJlYWRfYnl0ZSB0LnRkIGFkZHJcbiAgICApXG4gIHwgXyB3aGVuIFRpbGVfbWFwLmFjY2VwdHMgdC50bSBhZGRyIC0+IChcbiAgICAgICgqIFZSQU0gaXMgbm90IGFjY2Vzc2FibGUgZHVyaW5nIHBpeGVsIHRyYW5zZmVyICopXG4gICAgICBtYXRjaCBMY2Rfc3RhdC5nZXRfZ3B1X21vZGUgdC5scyB3aXRoXG4gICAgICB8IFBpeGVsX3RyYW5zZmVyIC0+IFVpbnQ4Lm9mX2ludCAweEZGXG4gICAgICB8IE9BTV9zZWFyY2ggfCBIQmxhbmsgfCBWQmxhbmsgLT4gVGlsZV9tYXAucmVhZF9ieXRlIHQudG0gYWRkclxuICAgIClcbiAgfCBfIHdoZW4gT2FtX3RhYmxlLmFjY2VwdHMgdC5vYW0gIGFkZHIgLT4gKFxuICAgICAgKCogVlJBTSBpcyBub3QgYWNjZXNzYWJsZSBkdXJpbmcgcGl4ZWwgdHJhbnNmZXIgYW5kIE9BTSBzZWFyY2ggKilcbiAgICAgIG1hdGNoIExjZF9zdGF0LmdldF9ncHVfbW9kZSB0LmxzIHdpdGhcbiAgICAgIHwgUGl4ZWxfdHJhbnNmZXIgfCBPQU1fc2VhcmNoIC0+IFVpbnQ4Lm9mX2ludCAweEZGXG4gICAgICB8IEhCbGFuayB8IFZCbGFuayAtPiBPYW1fdGFibGUucmVhZF9ieXRlIHQub2FtIGFkZHJcbiAgICApXG4gIHwgXyB3aGVuIFBhbGxldGUuYWNjZXB0cyB0LmJncCBhZGRyLT4gUGFsbGV0ZS5yZWFkX2J5dGUgdC5iZ3AgYWRkclxuICB8IF8gd2hlbiBQYWxsZXRlLmFjY2VwdHMgdC5vYnAwIGFkZHIgLT4gUGFsbGV0ZS5yZWFkX2J5dGUgdC5vYnAwIGFkZHJcbiAgfCBfIHdoZW4gUGFsbGV0ZS5hY2NlcHRzIHQub2JwMSBhZGRyIC0+IFBhbGxldGUucmVhZF9ieXRlIHQub2JwMSBhZGRyXG4gIHwgXyB3aGVuIExjZF9zdGF0LmFjY2VwdHMgdC5scyBhZGRyIC0+IExjZF9zdGF0LnJlYWRfYnl0ZSB0LmxzIGFkZHJcbiAgfCBfIHdoZW4gTGNkX2NvbnRyb2wuYWNjZXB0cyB0LmxjIGFkZHIgLT4gTGNkX2NvbnRyb2wucmVhZF9ieXRlIHQubGMgYWRkclxuICB8IF8gd2hlbiBMY2RfcG9zaXRpb24uYWNjZXB0cyB0LmxwIGFkZHIgLT4gTGNkX3Bvc2l0aW9uLnJlYWRfYnl0ZSB0LmxwIGFkZHJcbiAgfCBfIC0+IHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgKFByaW50Zi5zcHJpbnRmIFwiQWRkcmVzcyBvdXQgb2YgcmFuZ2U6ICVzXCIgKFVpbnQxNi5zaG93IGFkZHIpKVxuXG5sZXQgd3JpdGVfYnl0ZSB0IH5hZGRyIH5kYXRhID1cbiAgbWF0Y2ggYWRkciB3aXRoXG4gIHwgXyB3aGVuIFRpbGVfZGF0YS5hY2NlcHRzIHQudGQgYWRkciAtPiAoXG4gICAgICAoKiBWUkFNIGlzIG5vdCBhY2Nlc3NhYmxlIGR1cmluZyBwaXhlbCB0cmFuc2ZlciAqKVxuICAgICAgbWF0Y2ggTGNkX3N0YXQuZ2V0X2dwdV9tb2RlIHQubHMgd2l0aFxuICAgICAgfCBQaXhlbF90cmFuc2ZlciAtPiAoKVxuICAgICAgfCBPQU1fc2VhcmNoIHwgSEJsYW5rIHwgVkJsYW5rIC0+XG4gICAgICAgIFRpbGVfZGF0YS53cml0ZV9ieXRlIHQudGQgfmFkZHIgfmRhdGE7XG4gICAgKVxuICB8IF8gd2hlbiBUaWxlX21hcC5hY2NlcHRzIHQudG0gYWRkciAtPiAoXG4gICAgICAoKiBWUkFNIGlzIG5vdCBhY2Nlc3NhYmxlIGR1cmluZyBwaXhlbCB0cmFuc2ZlciAqKVxuICAgICAgbWF0Y2ggTGNkX3N0YXQuZ2V0X2dwdV9tb2RlIHQubHMgd2l0aFxuICAgICAgfCBQaXhlbF90cmFuc2ZlciAtPiAoKVxuICAgICAgfCBPQU1fc2VhcmNoIHwgSEJsYW5rIHwgVkJsYW5rIC0+IFRpbGVfbWFwLndyaXRlX2J5dGUgdC50bSB+YWRkciB+ZGF0YVxuICAgIClcbiAgfCBfIHdoZW4gT2FtX3RhYmxlLmFjY2VwdHMgdC5vYW0gYWRkciAtPiAoXG4gICAgICAoKiBWUkFNIGlzIG5vdCBhY2Nlc3NhYmxlIGR1cmluZyBwaXhlbCB0cmFuc2ZlciBhbmQgT0FNIHNlYXJjaCAqKVxuICAgICAgbWF0Y2ggTGNkX3N0YXQuZ2V0X2dwdV9tb2RlIHQubHMgd2l0aFxuICAgICAgfCBQaXhlbF90cmFuc2ZlciB8IE9BTV9zZWFyY2ggLT4gKClcbiAgICAgIHwgSEJsYW5rIHwgVkJsYW5rIC0+IE9hbV90YWJsZS53cml0ZV9ieXRlIHQub2FtICB+YWRkciB+ZGF0YVxuICAgIClcbiAgfCBfIHdoZW4gUGFsbGV0ZS5hY2NlcHRzIHQuYmdwIGFkZHIgLT4gUGFsbGV0ZS53cml0ZV9ieXRlIHQuYmdwIH5hZGRyIH5kYXRhXG4gIHwgXyB3aGVuIFBhbGxldGUuYWNjZXB0cyB0Lm9icDAgYWRkciAtPiBQYWxsZXRlLndyaXRlX2J5dGUgdC5vYnAwIH5hZGRyIH5kYXRhXG4gIHwgXyB3aGVuIFBhbGxldGUuYWNjZXB0cyB0Lm9icDEgYWRkciAtPiBQYWxsZXRlLndyaXRlX2J5dGUgdC5vYnAxIH5hZGRyIH5kYXRhXG4gIHwgXyB3aGVuIExjZF9zdGF0LmFjY2VwdHMgdC5scyBhZGRyIC0+IExjZF9zdGF0LndyaXRlX2J5dGUgdC5scyB+YWRkciB+ZGF0YVxuICB8IF8gd2hlbiBMY2RfY29udHJvbC5hY2NlcHRzIHQubGMgYWRkciAtPlxuICAgIGxldCBsY2RfZW5hYmxlX2JlZm9yZSA9IExjZF9jb250cm9sLmdldF9sY2RfZW5hYmxlIHQubGMgaW5cbiAgICBMY2RfY29udHJvbC53cml0ZV9ieXRlIHQubGMgfmFkZHIgfmRhdGE7XG4gICAgbGV0IGxjZF9lbmFibGVfYWZ0ZXIgPSBMY2RfY29udHJvbC5nZXRfbGNkX2VuYWJsZSB0LmxjIGluXG4gICAgYmVnaW4gbWF0Y2ggbGNkX2VuYWJsZV9iZWZvcmUsIGxjZF9lbmFibGVfYWZ0ZXIgd2l0aFxuICAgICAgfCB0cnVlLCBmYWxzZSAtPlxuICAgICAgICAoKiBXaGVuIExDRCBpcyBkaXNhYmxlZCwgTFkgYW5kIG1jeWNsZSBjb3VudCBpcyBzZXQgdG8gMCBhbmQgbW9kZSBpcyBzZXQgdG8gSEJsYW5rLiAqKVxuICAgICAgICBMY2RfcG9zaXRpb24ucmVzZXRfbHkgdC5scDtcbiAgICAgICAgdC5tY3ljbGVzX2luX21vZGUgPC0gMDtcbiAgICAgICAgdC5zdGF0ZSA8LSBEaXNhYmxlZDtcbiAgICAgICAgTGNkX3N0YXQuc2V0X2dwdV9tb2RlIHQubHMgSEJsYW5rXG4gICAgICB8IGZhbHNlLCB0cnVlIC0+XG4gICAgICAgICgqIFwiMzNcIiBpcyBmcm9tIG9ic2VydmF0aW9uIG9mIHdoYXQgaGFwcGVucyB3aGVuIExDRCBpcyBlbmFibGVkIGluIEJHQiAqKVxuICAgICAgICB0LnN0YXRlIDwtIEhCbGFua19hZnRlcl9lbmFibGVkO1xuICAgICAgICB0Lm1jeWNsZXNfaW5fbW9kZSA8LSAxODtcbiAgICAgICAgaGFuZGxlX2x5X2VxX2x5YyB0O1xuICAgICAgfCB0cnVlLCB0cnVlXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiAoKVxuICAgIGVuZFxuXG4gIHwgXyB3aGVuIExjZF9wb3NpdGlvbi5hY2NlcHRzIHQubHAgYWRkciAtPiBMY2RfcG9zaXRpb24ud3JpdGVfYnl0ZSB0LmxwIH5hZGRyIH5kYXRhXG4gIHwgXyAtPiByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IChQcmludGYuc3ByaW50ZiBcIkFkZHJlc3Mgb3V0IG9mIHJhbmdlOiAlc1wiIChVaW50MTYuc2hvdyBhZGRyKSlcblxuXG5sZXQgd3JpdGVfb2FtX3dpdGhfb2Zmc2V0IHQgfm9mZnNldCB+ZGF0YSA9IE9hbV90YWJsZS53cml0ZV93aXRoX29mZnNldCB0Lm9hbSB+b2Zmc2V0IH5kYXRhXG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcblxuICBsZXQgcnVuIHQgfm1jeWNsZXMgPVxuICAgIGxldCBtb2RlX2JlZm9yZSA9IExjZF9zdGF0LmdldF9ncHVfbW9kZSB0LmxzIGluXG4gICAgaWdub3JlIEBAIHJ1biB0IH5tY3ljbGVzO1xuICAgIGxldCBtb2RlX2FmdGVyID0gTGNkX3N0YXQuZ2V0X2dwdV9tb2RlIHQubHMgaW5cbiAgICBpZiBtb2RlX2JlZm9yZSAhPSBtb2RlX2FmdGVyIHRoZW5cbiAgICAgIGBNb2RlX2NoYW5nZWRcbiAgICBlbHNlXG4gICAgICBgTW9kZV9ub3RfY2hhbmdlZFxuXG4gIGxldCBzaG93IHQgPVxuICAgIGxldCBpbnRlcnJ1cHRfc3RyID0gbWF0Y2ggSW50ZXJydXB0X2NvbnRyb2xsZXIubmV4dCB0LmljIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBcIi1cIlxuICAgICAgfCBTb21lIGludCAtPiBJbnRlcnJ1cHRfY29udHJvbGxlci5zaG93X3R5cGVfIGludFxuICAgIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCJtb2RlPSVkLCBtY3ljbGVzPSU0ZCwgbHk9JTNkLCBsY2Rfc3RhdD0lcywgaW50ZXJydXB0PSVzKVwiXG4gICAgICAoTGNkX3N0YXQuZ2V0X2dwdV9tb2RlIHQubHMgfD4gR3B1X21vZGUudG9faW50KVxuICAgICAgdC5tY3ljbGVzX2luX21vZGVcbiAgICAgIChMY2RfcG9zaXRpb24uZ2V0X2x5IHQubHApXG4gICAgICAoTGNkX3N0YXQucGVlayB0LmxzIHw+IFVpbnQ4LnNob3cpXG4gICAgICBpbnRlcnJ1cHRfc3RyXG5cbiAgbGV0IGdldF9tY3ljbGVzX2luX21vZGUgdCA9IHQubWN5Y2xlc19pbl9tb2RlXG5cbmVuZFxuIiwib3BlbiBVaW50c1xuXG50eXBlIGtleSA9IERvd24gfCBVcCB8IExlZnQgfCBSaWdodCB8IFN0YXJ0IHwgU2VsZWN0IHwgQiB8IEFcblxudHlwZSBtb2RlID0gTm9uZSB8IERpcmVjdGlvbiB8IEFjdGlvblxuXG5tb2R1bGUgS2V5X3N0YXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IFByZXNzZWQgfCBOb3RfcHJlc3NlZFxuICBsZXQgdG9fYm9vbCB0ID0gdCA9IE5vdF9wcmVzc2VkICgqIDA9UHJlc3NlZCwgMT1Ob3RfcHJlc3NlZCAqKVxuZW5kXG5cbnR5cGUgdCA9IHtcbiAgYWRkciA6IHVpbnQxNjtcbiAgaWMgICA6IEludGVycnVwdF9jb250cm9sbGVyLnQ7XG4gIG11dGFibGUgbW9kZSAgIDogbW9kZTtcbiAgbXV0YWJsZSBkb3duICAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSB1cCAgICAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSBsZWZ0ICAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSByaWdodCAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSBzdGFydCAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSBzZWxlY3QgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSBiICAgICAgOiBLZXlfc3RhdGUudDtcbiAgbXV0YWJsZSBhICAgICAgOiBLZXlfc3RhdGUudDtcbn1cblxubGV0IGNyZWF0ZSB+YWRkciB+aWMgPSB7XG4gIGFkZHI7XG4gIGljO1xuICBtb2RlID0gRGlyZWN0aW9uO1xuICBkb3duICAgPSBOb3RfcHJlc3NlZDtcbiAgdXAgICAgID0gTm90X3ByZXNzZWQ7XG4gIGxlZnQgICA9IE5vdF9wcmVzc2VkO1xuICByaWdodCAgPSBOb3RfcHJlc3NlZDtcbiAgc3RhcnQgID0gTm90X3ByZXNzZWQ7XG4gIHNlbGVjdCA9IE5vdF9wcmVzc2VkO1xuICBiICAgICAgPSBOb3RfcHJlc3NlZDtcbiAgYSAgICAgID0gTm90X3ByZXNzZWRcbn1cblxubGV0IHByZXNzIHQga2V5ID1cbiAgSW50ZXJydXB0X2NvbnRyb2xsZXIucmVxdWVzdCB0LmljIEpveXBhZDtcbiAgbWF0Y2gga2V5IHdpdGhcbiAgfCBEb3duICAgLT4gdC5kb3duICAgPC0gUHJlc3NlZFxuICB8IFVwICAgICAtPiB0LnVwICAgICA8LSBQcmVzc2VkXG4gIHwgTGVmdCAgIC0+IHQubGVmdCAgIDwtIFByZXNzZWRcbiAgfCBSaWdodCAgLT4gdC5yaWdodCAgPC0gUHJlc3NlZFxuICB8IFN0YXJ0ICAtPiB0LnN0YXJ0ICA8LSBQcmVzc2VkXG4gIHwgU2VsZWN0IC0+IHQuc2VsZWN0IDwtIFByZXNzZWRcbiAgfCBCICAgICAgLT4gdC5iICAgICAgPC0gUHJlc3NlZFxuICB8IEEgICAgICAtPiB0LmEgICAgICA8LSBQcmVzc2VkXG5cbmxldCByZWxlYXNlIHQgPSBmdW5jdGlvblxuICB8IERvd24gICAtPiB0LmRvd24gICA8LSBOb3RfcHJlc3NlZFxuICB8IFVwICAgICAtPiB0LnVwICAgICA8LSBOb3RfcHJlc3NlZFxuICB8IExlZnQgICAtPiB0LmxlZnQgICA8LSBOb3RfcHJlc3NlZFxuICB8IFJpZ2h0ICAtPiB0LnJpZ2h0ICA8LSBOb3RfcHJlc3NlZFxuICB8IFN0YXJ0ICAtPiB0LnN0YXJ0ICA8LSBOb3RfcHJlc3NlZFxuICB8IFNlbGVjdCAtPiB0LnNlbGVjdCA8LSBOb3RfcHJlc3NlZFxuICB8IEIgICAgICAtPiB0LmIgICAgICA8LSBOb3RfcHJlc3NlZFxuICB8IEEgICAgICAtPiB0LmEgICAgICA8LSBOb3RfcHJlc3NlZFxuXG5cblxuKCogQml0IDcgLSBOb3QgdXNlZFxuICogQml0IDYgLSBOb3QgdXNlZFxuICogQml0IDUgLSBQMTUgU2VsZWN0IEFjdGlvbiBidXR0b25zICAgICgwPVNlbGVjdClcbiAqIEJpdCA0IC0gUDE0IFNlbGVjdCBEaXJlY3Rpb24gYnV0dG9ucyAoMD1TZWxlY3QpXG4gKiBCaXQgMyAtIFAxMyBJbnB1dDogRG93biAgb3IgU3RhcnQgICAgKDA9UHJlc3NlZCkgKFJlYWQgT25seSlcbiAqIEJpdCAyIC0gUDEyIElucHV0OiBVcCAgICBvciBTZWxlY3QgICAoMD1QcmVzc2VkKSAoUmVhZCBPbmx5KVxuICogQml0IDEgLSBQMTEgSW5wdXQ6IExlZnQgIG9yIEIgICAgICAgICgwPVByZXNzZWQpIChSZWFkIE9ubHkpXG4gKiBCaXQgMCAtIFAxMCBJbnB1dDogUmlnaHQgb3IgQSAgICAgICAgKDA9UHJlc3NlZCkgKFJlYWQgT25seSkgKilcblxubGV0IHJlYWRfYnl0ZSB0IF8gPVxuICBtYXRjaCB0Lm1vZGUgd2l0aFxuICB8IERpcmVjdGlvbiAtPlxuICAgIEJpdF91dGlsLmJ5dGVfb2ZfYml0ZmxhZ3NcbiAgICAgIHRydWVcbiAgICAgIHRydWVcbiAgICAgIGZhbHNlXG4gICAgICB0cnVlXG4gICAgICAodC5kb3duICB8PiBLZXlfc3RhdGUudG9fYm9vbClcbiAgICAgICh0LnVwICAgIHw+IEtleV9zdGF0ZS50b19ib29sKVxuICAgICAgKHQubGVmdCAgfD4gS2V5X3N0YXRlLnRvX2Jvb2wpXG4gICAgICAodC5yaWdodCB8PiBLZXlfc3RhdGUudG9fYm9vbClcbiAgfCBBY3Rpb24gLT5cbiAgICBCaXRfdXRpbC5ieXRlX29mX2JpdGZsYWdzXG4gICAgICB0cnVlXG4gICAgICB0cnVlXG4gICAgICB0cnVlXG4gICAgICBmYWxzZVxuICAgICAgKHQuc3RhcnQgIHw+IEtleV9zdGF0ZS50b19ib29sKVxuICAgICAgKHQuc2VsZWN0IHw+IEtleV9zdGF0ZS50b19ib29sKVxuICAgICAgKHQuYiAgICAgIHw+IEtleV9zdGF0ZS50b19ib29sKVxuICAgICAgKHQuYSAgICAgIHw+IEtleV9zdGF0ZS50b19ib29sKVxuICB8IE5vbmUgLT4gVWludDgub2ZfaW50IDB4MEZcblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkcjpfIH5kYXRhID1cbiAgbGV0IChfLCBfLCBiNSwgYjQsIF8sIF8sIF8sIF8pID0gQml0X3V0aWwuYml0ZmxhZ3Nfb2ZfYnl0ZSBkYXRhIGluXG4gIGlmIG5vdCBiNCB0aGVuXG4gICAgdC5tb2RlIDwtIERpcmVjdGlvblxuICBlbHNlIGlmIG5vdCBiNSB0aGVuXG4gICAgdC5tb2RlIDwtIEFjdGlvblxuICBlbHNlXG4gICAgdC5tb2RlIDwtIE5vbmVcblxubGV0IGFjY2VwdHMgdCBhZGRyID0gYWRkciA9IHQuYWRkclxuIiwib3BlbiBVaW50c1xuXG5tb2R1bGUgTWFrZSAoQ2FydHJpZGdlIDogQWRkcmVzc2FibGVfaW50Zi5TKSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHtcbiAgICBjYXJ0cmlkZ2UgICA6IENhcnRyaWRnZS50O1xuICAgIHdyYW0gICAgICAgIDogUmFtLnQ7XG4gICAgc2hhZG93X3JhbSAgOiBTaGFkb3dfcmFtLnQ7XG4gICAgZ3B1ICAgICAgICAgOiBHcHUudDtcbiAgICB6ZXJvX3BhZ2UgICA6IFJhbS50O1xuICAgIGpveXBhZCAgICAgIDogSm95cGFkLnQ7XG4gICAgc2VyaWFsX3BvcnQgOiBTZXJpYWxfcG9ydC50O1xuICAgIGljICAgICAgICAgIDogSW50ZXJydXB0X2NvbnRyb2xsZXIudDtcbiAgICB0aW1lciAgICAgICA6IFRpbWVyLnQ7XG4gICAgZHQgICAgICAgICAgOiBNbWFwX3JlZ2lzdGVyLnQ7XG4gIH1cblxuICBsZXQgY3JlYXRlIH5jYXJ0cmlkZ2UgfndyYW0gfmdwdSB+emVyb19wYWdlIH5zaGFkb3dfcmFtIH5qb3lwYWQgfnNlcmlhbF9wb3J0IH5pYyB+dGltZXIgfmRtYV90cmFuc2ZlciA9IHtcbiAgICBjYXJ0cmlkZ2U7XG4gICAgd3JhbTtcbiAgICBzaGFkb3dfcmFtO1xuICAgIGdwdTtcbiAgICB6ZXJvX3BhZ2U7XG4gICAgam95cGFkO1xuICAgIHNlcmlhbF9wb3J0O1xuICAgIGljO1xuICAgIHRpbWVyO1xuICAgIGR0ID0gZG1hX3RyYW5zZmVyO1xuICB9XG5cblxuICBsZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gICAgbWF0Y2ggYWRkciB3aXRoXG4gICAgfCBfIHdoZW4gQ2FydHJpZGdlLmFjY2VwdHMgdC5jYXJ0cmlkZ2UgYWRkciAgICAgLT4gQ2FydHJpZGdlLnJlYWRfYnl0ZSB0LmNhcnRyaWRnZSBhZGRyXG4gICAgfCBfIHdoZW4gUmFtLmFjY2VwdHMgdC53cmFtICAgICAgIGFkZHIgICAgICAgICAgLT4gUmFtLnJlYWRfYnl0ZSB0LndyYW0gYWRkclxuICAgIHwgXyB3aGVuIFJhbS5hY2NlcHRzIHQuemVyb19wYWdlICBhZGRyICAgICAgICAgIC0+IFJhbS5yZWFkX2J5dGUgdC56ZXJvX3BhZ2UgYWRkclxuICAgIHwgXyB3aGVuIEdwdS5hY2NlcHRzIHQuZ3B1ICAgICAgICBhZGRyICAgICAgICAgIC0+IEdwdS5yZWFkX2J5dGUgdC5ncHUgYWRkclxuICAgIHwgXyB3aGVuIEpveXBhZC5hY2NlcHRzIHQuam95cGFkIGFkZHIgICAgICAgICAgIC0+IEpveXBhZC5yZWFkX2J5dGUgdC5qb3lwYWQgYWRkclxuICAgIHwgXyB3aGVuIFNoYWRvd19yYW0uYWNjZXB0cyB0LnNoYWRvd19yYW0gYWRkciAgIC0+IFNoYWRvd19yYW0ucmVhZF9ieXRlIHQuc2hhZG93X3JhbSBhZGRyXG4gICAgfCBfIHdoZW4gU2VyaWFsX3BvcnQuYWNjZXB0cyB0LnNlcmlhbF9wb3J0IGFkZHIgLT4gU2VyaWFsX3BvcnQucmVhZF9ieXRlIHQuc2VyaWFsX3BvcnQgYWRkclxuICAgIHwgXyB3aGVuIEludGVycnVwdF9jb250cm9sbGVyLmFjY2VwdHMgdC5pYyBhZGRyIC0+IEludGVycnVwdF9jb250cm9sbGVyLnJlYWRfYnl0ZSB0LmljIGFkZHJcbiAgICB8IF8gd2hlbiBUaW1lci5hY2NlcHRzIHQudGltZXIgYWRkciAgICAgICAgICAgICAtPiBUaW1lci5yZWFkX2J5dGUgdC50aW1lciBhZGRyXG4gICAgfCBfIHdoZW4gTW1hcF9yZWdpc3Rlci5hY2NlcHRzIHQuZHQgYWRkciAgICAgICAgLT4gTW1hcF9yZWdpc3Rlci5yZWFkX2J5dGUgdC5kdCBhZGRyXG4gICAgfCBfIC0+XG4gICAgICAoKiBVbmRvY3VtZW50ZWQgSU8gcmVnaXN0ZXJzIHNob3VsZCBhbHdheXMgcmV0dXJuIDB4RkYuIEJsYXJnZydzIGNwdV9pbnNycyBmYWlsIHdpdGhvdXQgdGhpcy5cbiAgICAgICAqIGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vci9FbXVEZXYvY29tbWVudHMvaXBhcDB3L2NvbW1lbnQvZzc2bTA0aS8/dXRtX3NvdXJjZT1zaGFyZSZ1dG1fbWVkaXVtPXdlYjJ4JmNvbnRleHQ9MyAqKVxuICAgICAgVWludDgub2ZfaW50IDB4RkZcblxuXG4gIGxldCB3cml0ZV9ieXRlIHQgfihhZGRyIDogdWludDE2KSB+KGRhdGEgOiB1aW50OCkgPVxuICAgIGxldCBkbWFfdHJhbnNmZXIgKHNvdXJjZTp1aW50OCkgPVxuICAgICAgbGV0IHNvdXJjZSA9XG4gICAgICAgICgqIHNvdXJjZTogICAgICAkWFgwMC0kWFg5RiAgIDtYWCA9ICQwMCB0byAkREYgKilcbiAgICAgICAgVWludDE2Ligob2ZfdWludDggc291cmNlKSBsc2wgOClcbiAgICAgIGluXG4gICAgICBmb3IgaSA9IDAgdG8gMHg5RiBkb1xuICAgICAgICBsZXQgZGF0YSA9IHJlYWRfYnl0ZSB0IFVpbnQxNi4oc291cmNlICsgKG9mX2ludCBpKSkgaW5cbiAgICAgICAgR3B1LndyaXRlX29hbV93aXRoX29mZnNldCB0LmdwdSB+b2Zmc2V0OmkgfmRhdGFcbiAgICAgIGRvbmVcbiAgICBpblxuICAgIG1hdGNoIGFkZHIgd2l0aFxuICAgIHwgXyB3aGVuIENhcnRyaWRnZS5hY2NlcHRzIHQuY2FydHJpZGdlIGFkZHIgICAgIC0+IENhcnRyaWRnZS53cml0ZV9ieXRlIHQuY2FydHJpZGdlIH5hZGRyIH5kYXRhXG4gICAgfCBfIHdoZW4gUmFtLmFjY2VwdHMgdC53cmFtICAgICAgIGFkZHIgICAgICAgICAgLT4gUmFtLndyaXRlX2J5dGUgdC53cmFtIH5hZGRyIH5kYXRhXG4gICAgfCBfIHdoZW4gUmFtLmFjY2VwdHMgdC56ZXJvX3BhZ2UgIGFkZHIgICAgICAgICAgLT4gUmFtLndyaXRlX2J5dGUgdC56ZXJvX3BhZ2UgfmFkZHIgfmRhdGFcbiAgICB8IF8gd2hlbiBHcHUuYWNjZXB0cyB0LmdwdSAgICAgICAgYWRkciAgICAgICAgICAtPiBHcHUud3JpdGVfYnl0ZSB0LmdwdSB+YWRkciB+ZGF0YVxuICAgIHwgXyB3aGVuIEpveXBhZC5hY2NlcHRzIHQuam95cGFkIGFkZHIgICAgICAgICAgIC0+IEpveXBhZC53cml0ZV9ieXRlIHQuam95cGFkIH5hZGRyIH5kYXRhXG4gICAgfCBfIHdoZW4gU2hhZG93X3JhbS5hY2NlcHRzIHQuc2hhZG93X3JhbSBhZGRyICAgLT4gU2hhZG93X3JhbS53cml0ZV9ieXRlIHQuc2hhZG93X3JhbSB+YWRkciB+ZGF0YVxuICAgIHwgXyB3aGVuIFNlcmlhbF9wb3J0LmFjY2VwdHMgdC5zZXJpYWxfcG9ydCBhZGRyIC0+IFNlcmlhbF9wb3J0LndyaXRlX2J5dGUgdC5zZXJpYWxfcG9ydCB+YWRkciB+ZGF0YVxuICAgIHwgXyB3aGVuIEludGVycnVwdF9jb250cm9sbGVyLmFjY2VwdHMgdC5pYyBhZGRyIC0+IEludGVycnVwdF9jb250cm9sbGVyLndyaXRlX2J5dGUgdC5pYyB+YWRkciB+ZGF0YVxuICAgIHwgXyB3aGVuIFRpbWVyLmFjY2VwdHMgdC50aW1lciAgYWRkciAgICAgICAgICAgIC0+IFRpbWVyLndyaXRlX2J5dGUgdC50aW1lciB+YWRkciB+ZGF0YVxuICAgIHwgXyB3aGVuIE1tYXBfcmVnaXN0ZXIuYWNjZXB0cyB0LmR0ICBhZGRyICAgICAgIC0+XG4gICAgICBNbWFwX3JlZ2lzdGVyLndyaXRlX2J5dGUgdC5kdCB+YWRkciB+ZGF0YTtcbiAgICAgIGRtYV90cmFuc2ZlciBkYXRhXG4gICAgfCBfIC0+ICgpXG5cbiAgbGV0IGFjY2VwdHMgdCBhZGRyID1cbiAgICBDYXJ0cmlkZ2UuYWNjZXB0cyB0LmNhcnRyaWRnZSBhZGRyXG4gICAgfHwgUmFtLmFjY2VwdHMgdC53cmFtIGFkZHJcbiAgICB8fCBHcHUuYWNjZXB0cyB0LmdwdSBhZGRyXG4gICAgfHwgUmFtLmFjY2VwdHMgdC56ZXJvX3BhZ2UgYWRkclxuICAgIHx8IFNoYWRvd19yYW0uYWNjZXB0cyB0LnNoYWRvd19yYW0gYWRkclxuICAgIHx8IFNoYWRvd19yYW0uYWNjZXB0cyB0LnNoYWRvd19yYW0gYWRkclxuICAgIHx8IEpveXBhZC5hY2NlcHRzIHQuam95cGFkIGFkZHJcbiAgICB8fCBTZXJpYWxfcG9ydC5hY2NlcHRzIHQuc2VyaWFsX3BvcnQgYWRkclxuICAgIHx8IEludGVycnVwdF9jb250cm9sbGVyLmFjY2VwdHMgdC5pYyBhZGRyXG4gICAgfHwgVGltZXIuYWNjZXB0cyB0LnRpbWVyIGFkZHJcbiAgICB8fCBNbWFwX3JlZ2lzdGVyLmFjY2VwdHMgdC5kdCAgYWRkclxuXG5cbiAgbGV0IHJlYWRfd29yZCB0IGFkZHIgPVxuICAgIGxldCBsbyA9IFVpbnQ4LnRvX2ludCAocmVhZF9ieXRlIHQgYWRkcikgaW5cbiAgICBsZXQgaGkgPSBVaW50OC50b19pbnQgKHJlYWRfYnl0ZSB0IFVpbnQxNi4oc3VjYyBhZGRyKSkgaW5cbiAgICAoaGkgbHNsIDgpICsgbG8gfD4gVWludDE2Lm9mX2ludFxuXG4gIGxldCB3cml0ZV93b3JkIHQgfmFkZHIgfihkYXRhIDogdWludDE2KSA9XG4gICAgbGV0IGRhdGEgPSBVaW50MTYudG9faW50IGRhdGEgaW5cbiAgICBsZXQgaGkgPSBkYXRhIGxzciA4IHw+IFVpbnQ4Lm9mX2ludCBpblxuICAgIGxldCBsbyA9IGRhdGEgbGFuZCAweEZGIHw+IFVpbnQ4Lm9mX2ludCBpblxuICAgIHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YTpsbztcbiAgICB3cml0ZV9ieXRlIHQgfmFkZHI6VWludDE2LihzdWNjIGFkZHIpIH5kYXRhOmhpXG5cbmVuZFxuIiwib3BlbiBVaW50c1xuXG50eXBlICdhIGFyZyA9XG4gIHwgSW1tZWRpYXRlOCAgOiB1aW50OCAgICAgICAgLT4gdWludDggIGFyZ1xuICB8IEltbWVkaWF0ZTE2IDogdWludDE2ICAgICAgIC0+IHVpbnQxNiBhcmdcbiAgfCBEaXJlY3Q4ICAgICA6IHVpbnQxNiAgICAgICAtPiB1aW50OCAgYXJnXG4gIHwgRGlyZWN0MTYgICAgOiB1aW50MTYgICAgICAgLT4gdWludDE2IGFyZ1xuICB8IFIgICAgICAgICAgIDogUmVnaXN0ZXJzLnIgIC0+IHVpbnQ4ICBhcmdcbiAgfCBSUiAgICAgICAgICA6IFJlZ2lzdGVycy5yciAtPiB1aW50MTYgYXJnXG4gIHwgUlJfaW5kaXJlY3QgOiBSZWdpc3RlcnMucnIgLT4gdWludDggIGFyZ1xuICB8IEZGMDBfb2Zmc2V0IDogdWludDggICAgICAgIC0+IHVpbnQ4ICBhcmdcbiAgfCBGRjAwX0MgICAgICA6IHVpbnQ4IGFyZ1xuICB8IEhMX2luYyAgICAgIDogdWludDggYXJnXG4gIHwgSExfZGVjICAgICAgOiB1aW50OCBhcmdcbiAgfCBTUCAgICAgICAgICA6IHVpbnQxNiBhcmdcbiAgfCBTUF9vZmZzZXQgICA6IGludDggICAgICAgICAtPiB1aW50MTYgYXJnXG5cbmxldCBzaG93X2FyZyA6IHR5cGUgYS4gYSBhcmcgLT4gc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBJbW1lZGlhdGU4IG4gICAtPiBVaW50OC5zaG93IG5cbiAgfCBJbW1lZGlhdGUxNiBuICAtPiBVaW50MTYuc2hvdyBuXG4gIHwgRGlyZWN0OCBuXG4gIHwgRGlyZWN0MTYgbiAgICAgLT4gUHJpbnRmLnNwcmludGYgXCIoJXMpXCIgKFVpbnQxNi5zaG93IG4pXG4gIHwgUiByICAgICAgICAgICAgLT4gUmVnaXN0ZXJzLnNob3dfciByXG4gIHwgUlIgcnIgICAgICAgICAgLT4gUmVnaXN0ZXJzLnNob3dfcnIgcnJcbiAgfCBSUl9pbmRpcmVjdCByciAtPiBQcmludGYuc3ByaW50ZiBcIiglcylcIiAoUmVnaXN0ZXJzLnNob3dfcnIgcnIpXG4gIHwgRkYwMF9vZmZzZXQgbiAgLT4gUHJpbnRmLnNwcmludGYgXCIoJEZGMDArJXMpXCIgKFVpbnQ4LnNob3cgbilcbiAgfCBGRjAwX0MgICAgICAgICAtPiBcIigkRkYwMCtDKVwiXG4gIHwgSExfaW5jICAgICAgICAgLT4gXCIoSEwrKVwiXG4gIHwgSExfZGVjICAgICAgICAgLT4gXCIoSEwtKVwiXG4gIHwgU1AgICAgICAgICAgICAgLT4gXCJTUFwiXG4gIHwgU1Bfb2Zmc2V0IG4gICAgLT5cbiAgICBpZiBJbnQ4LmlzX25lZyBuIHRoZW5cbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiU1AtJXNcIiBJbnQ4LihzaG93IEBAIGFicyBuKVxuICAgIGVsc2VcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiU1ArJXNcIiBJbnQ4LihzaG93IG4pXG5cbnR5cGUgY29uZGl0aW9uID1cbiAgfCBOb25lXG4gIHwgTlpcbiAgfCBaXG4gIHwgTkNcbiAgfCBDXG5cbmxldCBzaG93X2NvbmRpdGlvbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgTlogICAtPiBcIk5aXCJcbiAgfCBaICAgIC0+IFwiWlwiXG4gIHwgTkMgICAtPiBcIk5DXCJcbiAgfCBDICAgIC0+IFwiQ1wiXG5cbnR5cGUgdCA9XG4gIHwgTEQ4ICAgb2YgdWludDggYXJnICogdWludDggYXJnXG4gIHwgTEQxNiAgb2YgdWludDE2IGFyZyAqIHVpbnQxNiBhcmdcbiAgfCBBREQ4ICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBBREQxNiBvZiB1aW50MTYgYXJnICogdWludDE2IGFyZ1xuICB8IEFERFNQIG9mIGludDhcbiAgfCBBREMgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBTVUIgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBTQkMgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBBTkQgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBPUiAgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBYT1IgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBDUCAgICBvZiB1aW50OCBhcmcgKiB1aW50OCBhcmdcbiAgfCBJTkMgICBvZiB1aW50OCBhcmdcbiAgfCBJTkMxNiBvZiB1aW50MTYgYXJnXG4gIHwgREVDICAgb2YgdWludDggYXJnXG4gIHwgREVDMTYgb2YgdWludDE2IGFyZ1xuICB8IFNXQVAgIG9mIHVpbnQ4IGFyZ1xuICB8IERBQVxuICB8IENQTFxuICB8IENDRlxuICB8IFNDRlxuICB8IE5PUFxuICB8IEhBTFRcbiAgfCBTVE9QXG4gIHwgRElcbiAgfCBFSVxuICB8IFJMQ0FcbiAgfCBSTEFcbiAgfCBSUkNBXG4gIHwgUlJBXG4gIHwgUkxDICAgb2YgdWludDggYXJnXG4gIHwgUkwgICAgb2YgdWludDggYXJnXG4gIHwgUlJDICAgb2YgdWludDggYXJnXG4gIHwgUlIgICAgb2YgdWludDggYXJnXG4gIHwgU0xBICAgb2YgdWludDggYXJnXG4gIHwgU1JBICAgb2YgdWludDggYXJnXG4gIHwgU1JMICAgb2YgdWludDggYXJnXG4gIHwgQklUICAgb2YgaW50ICogdWludDggYXJnXG4gIHwgU0VUICAgb2YgaW50ICogdWludDggYXJnXG4gIHwgUkVTICAgb2YgaW50ICogdWludDggYXJnXG4gIHwgUFVTSCAgb2YgUmVnaXN0ZXJzLnJyXG4gIHwgUE9QICAgb2YgUmVnaXN0ZXJzLnJyXG4gIHwgSlAgICAgb2YgY29uZGl0aW9uICogdWludDE2IGFyZ1xuICB8IEpSICAgIG9mIGNvbmRpdGlvbiAqIGludDhcbiAgfCBDQUxMICBvZiBjb25kaXRpb24gKiB1aW50MTZcbiAgfCBSU1QgICBvZiB1aW50MTZcbiAgfCBSRVQgICBvZiBjb25kaXRpb25cbiAgfCBSRVRJXG5cbmxldCBzaG93ID0gZnVuY3Rpb25cbiAgfCBMRDggKHgsIHkpICAgLT4gUHJpbnRmLnNwcmludGYgXCJMRCAlcywgJXNcIiAoc2hvd19hcmcgeCkgKHNob3dfYXJnIHkpXG4gIHwgTEQxNiAoeCwgeSkgIC0+IFByaW50Zi5zcHJpbnRmIFwiTEQgJXMsICVzXCIgKHNob3dfYXJnIHgpIChzaG93X2FyZyB5KVxuICB8IEFERDggKHgsIHkpICAtPiBQcmludGYuc3ByaW50ZiBcIkFERCAlcywgJXNcIiAoc2hvd19hcmcgeCkgKHNob3dfYXJnIHkpXG4gIHwgQUREMTYgKHgsIHkpIC0+IFByaW50Zi5zcHJpbnRmIFwiQUREICVzLCAlc1wiIChzaG93X2FyZyB4KSAoc2hvd19hcmcgeSlcbiAgfCBBRERTUCB5ICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJBREQgU1AsICVzXCIgKEludDguc2hvdyB5KVxuICB8IEFEQyAoeCwgeSkgICAtPiBQcmludGYuc3ByaW50ZiBcIkFEQyAlcywgJXNcIiAoc2hvd19hcmcgeCkgKHNob3dfYXJnIHkpXG4gIHwgU1VCICh4LCB5KSAgIC0+IFByaW50Zi5zcHJpbnRmIFwiU1VCICVzLCAlc1wiIChzaG93X2FyZyB4KSAoc2hvd19hcmcgeSlcbiAgfCBTQkMgKHgsIHkpICAgLT4gUHJpbnRmLnNwcmludGYgXCJTQkMgJXMsICVzXCIgKHNob3dfYXJnIHgpIChzaG93X2FyZyB5KVxuICB8IEFORCAoeCwgeSkgICAtPiBQcmludGYuc3ByaW50ZiBcIkFORCAlcywgJXNcIiAoc2hvd19hcmcgeCkgKHNob3dfYXJnIHkpXG4gIHwgT1IgKHgsIHkpICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiT1IgJXMsICVzXCIgKHNob3dfYXJnIHgpIChzaG93X2FyZyB5KVxuICB8IFhPUiAoeCwgeSkgICAtPiBQcmludGYuc3ByaW50ZiBcIlhPUiAlcywgJXNcIiAoc2hvd19hcmcgeCkgKHNob3dfYXJnIHkpXG4gIHwgQ1AgKHgsIHkpICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiQ1AgJXMsICVzXCIgKHNob3dfYXJnIHgpIChzaG93X2FyZyB5KVxuICB8IElOQyB4ICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIklOQyAlc1wiIChzaG93X2FyZyB4KVxuICB8IElOQzE2IHggICAgICAtPiBQcmludGYuc3ByaW50ZiBcIklOQyAlc1wiIChzaG93X2FyZyB4KVxuICB8IERFQyB4ICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIkRFQyAlc1wiIChzaG93X2FyZyB4KVxuICB8IERFQzE2IHggICAgICAtPiBQcmludGYuc3ByaW50ZiBcIkRFQyAlc1wiIChzaG93X2FyZyB4KVxuICB8IFNXQVAgeCAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlNXQVAgJXNcIiAoc2hvd19hcmcgeClcbiAgfCBEQUEgICAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJEQUFcIlxuICB8IENQTCAgICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIkNQTFwiXG4gIHwgQ0NGICAgICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiQ0NGXCJcbiAgfCBTQ0YgICAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJTQ0ZcIlxuICB8IE5PUCAgICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIk5PUFwiXG4gIHwgSEFMVCAgICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiSEFMVFwiXG4gIHwgU1RPUCAgICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiU1RPUFwiXG4gIHwgREkgICAgICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiRElcIlxuICB8IEVJICAgICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIkVJXCJcbiAgfCBSTENBICAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJSTENBXCJcbiAgfCBSTEEgICAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJSTEFcIlxuICB8IFJSQ0EgICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlJSQ0FcIlxuICB8IFJSQSAgICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlJSQVwiXG4gIHwgUkxDIHggICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiUkxDICVzXCIgKHNob3dfYXJnIHgpXG4gIHwgUkwgeCAgICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiUkwgJXNcIiAoc2hvd19hcmcgeClcbiAgfCBSUkMgeCAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJSUkMgJXNcIiAoc2hvd19hcmcgeClcbiAgfCBSUiB4ICAgICAgICAgLT4gUHJpbnRmLnNwcmludGYgXCJSUiAlc1wiIChzaG93X2FyZyB4KVxuICB8IFNMQSB4ICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlNMQSAlc1wiIChzaG93X2FyZyB4KVxuICB8IFNSQSB4ICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlNSQSAlc1wiIChzaG93X2FyZyB4KVxuICB8IFNSTCB4ICAgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlNSTCAlc1wiIChzaG93X2FyZyB4KVxuICB8IEJJVCAobiwgeCkgICAtPiBQcmludGYuc3ByaW50ZiBcIkJJVCAlZCwgJXNcIiBuIChzaG93X2FyZyB4KVxuICB8IFNFVCAobiwgeCkgICAtPiBQcmludGYuc3ByaW50ZiBcIlNFVCAlZCwgJXNcIiBuIChzaG93X2FyZyB4KVxuICB8IFJFUyAobiwgeCkgICAtPiBQcmludGYuc3ByaW50ZiBcIlJFUyAlZCwgJXNcIiBuIChzaG93X2FyZyB4KVxuICB8IFBVU0ggcnIgICAgICAtPiBQcmludGYuc3ByaW50ZiBcIlBVU0ggJXNcIiAoUmVnaXN0ZXJzLnNob3dfcnIgcnIpXG4gIHwgUE9QIHJyICAgICAgIC0+IFByaW50Zi5zcHJpbnRmIFwiUE9QICVzXCIgKFJlZ2lzdGVycy5zaG93X3JyIHJyKVxuICB8IEpQIChjLCB4KSAtPiAoXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBQcmludGYuc3ByaW50ZiBcIkpQICVzXCIgKHNob3dfYXJnIHgpXG4gICAgICB8IE5aIHwgWiB8IE5DIHwgQyAtPiBQcmludGYuc3ByaW50ZiBcIkpQICVzLCAlc1wiIChzaG93X2NvbmRpdGlvbiBjKSAoc2hvd19hcmcgeCkpXG4gIHwgSlIgKGMsIHgpIC0+IChcbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCBOb25lIC0+IFByaW50Zi5zcHJpbnRmIFwiSlIgJXNcIiAoSW50OC5zaG93IHgpXG4gICAgICB8IE5aIHwgWiB8IE5DIHwgQyAtPiBQcmludGYuc3ByaW50ZiBcIkpSICVzLCAlc1wiIChzaG93X2NvbmRpdGlvbiBjKSAoSW50OC5zaG93IHgpKVxuICB8IENBTEwgKGMsIHgpIC0+IChcbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCBOb25lIC0+IFByaW50Zi5zcHJpbnRmIFwiQ0FMTCAlc1wiIChVaW50MTYuc2hvdyB4KVxuICAgICAgfCBOWiB8IFogfCBOQyB8IEMgLT4gUHJpbnRmLnNwcmludGYgXCJDQUxMICVzLCAlc1wiIChzaG93X2NvbmRpdGlvbiBjKSAoVWludDE2LnNob3cgeCkpXG4gIHwgUlNUIHggLT4gUHJpbnRmLnNwcmludGYgXCJSU1QgJXNcIiAoVWludDE2LnNob3cgeClcbiAgfCBSRVQgYyAtPiBQcmludGYuc3ByaW50ZiBcIlJFVCAlc1wiIChzaG93X2NvbmRpdGlvbiBjKVxuICB8IFJFVEkgIC0+IFByaW50Zi5zcHJpbnRmIFwiUkVUSVwiXG4iLCJvcGVuIFVpbnRzXG5vcGVuIEluc3RydWN0aW9uXG5cbm1vZHVsZSBNYWtlIChNbXUgOiBXb3JkX2FkZHJlc3NhYmxlX2ludGYuUykgPSBzdHJ1Y3RcblxuICBtb2R1bGUgUlNUX29mZnNldCA9IHN0cnVjdFxuICAgIGxldCB4MDAgPSAweDAwIHw+IFVpbnQxNi5vZl9pbnRcbiAgICBsZXQgeDA4ID0gMHgwOCB8PiBVaW50MTYub2ZfaW50XG4gICAgbGV0IHgxMCA9IDB4MTAgfD4gVWludDE2Lm9mX2ludFxuICAgIGxldCB4MTggPSAweDE4IHw+IFVpbnQxNi5vZl9pbnRcbiAgICBsZXQgeDIwID0gMHgyMCB8PiBVaW50MTYub2ZfaW50XG4gICAgbGV0IHgyOCA9IDB4MjggfD4gVWludDE2Lm9mX2ludFxuICAgIGxldCB4MzAgPSAweDMwIHw+IFVpbnQxNi5vZl9pbnRcbiAgICBsZXQgeDM4ID0gMHgzOCB8PiBVaW50MTYub2ZfaW50XG4gIGVuZFxuXG4gIG1vZHVsZSBJbnN0cnVjdGlvbl9sZW5ndGggPSBzdHJ1Y3RcbiAgICBsZXQgbDEgPSAxIHw+IFVpbnQxNi5vZl9pbnRcbiAgICBsZXQgbDIgPSAyIHw+IFVpbnQxNi5vZl9pbnRcbiAgICBsZXQgbDMgPSAzIHw+IFVpbnQxNi5vZl9pbnRcbiAgZW5kXG5cbiAgbGV0IGYgbW11IH5wYyA6IHVpbnQxNiAqIChpbnQgKiBpbnQpICogSW5zdHJ1Y3Rpb24udCA9XG4gICAgbGV0IG9wZW4gSW5zdHJ1Y3Rpb25fbGVuZ3RoIGluXG4gICAgbGV0IGFkZHJfYWZ0ZXJfcGMgPSBVaW50MTYuKHN1Y2MgcGMpIGluXG4gICAgbGV0IG5leHRfYnl0ZSAoKSA9IE1tdS5yZWFkX2J5dGUgbW11IGFkZHJfYWZ0ZXJfcGMgaW5cbiAgICBsZXQgbmV4dF93b3JkICgpID0gTW11LnJlYWRfd29yZCBtbXUgYWRkcl9hZnRlcl9wYyBpblxuICAgIGxldCBvcCA9IE1tdS5yZWFkX2J5dGUgbW11IHBjIHw+IFVpbnQ4LnRvX2ludCBpblxuICAgIG1hdGNoIG9wIHdpdGhcbiAgICB8IDB4MDAgLT4gbDEsICgxLCAxKSwgTk9QXG4gICAgfCAweDAxIC0+IGwzLCAoMywgMyksIExEMTYgKFJSIEJDLCBJbW1lZGlhdGUxNiAobmV4dF93b3JkICgpKSlcbiAgICB8IDB4MDIgLT4gbDEsICgyLCAyKSwgTEQ4IChSUl9pbmRpcmVjdCBCQywgUiBBKVxuICAgIHwgMHgwMyAtPiBsMSwgKDIsIDIpLCBJTkMxNiAoUlIgQkMpXG4gICAgfCAweDA0IC0+IGwxLCAoMSwgMSksIElOQyAoUiBCKVxuICAgIHwgMHgwNSAtPiBsMSwgKDEsIDEpLCBERUMgKFIgQilcbiAgICB8IDB4MDYgLT4gbDIsICgyLCAyKSwgTEQ4IChSIEIsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweDA3IC0+IGwxLCAoMSwgMSksIFJMQ0FcbiAgICB8IDB4MDggLT4gbDMsICg1LCA1KSwgTEQxNiAoRGlyZWN0MTYgKG5leHRfd29yZCAoKSksIFNQKVxuICAgIHwgMHgwOSAtPiBsMSwgKDIsIDIpLCBBREQxNiAoUlIgSEwsIFJSIEJDKVxuICAgIHwgMHgwQSAtPiBsMSwgKDIsIDIpLCBMRDggKFIgQSwgUlJfaW5kaXJlY3QgQkMpXG4gICAgfCAweDBCIC0+IGwxLCAoMiwgMiksIERFQzE2IChSUiBCQylcbiAgICB8IDB4MEMgLT4gbDEsICgxLCAxKSwgSU5DIChSIEMpXG4gICAgfCAweDBEIC0+IGwxLCAoMSwgMSksIERFQyAoUiBDKVxuICAgIHwgMHgwRSAtPiBsMiwgKDIsIDIpLCBMRDggKFIgQywgSW1tZWRpYXRlOCAobmV4dF9ieXRlICgpKSlcbiAgICB8IDB4MEYgLT4gbDEsICgxLCAxKSwgUlJDQVxuICAgIHwgMHgxMCAtPiBpZ25vcmUobmV4dF9ieXRlICgpKTsgbDIsICgxLCAxKSwgU1RPUFxuICAgIHwgMHgxMSAtPiBsMywgKDMsIDMpLCBMRDE2IChSUiBERSwgSW1tZWRpYXRlMTYgKG5leHRfd29yZCAoKSkpXG4gICAgfCAweDEyIC0+IGwxLCAoMiwgMiksIExEOCAoUlJfaW5kaXJlY3QgREUsIFIgQSlcbiAgICB8IDB4MTMgLT4gbDEsICgyLCAyKSwgSU5DMTYgKFJSIERFKVxuICAgIHwgMHgxNCAtPiBsMSwgKDEsIDEpLCBJTkMgKFIgRClcbiAgICB8IDB4MTUgLT4gbDEsICgxLCAxKSwgREVDIChSIEQpXG4gICAgfCAweDE2IC0+IGwyLCAoMiwgMiksIExEOCAoUiBELCBJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKVxuICAgIHwgMHgxNyAtPiBsMSwgKDEsIDEpLCBSTEFcbiAgICB8IDB4MTggLT4gbDIsICgzLCAzKSwgSlIgKE5vbmUsIChJbnQ4Lm9mX2J5dGUgQEAgbmV4dF9ieXRlICgpKSlcbiAgICB8IDB4MTkgLT4gbDEsICgyLCAyKSwgQUREMTYgKFJSIEhMLCBSUiBERSlcbiAgICB8IDB4MUEgLT4gbDEsICgyLCAyKSwgTEQ4IChSIEEsIFJSX2luZGlyZWN0IERFKVxuICAgIHwgMHgxQiAtPiBsMSwgKDIsIDIpLCBERUMxNiAoUlIgREUpXG4gICAgfCAweDFDIC0+IGwxLCAoMSwgMSksIElOQyAoUiBFKVxuICAgIHwgMHgxRCAtPiBsMSwgKDEsIDEpLCBERUMgKFIgRSlcbiAgICB8IDB4MUUgLT4gbDIsICgyLCAyKSwgTEQ4IChSIEUsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweDFGIC0+IGwxLCAoMSwgMSksIFJSQVxuICAgIHwgMHgyMCAtPiBsMiwgKDIsIDMpLCBKUiAoTlosIEludDgub2ZfYnl0ZSBAQCBuZXh0X2J5dGUgKCkpXG4gICAgfCAweDIxIC0+IGwzLCAoMywgMyksIExEMTYgKFJSIEhMLCBJbW1lZGlhdGUxNiAobmV4dF93b3JkICgpKSlcbiAgICB8IDB4MjIgLT4gbDEsICgyLCAyKSwgTEQ4IChITF9pbmMsIFIgQSlcbiAgICB8IDB4MjMgLT4gbDEsICgyLCAyKSwgSU5DMTYgKFJSIEhMKVxuICAgIHwgMHgyNCAtPiBsMSwgKDEsIDEpLCBJTkMgKFIgSClcbiAgICB8IDB4MjUgLT4gbDEsICgxLCAxKSwgREVDIChSIEgpXG4gICAgfCAweDI2IC0+IGwyLCAoMiwgMiksIExEOCAoUiBILCBJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKVxuICAgIHwgMHgyNyAtPiBsMSwgKDEsIDEpLCBEQUFcbiAgICB8IDB4MjggLT4gbDIsICgyLCAzKSwgSlIgKFosIEludDgub2ZfYnl0ZSBAQCBuZXh0X2J5dGUgKCkpXG4gICAgfCAweDI5IC0+IGwxLCAoMiwgMiksIEFERDE2IChSUiBITCxSUiBITClcbiAgICB8IDB4MkEgLT4gbDEsICgyLCAyKSwgTEQ4IChSIEEsIEhMX2luYylcbiAgICB8IDB4MkIgLT4gbDEsICgyLCAyKSwgREVDMTYgKFJSIEhMKVxuICAgIHwgMHgyQyAtPiBsMSwgKDEsIDEpLCBJTkMgKFIgTClcbiAgICB8IDB4MkQgLT4gbDEsICgxLCAxKSwgREVDIChSIEwpXG4gICAgfCAweDJFIC0+IGwyLCAoMiwgMiksIExEOCAoUiBMLCBJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKVxuICAgIHwgMHgyRiAtPiBsMSwgKDEsIDEpLCBDUExcbiAgICB8IDB4MzAgLT4gbDIsICgyLCAzKSwgSlIgKE5DLCBJbnQ4Lm9mX2J5dGUgQEAgbmV4dF9ieXRlICgpKVxuICAgIHwgMHgzMSAtPiBsMywgKDMsIDMpLCBMRDE2IChTUCwgSW1tZWRpYXRlMTYgKG5leHRfd29yZCAoKSkpXG4gICAgfCAweDMyIC0+IGwxLCAoMiwgMiksIExEOCAoSExfZGVjLCBSIEEpXG4gICAgfCAweDMzIC0+IGwxLCAoMiwgMiksIElOQzE2IFNQXG4gICAgfCAweDM0IC0+IGwxLCAoMywgMyksIElOQyAoUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDM1IC0+IGwxLCAoMywgMyksIERFQyAoUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDM2IC0+IGwyLCAoMywgMyksIExEOCAoUlJfaW5kaXJlY3QgSEwsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweDM3IC0+IGwxLCAoMSwgMSksIFNDRlxuICAgIHwgMHgzOCAtPiBsMiwgKDIsIDMpLCBKUiAoQywgSW50OC5vZl9ieXRlIEBAIG5leHRfYnl0ZSAoKSlcbiAgICB8IDB4MzkgLT4gbDEsICgyLCAyKSwgQUREMTYgKFJSIEhMLCBTUClcbiAgICB8IDB4M0EgLT4gbDEsICgyLCAyKSwgTEQ4IChSIEEsIEhMX2RlYylcbiAgICB8IDB4M0IgLT4gbDEsICgyLCAyKSwgREVDMTYgU1BcbiAgICB8IDB4M0MgLT4gbDEsICgxLCAxKSwgSU5DIChSIEEpXG4gICAgfCAweDNEIC0+IGwxLCAoMSwgMSksIERFQyAoUiBBKVxuICAgIHwgMHgzRSAtPiBsMiwgKDIsIDIpLCBMRDggKFIgQSwgSW1tZWRpYXRlOCAobmV4dF9ieXRlICgpKSlcbiAgICB8IDB4M0YgLT4gbDEsICgxLCAxKSwgQ0NGXG4gICAgfCAweDQwIC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEIpXG4gICAgfCAweDQxIC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEMpXG4gICAgfCAweDQyIC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEQpXG4gICAgfCAweDQzIC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEUpXG4gICAgfCAweDQ0IC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEgpXG4gICAgfCAweDQ1IC0+IGwxLCAoMSwgMSksIExEOCAoUiBCLCBSIEwpXG4gICAgfCAweDQ2IC0+IGwxLCAoMiwgMiksIExEOCAoUiBCLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4NDcgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEIsIFIgQSlcbiAgICB8IDB4NDggLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgQilcbiAgICB8IDB4NDkgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgQylcbiAgICB8IDB4NEEgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgRClcbiAgICB8IDB4NEIgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgRSlcbiAgICB8IDB4NEMgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgSClcbiAgICB8IDB4NEQgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEMsIFIgTClcbiAgICB8IDB4NEUgLT4gbDEsICgyLCAyKSwgTEQ4IChSIEMsIFJSX2luZGlyZWN0IEhMKVxuICAgIHwgMHg0RiAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQywgUiBBKVxuICAgIHwgMHg1MCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBCKVxuICAgIHwgMHg1MSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBDKVxuICAgIHwgMHg1MiAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBEKVxuICAgIHwgMHg1MyAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBFKVxuICAgIHwgMHg1NCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBIKVxuICAgIHwgMHg1NSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgRCwgUiBMKVxuICAgIHwgMHg1NiAtPiBsMSwgKDIsIDIpLCBMRDggKFIgRCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDU3IC0+IGwxLCAoMSwgMSksIExEOCAoUiBELCBSIEEpXG4gICAgfCAweDU4IC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEIpXG4gICAgfCAweDU5IC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEMpXG4gICAgfCAweDVBIC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEQpXG4gICAgfCAweDVCIC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEUpXG4gICAgfCAweDVDIC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEgpXG4gICAgfCAweDVEIC0+IGwxLCAoMSwgMSksIExEOCAoUiBFLCBSIEwpXG4gICAgfCAweDVFIC0+IGwxLCAoMiwgMiksIExEOCAoUiBFLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4NUYgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEUsIFIgQSlcbiAgICB8IDB4NjAgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgQilcbiAgICB8IDB4NjEgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgQylcbiAgICB8IDB4NjIgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgRClcbiAgICB8IDB4NjMgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgRSlcbiAgICB8IDB4NjQgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgSClcbiAgICB8IDB4NjUgLT4gbDEsICgxLCAxKSwgTEQ4IChSIEgsIFIgTClcbiAgICB8IDB4NjYgLT4gbDEsICgyLCAyKSwgTEQ4IChSIEgsIFJSX2luZGlyZWN0IEhMKVxuICAgIHwgMHg2NyAtPiBsMSwgKDEsIDEpLCBMRDggKFIgSCwgUiBBKVxuICAgIHwgMHg2OCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBCKVxuICAgIHwgMHg2OSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBDKVxuICAgIHwgMHg2QSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBEKVxuICAgIHwgMHg2QiAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBFKVxuICAgIHwgMHg2QyAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBIKVxuICAgIHwgMHg2RCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgTCwgUiBMKVxuICAgIHwgMHg2RSAtPiBsMSwgKDIsIDIpLCBMRDggKFIgTCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDZGIC0+IGwxLCAoMSwgMSksIExEOCAoUiBMLCBSIEEpXG4gICAgfCAweDcwIC0+IGwxLCAoMiwgMiksIExEOCAoUlJfaW5kaXJlY3QgSEwsIFIgQilcbiAgICB8IDB4NzEgLT4gbDEsICgyLCAyKSwgTEQ4IChSUl9pbmRpcmVjdCBITCwgUiBDKVxuICAgIHwgMHg3MiAtPiBsMSwgKDIsIDIpLCBMRDggKFJSX2luZGlyZWN0IEhMLCBSIEQpXG4gICAgfCAweDczIC0+IGwxLCAoMiwgMiksIExEOCAoUlJfaW5kaXJlY3QgSEwsIFIgRSlcbiAgICB8IDB4NzQgLT4gbDEsICgyLCAyKSwgTEQ4IChSUl9pbmRpcmVjdCBITCwgUiBIKVxuICAgIHwgMHg3NSAtPiBsMSwgKDIsIDIpLCBMRDggKFJSX2luZGlyZWN0IEhMLCBSIEwpXG4gICAgfCAweDc2IC0+IGwxLCAoMSwgMSksIEhBTFRcbiAgICB8IDB4NzcgLT4gbDEsICgyLCAyKSwgTEQ4IChSUl9pbmRpcmVjdCBITCwgUiBBKVxuICAgIHwgMHg3OCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBCKVxuICAgIHwgMHg3OSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBDKVxuICAgIHwgMHg3QSAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBEKVxuICAgIHwgMHg3QiAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBFKVxuICAgIHwgMHg3QyAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBIKVxuICAgIHwgMHg3RCAtPiBsMSwgKDEsIDEpLCBMRDggKFIgQSwgUiBMKVxuICAgIHwgMHg3RSAtPiBsMSwgKDIsIDIpLCBMRDggKFIgQSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDdGIC0+IGwxLCAoMSwgMSksIExEOCAoUiBBLCBSIEEpXG4gICAgfCAweDgwIC0+IGwxLCAoMSwgMSksIEFERDggKFIgQSwgUiBCKVxuICAgIHwgMHg4MSAtPiBsMSwgKDEsIDEpLCBBREQ4IChSIEEsIFIgQylcbiAgICB8IDB4ODIgLT4gbDEsICgxLCAxKSwgQUREOCAoUiBBLCBSIEQpXG4gICAgfCAweDgzIC0+IGwxLCAoMSwgMSksIEFERDggKFIgQSwgUiBFKVxuICAgIHwgMHg4NCAtPiBsMSwgKDEsIDEpLCBBREQ4IChSIEEsIFIgSClcbiAgICB8IDB4ODUgLT4gbDEsICgxLCAxKSwgQUREOCAoUiBBLCBSIEwpXG4gICAgfCAweDg2IC0+IGwxLCAoMiwgMiksIEFERDggKFIgQSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDg3IC0+IGwxLCAoMSwgMSksIEFERDggKFIgQSwgKFIgQSkpXG4gICAgfCAweDg4IC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEIpXG4gICAgfCAweDg5IC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEMpXG4gICAgfCAweDhBIC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEQpXG4gICAgfCAweDhCIC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEUpXG4gICAgfCAweDhDIC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEgpXG4gICAgfCAweDhEIC0+IGwxLCAoMSwgMSksIEFEQyAoUiBBLCBSIEwpXG4gICAgfCAweDhFIC0+IGwxLCAoMiwgMiksIEFEQyAoUiBBLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4OEYgLT4gbDEsICgxLCAxKSwgQURDIChSIEEsIFIgQSlcbiAgICB8IDB4OTAgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgQilcbiAgICB8IDB4OTEgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgQylcbiAgICB8IDB4OTIgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgRClcbiAgICB8IDB4OTMgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgRSlcbiAgICB8IDB4OTQgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgSClcbiAgICB8IDB4OTUgLT4gbDEsICgxLCAxKSwgU1VCIChSIEEsIFIgTClcbiAgICB8IDB4OTYgLT4gbDEsICgyLCAyKSwgU1VCIChSIEEsIFJSX2luZGlyZWN0IEhMKVxuICAgIHwgMHg5NyAtPiBsMSwgKDEsIDEpLCBTVUIgKFIgQSwgUiBBKVxuICAgIHwgMHg5OCAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBCKVxuICAgIHwgMHg5OSAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBDKVxuICAgIHwgMHg5QSAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBEKVxuICAgIHwgMHg5QiAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBFKVxuICAgIHwgMHg5QyAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBIKVxuICAgIHwgMHg5RCAtPiBsMSwgKDEsIDEpLCBTQkMgKFIgQSwgUiBMKVxuICAgIHwgMHg5RSAtPiBsMSwgKDIsIDIpLCBTQkMgKFIgQSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgfCAweDlGIC0+IGwxLCAoMSwgMSksIFNCQyAoUiBBLCBSIEEpXG4gICAgfCAweEEwIC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEIpXG4gICAgfCAweEExIC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEMpXG4gICAgfCAweEEyIC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEQpXG4gICAgfCAweEEzIC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEUpXG4gICAgfCAweEE0IC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEgpXG4gICAgfCAweEE1IC0+IGwxLCAoMSwgMSksIEFORCAoUiBBLCBSIEwpXG4gICAgfCAweEE2IC0+IGwxLCAoMiwgMiksIEFORCAoUiBBLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4QTcgLT4gbDEsICgxLCAxKSwgQU5EIChSIEEsIFIgQSlcbiAgICB8IDB4QTggLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgQilcbiAgICB8IDB4QTkgLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgQylcbiAgICB8IDB4QUEgLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgRClcbiAgICB8IDB4QUIgLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgRSlcbiAgICB8IDB4QUMgLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgSClcbiAgICB8IDB4QUQgLT4gbDEsICgxLCAxKSwgWE9SIChSIEEsIFIgTClcbiAgICB8IDB4QUUgLT4gbDEsICgyLCAyKSwgWE9SIChSIEEsIFJSX2luZGlyZWN0IEhMKVxuICAgIHwgMHhBRiAtPiBsMSwgKDEsIDEpLCBYT1IgKFIgQSwgUiBBKVxuICAgIHwgMHhCMCAtPiBsMSwgKDEsIDEpLCBPUiAoUiBBLCBSIEIpXG4gICAgfCAweEIxIC0+IGwxLCAoMSwgMSksIE9SIChSIEEsIFIgQylcbiAgICB8IDB4QjIgLT4gbDEsICgxLCAxKSwgT1IgKFIgQSwgUiBEKVxuICAgIHwgMHhCMyAtPiBsMSwgKDEsIDEpLCBPUiAoUiBBLCBSIEUpXG4gICAgfCAweEI0IC0+IGwxLCAoMSwgMSksIE9SIChSIEEsIFIgSClcbiAgICB8IDB4QjUgLT4gbDEsICgxLCAxKSwgT1IgKFIgQSwgUiBMKVxuICAgIHwgMHhCNiAtPiBsMSwgKDIsIDIpLCBPUiAoUiBBLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4QjcgLT4gbDEsICgxLCAxKSwgT1IgKFIgQSwgUiBBKVxuICAgIHwgMHhCOCAtPiBsMSwgKDEsIDEpLCBDUCAoUiBBLCBSIEIpXG4gICAgfCAweEI5IC0+IGwxLCAoMSwgMSksIENQIChSIEEsIFIgQylcbiAgICB8IDB4QkEgLT4gbDEsICgxLCAxKSwgQ1AgKFIgQSwgUiBEKVxuICAgIHwgMHhCQiAtPiBsMSwgKDEsIDEpLCBDUCAoUiBBLCBSIEUpXG4gICAgfCAweEJDIC0+IGwxLCAoMSwgMSksIENQIChSIEEsIFIgSClcbiAgICB8IDB4QkQgLT4gbDEsICgxLCAxKSwgQ1AgKFIgQSwgUiBMKVxuICAgIHwgMHhCRSAtPiBsMSwgKDIsIDIpLCBDUCAoUiBBLCBSUl9pbmRpcmVjdCBITClcbiAgICB8IDB4QkYgLT4gbDEsICgxLCAxKSwgQ1AgKFIgQSwgUiBBKVxuICAgIHwgMHhDMCAtPiBsMSwgKDIsIDUpLCBSRVQgTlpcbiAgICB8IDB4QzEgLT4gbDEsICgzLCAzKSwgUE9QIEJDXG4gICAgfCAweEMyIC0+IGwzLCAoMywgNCksIEpQIChOWiwgSW1tZWRpYXRlMTYgKG5leHRfd29yZCAoKSkpXG4gICAgfCAweEMzIC0+IGwzLCAoNCwgNCksIEpQIChOb25lLCBJbW1lZGlhdGUxNiAobmV4dF93b3JkICgpKSlcbiAgICB8IDB4QzQgLT4gbDMsICgzLCA2KSwgQ0FMTCAoTlosIG5leHRfd29yZCAoKSlcbiAgICB8IDB4QzUgLT4gbDEsICg0LCA0KSwgUFVTSCBCQ1xuICAgIHwgMHhDNiAtPiBsMiwgKDIsIDIpLCBBREQ4IChSIEEsIChJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKSlcbiAgICB8IDB4QzcgLT4gbDEsICg0LCA0KSwgUlNUIFJTVF9vZmZzZXQueDAwXG4gICAgfCAweEM4IC0+IGwxLCAoMiwgNSksIFJFVCBaXG4gICAgfCAweEM5IC0+IGwxLCAoNCwgNCksIFJFVCBOb25lXG4gICAgfCAweENBIC0+IGwzLCAoMywgNCksIEpQIChaLCBJbW1lZGlhdGUxNiAobmV4dF93b3JkICgpKSlcbiAgICB8IDB4Q0MgLT4gbDMsICgzLCA2KSwgQ0FMTCAoWiwgbmV4dF93b3JkICgpKVxuICAgIHwgMHhDRCAtPiBsMywgKDYsIDYpLCBDQUxMIChOb25lLCBuZXh0X3dvcmQgKCkpXG4gICAgfCAweENFIC0+IGwyLCAoMiwgMiksIEFEQyAoUiBBLCBJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKVxuICAgIHwgMHhDRiAtPiBsMSwgKDQsIDQpLCBSU1QgUlNUX29mZnNldC54MDhcbiAgICB8IDB4RDAgLT4gbDEsICgyLCA1KSwgUkVUIE5DXG4gICAgfCAweEQxIC0+IGwxLCAoMywgMyksIFBPUCBERVxuICAgIHwgMHhEMiAtPiBsMywgKDMsIDQpLCBKUCAoTkMsIEltbWVkaWF0ZTE2IChuZXh0X3dvcmQgKCkpKVxuICAgIHwgMHhEMyAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4RDQgLT4gbDMsICgzLCA2KSwgQ0FMTCAoTkMsIG5leHRfd29yZCAoKSlcbiAgICB8IDB4RDUgLT4gbDEsICg0LCA0KSwgUFVTSCBERVxuICAgIHwgMHhENiAtPiBsMiwgKDIsIDIpLCBTVUIgKFIgQSwgSW1tZWRpYXRlOCAobmV4dF9ieXRlICgpKSlcbiAgICB8IDB4RDcgLT4gbDEsICg0LCA0KSwgUlNUIFJTVF9vZmZzZXQueDEwXG4gICAgfCAweEQ4IC0+IGwxLCAoMiwgNSksIFJFVCBDXG4gICAgfCAweEQ5IC0+IGwxLCAoNCwgNCksIFJFVElcbiAgICB8IDB4REEgLT4gbDMsICgzLCA0KSwgSlAgKEMsIEltbWVkaWF0ZTE2IChuZXh0X3dvcmQgKCkpKVxuICAgIHwgMHhEQiAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4REMgLT4gbDMsICgzLCA2KSwgQ0FMTCAoQywgbmV4dF93b3JkICgpKVxuICAgIHwgMHhERCAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4REUgLT4gbDIsICgyLCAyKSwgU0JDIChSIEEsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweERGIC0+IGwxLCAoNCwgNCksIFJTVCBSU1Rfb2Zmc2V0LngxOFxuICAgIHwgMHhFMCAtPiBsMiwgKDMsIDMpLCBMRDggKEZGMDBfb2Zmc2V0IChuZXh0X2J5dGUgKCkpLCBSIEEpXG4gICAgfCAweEUxIC0+IGwxLCAoMywgMyksIFBPUCBITFxuICAgIHwgMHhFMiAtPiBsMSwgKDIsIDIpLCBMRDggKEZGMDBfQywgUiBBKVxuICAgIHwgMHhFMyAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4RTQgLT4gbDEsICgxLCAxKSwgTk9QXG4gICAgfCAweEU1IC0+IGwxLCAoNCwgNCksIFBVU0ggSExcbiAgICB8IDB4RTYgLT4gbDIsICgyLCAyKSwgQU5EIChSIEEsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweEU3IC0+IGwxLCAoNCwgNCksIFJTVCBSU1Rfb2Zmc2V0LngyMFxuICAgIHwgMHhFOCAtPiBsMiwgKDQsIDQpLCBBRERTUCAobmV4dF9ieXRlICgpIHw+IEludDgub2ZfYnl0ZSlcbiAgICB8IDB4RTkgLT4gbDEsICgxLCAxKSwgSlAgKE5vbmUsIFJSIEhMKVxuICAgIHwgMHhFQSAtPiBsMywgKDQsIDQpLCBMRDggKERpcmVjdDggKG5leHRfd29yZCAoKSksIFIgQSlcbiAgICB8IDB4RUIgLT4gbDEsICgxLCAxKSwgTk9QXG4gICAgfCAweEVDIC0+IGwxLCAoMSwgMSksIE5PUFxuICAgIHwgMHhFRCAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4RUUgLT4gbDIsICgyLCAyKSwgWE9SIChSIEEsIEltbWVkaWF0ZTggKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweEVGIC0+IGwxLCAoNCwgNCksIFJTVCBSU1Rfb2Zmc2V0LngyOFxuICAgIHwgMHhGMCAtPiBsMiwgKDMsIDMpLCBMRDggKFIgQSwgRkYwMF9vZmZzZXQgKG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweEYxIC0+IGwxLCAoMywgMyksIFBPUCBBRlxuICAgIHwgMHhGMiAtPiBsMSwgKDIsIDIpLCBMRDggKFIgQSwgRkYwMF9DKVxuICAgIHwgMHhGMyAtPiBsMSwgKDEsIDEpLCBESVxuICAgIHwgMHhGNCAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4RjUgLT4gbDEsICg0LCA0KSwgUFVTSCBBRlxuICAgIHwgMHhGNiAtPiBsMiwgKDIsIDIpLCBPUiAoUiBBLCBJbW1lZGlhdGU4IChuZXh0X2J5dGUgKCkpKVxuICAgIHwgMHhGNyAtPiBsMSwgKDQsIDQpLCBSU1QgUlNUX29mZnNldC54MzBcbiAgICB8IDB4RjggLT4gbDIsICgzLCAzKSwgTEQxNiAoUlIgSEwsIFNQX29mZnNldCAoSW50OC5vZl9ieXRlIEBAIG5leHRfYnl0ZSAoKSkpXG4gICAgfCAweEY5IC0+IGwxLCAoMiwgMiksIExEMTYgKFNQLCBSUiBITClcbiAgICB8IDB4RkEgLT4gbDMsICg0LCA0KSwgTEQ4IChSIEEsIERpcmVjdDggKG5leHRfd29yZCAoKSkpXG4gICAgfCAweEZCIC0+IGwxLCAoMSwgMSksIEVJXG4gICAgfCAweEZDIC0+IGwxLCAoMSwgMSksIE5PUFxuICAgIHwgMHhGRCAtPiBsMSwgKDEsIDEpLCBOT1BcbiAgICB8IDB4RkUgLT4gbDIsICgyLCAyKSwgQ1AgKFIgQSwgSW1tZWRpYXRlOCAobmV4dF9ieXRlICgpKSlcbiAgICB8IDB4RkYgLT4gbDEsICg0LCA0KSwgUlNUIFJTVF9vZmZzZXQueDM4XG4gICAgfCAweENCIC0+IGJlZ2luXG4gICAgICAgIGxldCBvcCA9IG5leHRfYnl0ZSAoKSB8PiBVaW50OC50b19pbnQgaW5cbiAgICAgICAgbWF0Y2ggb3Agd2l0aFxuICAgICAgICB8IDB4MDAgLT4gbDIsICgyLCAyKSwgUkxDIChSIEIpXG4gICAgICAgIHwgMHgwMSAtPiBsMiwgKDIsIDIpLCBSTEMgKFIgQylcbiAgICAgICAgfCAweDAyIC0+IGwyLCAoMiwgMiksIFJMQyAoUiBEKVxuICAgICAgICB8IDB4MDMgLT4gbDIsICgyLCAyKSwgUkxDIChSIEUpXG4gICAgICAgIHwgMHgwNCAtPiBsMiwgKDIsIDIpLCBSTEMgKFIgSClcbiAgICAgICAgfCAweDA1IC0+IGwyLCAoMiwgMiksIFJMQyAoUiBMKVxuICAgICAgICB8IDB4MDYgLT4gbDIsICg0LCA0KSwgUkxDIChSUl9pbmRpcmVjdCBITClcbiAgICAgICAgfCAweDA3IC0+IGwyLCAoMiwgMiksIFJMQyAoUiBBKVxuICAgICAgICB8IDB4MDggLT4gbDIsICgyLCAyKSwgUlJDIChSIEIpXG4gICAgICAgIHwgMHgwOSAtPiBsMiwgKDIsIDIpLCBSUkMgKFIgQylcbiAgICAgICAgfCAweDBBIC0+IGwyLCAoMiwgMiksIFJSQyAoUiBEKVxuICAgICAgICB8IDB4MEIgLT4gbDIsICgyLCAyKSwgUlJDIChSIEUpXG4gICAgICAgIHwgMHgwQyAtPiBsMiwgKDIsIDIpLCBSUkMgKFIgSClcbiAgICAgICAgfCAweDBEIC0+IGwyLCAoMiwgMiksIFJSQyAoUiBMKVxuICAgICAgICB8IDB4MEUgLT4gbDIsICg0LCA0KSwgUlJDIChSUl9pbmRpcmVjdCBITClcbiAgICAgICAgfCAweDBGIC0+IGwyLCAoMiwgMiksIFJSQyAoUiBBKVxuICAgICAgICB8IDB4MTAgLT4gbDIsICgyLCAyKSwgUkwgKFIgQilcbiAgICAgICAgfCAweDExIC0+IGwyLCAoMiwgMiksIFJMIChSIEMpXG4gICAgICAgIHwgMHgxMiAtPiBsMiwgKDIsIDIpLCBSTCAoUiBEKVxuICAgICAgICB8IDB4MTMgLT4gbDIsICgyLCAyKSwgUkwgKFIgRSlcbiAgICAgICAgfCAweDE0IC0+IGwyLCAoMiwgMiksIFJMIChSIEgpXG4gICAgICAgIHwgMHgxNSAtPiBsMiwgKDIsIDIpLCBSTCAoUiBMKVxuICAgICAgICB8IDB4MTYgLT4gbDIsICg0LCA0KSwgUkwgKFJSX2luZGlyZWN0IEhMKVxuICAgICAgICB8IDB4MTcgLT4gbDIsICgyLCAyKSwgUkwgKFIgQSlcbiAgICAgICAgfCAweDE4IC0+IGwyLCAoMiwgMiksIFJSIChSIEIpXG4gICAgICAgIHwgMHgxOSAtPiBsMiwgKDIsIDIpLCBSUiAoUiBDKVxuICAgICAgICB8IDB4MUEgLT4gbDIsICgyLCAyKSwgUlIgKFIgRClcbiAgICAgICAgfCAweDFCIC0+IGwyLCAoMiwgMiksIFJSIChSIEUpXG4gICAgICAgIHwgMHgxQyAtPiBsMiwgKDIsIDIpLCBSUiAoUiBIKVxuICAgICAgICB8IDB4MUQgLT4gbDIsICgyLCAyKSwgUlIgKFIgTClcbiAgICAgICAgfCAweDFFIC0+IGwyLCAoNCwgNCksIFJSIChSUl9pbmRpcmVjdCBITClcbiAgICAgICAgfCAweDFGIC0+IGwyLCAoMiwgMiksIFJSIChSIEEpXG4gICAgICAgIHwgMHgyMCAtPiBsMiwgKDIsIDIpLCBTTEEgKFIgQilcbiAgICAgICAgfCAweDIxIC0+IGwyLCAoMiwgMiksIFNMQSAoUiBDKVxuICAgICAgICB8IDB4MjIgLT4gbDIsICgyLCAyKSwgU0xBIChSIEQpXG4gICAgICAgIHwgMHgyMyAtPiBsMiwgKDIsIDIpLCBTTEEgKFIgRSlcbiAgICAgICAgfCAweDI0IC0+IGwyLCAoMiwgMiksIFNMQSAoUiBIKVxuICAgICAgICB8IDB4MjUgLT4gbDIsICgyLCAyKSwgU0xBIChSIEwpXG4gICAgICAgIHwgMHgyNiAtPiBsMiwgKDQsIDQpLCBTTEEgKFJSX2luZGlyZWN0IEhMKVxuICAgICAgICB8IDB4MjcgLT4gbDIsICgyLCAyKSwgU0xBIChSIEEpXG4gICAgICAgIHwgMHgyOCAtPiBsMiwgKDIsIDIpLCBTUkEgKFIgQilcbiAgICAgICAgfCAweDI5IC0+IGwyLCAoMiwgMiksIFNSQSAoUiBDKVxuICAgICAgICB8IDB4MkEgLT4gbDIsICgyLCAyKSwgU1JBIChSIEQpXG4gICAgICAgIHwgMHgyQiAtPiBsMiwgKDIsIDIpLCBTUkEgKFIgRSlcbiAgICAgICAgfCAweDJDIC0+IGwyLCAoMiwgMiksIFNSQSAoUiBIKVxuICAgICAgICB8IDB4MkQgLT4gbDIsICgyLCAyKSwgU1JBIChSIEwpXG4gICAgICAgIHwgMHgyRSAtPiBsMiwgKDQsIDQpLCBTUkEgKFJSX2luZGlyZWN0IEhMKVxuICAgICAgICB8IDB4MkYgLT4gbDIsICgyLCAyKSwgU1JBIChSIEEpXG4gICAgICAgIHwgMHgzMCAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEIpXG4gICAgICAgIHwgMHgzMSAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEMpXG4gICAgICAgIHwgMHgzMiAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEQpXG4gICAgICAgIHwgMHgzMyAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEUpXG4gICAgICAgIHwgMHgzNCAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEgpXG4gICAgICAgIHwgMHgzNSAtPiBsMiwgKDIsIDIpLCBTV0FQIChSIEwpXG4gICAgICAgIHwgMHgzNiAtPiBsMiwgKDQsIDQpLCBTV0FQIChSUl9pbmRpcmVjdCBITClcbiAgICAgICAgfCAweDM3IC0+IGwyLCAoMiwgMiksIFNXQVAgKFIgQSlcbiAgICAgICAgfCAweDM4IC0+IGwyLCAoMiwgMiksIFNSTCAoUiBCKVxuICAgICAgICB8IDB4MzkgLT4gbDIsICgyLCAyKSwgU1JMIChSIEMpXG4gICAgICAgIHwgMHgzQSAtPiBsMiwgKDIsIDIpLCBTUkwgKFIgRClcbiAgICAgICAgfCAweDNCIC0+IGwyLCAoMiwgMiksIFNSTCAoUiBFKVxuICAgICAgICB8IDB4M0MgLT4gbDIsICgyLCAyKSwgU1JMIChSIEgpXG4gICAgICAgIHwgMHgzRCAtPiBsMiwgKDIsIDIpLCBTUkwgKFIgTClcbiAgICAgICAgfCAweDNFIC0+IGwyLCAoNCwgNCksIFNSTCAoUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHgzRiAtPiBsMiwgKDIsIDIpLCBTUkwgKFIgQSlcbiAgICAgICAgfCAweDQwIC0+IGwyLCAoMiwgMiksIEJJVCAoMCwgUiBCKVxuICAgICAgICB8IDB4NDEgLT4gbDIsICgyLCAyKSwgQklUICgwLCBSIEMpXG4gICAgICAgIHwgMHg0MiAtPiBsMiwgKDIsIDIpLCBCSVQgKDAsIFIgRClcbiAgICAgICAgfCAweDQzIC0+IGwyLCAoMiwgMiksIEJJVCAoMCwgUiBFKVxuICAgICAgICB8IDB4NDQgLT4gbDIsICgyLCAyKSwgQklUICgwLCBSIEgpXG4gICAgICAgIHwgMHg0NSAtPiBsMiwgKDIsIDIpLCBCSVQgKDAsIFIgTClcbiAgICAgICAgfCAweDQ2IC0+IGwyLCAoMywgMyksIEJJVCAoMCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg0NyAtPiBsMiwgKDIsIDIpLCBCSVQgKDAsIFIgQSlcbiAgICAgICAgfCAweDQ4IC0+IGwyLCAoMiwgMiksIEJJVCAoMSwgUiBCKVxuICAgICAgICB8IDB4NDkgLT4gbDIsICgyLCAyKSwgQklUICgxLCBSIEMpXG4gICAgICAgIHwgMHg0QSAtPiBsMiwgKDIsIDIpLCBCSVQgKDEsIFIgRClcbiAgICAgICAgfCAweDRCIC0+IGwyLCAoMiwgMiksIEJJVCAoMSwgUiBFKVxuICAgICAgICB8IDB4NEMgLT4gbDIsICgyLCAyKSwgQklUICgxLCBSIEgpXG4gICAgICAgIHwgMHg0RCAtPiBsMiwgKDIsIDIpLCBCSVQgKDEsIFIgTClcbiAgICAgICAgfCAweDRFIC0+IGwyLCAoMywgMyksIEJJVCAoMSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg0RiAtPiBsMiwgKDIsIDIpLCBCSVQgKDEsIFIgQSlcbiAgICAgICAgfCAweDUwIC0+IGwyLCAoMiwgMiksIEJJVCAoMiwgUiBCKVxuICAgICAgICB8IDB4NTEgLT4gbDIsICgyLCAyKSwgQklUICgyLCBSIEMpXG4gICAgICAgIHwgMHg1MiAtPiBsMiwgKDIsIDIpLCBCSVQgKDIsIFIgRClcbiAgICAgICAgfCAweDUzIC0+IGwyLCAoMiwgMiksIEJJVCAoMiwgUiBFKVxuICAgICAgICB8IDB4NTQgLT4gbDIsICgyLCAyKSwgQklUICgyLCBSIEgpXG4gICAgICAgIHwgMHg1NSAtPiBsMiwgKDIsIDIpLCBCSVQgKDIsIFIgTClcbiAgICAgICAgfCAweDU2IC0+IGwyLCAoMywgMyksIEJJVCAoMiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg1NyAtPiBsMiwgKDIsIDIpLCBCSVQgKDIsIFIgQSlcbiAgICAgICAgfCAweDU4IC0+IGwyLCAoMiwgMiksIEJJVCAoMywgUiBCKVxuICAgICAgICB8IDB4NTkgLT4gbDIsICgyLCAyKSwgQklUICgzLCBSIEMpXG4gICAgICAgIHwgMHg1QSAtPiBsMiwgKDIsIDIpLCBCSVQgKDMsIFIgRClcbiAgICAgICAgfCAweDVCIC0+IGwyLCAoMiwgMiksIEJJVCAoMywgUiBFKVxuICAgICAgICB8IDB4NUMgLT4gbDIsICgyLCAyKSwgQklUICgzLCBSIEgpXG4gICAgICAgIHwgMHg1RCAtPiBsMiwgKDIsIDIpLCBCSVQgKDMsIFIgTClcbiAgICAgICAgfCAweDVFIC0+IGwyLCAoMywgMyksIEJJVCAoMywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg1RiAtPiBsMiwgKDIsIDIpLCBCSVQgKDMsIFIgQSlcbiAgICAgICAgfCAweDYwIC0+IGwyLCAoMiwgMiksIEJJVCAoNCwgUiBCKVxuICAgICAgICB8IDB4NjEgLT4gbDIsICgyLCAyKSwgQklUICg0LCBSIEMpXG4gICAgICAgIHwgMHg2MiAtPiBsMiwgKDIsIDIpLCBCSVQgKDQsIFIgRClcbiAgICAgICAgfCAweDYzIC0+IGwyLCAoMiwgMiksIEJJVCAoNCwgUiBFKVxuICAgICAgICB8IDB4NjQgLT4gbDIsICgyLCAyKSwgQklUICg0LCBSIEgpXG4gICAgICAgIHwgMHg2NSAtPiBsMiwgKDIsIDIpLCBCSVQgKDQsIFIgTClcbiAgICAgICAgfCAweDY2IC0+IGwyLCAoMywgMyksIEJJVCAoNCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg2NyAtPiBsMiwgKDIsIDIpLCBCSVQgKDQsIFIgQSlcbiAgICAgICAgfCAweDY4IC0+IGwyLCAoMiwgMiksIEJJVCAoNSwgUiBCKVxuICAgICAgICB8IDB4NjkgLT4gbDIsICgyLCAyKSwgQklUICg1LCBSIEMpXG4gICAgICAgIHwgMHg2QSAtPiBsMiwgKDIsIDIpLCBCSVQgKDUsIFIgRClcbiAgICAgICAgfCAweDZCIC0+IGwyLCAoMiwgMiksIEJJVCAoNSwgUiBFKVxuICAgICAgICB8IDB4NkMgLT4gbDIsICgyLCAyKSwgQklUICg1LCBSIEgpXG4gICAgICAgIHwgMHg2RCAtPiBsMiwgKDIsIDIpLCBCSVQgKDUsIFIgTClcbiAgICAgICAgfCAweDZFIC0+IGwyLCAoMywgMyksIEJJVCAoNSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg2RiAtPiBsMiwgKDIsIDIpLCBCSVQgKDUsIFIgQSlcbiAgICAgICAgfCAweDcwIC0+IGwyLCAoMiwgMiksIEJJVCAoNiwgUiBCKVxuICAgICAgICB8IDB4NzEgLT4gbDIsICgyLCAyKSwgQklUICg2LCBSIEMpXG4gICAgICAgIHwgMHg3MiAtPiBsMiwgKDIsIDIpLCBCSVQgKDYsIFIgRClcbiAgICAgICAgfCAweDczIC0+IGwyLCAoMiwgMiksIEJJVCAoNiwgUiBFKVxuICAgICAgICB8IDB4NzQgLT4gbDIsICgyLCAyKSwgQklUICg2LCBSIEgpXG4gICAgICAgIHwgMHg3NSAtPiBsMiwgKDIsIDIpLCBCSVQgKDYsIFIgTClcbiAgICAgICAgfCAweDc2IC0+IGwyLCAoMywgMyksIEJJVCAoNiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg3NyAtPiBsMiwgKDIsIDIpLCBCSVQgKDYsIFIgQSlcbiAgICAgICAgfCAweDc4IC0+IGwyLCAoMiwgMiksIEJJVCAoNywgUiBCKVxuICAgICAgICB8IDB4NzkgLT4gbDIsICgyLCAyKSwgQklUICg3LCBSIEMpXG4gICAgICAgIHwgMHg3QSAtPiBsMiwgKDIsIDIpLCBCSVQgKDcsIFIgRClcbiAgICAgICAgfCAweDdCIC0+IGwyLCAoMiwgMiksIEJJVCAoNywgUiBFKVxuICAgICAgICB8IDB4N0MgLT4gbDIsICgyLCAyKSwgQklUICg3LCBSIEgpXG4gICAgICAgIHwgMHg3RCAtPiBsMiwgKDIsIDIpLCBCSVQgKDcsIFIgTClcbiAgICAgICAgfCAweDdFIC0+IGwyLCAoMywgMyksIEJJVCAoNywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg3RiAtPiBsMiwgKDIsIDIpLCBCSVQgKDcsIFIgQSlcbiAgICAgICAgfCAweDgwIC0+IGwyLCAoMiwgMiksIFJFUyAoMCwgUiBCKVxuICAgICAgICB8IDB4ODEgLT4gbDIsICgyLCAyKSwgUkVTICgwLCBSIEMpXG4gICAgICAgIHwgMHg4MiAtPiBsMiwgKDIsIDIpLCBSRVMgKDAsIFIgRClcbiAgICAgICAgfCAweDgzIC0+IGwyLCAoMiwgMiksIFJFUyAoMCwgUiBFKVxuICAgICAgICB8IDB4ODQgLT4gbDIsICgyLCAyKSwgUkVTICgwLCBSIEgpXG4gICAgICAgIHwgMHg4NSAtPiBsMiwgKDIsIDIpLCBSRVMgKDAsIFIgTClcbiAgICAgICAgfCAweDg2IC0+IGwyLCAoNCwgNCksIFJFUyAoMCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg4NyAtPiBsMiwgKDIsIDIpLCBSRVMgKDAsIFIgQSlcbiAgICAgICAgfCAweDg4IC0+IGwyLCAoMiwgMiksIFJFUyAoMSwgUiBCKVxuICAgICAgICB8IDB4ODkgLT4gbDIsICgyLCAyKSwgUkVTICgxLCBSIEMpXG4gICAgICAgIHwgMHg4QSAtPiBsMiwgKDIsIDIpLCBSRVMgKDEsIFIgRClcbiAgICAgICAgfCAweDhCIC0+IGwyLCAoMiwgMiksIFJFUyAoMSwgUiBFKVxuICAgICAgICB8IDB4OEMgLT4gbDIsICgyLCAyKSwgUkVTICgxLCBSIEgpXG4gICAgICAgIHwgMHg4RCAtPiBsMiwgKDIsIDIpLCBSRVMgKDEsIFIgTClcbiAgICAgICAgfCAweDhFIC0+IGwyLCAoNCwgNCksIFJFUyAoMSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg4RiAtPiBsMiwgKDIsIDIpLCBSRVMgKDEsIFIgQSlcbiAgICAgICAgfCAweDkwIC0+IGwyLCAoMiwgMiksIFJFUyAoMiwgUiBCKVxuICAgICAgICB8IDB4OTEgLT4gbDIsICgyLCAyKSwgUkVTICgyLCBSIEMpXG4gICAgICAgIHwgMHg5MiAtPiBsMiwgKDIsIDIpLCBSRVMgKDIsIFIgRClcbiAgICAgICAgfCAweDkzIC0+IGwyLCAoMiwgMiksIFJFUyAoMiwgUiBFKVxuICAgICAgICB8IDB4OTQgLT4gbDIsICgyLCAyKSwgUkVTICgyLCBSIEgpXG4gICAgICAgIHwgMHg5NSAtPiBsMiwgKDIsIDIpLCBSRVMgKDIsIFIgTClcbiAgICAgICAgfCAweDk2IC0+IGwyLCAoNCwgNCksIFJFUyAoMiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg5NyAtPiBsMiwgKDIsIDIpLCBSRVMgKDIsIFIgQSlcbiAgICAgICAgfCAweDk4IC0+IGwyLCAoMiwgMiksIFJFUyAoMywgUiBCKVxuICAgICAgICB8IDB4OTkgLT4gbDIsICgyLCAyKSwgUkVTICgzLCBSIEMpXG4gICAgICAgIHwgMHg5QSAtPiBsMiwgKDIsIDIpLCBSRVMgKDMsIFIgRClcbiAgICAgICAgfCAweDlCIC0+IGwyLCAoMiwgMiksIFJFUyAoMywgUiBFKVxuICAgICAgICB8IDB4OUMgLT4gbDIsICgyLCAyKSwgUkVTICgzLCBSIEgpXG4gICAgICAgIHwgMHg5RCAtPiBsMiwgKDIsIDIpLCBSRVMgKDMsIFIgTClcbiAgICAgICAgfCAweDlFIC0+IGwyLCAoNCwgNCksIFJFUyAoMywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHg5RiAtPiBsMiwgKDIsIDIpLCBSRVMgKDMsIFIgQSlcbiAgICAgICAgfCAweEEwIC0+IGwyLCAoMiwgMiksIFJFUyAoNCwgUiBCKVxuICAgICAgICB8IDB4QTEgLT4gbDIsICgyLCAyKSwgUkVTICg0LCBSIEMpXG4gICAgICAgIHwgMHhBMiAtPiBsMiwgKDIsIDIpLCBSRVMgKDQsIFIgRClcbiAgICAgICAgfCAweEEzIC0+IGwyLCAoMiwgMiksIFJFUyAoNCwgUiBFKVxuICAgICAgICB8IDB4QTQgLT4gbDIsICgyLCAyKSwgUkVTICg0LCBSIEgpXG4gICAgICAgIHwgMHhBNSAtPiBsMiwgKDIsIDIpLCBSRVMgKDQsIFIgTClcbiAgICAgICAgfCAweEE2IC0+IGwyLCAoNCwgNCksIFJFUyAoNCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhBNyAtPiBsMiwgKDIsIDIpLCBSRVMgKDQsIFIgQSlcbiAgICAgICAgfCAweEE4IC0+IGwyLCAoMiwgMiksIFJFUyAoNSwgUiBCKVxuICAgICAgICB8IDB4QTkgLT4gbDIsICgyLCAyKSwgUkVTICg1LCBSIEMpXG4gICAgICAgIHwgMHhBQSAtPiBsMiwgKDIsIDIpLCBSRVMgKDUsIFIgRClcbiAgICAgICAgfCAweEFCIC0+IGwyLCAoMiwgMiksIFJFUyAoNSwgUiBFKVxuICAgICAgICB8IDB4QUMgLT4gbDIsICgyLCAyKSwgUkVTICg1LCBSIEgpXG4gICAgICAgIHwgMHhBRCAtPiBsMiwgKDIsIDIpLCBSRVMgKDUsIFIgTClcbiAgICAgICAgfCAweEFFIC0+IGwyLCAoNCwgNCksIFJFUyAoNSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhBRiAtPiBsMiwgKDIsIDIpLCBSRVMgKDUsIFIgQSlcbiAgICAgICAgfCAweEIwIC0+IGwyLCAoMiwgMiksIFJFUyAoNiwgUiBCKVxuICAgICAgICB8IDB4QjEgLT4gbDIsICgyLCAyKSwgUkVTICg2LCBSIEMpXG4gICAgICAgIHwgMHhCMiAtPiBsMiwgKDIsIDIpLCBSRVMgKDYsIFIgRClcbiAgICAgICAgfCAweEIzIC0+IGwyLCAoMiwgMiksIFJFUyAoNiwgUiBFKVxuICAgICAgICB8IDB4QjQgLT4gbDIsICgyLCAyKSwgUkVTICg2LCBSIEgpXG4gICAgICAgIHwgMHhCNSAtPiBsMiwgKDIsIDIpLCBSRVMgKDYsIFIgTClcbiAgICAgICAgfCAweEI2IC0+IGwyLCAoNCwgNCksIFJFUyAoNiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhCNyAtPiBsMiwgKDIsIDIpLCBSRVMgKDYsIFIgQSlcbiAgICAgICAgfCAweEI4IC0+IGwyLCAoMiwgMiksIFJFUyAoNywgUiBCKVxuICAgICAgICB8IDB4QjkgLT4gbDIsICgyLCAyKSwgUkVTICg3LCBSIEMpXG4gICAgICAgIHwgMHhCQSAtPiBsMiwgKDIsIDIpLCBSRVMgKDcsIFIgRClcbiAgICAgICAgfCAweEJCIC0+IGwyLCAoMiwgMiksIFJFUyAoNywgUiBFKVxuICAgICAgICB8IDB4QkMgLT4gbDIsICgyLCAyKSwgUkVTICg3LCBSIEgpXG4gICAgICAgIHwgMHhCRCAtPiBsMiwgKDIsIDIpLCBSRVMgKDcsIFIgTClcbiAgICAgICAgfCAweEJFIC0+IGwyLCAoNCwgNCksIFJFUyAoNywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhCRiAtPiBsMiwgKDIsIDIpLCBSRVMgKDcsIFIgQSlcbiAgICAgICAgfCAweEMwIC0+IGwyLCAoMiwgMiksIFNFVCAoMCwgUiBCKVxuICAgICAgICB8IDB4QzEgLT4gbDIsICgyLCAyKSwgU0VUICgwLCBSIEMpXG4gICAgICAgIHwgMHhDMiAtPiBsMiwgKDIsIDIpLCBTRVQgKDAsIFIgRClcbiAgICAgICAgfCAweEMzIC0+IGwyLCAoMiwgMiksIFNFVCAoMCwgUiBFKVxuICAgICAgICB8IDB4QzQgLT4gbDIsICgyLCAyKSwgU0VUICgwLCBSIEgpXG4gICAgICAgIHwgMHhDNSAtPiBsMiwgKDIsIDIpLCBTRVQgKDAsIFIgTClcbiAgICAgICAgfCAweEM2IC0+IGwyLCAoNCwgNCksIFNFVCAoMCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhDNyAtPiBsMiwgKDIsIDIpLCBTRVQgKDAsIFIgQSlcbiAgICAgICAgfCAweEM4IC0+IGwyLCAoMiwgMiksIFNFVCAoMSwgUiBCKVxuICAgICAgICB8IDB4QzkgLT4gbDIsICgyLCAyKSwgU0VUICgxLCBSIEMpXG4gICAgICAgIHwgMHhDQSAtPiBsMiwgKDIsIDIpLCBTRVQgKDEsIFIgRClcbiAgICAgICAgfCAweENCIC0+IGwyLCAoMiwgMiksIFNFVCAoMSwgUiBFKVxuICAgICAgICB8IDB4Q0MgLT4gbDIsICgyLCAyKSwgU0VUICgxLCBSIEgpXG4gICAgICAgIHwgMHhDRCAtPiBsMiwgKDIsIDIpLCBTRVQgKDEsIFIgTClcbiAgICAgICAgfCAweENFIC0+IGwyLCAoNCwgNCksIFNFVCAoMSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhDRiAtPiBsMiwgKDIsIDIpLCBTRVQgKDEsIFIgQSlcbiAgICAgICAgfCAweEQwIC0+IGwyLCAoMiwgMiksIFNFVCAoMiwgUiBCKVxuICAgICAgICB8IDB4RDEgLT4gbDIsICgyLCAyKSwgU0VUICgyLCBSIEMpXG4gICAgICAgIHwgMHhEMiAtPiBsMiwgKDIsIDIpLCBTRVQgKDIsIFIgRClcbiAgICAgICAgfCAweEQzIC0+IGwyLCAoMiwgMiksIFNFVCAoMiwgUiBFKVxuICAgICAgICB8IDB4RDQgLT4gbDIsICgyLCAyKSwgU0VUICgyLCBSIEgpXG4gICAgICAgIHwgMHhENSAtPiBsMiwgKDIsIDIpLCBTRVQgKDIsIFIgTClcbiAgICAgICAgfCAweEQ2IC0+IGwyLCAoNCwgNCksIFNFVCAoMiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhENyAtPiBsMiwgKDIsIDIpLCBTRVQgKDIsIFIgQSlcbiAgICAgICAgfCAweEQ4IC0+IGwyLCAoMiwgMiksIFNFVCAoMywgUiBCKVxuICAgICAgICB8IDB4RDkgLT4gbDIsICgyLCAyKSwgU0VUICgzLCBSIEMpXG4gICAgICAgIHwgMHhEQSAtPiBsMiwgKDIsIDIpLCBTRVQgKDMsIFIgRClcbiAgICAgICAgfCAweERCIC0+IGwyLCAoMiwgMiksIFNFVCAoMywgUiBFKVxuICAgICAgICB8IDB4REMgLT4gbDIsICgyLCAyKSwgU0VUICgzLCBSIEgpXG4gICAgICAgIHwgMHhERCAtPiBsMiwgKDIsIDIpLCBTRVQgKDMsIFIgTClcbiAgICAgICAgfCAweERFIC0+IGwyLCAoNCwgNCksIFNFVCAoMywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhERiAtPiBsMiwgKDIsIDIpLCBTRVQgKDMsIFIgQSlcbiAgICAgICAgfCAweEUwIC0+IGwyLCAoMiwgMiksIFNFVCAoNCwgUiBCKVxuICAgICAgICB8IDB4RTEgLT4gbDIsICgyLCAyKSwgU0VUICg0LCBSIEMpXG4gICAgICAgIHwgMHhFMiAtPiBsMiwgKDIsIDIpLCBTRVQgKDQsIFIgRClcbiAgICAgICAgfCAweEUzIC0+IGwyLCAoMiwgMiksIFNFVCAoNCwgUiBFKVxuICAgICAgICB8IDB4RTQgLT4gbDIsICgyLCAyKSwgU0VUICg0LCBSIEgpXG4gICAgICAgIHwgMHhFNSAtPiBsMiwgKDIsIDIpLCBTRVQgKDQsIFIgTClcbiAgICAgICAgfCAweEU2IC0+IGwyLCAoNCwgNCksIFNFVCAoNCwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhFNyAtPiBsMiwgKDIsIDIpLCBTRVQgKDQsIFIgQSlcbiAgICAgICAgfCAweEU4IC0+IGwyLCAoMiwgMiksIFNFVCAoNSwgUiBCKVxuICAgICAgICB8IDB4RTkgLT4gbDIsICgyLCAyKSwgU0VUICg1LCBSIEMpXG4gICAgICAgIHwgMHhFQSAtPiBsMiwgKDIsIDIpLCBTRVQgKDUsIFIgRClcbiAgICAgICAgfCAweEVCIC0+IGwyLCAoMiwgMiksIFNFVCAoNSwgUiBFKVxuICAgICAgICB8IDB4RUMgLT4gbDIsICgyLCAyKSwgU0VUICg1LCBSIEgpXG4gICAgICAgIHwgMHhFRCAtPiBsMiwgKDIsIDIpLCBTRVQgKDUsIFIgTClcbiAgICAgICAgfCAweEVFIC0+IGwyLCAoNCwgNCksIFNFVCAoNSwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhFRiAtPiBsMiwgKDIsIDIpLCBTRVQgKDUsIFIgQSlcbiAgICAgICAgfCAweEYwIC0+IGwyLCAoMiwgMiksIFNFVCAoNiwgUiBCKVxuICAgICAgICB8IDB4RjEgLT4gbDIsICgyLCAyKSwgU0VUICg2LCBSIEMpXG4gICAgICAgIHwgMHhGMiAtPiBsMiwgKDIsIDIpLCBTRVQgKDYsIFIgRClcbiAgICAgICAgfCAweEYzIC0+IGwyLCAoMiwgMiksIFNFVCAoNiwgUiBFKVxuICAgICAgICB8IDB4RjQgLT4gbDIsICgyLCAyKSwgU0VUICg2LCBSIEgpXG4gICAgICAgIHwgMHhGNSAtPiBsMiwgKDIsIDIpLCBTRVQgKDYsIFIgTClcbiAgICAgICAgfCAweEY2IC0+IGwyLCAoNCwgNCksIFNFVCAoNiwgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhGNyAtPiBsMiwgKDIsIDIpLCBTRVQgKDYsIFIgQSlcbiAgICAgICAgfCAweEY4IC0+IGwyLCAoMiwgMiksIFNFVCAoNywgUiBCKVxuICAgICAgICB8IDB4RjkgLT4gbDIsICgyLCAyKSwgU0VUICg3LCBSIEMpXG4gICAgICAgIHwgMHhGQSAtPiBsMiwgKDIsIDIpLCBTRVQgKDcsIFIgRClcbiAgICAgICAgfCAweEZCIC0+IGwyLCAoMiwgMiksIFNFVCAoNywgUiBFKVxuICAgICAgICB8IDB4RkMgLT4gbDIsICgyLCAyKSwgU0VUICg3LCBSIEgpXG4gICAgICAgIHwgMHhGRCAtPiBsMiwgKDIsIDIpLCBTRVQgKDcsIFIgTClcbiAgICAgICAgfCAweEZFIC0+IGwyLCAoNCwgNCksIFNFVCAoNywgUlJfaW5kaXJlY3QgSEwpXG4gICAgICAgIHwgMHhGRiAtPiBsMiwgKDIsIDIpLCBTRVQgKDcsIFIgQSlcbiAgICAgICAgfCBfIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiBcIlVucmVjb2duaXplZCBvcGNvZGUgYWZ0ZXIgMHhDQjogMHglMDJ4XCIgb3ApXG4gICAgICBlbmRcbiAgICB8IF8gLT4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmIFwiVW5yZWNvZ25pemVkIG9wY29kZTogMHglMDJ4XCIgb3ApXG5lbmRcbiIsInR5cGUgdCA9XG4gIHwgUk9NX09OTFlcbiAgfCBNQkMxXG4gIHwgTUJDMV9SQU1cbiAgfCBNQkMxX1JBTV9CQVRURVJZXG4gIHwgTUJDMlxuICB8IE1CQzJfQkFUVEVSWVxuICB8IE1CQzNfVElNRVJfQkFUVEVSWVxuICB8IE1CQzNfVElNRVJfUkFNX0JBVFRFUllcbiAgfCBNQkMzXG5cbmxldCBzaG93ID0gZnVuY3Rpb25cbiAgfCBST01fT05MWSAgICAgICAgICAgICAgIC0+IFwiUk9NX09OTFlcIlxuICB8IE1CQzEgICAgICAgICAgICAgICAgICAgLT4gXCJNQkMxXCJcbiAgfCBNQkMxX1JBTSAgICAgICAgICAgICAgIC0+IFwiTUJDMV9SQU1cIlxuICB8IE1CQzFfUkFNX0JBVFRFUlkgICAgICAgLT4gXCJNQkMxX1JBTV9CQVRURVJZXCJcbiAgfCBNQkMyICAgICAgICAgICAgICAgICAgIC0+IFwiTUJDMlwiXG4gIHwgTUJDMl9CQVRURVJZICAgICAgICAgICAtPiBcIk1CQzJfQkFUVEVSWVwiXG4gIHwgTUJDM19USU1FUl9CQVRURVJZICAgICAtPiBcIk1CQzNfVElNRVJfQkFUVEVSWVwiXG4gIHwgTUJDM19USU1FUl9SQU1fQkFUVEVSWSAtPiBcIk1CQzNfVElNRVJfUkFNX0JBVFRFUllcIlxuICB8IE1CQzMgICAgICAgICAgICAgICAgICAgLT4gXCJNQkMzXCJcbiIsInR5cGUgdCA9IHtcbiAgY2FydHJpZGdlX3R5cGUgOiBDYXJ0cmlkZ2VfdHlwZS50O1xuICByb21fYmFua19jb3VudCA6IGludDtcbiAgcmFtX2JhbmtfY291bnQgOiBpbnQ7XG59XG5cbmxldCBjcmVhdGUgfnJvbV9ieXRlcyA9XG4gIGxldCBjYXJ0cmlkZ2VfdHlwZSA9XG4gICAgbGV0IG9wZW4gQ2FydHJpZGdlX3R5cGUgaW5cbiAgICBtYXRjaCBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHJvbV9ieXRlcyAweDE0NyB8PiBDaGFyLmNvZGUgd2l0aFxuICAgIHwgMHgwMCAtPiBST01fT05MWVxuICAgIHwgMHgwMSAtPiBNQkMxXG4gICAgfCAweDAyIC0+IE1CQzFfUkFNXG4gICAgfCAweDAzIC0+IE1CQzFfUkFNX0JBVFRFUllcbiAgICB8IDB4MDUgLT4gTUJDMlxuICAgIHwgMHgwNiAtPiBNQkMyX0JBVFRFUllcbiAgICB8IDB4MEYgLT4gTUJDM19USU1FUl9CQVRURVJZXG4gICAgfCAweDEwIC0+IE1CQzNfVElNRVJfUkFNX0JBVFRFUllcbiAgICB8IDB4MTEgLT4gTUJDM1xuICAgIHwgICAgeCAtPiByYWlzZSBAQCBJbnZhbGlkX2FyZ3VtZW50IChQcmludGYuc3ByaW50ZiBcIlVua25vd24gcm9tIHR5cGUgOiAweCV4XCIgeClcbiAgaW5cbiAgbGV0IHJvbV9iYW5rX2NvdW50ID1cbiAgICBtYXRjaCBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHJvbV9ieXRlcyAweDE0OCB8PiBDaGFyLmNvZGUgd2l0aFxuICAgIHwgMHgwMCAtPiAyXG4gICAgfCAweDAxIC0+IDRcbiAgICB8IDB4MDIgLT4gOFxuICAgIHwgMHgwMyAtPiAxNlxuICAgIHwgMHgwNCAtPiAzMlxuICAgIHwgMHgwNSAtPiA2NFxuICAgIHwgMHgwNiAtPiAxMjhcbiAgICB8IDB4MDcgLT4gMjU2XG4gICAgfCAweDA4IC0+IDUxMlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgbGV0IHJhbV9iYW5rX2NvdW50ID1cbiAgICBtYXRjaCBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHJvbV9ieXRlcyAweDE0OSB8PiBDaGFyLmNvZGUgd2l0aFxuICAgIHwgMHgwMCAtPiAwXG4gICAgfCAweDAxIC0+IDFcbiAgICB8IDB4MDIgLT4gMVxuICAgIHwgMHgwMyAtPiA0XG4gICAgfCAweDA0IC0+IDE2XG4gICAgfCAweDA1IC0+IDhcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIHsgY2FydHJpZGdlX3R5cGU7IHJvbV9iYW5rX2NvdW50OyByYW1fYmFua19jb3VudCB9XG5cbmxldCBnZXRfY2FydHJpZGdlX3R5cGUgdCA9IHQuY2FydHJpZGdlX3R5cGVcblxubGV0IGdldF9yb21fYmFua19jb3VudCB0ID0gdC5yb21fYmFua19jb3VudFxuXG5sZXQgZ2V0X3JhbV9iYW5rX2NvdW50IHQgPSB0LnJhbV9iYW5rX2NvdW50XG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgbW9kZSA9IEYwIHwgRjFcblxudHlwZSB0ID0ge1xuICByb21fYnl0ZXMgOiBCaWdzdHJpbmdhZi50O1xuICByYW1fYnl0ZXMgOiBCaWdzdHJpbmdhZi50O1xuICByb21fYmFua19zaXplIDogaW50O1xuICByYW1fYmFua19zaXplIDogaW50O1xuICBtdXRhYmxlIHJhbV9lbmFibGVkIDogYm9vbDtcbiAgbXV0YWJsZSByb21fYmFua19udW0gOiBpbnQ7XG4gIG11dGFibGUgcmFtX2JhbmtfbnVtIDogaW50O1xuICBtdXRhYmxlIG1vZGUgOiBtb2RlO1xufVxuXG5sZXQgY3JlYXRlIH5yb21fYnl0ZXMgPVxuICBsZXQgaCA9IENhcnRyaWRnZV9oZWFkZXIuY3JlYXRlIH5yb21fYnl0ZXMgaW5cbiAgbGV0IHJvbV9iYW5rX3NpemUgPSBDYXJ0cmlkZ2VfaGVhZGVyLmdldF9yb21fYmFua19jb3VudCBoIGluXG4gIGxldCByYW1fYmFua19zaXplID0gQ2FydHJpZGdlX2hlYWRlci5nZXRfcmFtX2JhbmtfY291bnQgaCBpblxuICBsZXQgcmFtX2J5dGVzID0gQmlnc3RyaW5nYWYuY3JlYXRlIChyYW1fYmFua19zaXplICogMHgyMDAwKSBpblxuICB7XG4gICAgcm9tX2J5dGVzO1xuICAgIHJhbV9ieXRlcztcbiAgICByb21fYmFua19zaXplO1xuICAgIHJhbV9iYW5rX3NpemU7XG4gICAgcmFtX2VuYWJsZWQgPSBmYWxzZTtcbiAgICByb21fYmFua19udW0gPSAxO1xuICAgIHJhbV9iYW5rX251bSA9IDA7XG4gICAgbW9kZSA9IEYwO1xuICB9XG5cbigqIGh0dHBzOi8vaGFja3RpeG1lLmdhL0dCRURHL21iY3MvbWJjMS8jemVyby1iYW5rICopXG5sZXQgemVyb19iYW5rX251bSB0ID1cbiAgbWF0Y2ggdC5tb2RlLCB0LnJvbV9iYW5rX3NpemUgd2l0aFxuICB8IEYwLCBfICAgICAgICAgICAgICAtPiAwXG4gIHwgRjEsIG4gd2hlbiBuIDw9IDMyIC0+IDBcbiAgfCBGMSwgbiB3aGVuIG4gPSAgNjQgLT4gKHQucmFtX2JhbmtfbnVtIGxhbmQgMGIxKSBsc2wgNVxuICB8IEYxLCBuIHdoZW4gbiA9IDEyOCAtPiAodC5yYW1fYmFua19udW0gbGFuZCAwYjExKSBsc2wgNVxuICB8IEYxLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBodHRwczovL2hhY2t0aXhtZS5nYS9HQkVERy9tYmNzL21iYzEvI2hpZ2gtYmFuayAqKVxubGV0IGhpZ2hfYmFua19udW0gdCA9XG4gIG1hdGNoIHQucm9tX2Jhbmtfc2l6ZSB3aXRoXG4gIHwgbiB3aGVuIG4gPD0gMzIgLT4gdC5yb21fYmFua19udW1cbiAgfCBuIHdoZW4gbiA9ICA2NCAtPlxuICAgIGxldCBiaXQ1ICA9ICh0LnJhbV9iYW5rX251bSBsYW5kIDBiMSkgbHNsIDUgaW5cbiAgICBiaXQ1IGxvciB0LnJvbV9iYW5rX251bVxuICB8IG4gd2hlbiBuID0gMTI4IC0+XG4gICAgbGV0IGJpdDU2ID0gKHQucmFtX2JhbmtfbnVtIGxhbmQgMGIxMSkgbHNsIDUgaW5cbiAgICBiaXQ1NiBsb3IgdC5yb21fYmFua19udW1cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmFtX2FkZHJfb2ZfYWRkciB0IGFkZHIgPVxuICBtYXRjaCB0Lm1vZGUsIHQucmFtX2Jhbmtfc2l6ZSB3aXRoXG4gIHwgRjAsIF9cbiAgfCBGMSwgMSAtPlxuICAgIChhZGRyIC0gMHhBMDAwKSBtb2QgMHgyMDAwXG4gIHwgRjEsIDQgLT5cbiAgICAweDIwMDAgKiB0LnJhbV9iYW5rX251bSArIChhZGRyIC0gMHhBMDAwKVxuICB8IEYxLCBuIC0+XG4gICAgcmFpc2UgQEAgSW52YWxpZF9hcmd1bWVudCAoUHJpbnRmLnNwcmludGYgXCJVbmV4cGVjdGVkIHJhbSBzaXplOiAlZFwiIG4pXG5cbmxldCByZWFkX2J5dGUgdCBhZGRyID1cbiAgbGV0IGFkZHIgPSBVaW50MTYudG9faW50IGFkZHIgaW5cbiAgbWF0Y2ggYWRkciB3aXRoXG4gIHwgXyB3aGVuIDB4MDAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHgzRkZGIC0+XG4gICAgbGV0IHplcm9fYmFua19udW0gPSB6ZXJvX2JhbmtfbnVtIHQgaW5cbiAgICAoMHg0MDAwICogemVyb19iYW5rX251bSArIGFkZHIpXG4gICAgfD4gQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LnJvbV9ieXRlc1xuICAgIHw+IFVpbnQ4Lm9mX2NoYXJcbiAgfCBfIHdoZW4gMHg0MDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweDdGRkYgLT5cbiAgICBsZXQgaGlnaF9iYW5rX251bSA9IGhpZ2hfYmFua19udW0gdCBpblxuICAgICgweDQwMDAgKiBoaWdoX2JhbmtfbnVtICsgKGFkZHIgLSAweDQwMDApKVxuICAgIHw+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5yb21fYnl0ZXNcbiAgICB8PiBVaW50OC5vZl9jaGFyXG4gIHwgXyB3aGVuIDB4QTAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHhCRkZGIC0+XG4gICAgaWYgdC5yYW1fZW5hYmxlZCAmJiB0LnJhbV9iYW5rX3NpemUgPiAwIHRoZW5cbiAgICAgIGFkZHJcbiAgICAgIHw+IHJhbV9hZGRyX29mX2FkZHIgdFxuICAgICAgfD4gQmlnc3RyaW5nYWYudW5zYWZlX2dldCB0LnJhbV9ieXRlc1xuICAgICAgfD4gVWludDgub2ZfY2hhclxuICAgIGVsc2VcbiAgICAgIFVpbnQ4Lm9mX2ludCAweEZGXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG5sZXQgYml0bWFza19vZl9yb21fc2l6ZSA9IGZ1bmN0aW9uXG4gIHwgMiAgIC0+IDBiMDAwMDAwMDFcbiAgfCA0ICAgLT4gMGIwMDAwMDAxMVxuICB8IDggICAtPiAwYjAwMDAwMTExXG4gIHwgMTYgIC0+IDBiMDAwMDExMTFcbiAgfCAzMiAgLT4gMGIwMDAxMTExMVxuICB8IDY0ICAtPiAwYjAwMDExMTExXG4gIHwgMTI4IC0+IDBiMDAwMTExMTFcbiAgfCBuIC0+IHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgKFByaW50Zi5zcHJpbnRmIFwiVW5leHBlY3RlZCByb20gc2l6ZTogJWRcIiBuKVxuXG5sZXQgd3JpdGVfYnl0ZSB0IH5hZGRyIH5kYXRhID1cbiAgbGV0IGFkZHIgPSBVaW50MTYudG9faW50IGFkZHIgaW5cbiAgbGV0IGRhdGEgPSBVaW50OC50b19pbnQgZGF0YSBpblxuICBtYXRjaCBhZGRyIHdpdGhcbiAgfCBfIHdoZW4gMHgwMDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweDFGRkYgLT5cbiAgICB0LnJhbV9lbmFibGVkIDwtIGRhdGEgPSAweDBBXG4gIHwgXyB3aGVuIDB4MjAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHgzRkZGIC0+XG4gICAgbGV0IHJvbV9iYW5rX251bSA9IGRhdGEgbGFuZCAoYml0bWFza19vZl9yb21fc2l6ZSB0LnJvbV9iYW5rX3NpemUpIGluXG4gICAgdC5yb21fYmFua19udW0gPC0gaWYgcm9tX2JhbmtfbnVtID0gMCB0aGVuIDEgZWxzZSByb21fYmFua19udW1cbiAgfCBfIHdoZW4gMHg0MDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweDVGRkYgLT5cbiAgICB0LnJhbV9iYW5rX251bSA8LSBkYXRhIGxhbmQgMGIxMVxuICB8IF8gd2hlbiAweDYwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4N0ZGRiAtPlxuICAgIHQubW9kZSA8LSBpZiBkYXRhIGxhbmQgMSA9IDAgdGhlbiBGMCBlbHNlIEYxXG4gIHwgXyB3aGVuIDB4QTAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHhCRkZGIC0+XG4gICAgaWYgdC5yYW1fZW5hYmxlZCAmJiB0LnJhbV9iYW5rX3NpemUgPiAwICB0aGVuXG4gICAgICBsZXQgcmFtX2FkZHIgPSBhZGRyIHw+IHJhbV9hZGRyX29mX2FkZHIgdCBpblxuICAgICAgQmlnc3RyaW5nYWYudW5zYWZlX3NldCB0LnJhbV9ieXRlcyByYW1fYWRkciAoQ2hhci51bnNhZmVfY2hyIGRhdGEpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFjY2VwdHMgXyBhZGRyID1cbiAgbGV0IGFkZHIgPSBVaW50MTYudG9faW50IGFkZHIgaW5cbiAgMHgwMDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweDdGRkYgfHwgIDB4QTAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHhCRkZGXG4iLCJvcGVuIFVpbnRzXG5cbnR5cGUgdCA9IHsgcm9tX2J5dGVzIDogQmlnc3RyaW5nYWYudDsgfVxuXG5sZXQgY3JlYXRlIH5yb21fYnl0ZXMgPSB7IHJvbV9ieXRlczsgfVxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGxldCBhZGRyID0gVWludDE2LnRvX2ludCBhZGRyIGluXG4gIGlmICgweDAwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4N0ZGRikgdGhlblxuICAgIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5yb21fYnl0ZXMgYWRkclxuICAgIHw+IFVpbnQ4Lm9mX2NoYXJcbiAgZWxzZVxuICAgIHJhaXNlIEBAIEludmFsaWRfYXJndW1lbnQgXCJBZGRyZXNzIG91dCBvZiBib3VuZHNcIlxuXG5sZXQgd3JpdGVfYnl0ZSBfIH5hZGRyOl8gfmRhdGE6XyA9ICgpXG5cbmxldCBhY2NlcHRzIF8gYWRkciA9XG4gIGxldCBhZGRyID0gVWludDE2LnRvX2ludCBhZGRyIGluXG4gICgweDAwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4N0ZGRilcbiIsImxldCBmIH5yb21fYnl0ZXMgPVxuICBsZXQgdHlwZV8gPVxuICAgIENhcnRyaWRnZV9oZWFkZXIuY3JlYXRlIH5yb21fYnl0ZXNcbiAgICB8PiBDYXJ0cmlkZ2VfaGVhZGVyLmdldF9jYXJ0cmlkZ2VfdHlwZVxuICBpblxuICBtYXRjaCB0eXBlXyB3aXRoXG4gIHwgQ2FydHJpZGdlX3R5cGUuUk9NX09OTFkgLT4gKG1vZHVsZSBDYXJ0cmlkZ2Vfcm9tX29ubHkgOiBDYXJ0cmlkZ2VfaW50Zi5TKVxuICB8IE1CQzFcbiAgfCBNQkMxX1JBTVxuICB8IE1CQzFfUkFNX0JBVFRFUlkgICAgICAgIC0+IChtb2R1bGUgQ2FydHJpZGdlX21iYzEgOiBDYXJ0cmlkZ2VfaW50Zi5TKVxuICB8IF8gICAgICAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuIiwib3BlbiBVaW50c1xuXG5tb2R1bGUgTWFrZSAoTW11IDogV29yZF9hZGRyZXNzYWJsZV9pbnRmLlMpID0gc3RydWN0XG5cbiAgdHlwZSB0ID0ge1xuICAgIHJlZ2lzdGVycyA6IFJlZ2lzdGVycy50O1xuICAgIG11dGFibGUgcGMgOiB1aW50MTY7XG4gICAgbXV0YWJsZSBzcCA6IHVpbnQxNjtcbiAgICBtbXUgOiBNbXUudDtcbiAgICBtdXRhYmxlIGhhbHRlZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpbWUgOiBib29sOyAoKiBpbnRlcnJ1cHQgbWFzdGVyIGVuYWJsZSAqKVxuICAgIG11dGFibGUgZW5hYmxlX2ltZV9iZWZvcmVfbmV4dF9pbnN0ciA6IGJvb2w7XG4gICAgbXV0YWJsZSBwcmV2X2luc3QgOiBJbnN0cnVjdGlvbi50OyAoKiBmb3IgZGVidWdnaW5nIHB1cnBvc2UgKilcbiAgICBpYyA6IEludGVycnVwdF9jb250cm9sbGVyLnQ7XG4gIH1cblxuICBsZXQgc2hvdyB0ID1cbiAgICBQcmludGYuc3ByaW50ZiBcIiVzIFNQOiVzIFBDOiVzXCJcbiAgICAgIChSZWdpc3RlcnMuc2hvdyB0LnJlZ2lzdGVycykgKHQuc3AgfD4gVWludDE2LnNob3cpICh0LnBjIHw+IFVpbnQxNi5zaG93KVxuXG4gIGxldCBjcmVhdGUgfm1tdSB+aWMgfnJlZ2lzdGVycyB+c3AgfnBjIH5oYWx0ZWQgfmltZSA9XG4gICAge1xuICAgICAgcmVnaXN0ZXJzO1xuICAgICAgbW11O1xuICAgICAgc3A7XG4gICAgICBwYztcbiAgICAgIGhhbHRlZDtcbiAgICAgIGltZTtcbiAgICAgIGVuYWJsZV9pbWVfYmVmb3JlX25leHRfaW5zdHIgPSBmYWxzZTtcbiAgICAgIHByZXZfaW5zdCA9IE5PUDtcbiAgICAgIGljXG4gICAgfVxuXG5cbiAgdHlwZSBuZXh0X3BjID0gTmV4dCB8IEp1bXAgb2YgdWludDE2XG5cbiAgbGV0IGV4ZWN1dGUgKHQgOiB0KSAobWN5Y2xlcyA6IGludCAqIGludCkgIChpbnN0IDogSW5zdHJ1Y3Rpb24udCkgOiBpbnQgPVxuICAgIGxldCBzZXRfZmxhZ3MgPSBSZWdpc3RlcnMuc2V0X2ZsYWdzIHQucmVnaXN0ZXJzIGluXG4gICAgbGV0IHJlYWQgOiB0eXBlIGEuIGEgSW5zdHJ1Y3Rpb24uYXJnIC0+IGEgPSBmdW4gYXJnIC0+XG4gICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgfCBJbW1lZGlhdGU4IG4gLT4gblxuICAgICAgfCBJbW1lZGlhdGUxNiBuIC0+IG5cbiAgICAgIHwgRGlyZWN0OCBhZGRyIC0+IE1tdS5yZWFkX2J5dGUgdC5tbXUgYWRkclxuICAgICAgfCBSIHIgLT4gUmVnaXN0ZXJzLnJlYWRfciB0LnJlZ2lzdGVycyByXG4gICAgICB8IFJSX2luZGlyZWN0IHJyIC0+XG4gICAgICAgIGxldCBhZGRyID0gUmVnaXN0ZXJzLnJlYWRfcnIgdC5yZWdpc3RlcnMgcnIgaW5cbiAgICAgICAgTW11LnJlYWRfYnl0ZSB0Lm1tdSBhZGRyXG4gICAgICB8IEZGMDBfb2Zmc2V0IG4gLT5cbiAgICAgICAgbGV0IGFkZHIgPSBVaW50MTYuKG9mX2ludCAweEZGMDAgKyBvZl91aW50OCBuKSBpblxuICAgICAgICBNbXUucmVhZF9ieXRlIHQubW11IGFkZHJcbiAgICAgIHwgRkYwMF9DIC0+XG4gICAgICAgIGxldCBjID0gUmVnaXN0ZXJzLnJlYWRfciB0LnJlZ2lzdGVycyBDIGluXG4gICAgICAgIGxldCBhZGRyID0gVWludDE2LihvZl9pbnQgMHhGRjAwICsgb2ZfdWludDggYykgaW5cbiAgICAgICAgTW11LnJlYWRfYnl0ZSB0Lm1tdSBhZGRyXG4gICAgICB8IEhMX2luYyAtPlxuICAgICAgICBsZXQgYWRkciA9IFJlZ2lzdGVycy5yZWFkX3JyIHQucmVnaXN0ZXJzIEhMIGluXG4gICAgICAgIFJlZ2lzdGVycy53cml0ZV9yciB0LnJlZ2lzdGVycyBITCBVaW50MTYuKHN1Y2MgYWRkcik7XG4gICAgICAgIE1tdS5yZWFkX2J5dGUgdC5tbXUgYWRkclxuICAgICAgfCBITF9kZWMgLT5cbiAgICAgICAgbGV0IGFkZHIgPSBSZWdpc3RlcnMucmVhZF9yciB0LnJlZ2lzdGVycyBITCBpblxuICAgICAgICBSZWdpc3RlcnMud3JpdGVfcnIgdC5yZWdpc3RlcnMgSEwgVWludDE2LihwcmVkIGFkZHIpO1xuICAgICAgICBNbXUucmVhZF9ieXRlIHQubW11IGFkZHJcbiAgICAgIHwgRGlyZWN0MTYgYWRkciAtPiBNbXUucmVhZF93b3JkIHQubW11IGFkZHJcbiAgICAgIHwgUlIgcnIgLT4gUmVnaXN0ZXJzLnJlYWRfcnIgdC5yZWdpc3RlcnMgcnJcbiAgICAgIHwgU1AgLT4gdC5zcFxuICAgICAgfCBTUF9vZmZzZXQgbiAtPlxuICAgICAgICBsZXQgc3AgPSB0LnNwIHw+IFVpbnQxNi50b19pbnQgaW5cbiAgICAgICAgbGV0IG4gPSBuIHw+IEludDgudG9faW50IGluXG4gICAgICAgIHNldF9mbGFnc1xuICAgICAgICAgIH56OmZhbHNlXG4gICAgICAgICAgfmg6KHNwIGxhbmQgMHhGICsgbiBsYW5kIDB4RiA+IDB4RilcbiAgICAgICAgICB+bjpmYWxzZVxuICAgICAgICAgIH5jOihzcCBsYW5kIDB4RkYgKyBuIGxhbmQgMHhGRiA+IDB4RkYpICgpO1xuICAgICAgICBzcCArIG4gfD4gVWludDE2Lm9mX2ludFxuICAgIGluXG4gICAgbGV0IHdyaXRlIDogdHlwZSBhLiBhIEluc3RydWN0aW9uLmFyZyAtPiBhIC0+IHVuaXQgPSBmdW4geCB5IC0+XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgUiByIC0+IFJlZ2lzdGVycy53cml0ZV9yIHQucmVnaXN0ZXJzIHIgeVxuICAgICAgfCBSUiByciAtPiBSZWdpc3RlcnMud3JpdGVfcnIgdC5yZWdpc3RlcnMgcnIgeVxuICAgICAgfCBGRjAwX29mZnNldCBuIC0+XG4gICAgICAgIGxldCBhZGRyID0gVWludDE2LihvZl9pbnQgMHhGRjAwICsgb2ZfdWludDggbikgaW5cbiAgICAgICAgTW11LndyaXRlX2J5dGUgdC5tbXUgfmFkZHIgfmRhdGE6eVxuICAgICAgfCBSUl9pbmRpcmVjdCByciAtPlxuICAgICAgICBsZXQgYWRkciA9IFJlZ2lzdGVycy5yZWFkX3JyIHQucmVnaXN0ZXJzIHJyIGluXG4gICAgICAgIE1tdS53cml0ZV9ieXRlIHQubW11IH5hZGRyIH5kYXRhOnlcbiAgICAgIHwgRkYwMF9DIC0+XG4gICAgICAgIGxldCBjID0gUmVnaXN0ZXJzLnJlYWRfciB0LnJlZ2lzdGVycyBDIGluXG4gICAgICAgIGxldCBhZGRyID0gVWludDE2LihvZl9pbnQgMHhGRjAwICsgb2ZfdWludDggYykgaW5cbiAgICAgICAgTW11LndyaXRlX2J5dGUgdC5tbXUgfmFkZHIgfmRhdGE6eVxuICAgICAgfCBITF9pbmMgLT5cbiAgICAgICAgbGV0IGFkZHIgPSBSZWdpc3RlcnMucmVhZF9yciB0LnJlZ2lzdGVycyBITCBpblxuICAgICAgICBNbXUud3JpdGVfYnl0ZSB0Lm1tdSB+YWRkciB+ZGF0YTp5O1xuICAgICAgICBSZWdpc3RlcnMud3JpdGVfcnIgdC5yZWdpc3RlcnMgSEwgVWludDE2LihzdWNjIGFkZHIpXG4gICAgICB8IEhMX2RlYyAtPlxuICAgICAgICBsZXQgYWRkciA9IFJlZ2lzdGVycy5yZWFkX3JyIHQucmVnaXN0ZXJzIEhMIGluXG4gICAgICAgIE1tdS53cml0ZV9ieXRlIHQubW11IH5hZGRyIH5kYXRhOnk7XG4gICAgICAgIFJlZ2lzdGVycy53cml0ZV9yciB0LnJlZ2lzdGVycyBITCBVaW50MTYuKHByZWQgYWRkcilcbiAgICAgIHwgRGlyZWN0OCBhZGRyIC0+IE1tdS53cml0ZV9ieXRlIHQubW11IH5hZGRyIH5kYXRhOnlcbiAgICAgIHwgRGlyZWN0MTYgYWRkciAtPiBNbXUud3JpdGVfd29yZCB0Lm1tdSB+YWRkciB+ZGF0YTp5XG4gICAgICB8IFNQIC0+IHQuc3AgPC0geVxuICAgICAgfCBTUF9vZmZzZXQgX1xuICAgICAgfCBJbW1lZGlhdGUxNiBfXG4gICAgICB8IEltbWVkaWF0ZTggXyAtPiBmYWlsd2l0aCBAQCBQcmludGYuc3ByaW50ZiBcIkludmFsaWQgYXJ1Z21lbnRcIlxuICAgIGluXG4gICAgbGV0ICg8LS0pIHggeSA9IHdyaXRlIHggeSBpblxuICAgIGxldCBjaGVja19jb25kaXRpb24gdCA6IEluc3RydWN0aW9uLmNvbmRpdGlvbiAtPiBib29sID0gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFogICAgLT4gUmVnaXN0ZXJzLnJlYWRfZmxhZyB0LnJlZ2lzdGVycyBaZXJvXG4gICAgICB8IE5aICAgLT4gbm90IChSZWdpc3RlcnMucmVhZF9mbGFnIHQucmVnaXN0ZXJzIFplcm8pXG4gICAgICB8IEMgICAgLT4gUmVnaXN0ZXJzLnJlYWRfZmxhZyB0LnJlZ2lzdGVycyBDYXJyeVxuICAgICAgfCBOQyAgIC0+IG5vdCAoUmVnaXN0ZXJzLnJlYWRfZmxhZyB0LnJlZ2lzdGVycyBDYXJyeSlcbiAgICBpblxuICAgIGxldCBuZXh0X3BjID0gbWF0Y2ggaW5zdCB3aXRoXG4gICAgICB8IExEOCAoeCwgeSkgLT5cbiAgICAgICAgeCA8LS0gcmVhZCB5O1xuICAgICAgICBOZXh0XG4gICAgICB8IExEMTYgKHgsIHkpIC0+XG4gICAgICAgIHggPC0tIHJlYWQgeTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBBREQ4ICh4LCB5KSAtPlxuICAgICAgICBsZXQgeCcsIHknID0gcmVhZCB4LCByZWFkIHkgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oeCcgKyB5JykgaW5cbiAgICAgICAgc2V0X2ZsYWdzXG4gICAgICAgICAgfno6KG4gPSBVaW50OC56ZXJvKVxuICAgICAgICAgIH5oOlVpbnQ4Lih4JyBsYW5kIG9mX2ludCAweEYgKyB5JyBsYW5kIG9mX2ludCAweEYgPiBvZl9pbnQgMHhGKVxuICAgICAgICAgIH5uOmZhbHNlXG4gICAgICAgICAgfmM6VWludDguKHgnID4gb2ZfaW50IDB4RkYgLSB5JykgKCk7XG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIE5leHRcbiAgICAgIHwgQUREMTYgKHgsIHkpIC0+XG4gICAgICAgIGxldCB4JywgeScgPSByZWFkIHgsIHJlYWQgeSBpblxuICAgICAgICBsZXQgbiA9IFVpbnQxNi4oeCcgKyB5JykgaW5cbiAgICAgICAgc2V0X2ZsYWdzXG4gICAgICAgICAgfmg6VWludDE2Lih4JyBsYW5kIG9mX2ludCAweDBGRkYgKyB5JyBsYW5kIG9mX2ludCAweDBGRkYgPiBvZl9pbnQgMHgwRkZGKVxuICAgICAgICAgIH5uOmZhbHNlXG4gICAgICAgICAgfmM6VWludDE2Lih4JyA+IG9mX2ludCAweEZGRkYgLSB5JykgKCk7XG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIE5leHRcbiAgICAgIHwgQUREU1AgeSAtPlxuICAgICAgICAoKiBGb3IgXCJBREQgU1AsIG5cIiB0aGUgZmxhZ3MgYXJlIHNldCBhcyBpZiB0aGUgaW5zdHJ1Y3Rpb24gd2FzIGEgOCBiaXQgYWRkLlxuICAgICAgICAgKiBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBhZGQgdGhlIGxvd2VyIDggYml0cyAqKVxuICAgICAgICBsZXQgeCcgPSByZWFkIFNQIHw+IFVpbnQxNi50b19pbnQgaW5cbiAgICAgICAgbGV0IHknID0geSB8PiBJbnQ4LnRvX2ludCBpblxuICAgICAgICBzZXRfZmxhZ3NcbiAgICAgICAgICB+ejpmYWxzZVxuICAgICAgICAgIH5oOih4JyBsYW5kIDB4RiArIHknIGxhbmQgMHhGID4gMHhGKVxuICAgICAgICAgIH5uOmZhbHNlXG4gICAgICAgICAgfmM6KHgnIGxhbmQgMHhGRiArIHknIGxhbmQgMHhGRiA+IDB4RkYpICgpO1xuICAgICAgICBTUCA8LS0gKHgnICsgeSd8PiBVaW50MTYub2ZfaW50KTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBBREMgKHgsIHkpIC0+XG4gICAgICAgIGxldCBjID0gaWYgUmVnaXN0ZXJzLihyZWFkX2ZsYWcgdC5yZWdpc3RlcnMgQ2FycnkpIHRoZW4gVWludDgub25lIGVsc2UgVWludDguemVybyBpblxuICAgICAgICBsZXQgeCcsIHknID0gcmVhZCB4LCByZWFkIHkgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oeCcgKyB5JyArIGMpIGluXG4gICAgICAgIHNldF9mbGFnc1xuICAgICAgICAgIH56OihuID0gVWludDguemVybylcbiAgICAgICAgICB+aDpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHhGICsgeScgbGFuZCBvZl9pbnQgMHhGICsgYyA+IG9mX2ludCAweEYpXG4gICAgICAgICAgfm46ZmFsc2VcbiAgICAgICAgICB+YzooKFVpbnQ4LnRvX2ludCB4JyArIFVpbnQ4LnRvX2ludCB5JyArIFVpbnQ4LnRvX2ludCBjKSA+IDB4RkYpICgpO1xuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBOZXh0XG4gICAgICB8IFNVQiAoeCwgeSkgLT5cbiAgICAgICAgbGV0IHgnLCB5JyA9IHJlYWQgeCwgcmVhZCB5IGluXG4gICAgICAgIGxldCBuID0gVWludDguKHgnIC0geScpIGluXG4gICAgICAgIHNldF9mbGFnc1xuICAgICAgICAgIH56OihuID0gVWludDguemVybylcbiAgICAgICAgICB+aDpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHhGIDwgeScgbGFuZCBvZl9pbnQgMHhGKVxuICAgICAgICAgIH5uOnRydWVcbiAgICAgICAgICB+YzooKFVpbnQ4LnRvX2ludCB4JykgPCBVaW50OC50b19pbnQgeScpICgpO1xuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBOZXh0XG4gICAgICB8IFNCQyAoeCwgeSkgLT5cbiAgICAgICAgbGV0IGMgPSBpZiBSZWdpc3RlcnMuKHJlYWRfZmxhZyB0LnJlZ2lzdGVycyBDYXJyeSkgdGhlbiBVaW50OC5vbmUgZWxzZSBVaW50OC56ZXJvIGluXG4gICAgICAgIGxldCB4JywgeScgPSByZWFkIHgsIHJlYWQgeSBpblxuICAgICAgICBsZXQgbiA9IFVpbnQ4Lih4JyAtICh5JyArIGMpKSBpblxuICAgICAgICBzZXRfZmxhZ3NcbiAgICAgICAgICB+ejoobiA9IFVpbnQ4Lnplcm8pXG4gICAgICAgICAgfmg6VWludDguKHgnIGxhbmQgb2ZfaW50IDB4RiA8IHknIGxhbmQgb2ZfaW50IDB4RiArIGMpXG4gICAgICAgICAgfm46dHJ1ZVxuICAgICAgICAgIH5jOigoVWludDgudG9faW50IHgnKSA8IFVpbnQ4LnRvX2ludCB5JyArIFVpbnQ4LnRvX2ludCBjKSAoKTtcbiAgICAgICAgeCA8LS0gbjtcbiAgICAgICAgTmV4dFxuICAgICAgfCBBTkQgKHgsIHkpIC0+XG4gICAgICAgIGxldCBuID0gVWludDguKHJlYWQgeCBsYW5kIHJlYWQgeSkgaW5cbiAgICAgICAgc2V0X2ZsYWdzIH56OihuID0gVWludDguemVybykgfmg6dHJ1ZSB+bjpmYWxzZSB+YzpmYWxzZSAoKTtcbiAgICAgICAgeCA8LS0gbjtcbiAgICAgICAgTmV4dFxuICAgICAgfCBPUiAoeCwgeSkgLT5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4ocmVhZCB4IGxvciByZWFkIHkpIGluXG4gICAgICAgIHNldF9mbGFncyB+ejoobiA9IFVpbnQ4Lnplcm8pIH5oOmZhbHNlIH5uOmZhbHNlIH5jOmZhbHNlICgpO1xuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBOZXh0XG4gICAgICB8IFhPUiAoeCwgeSkgLT5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4ocmVhZCB4IGx4b3IgcmVhZCB5KSBpblxuICAgICAgICBzZXRfZmxhZ3Mgfno6KG4gPSBVaW50OC56ZXJvKSB+aDpmYWxzZSB+bjpmYWxzZSB+YzpmYWxzZSAoKTtcbiAgICAgICAgeCA8LS0gbjtcbiAgICAgICAgTmV4dFxuICAgICAgfCBDUCAoeCwgeSkgLT5cbiAgICAgICAgbGV0IHgnLCB5JyA9IHJlYWQgeCwgcmVhZCB5IGluXG4gICAgICAgIGxldCBuID0gVWludDguKHgnIC0geScpIGluXG4gICAgICAgIHNldF9mbGFnc1xuICAgICAgICAgIH56OihuID0gVWludDguemVybylcbiAgICAgICAgICB+aDpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHhGIDwgeScgbGFuZCBvZl9pbnQgMHhGKVxuICAgICAgICAgIH5uOnRydWVcbiAgICAgICAgICB+YzooKFVpbnQ4LnRvX2ludCB4JykgPCBVaW50OC50b19pbnQgeScpICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IElOQyB4IC0+XG4gICAgICAgIGxldCB4JyA9IChyZWFkIHgpIGluXG4gICAgICAgIGxldCBuID0gVWludDguKHN1Y2MgeCcpIGluXG4gICAgICAgIHNldF9mbGFnc1xuICAgICAgICAgIH56OihuID0gVWludDguemVybylcbiAgICAgICAgICB+aDpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHgwRiA9IG9mX2ludCAweDBGKVxuICAgICAgICAgIH5uOmZhbHNlICgpO1xuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBOZXh0XG4gICAgICB8IElOQzE2IHggLT5cbiAgICAgICAgeCA8LS0gVWludDE2LihzdWNjIEBAIHJlYWQgeCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgREVDIHggLT5cbiAgICAgICAgbGV0IHgnID0gKHJlYWQgeCkgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4ocHJlZCB4JykgaW5cbiAgICAgICAgc2V0X2ZsYWdzXG4gICAgICAgICAgfno6KG4gPSBVaW50OC56ZXJvKVxuICAgICAgICAgIH5oOlVpbnQ4Lih4JyBsYW5kIG9mX2ludCAweDBGID0gb2ZfaW50IDB4MClcbiAgICAgICAgICB+bjp0cnVlICgpO1xuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBOZXh0XG4gICAgICB8IERFQzE2IHggLT5cbiAgICAgICAgeCA8LS0gVWludDE2LihwcmVkIEBAIHJlYWQgeCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgU1dBUCB4IC0+XG4gICAgICAgIGxldCB4JyA9IHJlYWQgeCBpblxuICAgICAgICBsZXQgbiA9IFVpbnQ4LigoeCcgbHNsIDQpIGxvciAoeCcgbHNyIDQpKSBpblxuICAgICAgICBzZXRfZmxhZ3NcbiAgICAgICAgICB+ejoobiA9IFVpbnQ4Lnplcm8pXG4gICAgICAgICAgfmg6ZmFsc2UgfmM6ZmFsc2Ugfm46ZmFsc2UgKCk7XG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIE5leHRcbiAgICAgIHwgREFBIC0+XG4gICAgICAgIGxldCBuX2ZsYWcgPSBSZWdpc3RlcnMucmVhZF9mbGFnIHQucmVnaXN0ZXJzIFN1YnRyYWN0aW9uIGluXG4gICAgICAgIGxldCBjX2ZsYWcgPSBSZWdpc3RlcnMucmVhZF9mbGFnIHQucmVnaXN0ZXJzIENhcnJ5IGluXG4gICAgICAgIGxldCBoX2ZsYWcgPSBSZWdpc3RlcnMucmVhZF9mbGFnIHQucmVnaXN0ZXJzIEhhbGZfY2FycnkgaW5cbiAgICAgICAgbGV0IGEgPSByZWYgKFJlZ2lzdGVycy5yZWFkX3IgdC5yZWdpc3RlcnMgQSkgaW5cbiAgICAgICAgbGV0IG9wZW4gVWludDggaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbl9mbGFnIHdpdGhcbiAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICBpZiBjX2ZsYWcgfHwgIWEgPiBvZl9pbnQgMHg5OSB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGEgOj0gIWEgKyBvZl9pbnQgMHg2MDtcbiAgICAgICAgICAgICAgc2V0X2ZsYWdzIH5jOnRydWUgKClcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGlmIGhfZmxhZyB8fCAoIWEgbGFuZCBvZl9pbnQgMHgwRikgPiBvZl9pbnQgMHgwOSB0aGVuXG4gICAgICAgICAgICAgIGEgOj0gIWEgKyBvZl9pbnQgMHgwNlxuICAgICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICAgaWYgY19mbGFnIHRoZW5cbiAgICAgICAgICAgICAgYSA6PSAhYSAtIG9mX2ludCAweDYwO1xuICAgICAgICAgICAgaWYgaF9mbGFnIHRoZW5cbiAgICAgICAgICAgICAgYSA6PSAhYSAtIG9mX2ludCAweDA2O1xuICAgICAgICBlbmQ7XG4gICAgICAgIHNldF9mbGFncyB+aDpmYWxzZSB+ejooIWEgPSB6ZXJvKSAoKTtcbiAgICAgICAgUmVnaXN0ZXJzLndyaXRlX3IgdC5yZWdpc3RlcnMgQSAhYTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBDUEwgLT5cbiAgICAgICAgc2V0X2ZsYWdzIH5uOnRydWUgfmg6dHJ1ZSAoKTtcbiAgICAgICAgUmVnaXN0ZXJzLnJlYWRfciB0LnJlZ2lzdGVycyBBXG4gICAgICAgIHw+IChmdW4gbiAtPiBVaW50OC4obiBseG9yIG1heF9pbnQpKVxuICAgICAgICB8PiBSZWdpc3RlcnMud3JpdGVfciB0LnJlZ2lzdGVycyBBO1xuICAgICAgICBOZXh0XG4gICAgICB8IENDRiAtPlxuICAgICAgICBsZXQgYyA9IFJlZ2lzdGVycy5yZWFkX2ZsYWcgdC5yZWdpc3RlcnMgQ2FycnkgaW5cbiAgICAgICAgc2V0X2ZsYWdzIH5uOmZhbHNlIH5oOmZhbHNlIH5jOihub3QgYykgKCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgU0NGIC0+XG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+Yzp0cnVlICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IE5PUCAtPiBOZXh0XG4gICAgICB8IEhBTFQgLT5cbiAgICAgICAgdC5oYWx0ZWQgPC0gdHJ1ZTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBTVE9QIC0+IGFzc2VydCBmYWxzZTtcbiAgICAgIHwgREkgLT5cbiAgICAgICAgKCogREkgY2FuY2VscyBwZW5kaW5nIEVJICopXG4gICAgICAgIHQuZW5hYmxlX2ltZV9iZWZvcmVfbmV4dF9pbnN0ciA8LSBmYWxzZTtcbiAgICAgICAgdC5pbWUgPC0gZmFsc2U7XG4gICAgICAgIE5leHRcbiAgICAgIHwgRUkgLT5cbiAgICAgICAgdC5lbmFibGVfaW1lX2JlZm9yZV9uZXh0X2luc3RyIDwtIHRydWU7XG4gICAgICAgIE5leHRcbiAgICAgIHwgUkxDQSAtPlxuICAgICAgICBsZXQgYSA9IFJlZ2lzdGVycy5yZWFkX3IgdC5yZWdpc3RlcnMgQSBpblxuICAgICAgICBsZXQgYyA9IFVpbnQ4LihhIGxhbmQgb2ZfaW50IDB4ODAgPD4gemVybykgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oKGEgbHNsIDEpIGxvciBpZiBjIHRoZW4gb25lIGVsc2UgemVybykgaW5cbiAgICAgICAgUmVnaXN0ZXJzLndyaXRlX3IgdC5yZWdpc3RlcnMgQSBuO1xuICAgICAgICBzZXRfZmxhZ3Mgfm46ZmFsc2Ugfmg6ZmFsc2Ugfno6ZmFsc2UgfmMgKCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgUkxBIC0+XG4gICAgICAgIGxldCBhID0gUmVnaXN0ZXJzLnJlYWRfciB0LnJlZ2lzdGVycyBBIGluXG4gICAgICAgIGxldCBvbGRfYyA9IFJlZ2lzdGVycy5yZWFkX2ZsYWcgdC5yZWdpc3RlcnMgQ2FycnkgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oKGEgbHNsIDEpIGxvciBpZiBvbGRfYyB0aGVuIG9uZSBlbHNlIHplcm8pIGluXG4gICAgICAgIFJlZ2lzdGVycy53cml0ZV9yIHQucmVnaXN0ZXJzIEEgbjtcbiAgICAgICAgbGV0IG5ld19jID0gVWludDguKGEgbGFuZCBvZl9pbnQgMHg4MCA8PiB6ZXJvKSBpblxuICAgICAgICBzZXRfZmxhZ3Mgfm46ZmFsc2Ugfmg6ZmFsc2Ugfno6ZmFsc2UgfmM6bmV3X2MgKCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgUlJDQSAtPlxuICAgICAgICBsZXQgYSA9IFJlZ2lzdGVycy5yZWFkX3IgdC5yZWdpc3RlcnMgQSBpblxuICAgICAgICBsZXQgYyA9IFVpbnQ4LihhIGxhbmQgb2ZfaW50IDEgPD4gemVybykgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oKGEgbHNyIDEpIGxvciBpZiBjIHRoZW4gb2ZfaW50IDB4ODAgZWxzZSB6ZXJvKSBpblxuICAgICAgICBSZWdpc3RlcnMud3JpdGVfciB0LnJlZ2lzdGVycyBBIG47XG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+ejpmYWxzZSB+YzpjICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IFJSQSAtPlxuICAgICAgICBsZXQgYSA9IFJlZ2lzdGVycy5yZWFkX3IgdC5yZWdpc3RlcnMgQSBpblxuICAgICAgICBsZXQgb2xkX2MgPSBSZWdpc3RlcnMucmVhZF9mbGFnIHQucmVnaXN0ZXJzIENhcnJ5IGluXG4gICAgICAgIGxldCBuID0gVWludDguKChhIGxzciAxKSBsb3IgaWYgb2xkX2MgdGhlbiBvZl9pbnQgMHg4MCBlbHNlIHplcm8pIGluXG4gICAgICAgIFJlZ2lzdGVycy53cml0ZV9yIHQucmVnaXN0ZXJzIEEgbjtcbiAgICAgICAgbGV0IG5ld19jID0gVWludDguKGEgbGFuZCBvZl9pbnQgMHgxIDw+IHplcm8pIGluXG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+ejpmYWxzZSB+YzpuZXdfYyAoKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBSTEMgeCAtPlxuICAgICAgICBsZXQgeCcgPSByZWFkIHggaW5cbiAgICAgICAgbGV0IGMgPSBVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHg4MCA8PiB6ZXJvKSBpblxuICAgICAgICBsZXQgbiA9IFVpbnQ4LigoeCcgbHNsIDEpIGxvciBpZiBjIHRoZW4gb25lIGVsc2UgemVybykgaW5cbiAgICAgICAgeCA8LS0gbjtcbiAgICAgICAgc2V0X2ZsYWdzIH5uOmZhbHNlIH5oOmZhbHNlIH56OlVpbnQ4LihuID0gemVybykgfmMgKCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgUkwgeCAtPlxuICAgICAgICBsZXQgeCcgPSByZWFkIHggaW5cbiAgICAgICAgbGV0IG9sZF9jID0gUmVnaXN0ZXJzLnJlYWRfZmxhZyB0LnJlZ2lzdGVycyBDYXJyeSBpblxuICAgICAgICBsZXQgbiA9IFVpbnQ4LigoeCcgbHNsIDEpIGxvciBpZiBvbGRfYyB0aGVuIG9uZSBlbHNlIHplcm8pIGluXG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIGxldCBuZXdfYyA9IFVpbnQ4Lih4JyBsYW5kIG9mX2ludCAweDgwIDw+IHplcm8pIGluXG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+ejpVaW50OC4obiA9IHplcm8pIH5jOm5ld19jICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IFJSQyB4IC0+XG4gICAgICAgIGxldCB4JyA9IHJlYWQgeCBpblxuICAgICAgICBsZXQgYyA9IFVpbnQ4Lih4JyBsYW5kIG9mX2ludCAxIDw+IHplcm8pIGluXG4gICAgICAgIGxldCBuID0gVWludDguKCh4JyBsc3IgMSkgbG9yIGlmIGMgdGhlbiBvZl9pbnQgMHg4MCBlbHNlIHplcm8pIGluXG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+ejpVaW50OC4obiA9IHplcm8pIH5jICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IFJSIHggLT5cbiAgICAgICAgbGV0IHgnID0gcmVhZCB4IGluXG4gICAgICAgIGxldCBvbGRfYyA9IFJlZ2lzdGVycy5yZWFkX2ZsYWcgdC5yZWdpc3RlcnMgQ2FycnkgaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oKHgnIGxzciAxKSBsb3IgaWYgb2xkX2MgdGhlbiBvZl9pbnQgMHg4MCBlbHNlIHplcm8pIGluXG4gICAgICAgIHggPC0tIG47XG4gICAgICAgIHNldF9mbGFncyB+bjpmYWxzZSB+aDpmYWxzZSB+ejpVaW50OC4obiA9IHplcm8pIH5jOlVpbnQ4Lih4JyBsYW5kIG9mX2ludCAweDEgPD4gemVybykgKCk7XG4gICAgICAgIE5leHRcbiAgICAgIHwgU0xBIHggLT5cbiAgICAgICAgbGV0IHgnID0gcmVhZCB4IGluXG4gICAgICAgIGxldCBuID0gVWludDguKHgnIGxzbCAxKSBpblxuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBzZXRfZmxhZ3Mgfm46ZmFsc2Ugfmg6ZmFsc2Ugfno6VWludDguKG4gPSB6ZXJvKSB+YzpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHg4MCA8PiB6ZXJvKSAoKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBTUkEgeCAtPlxuICAgICAgICBsZXQgeCcgPSByZWFkIHggaW5cbiAgICAgICAgbGV0IG4gPSBVaW50OC4oKHgnIGxzciAxKSBsb3IgKHgnIGxhbmQgb2ZfaW50IDB4ODApKSBpblxuICAgICAgICB4IDwtLSBuO1xuICAgICAgICBzZXRfZmxhZ3Mgfm46ZmFsc2Ugfmg6ZmFsc2Ugfno6VWludDguKG4gPSB6ZXJvKSB+YzpVaW50OC4oeCcgbGFuZCBvZl9pbnQgMHgxIDw+IHplcm8pICgpO1xuICAgICAgICBOZXh0XG4gICAgICB8IFNSTCB4IC0+XG4gICAgICAgIGxldCB4JyA9IHJlYWQgeCBpblxuICAgICAgICBsZXQgbiA9IFVpbnQ4Lih4JyBsc3IgMSkgaW5cbiAgICAgICAgeCA8LS0gbjtcbiAgICAgICAgc2V0X2ZsYWdzIH5uOmZhbHNlIH5oOmZhbHNlIH56OlVpbnQ4LihuID0gemVybykgfmM6VWludDguKHgnIGxhbmQgb2ZfaW50IDB4MSA8PiB6ZXJvKSAoKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBCSVQgKG4sIHgpIC0+XG4gICAgICAgIGxldCBiID0gVWludDguKHJlYWQgeCBsYW5kIChvbmUgbHNsIG4pID0gemVybykgaW5cbiAgICAgICAgc2V0X2ZsYWdzIH5uOmZhbHNlIH5oOnRydWUgfno6YiAoKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBTRVQgKG4sIHgpIC0+XG4gICAgICAgIHggPC0tIFVpbnQ4LihyZWFkIHggbG9yIChvbmUgbHNsIG4pKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBSRVMgKG4sIHgpIC0+XG4gICAgICAgIGxldCBtYXNrID0gVWludDguKChvbmUgbHNsIG4pIGx4b3Igb2ZfaW50IDBiMTExMTExMTEpIGluXG4gICAgICAgIHggPC0tIFVpbnQ4LihyZWFkIHggbGFuZCBtYXNrKTtcbiAgICAgICAgTmV4dFxuICAgICAgfCBQVVNIIHJyIC0+XG4gICAgICAgIHQuc3AgPC0gVWludDE2Lih0LnNwIC0gb2ZfaW50IDIpO1xuICAgICAgICBNbXUud3JpdGVfd29yZCB0Lm1tdSB+YWRkcjp0LnNwIH5kYXRhOihSZWdpc3RlcnMucmVhZF9yciB0LnJlZ2lzdGVycyBycik7XG4gICAgICAgIE5leHRcbiAgICAgIHwgUE9QIHJyIC0+XG4gICAgICAgIFJlZ2lzdGVycy53cml0ZV9yciB0LnJlZ2lzdGVycyByciAoTW11LnJlYWRfd29yZCB0Lm1tdSB0LnNwKTtcbiAgICAgICAgdC5zcCA8LSBVaW50MTYuKHQuc3AgKyBvZl9pbnQgMik7XG4gICAgICAgIE5leHRcbiAgICAgIHwgSlAgKGMsIHgpIC0+XG4gICAgICAgIGlmIGNoZWNrX2NvbmRpdGlvbiB0IGMgdGhlblxuICAgICAgICAgIEp1bXAgKHJlYWQgeClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5leHRcbiAgICAgIHwgSlIgKGMsIHgpIC0+XG4gICAgICAgIGlmIGNoZWNrX2NvbmRpdGlvbiB0IGMgdGhlblxuICAgICAgICAgIGxldCBhZGRyID0gVWludDE2LnRvX2ludCB0LnBjICsgSW50OC50b19pbnQgeCB8PiBVaW50MTYub2ZfaW50IGluXG4gICAgICAgICAgSnVtcCBhZGRyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOZXh0XG4gICAgICB8IENBTEwgKGMsIHgpIC0+XG4gICAgICAgIGlmIGNoZWNrX2NvbmRpdGlvbiB0IGMgdGhlbiBiZWdpblxuICAgICAgICAgIHQuc3AgPC0gVWludDE2Lih0LnNwIC0gb2ZfaW50IDIpO1xuICAgICAgICAgIE1tdS53cml0ZV93b3JkIHQubW11IH5hZGRyOnQuc3AgfmRhdGE6dC5wYztcbiAgICAgICAgICBKdW1wIHhcbiAgICAgICAgZW5kIGVsc2VcbiAgICAgICAgICBOZXh0XG4gICAgICB8IFJTVCB4IC0+XG4gICAgICAgIHQuc3AgPC0gVWludDE2Lih0LnNwIC0gb2ZfaW50IDIpO1xuICAgICAgICBNbXUud3JpdGVfd29yZCB0Lm1tdSB+YWRkcjp0LnNwIH5kYXRhOnQucGM7XG4gICAgICAgIEp1bXAgeFxuICAgICAgfCBSRVQgYyAtPlxuICAgICAgICBpZiBjaGVja19jb25kaXRpb24gdCBjIHRoZW4gYmVnaW5cbiAgICAgICAgICBsZXQgYWRkciA9IE1tdS5yZWFkX3dvcmQgdC5tbXUgdC5zcCBpblxuICAgICAgICAgIHQuc3AgPC0gVWludDE2Lih0LnNwICsgb2ZfaW50IDIpO1xuICAgICAgICAgIEp1bXAgYWRkclxuICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgIE5leHRcbiAgICAgIHwgUkVUSSAgLT5cbiAgICAgICAgbGV0IGFkZHIgPSBNbXUucmVhZF93b3JkIHQubW11IHQuc3AgaW5cbiAgICAgICAgdC5zcCA8LSBVaW50MTYuKHQuc3AgKyBvZl9pbnQgMik7XG4gICAgICAgIHQuaW1lIDwtIHRydWU7XG4gICAgICAgIEp1bXAgYWRkclxuICAgIGluXG4gICAgdC5wcmV2X2luc3QgPC0gaW5zdDtcbiAgICBtYXRjaCBuZXh0X3BjLCBtY3ljbGVzIHdpdGhcbiAgICB8IE5leHQsIChub3RfYnJhbmNoZWRfbWN5Y2xlLCBfKSAtPlxuICAgICAgbm90X2JyYW5jaGVkX21jeWNsZVxuICAgIHwgSnVtcCBhZGRyLCAoXywgYnJhbmNoZWRfbWN5Y2xlKSAtPlxuICAgICAgdC5wYyA8LSBhZGRyO1xuICAgICAgYnJhbmNoZWRfbWN5Y2xlXG5cbiAgbW9kdWxlIEZldGNoX2FuZF9kZWNvZGUgPSBGZXRjaF9hbmRfZGVjb2RlLk1ha2UoTW11KVxuXG4gIGxldCBydW5faW5zdHJ1Y3Rpb24gdCAgPVxuICAgIGxldCBmZXRjaF9kZWNvZGVfZXhlY3V0ZSB0ID1cbiAgICAgIGlmIHQuaGFsdGVkIHRoZW5cbiAgICAgICAgNFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgKGxlbiwgbWN5Y2xlcywgaW5zdCkgPSBGZXRjaF9hbmRfZGVjb2RlLmYgdC5tbXUgfnBjOnQucGMgaW5cbiAgICAgICAgdC5wYyA8LSBVaW50MTYuKHQucGMgKyBsZW4pO1xuICAgICAgICBleGVjdXRlIHQgbWN5Y2xlcyBpbnN0XG4gICAgaW5cbiAgICBsZXQgaGFuZGxlX2ludGVycnVwdCB0IDogaW50ID1cbiAgICAgIG1hdGNoIEludGVycnVwdF9jb250cm9sbGVyLm5leHQgdC5pYyB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgMFxuICAgICAgfCBTb21lIHR5cGVfIC0+XG4gICAgICAgIHQuaGFsdGVkIDwtIGZhbHNlO1xuICAgICAgICBpZiBub3QgdC5pbWUgdGhlblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIHQuaW1lIDwtIGZhbHNlO1xuICAgICAgICAgIEludGVycnVwdF9jb250cm9sbGVyLmNsZWFyIHQuaWMgdHlwZV87XG4gICAgICAgICAgbGV0IGFkZHIgPSAgbWF0Y2ggdHlwZV8gd2l0aFxuICAgICAgICAgICAgfCBWQmxhbmsgICAgICAtPiBVaW50MTYuKG9mX2ludCAweDQwKVxuICAgICAgICAgICAgfCBMQ0Rfc3RhdCAgICAtPiBVaW50MTYuKG9mX2ludCAweDQ4KVxuICAgICAgICAgICAgfCBUaW1lciAgICAgICAtPiBVaW50MTYuKG9mX2ludCAweDUwKVxuICAgICAgICAgICAgfCBTZXJpYWxfcG9ydCAtPiBVaW50MTYuKG9mX2ludCAweDU4KVxuICAgICAgICAgICAgfCBKb3lwYWQgICAgICAtPiBVaW50MTYuKG9mX2ludCAweDYwKVxuICAgICAgICAgIGluXG4gICAgICAgICAgdC5zcCA8LSBVaW50MTYuKHQuc3AgLSBvZl9pbnQgMik7XG4gICAgICAgICAgTW11LndyaXRlX3dvcmQgdC5tbXUgfmFkZHI6dC5zcCB+ZGF0YTp0LnBjO1xuICAgICAgICAgIHQucGMgPC0gYWRkcjtcbiAgICAgICAgICA1XG4gICAgICAgIGVuZFxuICAgIGluXG4gICAgaWYgdC5lbmFibGVfaW1lX2JlZm9yZV9uZXh0X2luc3RyIHRoZW4gYmVnaW5cbiAgICAgIHQuaW1lIDwtIHRydWU7XG4gICAgICB0LmVuYWJsZV9pbWVfYmVmb3JlX25leHRfaW5zdHIgPC0gZmFsc2VcbiAgICBlbmQ7XG4gICAgbGV0IGluc3RfbWN5Y2xlcyA9IGZldGNoX2RlY29kZV9leGVjdXRlIHQgaW5cbiAgICBsZXQgaW50ZXJydXB0X21jeWNsZXMgPSBoYW5kbGVfaW50ZXJydXB0IHQgaW5cbiAgICBpbnN0X21jeWNsZXMgKyBpbnRlcnJ1cHRfbWN5Y2xlc1xuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcblxuICAgIGxldCBleGVjdXRlID0gZXhlY3V0ZVxuXG4gICAgbGV0IHByZXZfaW5zdCB0ID0gdC5wcmV2X2luc3RcblxuICBlbmRcblxuZW5kXG4iLCJvcGVuIFVpbnRzXG5cbigqIFRPRE86IFN1cHBvcnQgUmVhbCBUaW1lIENsb2NrIChSVEMpIGFuZCBiYXR0ZXJ5IGJhY2tlZCBzYXZlICopXG5cbnR5cGUgdCA9IHtcbiAgcm9tX2J5dGVzIDogQmlnc3RyaW5nYWYudDtcbiAgcmFtX2J5dGVzIDogQmlnc3RyaW5nYWYudDtcbiAgbXV0YWJsZSByYW1fZW5hYmxlZCA6IGJvb2w7XG4gIG11dGFibGUgcm9tX2JhbmtfbnVtIDogaW50O1xuICBtdXRhYmxlIHJhbV9iYW5rX251bSA6IGludDtcbn1cblxubGV0IGNyZWF0ZSB+cm9tX2J5dGVzID1cbiAgbGV0IGggPSBDYXJ0cmlkZ2VfaGVhZGVyLmNyZWF0ZSB+cm9tX2J5dGVzIGluXG4gIGxldCByYW1fYmFua19zaXplID0gQ2FydHJpZGdlX2hlYWRlci5nZXRfcmFtX2JhbmtfY291bnQgaCBpblxuICBsZXQgcmFtX2J5dGVzID0gQmlnc3RyaW5nYWYuY3JlYXRlIChyYW1fYmFua19zaXplICogMHgyMDAwKSBpblxuICB7XG4gICAgcm9tX2J5dGVzO1xuICAgIHJhbV9ieXRlcztcbiAgICByYW1fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJvbV9iYW5rX251bSA9IDE7XG4gICAgcmFtX2JhbmtfbnVtID0gMDtcbiAgfVxuXG5sZXQgcmVhZF9ieXRlIHQgYWRkciA9XG4gIGxldCBhZGRyID0gVWludDE2LnRvX2ludCBhZGRyIGluXG4gIG1hdGNoIGFkZHIgd2l0aFxuICB8IF8gd2hlbiAweDAwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4M0ZGRiAtPlxuICAgIGFkZHJcbiAgICB8PiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQucm9tX2J5dGVzXG4gICAgfD4gVWludDgub2ZfY2hhclxuICB8IF8gd2hlbiAweDQwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4N0ZGRiAtPlxuICAgICgweDQwMDAgKiB0LnJvbV9iYW5rX251bSArIChhZGRyIC0gMHg0MDAwKSlcbiAgICB8PiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQucm9tX2J5dGVzXG4gICAgfD4gVWludDgub2ZfY2hhclxuICB8IF8gd2hlbiAweEEwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4QkZGRiAtPlxuICAgIGlmIHQucmFtX2VuYWJsZWQgdGhlblxuICAgICAgMHg0MDAwICogdC5yb21fYmFua19udW0gKyAoYWRkciAtIDB4NDAwMClcbiAgICAgIHw+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5yYW1fYnl0ZXNcbiAgICAgIHw+IFVpbnQ4Lm9mX2NoYXJcbiAgICBlbHNlXG4gICAgICBVaW50OC5vZl9pbnQgMHhGRlxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxubGV0IHdyaXRlX2J5dGUgdCB+YWRkciB+ZGF0YSA9XG4gIGxldCBhZGRyID0gVWludDE2LnRvX2ludCBhZGRyIGluXG4gIGxldCBkYXRhID0gVWludDgudG9faW50IGRhdGEgaW5cbiAgbWF0Y2ggYWRkciB3aXRoXG4gIHwgXyB3aGVuIDB4MDAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHgxRkZGIC0+XG4gICAgdC5yYW1fZW5hYmxlZCA8LSBkYXRhID0gMHgwQVxuICB8IF8gd2hlbiAweDIwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4M0ZGRiAtPlxuICAgIGxldCByb21fYmFua19udW0gPSBkYXRhIGxhbmQgMGIwMTExMTExMSBpblxuICAgIHQucm9tX2JhbmtfbnVtIDwtIGlmIHJvbV9iYW5rX251bSA9IDAgdGhlbiAxIGVsc2Ugcm9tX2JhbmtfbnVtXG4gIHwgXyB3aGVuIDB4NDAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHg1RkZGIC0+XG4gICAgaWYgMHgwIDw9IGRhdGEgJiYgZGF0YSA8PSAweDMgdGhlbiB0LnJhbV9iYW5rX251bSA8LSBkYXRhXG4gIHwgXyB3aGVuIDB4NjAwMCA8PSBhZGRyICYmIGFkZHIgPD0gMHg3RkZGIC0+XG4gICAgKCogTm8gUlRDIHN1cHBvcnQgeWV0ICopXG4gICAgKClcbiAgfCBfIHdoZW4gMHhBMDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweEJGRkYgLT5cbiAgICBpZiB0LnJhbV9lbmFibGVkIHRoZW5cbiAgICAgIGxldCByYW1fYWRkciA9IDB4NDAwMCAqIHQucm9tX2JhbmtfbnVtICsgKGFkZHIgLSAweDQwMDApIGluXG4gICAgICBCaWdzdHJpbmdhZi51bnNhZmVfc2V0IHQucmFtX2J5dGVzIHJhbV9hZGRyIChDaGFyLnVuc2FmZV9jaHIgZGF0YSlcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgYWNjZXB0cyBfIGFkZHIgPVxuICBsZXQgYWRkciA9IFVpbnQxNi50b19pbnQgYWRkciBpblxuICAweDAwMDAgPD0gYWRkciAmJiBhZGRyIDw9IDB4N0ZGRiB8fCAgMHhBMDAwIDw9IGFkZHIgJiYgYWRkciA8PSAweEJGRkZcbiIsIm9wZW4gVWludHNcblxubW9kdWxlIE1ha2UgKENhcnRyaWRnZSA6IENhcnRyaWRnZV9pbnRmLlMpID0gc3RydWN0XG5cbiAgbW9kdWxlIE1tdSA9IE1tdS5NYWtlKENhcnRyaWRnZSlcblxuICBtb2R1bGUgQ3B1ID0gQ3B1Lk1ha2UoTW11KVxuXG4gIHR5cGUgdCA9IHtcbiAgICBjcHUgICAgOiBDcHUudDtcbiAgICB0aW1lciAgOiBUaW1lci50O1xuICAgIGdwdSAgICA6IEdwdS50O1xuICAgIGpveXBhZCA6IEpveXBhZC50O1xuICB9XG5cbiAgbGV0IHNob3cgdCA9IENwdS5zaG93IHQuY3B1XG5cbiAgbGV0IGluaXRpYWxpemVfc3RhdGUgfnJlZ2lzdGVycyB+bW11IH5sY2Rfc3RhdCB+Z3B1ID1cbiAgICAoKiBpbml0aWFsaXplIHJlZ2lzdGVycyAqKVxuICAgIFJlZ2lzdGVycy5zZXRfZmxhZ3MgcmVnaXN0ZXJzIH56OnRydWUgfm46ZmFsc2Ugfmg6dHJ1ZSB+Yzp0cnVlICgpO1xuICAgIFJlZ2lzdGVycy5bXG4gICAgICAoQUYsIDB4MDFCMCk7XG4gICAgICAoQkMsIDB4MDAxMyk7XG4gICAgICAoREUsIDB4MDBEOCk7XG4gICAgICAoSEwsIDB4MDE0RClcbiAgICBdXG4gICAgfD4gTGlzdC5pdGVyIChmdW4gKHJlZywgZGF0YSkgLT5cbiAgICAgICAgUmVnaXN0ZXJzLndyaXRlX3JyIHJlZ2lzdGVycyByZWcgKFVpbnQxNi5vZl9pbnQgZGF0YSkpO1xuXG4gICAgKCogaW5pdGlhbGl6ZSBtbXUgKilcbiAgICBbXG4gICAgICAoMHhGRjAwLCAweENGKTtcbiAgICAgICgweEZGMDEsIDB4MDApO1xuICAgICAgKDB4RkYwMiwgMHg3RSk7XG4gICAgICAoMHhGRjA0LCAweEFCKTtcbiAgICAgICgweEZGMDUsIDB4MDApO1xuICAgICAgKDB4RkYwNiwgMHgwMCk7XG4gICAgICAoMHhGRjA3LCAweEY4KTtcbiAgICAgICgweEZGMEYsIDB4RTEpO1xuICAgICAgKCogVE9ETzogRmlsbCBzb3VuZCByZWxhdGVkIElPIHJlZ2lzdGVycyAqKVxuICAgICAgKCogKDB4RkYxMCwgMHgtLSk7ICopXG4gICAgICAoMHhGRjQwLCAweDkxKTtcbiAgICAgICgweEZGNDIsIDB4MDApO1xuICAgICAgKDB4RkY0MywgMHgwMCk7XG4gICAgICAoMHhGRjQ0LCAweDAwKTtcbiAgICAgICgweEZGNDUsIDB4MDApO1xuICAgICAgKDB4RkY0NiwgMHhGRik7XG4gICAgICAoMHhGRjQ3LCAweEZDKTtcbiAgICAgICgweEZGNEEsIDB4MDApO1xuICAgICAgKDB4RkY0QiwgMHgwMCk7XG4gICAgICAoKiAoMHhGRjRELCAweC0tKTsgKilcbiAgICAgICgweEZGRkYsIDB4MDApO1xuICAgIF1cbiAgICB8PiBMaXN0Lml0ZXIgKGZ1biAoYWRkciwgZGF0YSkgLT5cbiAgICAgICAgTW11LndyaXRlX2J5dGUgbW11IH5hZGRyOihVaW50MTYub2ZfaW50IGFkZHIpIH5kYXRhOihVaW50OC5vZl9pbnQgZGF0YSkpO1xuXG4gICAgKCogaW5pdGlhbGl6ZSBHUFUgKilcbiAgICBMY2Rfc3RhdC5zZXRfZ3B1X21vZGUgbGNkX3N0YXQgR3B1X21vZGUuVkJsYW5rO1xuICAgIEdwdS5zZXRfbWN5Y2xlc19pbl9tb2RlIGdwdSAwXG5cblxuICBsZXQgbHlfYWRkciA9IFVpbnQxNi5vZl9pbnQgMHhGRjQ0XG5cbiAgbGV0IGxjZF9zdGF0X2FkZHIgPSBVaW50MTYub2ZfaW50IDB4RkY0MVxuXG4gIGxldCBjcmVhdGVfd2l0aF9yb20gfnByaW50X3NlcmlhbF9wb3J0IH4ocm9tX2J5dGVzIDogQmlnc3RyaW5nYWYudCkgPVxuICAgIGxldCBvcGVuIFVpbnQxNiBpblxuICAgIGxldCBjYXJ0cmlkZ2UgPSBDYXJ0cmlkZ2UuY3JlYXRlIH5yb21fYnl0ZXNcbiAgICBpblxuICAgIGxldCB3cmFtID0gUmFtLmNyZWF0ZVxuICAgICAgICB+c3RhcnRfYWRkcjoob2ZfaW50IDB4QzAwMClcbiAgICAgICAgfmVuZF9hZGRyOihvZl9pbnQgMHhERkZGKVxuICAgIGluXG4gICAgbGV0IHNoYWRvd19yYW0gPSBTaGFkb3dfcmFtLmNyZWF0ZVxuICAgICAgICB+dGFyZ2V0OndyYW1cbiAgICAgICAgfnRhcmdldF9zdGFydDoob2ZfaW50IDB4QzAwMClcbiAgICAgICAgfnNoYWRvd19zdGFydDoob2ZfaW50IDB4RTAwMClcbiAgICAgICAgfnNoYWRvd19lbmQ6KG9mX2ludCAweEZERkYpXG4gICAgaW5cbiAgICBsZXQgemVyb19wYWdlID0gUmFtLmNyZWF0ZVxuICAgICAgICB+c3RhcnRfYWRkcjoob2ZfaW50IDB4RkY4MClcbiAgICAgICAgfmVuZF9hZGRyOihvZl9pbnQgMHhGRkZFKVxuICAgIGluXG4gICAgbGV0IHNlcmlhbF9wb3J0ID0gU2VyaWFsX3BvcnQuY3JlYXRlXG4gICAgICAgIH5zYjooTW1hcF9yZWdpc3Rlci5jcmVhdGUgfmFkZHI6KG9mX2ludCAweEZGMDEpIH50eXBlXzpgUlcgKCkpXG4gICAgICAgIH5zYzooTW1hcF9yZWdpc3Rlci5jcmVhdGUgfmFkZHI6KG9mX2ludCAweEZGMDIpIH50eXBlXzpgUlcgKCkpXG4gICAgICAgIH5wcmludF9zZXJpYWxfcG9ydFxuICAgICAgICAoKVxuICAgIGluXG4gICAgbGV0IGljID0gSW50ZXJydXB0X2NvbnRyb2xsZXIuY3JlYXRlXG4gICAgICAgIH5pZV9hZGRyOihvZl9pbnQgMHhGRkZGKVxuICAgICAgICB+aWZfYWRkcjoob2ZfaW50IDB4RkYwRilcbiAgICBpblxuICAgIGxldCB0aWxlX2RhdGEgPSBUaWxlX2RhdGEuY3JlYXRlXG4gICAgICAgIH5zdGFydF9hZGRyOihvZl9pbnQgMHg4MDAwKVxuICAgICAgICB+ZW5kX2FkZHI6KG9mX2ludCAweDk3RkYpXG4gICAgaW5cbiAgICBsZXQgdGlsZV9tYXAgPSBUaWxlX21hcC5jcmVhdGVcbiAgICAgICAgfmFyZWEwX3N0YXJ0X2FkZHI6KFVpbnQxNi5vZl9pbnQgMHg5ODAwKVxuICAgICAgICB+YXJlYTBfZW5kX2FkZHI6KFVpbnQxNi5vZl9pbnQgMHg5QkZGKVxuICAgICAgICB+YXJlYTFfc3RhcnRfYWRkcjooVWludDE2Lm9mX2ludCAweDlDMDApXG4gICAgICAgIH5hcmVhMV9lbmRfYWRkcjooVWludDE2Lm9mX2ludCAweDlGRkYpXG4gICAgaW5cbiAgICBsZXQgb2FtX3RhYmxlID0gT2FtX3RhYmxlLmNyZWF0ZVxuICAgICAgICB+c3RhcnRfYWRkcjoob2ZfaW50IDB4RkUwMClcbiAgICAgICAgfmVuZF9hZGRyOihvZl9pbnQgMHhGRTlGKVxuICAgIGluXG4gICAgbGV0IGxjZF9zdGF0ID0gTGNkX3N0YXQuY3JlYXRlIH5hZGRyOmxjZF9zdGF0X2FkZHIgaW5cbiAgICBsZXQgam95cGFkID0gSm95cGFkLmNyZWF0ZVxuICAgICAgICB+YWRkcjoob2ZfaW50IDB4RkYwMClcbiAgICAgICAgfmljXG4gICAgaW5cbiAgICBsZXQgZ3B1ID0gR3B1LmNyZWF0ZVxuICAgICAgICB+dGlsZV9kYXRhXG4gICAgICAgIH50aWxlX21hcFxuICAgICAgICB+b2FtOm9hbV90YWJsZVxuICAgICAgICB+YmdwOihQYWxsZXRlLmNyZWF0ZSB+YWRkcjoob2ZfaW50IDB4RkY0NykpXG4gICAgICAgIH5vYnAwOihQYWxsZXRlLmNyZWF0ZSB+YWRkcjoob2ZfaW50IDB4RkY0OCkpXG4gICAgICAgIH5vYnAxOihQYWxsZXRlLmNyZWF0ZSB+YWRkcjoob2ZfaW50IDB4RkY0OSkpXG4gICAgICAgIH5sY2RfY29udHJvbDooTGNkX2NvbnRyb2wuY3JlYXRlIH5hZGRyOihvZl9pbnQgMHhGRjQwKSlcbiAgICAgICAgfmxjZF9zdGF0XG4gICAgICAgIH5sY2RfcG9zaXRpb246KFxuICAgICAgICAgIExjZF9wb3NpdGlvbi5jcmVhdGVcbiAgICAgICAgICAgIH5zY3lfYWRkcjoob2ZfaW50IDB4RkY0MilcbiAgICAgICAgICAgIH5zY3hfYWRkcjoob2ZfaW50IDB4RkY0MylcbiAgICAgICAgICAgIH5seV9hZGRyXG4gICAgICAgICAgICB+bHljX2FkZHI6KG9mX2ludCAweEZGNDUpXG4gICAgICAgICAgICB+d3lfYWRkcjoob2ZfaW50IDB4RkY0QSlcbiAgICAgICAgICAgIH53eF9hZGRyOihvZl9pbnQgMHhGRjRCKSlcbiAgICAgICAgfmljXG4gICAgaW5cbiAgICBsZXQgdGltZXIgPSBUaW1lci5jcmVhdGVcbiAgICAgICAgfmRpdl9hZGRyOihvZl9pbnQgMHhGRjA0KVxuICAgICAgICB+dGltYV9hZGRyOihvZl9pbnQgMHhGRjA1KVxuICAgICAgICB+dG1hX2FkZHI6KG9mX2ludCAweEZGMDYpXG4gICAgICAgIH50YWNfYWRkcjoob2ZfaW50IDB4RkYwNylcbiAgICAgICAgfmljXG4gICAgaW5cbiAgICBsZXQgZG1hX3RyYW5zZmVyID0gTW1hcF9yZWdpc3Rlci5jcmVhdGVcbiAgICAgICAgfmFkZHI6KG9mX2ludCAweEZGNDYpXG4gICAgICAgIH50eXBlXzpgUldcbiAgICAgICAgKClcbiAgICBpblxuICAgIGxldCBtbXUgPSBNbXUuY3JlYXRlXG4gICAgICAgIH5jYXJ0cmlkZ2VcbiAgICAgICAgfndyYW1cbiAgICAgICAgfnNoYWRvd19yYW1cbiAgICAgICAgfnplcm9fcGFnZVxuICAgICAgICB+Z3B1XG4gICAgICAgIH5qb3lwYWRcbiAgICAgICAgfnNlcmlhbF9wb3J0XG4gICAgICAgIH5pY1xuICAgICAgICB+dGltZXJcbiAgICAgICAgfmRtYV90cmFuc2ZlclxuICAgIGluXG4gICAgbGV0IHJlZ2lzdGVycyA9IFJlZ2lzdGVycy5jcmVhdGUgKCkgaW5cbiAgICBsZXQgY3B1ID0gQ3B1LmNyZWF0ZVxuICAgICAgICB+bW11XG4gICAgICAgIH5pY1xuICAgICAgICB+cmVnaXN0ZXJzXG4gICAgICAgIH5zcDoob2ZfaW50IDB4RkZGRSlcbiAgICAgICAgfnBjOihvZl9pbnQgMHgwMTAwKVxuICAgICAgICB+aGFsdGVkOmZhbHNlXG4gICAgICAgIH5pbWU6ZmFsc2VcbiAgICBpblxuICAgIGluaXRpYWxpemVfc3RhdGUgfm1tdSB+cmVnaXN0ZXJzIH5sY2Rfc3RhdCB+Z3B1O1xuICAgIHsgY3B1OyB0aW1lcjsgZ3B1OyBqb3lwYWQgfVxuXG4gIGxldCBydW5faW5zdHJ1Y3Rpb24gdCA9XG4gICAgbGV0IG1jeWNsZXMgPSBDcHUucnVuX2luc3RydWN0aW9uIHQuY3B1IGluXG4gICAgVGltZXIucnVuIHQudGltZXIgfm1jeWNsZXM7XG4gICAgR3B1LnJ1biB0LmdwdSB+bWN5Y2xlc1xuXG4gIGxldCBwcmVzcyB0IGtleSA9IEpveXBhZC5wcmVzcyB0LmpveXBhZCBrZXlcblxuICBsZXQgcmVsZWFzZSB0IGtleSA9IEpveXBhZC5yZWxlYXNlIHQuam95cGFkIGtleVxuXG5cbiAgbW9kdWxlIEZvcl90ZXN0cyA9IHN0cnVjdFxuXG4gICAgbGV0IHByZXZfaW5zdCB0ID0gQ3B1LkZvcl90ZXN0cy5wcmV2X2luc3QgdC5jcHVcblxuICAgIGxldCBnZXRfbHkgdCA9IEdwdS5yZWFkX2J5dGUgdC5ncHUgbHlfYWRkciB8PiBVaW50OC50b19pbnRcblxuICAgIGxldCBnZXRfbGNkX3N0YXQgdCA9IEdwdS5yZWFkX2J5dGUgdC5ncHUgbGNkX3N0YXRfYWRkclxuXG4gICAgbGV0IGdldF9tY3ljbGVzX2luX21vZGUgdCA9IEdwdS5Gb3JfdGVzdHMuZ2V0X21jeWNsZXNfaW5fbW9kZSB0LmdwdVxuXG4gICAgbGV0IGdldF90aW1hX2NvdW50IHQgPSBUaW1lci5Gb3JfdGVzdHMuZ2V0X3RpbWFfY291bnQgdC50aW1lclxuXG4gIGVuZFxuXG5lbmRcbiIsIm9wZW4gQ2FtbGJveV9saWJcbm9wZW4gQnJyXG5vcGVuIEJycl9jYW52YXNcbm9wZW4gQnJyX2lvXG5vcGVuIEZ1dC5TeW50YXhcblxuXG5sZXQgZ2JfdyA9IDE2MFxubGV0IGdiX2ggPSAxNDRcblxudHlwZSByb21fb3B0aW9uID0ge25hbWUgOiBzdHJpbmc7IHBhdGggOiBzdHJpbmd9XG5sZXQgcm9tX29wdGlvbnMgPSBbXG4gIHtuYW1lID0gXCJUaGUgQm91bmNpbmcgQmFsbFwiIDsgcGF0aCA9IFwiLi90aGUtYm91bmNpbmctYmFsbC5nYlwifTtcbiAge25hbWUgPSBcIlJldHJvaWRcIiAgICAgICAgICAgOyBwYXRoID0gXCIuL3JldHJvaWQuZ2JcIn07XG4gIHtuYW1lID0gXCJJbnRvIFRoZSBCbHVlXCIgICAgIDsgcGF0aCA9IFwiLi9pbnRvLXRoZS1ibHVlLmdiXCJ9O1xuICB7bmFtZSA9IFwiVG9idSBUb2J1IEdpcmxcIiAgICA7IHBhdGggPSBcIi4vdG9idS5nYlwifTtcbiAge25hbWUgPSBcIldpc2hpbmcgU2FyYWhcIiAgICA7IHBhdGggPSBcIi4vZHJlYW1pbmctc2FyYWguZ2JcIn07XG4gIHtuYW1lID0gXCJSb2NrZXQgTWFuIERlbW9cIiAgIDsgcGF0aCA9IFwiLi9yb2NrZXQtbWFuLWRlbW8uZ2JcIn07XG4gIHtuYW1lID0gXCJTSEVFUCBJVCBVUFwiICAgICAgIDsgcGF0aCA9IFwiLi9zaGVlcC1pdC11cC5nYlwifTtcbl1cblxubGV0IGFsZXJ0IHYgPVxuICBsZXQgYWxlcnQgPSBKdi5nZXQgSnYuZ2xvYmFsIFwiYWxlcnRcIiBpblxuICBpZ25vcmUgQEAgSnYuYXBwbHkgYWxlcnQgSnYuW3wgb2Zfc3RyaW5nIHYgfF1cblxubGV0IGZpbmRfZWxfYnlfaWQgaWQgPSBEb2N1bWVudC5maW5kX2VsX2J5X2lkIEcuZG9jdW1lbnQgKEpzdHIudiBpZCkgfD4gT3B0aW9uLmdldFxuXG5sZXQgZHJhd19mcmFtZWJ1ZmZlciBjdHggaW1hZ2VfZGF0YSBmYiA9XG4gIGxldCBkID0gQzJkLkltYWdlX2RhdGEuZGF0YSBpbWFnZV9kYXRhIGluXG4gIGZvciB5ID0gMCB0byBnYl9oIC0gMSBkb1xuICAgIGZvciB4ID0gMCB0byBnYl93IC0gMSBkb1xuICAgICAgbGV0IG9mZiA9IDQgKiAoeSAqIGdiX3cgKyB4KSBpblxuICAgICAgbWF0Y2ggZmIuKHkpLih4KSB3aXRoXG4gICAgICB8IGBXaGl0ZSAtPlxuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiAgICApIDB4RTU7XG4gICAgICAgIFRhcnJheS5zZXQgZCAob2ZmICsgMSkgMHhGQjtcbiAgICAgICAgVGFycmF5LnNldCBkIChvZmYgKyAyKSAweEY0O1xuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiArIDMpIDB4RkY7XG4gICAgICB8IGBMaWdodF9ncmF5IC0+XG4gICAgICAgIFRhcnJheS5zZXQgZCAob2ZmICAgICkgMHg5NztcbiAgICAgICAgVGFycmF5LnNldCBkIChvZmYgKyAxKSAweEFFO1xuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiArIDIpIDB4Qjg7XG4gICAgICAgIFRhcnJheS5zZXQgZCAob2ZmICsgMykgMHhGRjtcbiAgICAgIHwgYERhcmtfZ3JheSAtPlxuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiAgICApIDB4NjE7XG4gICAgICAgIFRhcnJheS5zZXQgZCAob2ZmICsgMSkgMHg2ODtcbiAgICAgICAgVGFycmF5LnNldCBkIChvZmYgKyAyKSAweDdEO1xuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiArIDMpIDB4RkY7XG4gICAgICB8IGBCbGFjayAtPlxuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiAgICApIDB4MjI7XG4gICAgICAgIFRhcnJheS5zZXQgZCAob2ZmICsgMSkgMHgxRTtcbiAgICAgICAgVGFycmF5LnNldCBkIChvZmYgKyAyKSAweDMxO1xuICAgICAgICBUYXJyYXkuc2V0IGQgKG9mZiArIDMpIDB4RkY7XG4gICAgZG9uZVxuICBkb25lO1xuICBDMmQucHV0X2ltYWdlX2RhdGEgY3R4IGltYWdlX2RhdGEgfng6MCB+eTowXG5cbigqKiBNYW5hZ2VzIHN0YXRlIHRoYXQgbmVlZCB0byBiZSByZXNldCB3aGVuIGxvYWRpbmcgYSBuZXcgcm9tICopXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgbGV0IHJ1bl9pZCA9IHJlZiBOb25lXG4gIGxldCBrZXlfZG93bl9saXN0ZW5lciA9IHJlZiBOb25lXG4gIGxldCBrZXlfdXBfbGlzdGVuZXIgPSByZWYgTm9uZVxuICBsZXQgc2V0X2xpc3RlbmVyIGRvd24gdXAgPVxuICAgIGtleV9kb3duX2xpc3RlbmVyIDo9IFNvbWUgZG93bjtcbiAgICBrZXlfdXBfbGlzdGVuZXIgOj0gU29tZSB1cFxuICBsZXQgY2xlYXIgKCkgPVxuICAgIGJlZ2luIG1hdGNoICFydW5faWQgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgdGltZXJfaWQgLT5cbiAgICAgICAgRy5zdG9wX3RpbWVyIHRpbWVyX2lkO1xuICAgICAgICBHLmNhbmNlbF9hbmltYXRpb25fZnJhbWUgdGltZXJfaWQ7XG4gICAgZW5kO1xuICAgIGJlZ2luIG1hdGNoICFrZXlfZG93bl9saXN0ZW5lciB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBsaXN0ZXIgLT4gRXYudW5saXN0ZW4gRXYua2V5ZG93biBsaXN0ZXIgRy50YXJnZXRcbiAgICBlbmQ7XG4gICAgYmVnaW4gbWF0Y2ggIWtleV91cF9saXN0ZW5lciB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBsaXN0ZXIgLT4gRXYudW5saXN0ZW4gRXYua2V5dXAgbGlzdGVyIEcudGFyZ2V0XG4gICAgZW5kXG5lbmRcblxubGV0IHNldF91cF9rZXlib2FyZCAodHlwZSBhKSAobW9kdWxlIEMgOiBDYW1sYm95X2ludGYuUyB3aXRoIHR5cGUgdCA9IGEpICh0IDogYSkgPVxuICBsZXQga2V5X2Rvd25fbGlzdGVuZXIgZXYgPVxuICAgIGxldCBrZXlfZXYgPSBFdi5hc190eXBlIGV2IGluXG4gICAgbGV0IGtleV9uYW1lID0ga2V5X2V2IHw+IEV2LktleWJvYXJkLmtleSB8PiBKc3RyLnRvX3N0cmluZyBpblxuICAgIG1hdGNoIGtleV9uYW1lIHdpdGhcbiAgICB8IFwiRW50ZXJcIiAtPiBDLnByZXNzIHQgU3RhcnRcbiAgICB8IFwiU2hpZnRcIiAtPiBDLnByZXNzIHQgU2VsZWN0XG4gICAgfCBcImpcIiAgICAgLT4gQy5wcmVzcyB0IEJcbiAgICB8IFwia1wiICAgICAtPiBDLnByZXNzIHQgQVxuICAgIHwgXCJ3XCIgICAgIC0+IEMucHJlc3MgdCBVcFxuICAgIHwgXCJhXCIgICAgIC0+IEMucHJlc3MgdCBMZWZ0XG4gICAgfCBcInNcIiAgICAgLT4gQy5wcmVzcyB0IERvd25cbiAgICB8IFwiZFwiICAgICAtPiBDLnByZXNzIHQgUmlnaHRcbiAgICB8IF8gICAgICAgLT4gKClcbiAgaW5cbiAgbGV0IGtleV91cF9saXN0ZW5lciBldiA9XG4gICAgbGV0IGtleV9ldiA9IEV2LmFzX3R5cGUgZXYgaW5cbiAgICBsZXQga2V5X25hbWUgPSBrZXlfZXYgfD4gRXYuS2V5Ym9hcmQua2V5IHw+IEpzdHIudG9fc3RyaW5nIGluXG4gICAgbWF0Y2gga2V5X25hbWUgd2l0aFxuICAgIHwgXCJFbnRlclwiIC0+IEMucmVsZWFzZSB0IFN0YXJ0XG4gICAgfCBcIlNoaWZ0XCIgLT4gQy5yZWxlYXNlIHQgU2VsZWN0XG4gICAgfCBcImpcIiAgICAgLT4gQy5yZWxlYXNlIHQgQlxuICAgIHwgXCJrXCIgICAgIC0+IEMucmVsZWFzZSB0IEFcbiAgICB8IFwid1wiICAgICAtPiBDLnJlbGVhc2UgdCBVcFxuICAgIHwgXCJhXCIgICAgIC0+IEMucmVsZWFzZSB0IExlZnRcbiAgICB8IFwic1wiICAgICAtPiBDLnJlbGVhc2UgdCBEb3duXG4gICAgfCBcImRcIiAgICAgLT4gQy5yZWxlYXNlIHQgUmlnaHRcbiAgICB8IF8gICAgICAgLT4gKClcbiAgaW5cbiAgRXYubGlzdGVuIEV2LmtleWRvd24gKGtleV9kb3duX2xpc3RlbmVyKSBHLnRhcmdldDtcbiAgRXYubGlzdGVuIEV2LmtleXVwIChrZXlfdXBfbGlzdGVuZXIpIEcudGFyZ2V0O1xuICBTdGF0ZS5zZXRfbGlzdGVuZXIga2V5X2Rvd25fbGlzdGVuZXIga2V5X3VwX2xpc3RlbmVyXG5cbmxldCBzZXRfdXBfam95cGFkICh0eXBlIGEpIChtb2R1bGUgQyA6IENhbWxib3lfaW50Zi5TIHdpdGggdHlwZSB0ID0gYSkgKHQgOiBhKSA9XG4gIGxldCB1cF9lbCwgZG93bl9lbCwgbGVmdF9lbCwgcmlnaHRfZWwgPVxuICAgIGZpbmRfZWxfYnlfaWQgXCJ1cFwiLCBmaW5kX2VsX2J5X2lkIFwiZG93blwiLCBmaW5kX2VsX2J5X2lkIFwibGVmdFwiLCBmaW5kX2VsX2J5X2lkIFwicmlnaHRcIiBpblxuICBsZXQgYV9lbCwgYl9lbCA9IGZpbmRfZWxfYnlfaWQgXCJhXCIsIGZpbmRfZWxfYnlfaWQgXCJiXCIgaW5cbiAgbGV0IHN0YXJ0X2VsLCBzZWxlY3RfZWwgPSBmaW5kX2VsX2J5X2lkIFwic3RhcnRcIiwgZmluZF9lbF9ieV9pZCBcInNlbGVjdFwiIGluXG4gICgqIFRPRE86IHVubGlzdGVuIHRoZXNlIGxpc3RlbmVyIHdoZW4gcm9tIGNoYW5nZSAqKVxuICBsZXQgcHJlc3MgZXYgdCBrZXkgPSBFdi5wcmV2ZW50X2RlZmF1bHQgZXY7IEMucHJlc3MgdCBrZXkgaW5cbiAgbGV0IHJlbGVhc2UgZXYgdCBrZXkgPSBFdi5wcmV2ZW50X2RlZmF1bHQgZXY7IEMucmVsZWFzZSB0IGtleSBpblxuICBsZXQgbGlzdGVuX29wcyA9IEV2Lmxpc3Rlbl9vcHRzIH5jYXB0dXJlOnRydWUgKCkgaW5cbiAgRXYubGlzdGVuIEV2LnBvaW50ZXJkb3duIH5vcHRzOmxpc3Rlbl9vcHMgKGZ1biBldiAtPiBwcmVzcyBldiB0IFVwKSAgICAgKEVsLmFzX3RhcmdldCB1cF9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVyZG93biB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcHJlc3MgZXYgdCBEb3duKSAgIChFbC5hc190YXJnZXQgZG93bl9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVyZG93biB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcHJlc3MgZXYgdCBMZWZ0KSAgIChFbC5hc190YXJnZXQgbGVmdF9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVyZG93biB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcHJlc3MgZXYgdCBSaWdodCkgIChFbC5hc190YXJnZXQgcmlnaHRfZWwpO1xuICBFdi5saXN0ZW4gRXYucG9pbnRlcmRvd24gfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHByZXNzIGV2IHQgQSkgICAgICAoRWwuYXNfdGFyZ2V0IGFfZWwpO1xuICBFdi5saXN0ZW4gRXYucG9pbnRlcmRvd24gfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHByZXNzIGV2IHQgQikgICAgICAoRWwuYXNfdGFyZ2V0IGJfZWwpO1xuICBFdi5saXN0ZW4gRXYucG9pbnRlcmRvd24gfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHByZXNzIGV2IHQgU3RhcnQpICAoRWwuYXNfdGFyZ2V0IHN0YXJ0X2VsKTtcbiAgRXYubGlzdGVuIEV2LnBvaW50ZXJkb3duIH5vcHRzOmxpc3Rlbl9vcHMgKGZ1biBldiAtPiBwcmVzcyBldiB0IFNlbGVjdCkgKEVsLmFzX3RhcmdldCBzZWxlY3RfZWwpO1xuICBFdi5saXN0ZW4gRXYucG9pbnRlcmxlYXZlIH5vcHRzOmxpc3Rlbl9vcHMgKGZ1biBldiAtPiByZWxlYXNlIGV2IHQgVXApICAgICAoRWwuYXNfdGFyZ2V0IHVwX2VsKTtcbiAgRXYubGlzdGVuIEV2LnBvaW50ZXJsZWF2ZSB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcmVsZWFzZSBldiB0IERvd24pICAgKEVsLmFzX3RhcmdldCBkb3duX2VsKTtcbiAgRXYubGlzdGVuIEV2LnBvaW50ZXJsZWF2ZSB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcmVsZWFzZSBldiB0IExlZnQpICAgKEVsLmFzX3RhcmdldCBsZWZ0X2VsKTtcbiAgRXYubGlzdGVuIEV2LnBvaW50ZXJsZWF2ZSB+b3B0czpsaXN0ZW5fb3BzIChmdW4gZXYgLT4gcmVsZWFzZSBldiB0IFJpZ2h0KSAgKEVsLmFzX3RhcmdldCByaWdodF9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVybGVhdmUgfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHJlbGVhc2UgZXYgdCBBKSAgICAgIChFbC5hc190YXJnZXQgYV9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVybGVhdmUgfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHJlbGVhc2UgZXYgdCBCKSAgICAgIChFbC5hc190YXJnZXQgYl9lbCk7XG4gIEV2Lmxpc3RlbiBFdi5wb2ludGVybGVhdmUgfm9wdHM6bGlzdGVuX29wcyAoZnVuIGV2IC0+IHJlbGVhc2UgZXYgdCBTdGFydCkgIChFbC5hc190YXJnZXQgc3RhcnRfZWwpO1xuICBFdi5saXN0ZW4gRXYucG9pbnRlcmxlYXZlIH5vcHRzOmxpc3Rlbl9vcHMgKGZ1biBldiAtPiByZWxlYXNlIGV2IHQgU2VsZWN0KSAoRWwuYXNfdGFyZ2V0IHNlbGVjdF9lbClcblxubGV0IHRocm90dGxlZCA9IHJlZiB0cnVlXG5cbmxldCBydW5fcm9tX2J5dGVzIGN0eCBpbWFnZV9kYXRhIHJvbV9ieXRlcyA9XG4gIFN0YXRlLmNsZWFyICgpO1xuICBsZXQgY2FydHJpZGdlID0gRGV0ZWN0X2NhcnRyaWRnZS5mIH5yb21fYnl0ZXMgaW5cbiAgbGV0IG1vZHVsZSBDID0gQ2FtbGJveS5NYWtlKHZhbCBjYXJ0cmlkZ2UpIGluXG4gIGxldCB0ID0gIEMuY3JlYXRlX3dpdGhfcm9tIH5wcmludF9zZXJpYWxfcG9ydDp0cnVlIH5yb21fYnl0ZXMgaW5cbiAgc2V0X3VwX2tleWJvYXJkIChtb2R1bGUgQykgdDtcbiAgc2V0X3VwX2pveXBhZCAobW9kdWxlIEMpIHQ7XG4gIGxldCBjbnQgPSByZWYgMCBpblxuICBsZXQgc3RhcnRfdGltZSA9IHJlZiAoUGVyZm9ybWFuY2Uubm93X21zIEcucGVyZm9ybWFuY2UpIGluXG4gIGxldCBzZXRfZnBzIGZwcyA9XG4gICAgbGV0IGZwc19zdHIgPSBQcmludGYuc3ByaW50ZiBcIiUuMmZcIiBmcHMgaW5cbiAgICBsZXQgZnBzX2VsID0gZmluZF9lbF9ieV9pZCBcImZwc1wiIGluXG4gICAgRWwuc2V0X2NoaWxkcmVuIGZwc19lbCBbRWwudHh0IChKc3RyLnYgZnBzX3N0cildXG4gIGluXG4gIGxldCByZWMgbWFpbl9sb29wICgpID1cbiAgICBiZWdpbiBtYXRjaCBDLnJ1bl9pbnN0cnVjdGlvbiB0IHdpdGhcbiAgICAgIHwgSW5fZnJhbWUgLT5cbiAgICAgICAgbWFpbl9sb29wICgpXG4gICAgICB8IEZyYW1lX2VuZGVkIGZiIC0+XG4gICAgICAgIGluY3IgY250O1xuICAgICAgICBpZiAhY250ID0gNjAgdGhlbiBiZWdpblxuICAgICAgICAgIGxldCBlbmRfdGltZSA9IFBlcmZvcm1hbmNlLm5vd19tcyBHLnBlcmZvcm1hbmNlIGluXG4gICAgICAgICAgbGV0IHNlY19wZXJfNjBfZnJhbWUgPSAoZW5kX3RpbWUgLS4gIXN0YXJ0X3RpbWUpIC8uIDEwMDAuIGluXG4gICAgICAgICAgbGV0IGZwcyA9IDYwLiAvLiAgc2VjX3Blcl82MF9mcmFtZSBpblxuICAgICAgICAgIHN0YXJ0X3RpbWUgOj0gZW5kX3RpbWU7XG4gICAgICAgICAgc2V0X2ZwcyBmcHM7XG4gICAgICAgICAgY250IDo9IDA7XG4gICAgICAgIGVuZDtcbiAgICAgICAgZHJhd19mcmFtZWJ1ZmZlciBjdHggaW1hZ2VfZGF0YSBmYjtcbiAgICAgICAgaWYgbm90ICF0aHJvdHRsZWQgdGhlblxuICAgICAgICAgIFN0YXRlLnJ1bl9pZCA6PSBTb21lIChHLnNldF90aW1lb3V0IH5tczowIG1haW5fbG9vcClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFN0YXRlLnJ1bl9pZCA6PSBTb21lIChHLnJlcXVlc3RfYW5pbWF0aW9uX2ZyYW1lIChmdW4gXyAtPiBtYWluX2xvb3AgKCkpKVxuICAgIGVuZDtcbiAgaW5cbiAgbWFpbl9sb29wICgpXG5cbmxldCBydW5fcm9tX2Jsb2IgY3R4IGltYWdlX2RhdGEgcm9tX2Jsb2IgPVxuICBsZXQqIHJlc3VsdCA9IEJsb2IuYXJyYXlfYnVmZmVyIHJvbV9ibG9iIGluXG4gIG1hdGNoIHJlc3VsdCB3aXRoXG4gIHwgT2sgYnVmIC0+XG4gICAgbGV0IHJvbV9ieXRlcyA9XG4gICAgICBUYXJyYXkub2ZfYnVmZmVyIFVpbnQ4IGJ1ZlxuICAgICAgfD4gVGFycmF5LnRvX2JpZ2FycmF5MVxuICAgICAgKCogQ29udmVydCB1aW50OCBiaWdhcnJheSB0byBjaGFyIGJpZ2FycmF5ICopXG4gICAgICB8PiBPYmoubWFnaWNcbiAgICBpblxuICAgIEZ1dC5yZXR1cm4gQEAgcnVuX3JvbV9ieXRlcyBjdHggaW1hZ2VfZGF0YSByb21fYnl0ZXNcbiAgfCBFcnJvciBlIC0+XG4gICAgRnV0LnJldHVybiBAQCBDb25zb2xlLihsb2cgW0p2LkVycm9yLm1lc3NhZ2UgZV0pXG5cbmxldCBvbl9sb2FkX3JvbSBjdHggaW1hZ2VfZGF0YSBpbnB1dF9lbCA9XG4gIGxldCBmaWxlID0gRWwuSW5wdXQuZmlsZXMgaW5wdXRfZWwgfD4gTGlzdC5oZCBpblxuICBsZXQgYmxvYiA9IEZpbGUuYXNfYmxvYiBmaWxlIGluXG4gIEZ1dC5hd2FpdCAocnVuX3JvbV9ibG9iIGN0eCBpbWFnZV9kYXRhIGJsb2IpIChmdW4gKCkgLT4gKCkpXG5cbmxldCBydW5fc2VsZWN0ZWRfcm9tIGN0eCBpbWFnZV9kYXRhIHJvbV9wYXRoID1cbiAgbGV0KiByZXN1bHQgPSBGZXRjaC51cmwgKEpzdHIudiByb21fcGF0aCkgaW5cbiAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgfCBPayByZXNwb25zZSAtPlxuICAgIGxldCBib2R5ID0gRmV0Y2guUmVzcG9uc2UuYXNfYm9keSByZXNwb25zZSBpblxuICAgIGxldCogcmVzdWx0ID0gRmV0Y2guQm9keS5ibG9iIGJvZHkgaW5cbiAgICBiZWdpbiBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgfCBPayBibG9iIC0+IHJ1bl9yb21fYmxvYiBjdHggaW1hZ2VfZGF0YSBibG9iXG4gICAgICB8IEVycm9yIGUgIC0+IEZ1dC5yZXR1cm4gQEAgQ29uc29sZS4obG9nIFtKdi5FcnJvci5tZXNzYWdlIGVdKVxuICAgIGVuZFxuICB8IEVycm9yIGUgIC0+IEZ1dC5yZXR1cm4gQEAgQ29uc29sZS4obG9nIFtKdi5FcnJvci5tZXNzYWdlIGVdKVxuXG5sZXQgc2V0X3VwX3JvbV9zZWxlY3RvciBjdHggaW1hZ2VfZGF0YSBzZWxlY3Rvcl9lbCA9XG4gIHJvbV9vcHRpb25zXG4gIHw+IExpc3QubWFwIChmdW4gcm9tX29wdGlvbiAtPlxuICAgICAgRWwub3B0aW9uXG4gICAgICAgIH5hdDpBdC5bdmFsdWUgKEpzdHIudiByb21fb3B0aW9uLnBhdGgpXVxuICAgICAgICBbRWwudHh0JyByb21fb3B0aW9uLm5hbWVdKVxuICB8PiBFbC5hcHBlbmRfY2hpbGRyZW4gc2VsZWN0b3JfZWw7XG4gIGxldCBvbl9jaGFuZ2UgXyA9XG4gICAgbGV0IHJvbV9wYXRoID0gRWwucHJvcCAoRWwuUHJvcC52YWx1ZSkgc2VsZWN0b3JfZWwgfD4gSnN0ci50b19zdHJpbmcgaW5cbiAgICBGdXQuYXdhaXQgKHJ1bl9zZWxlY3RlZF9yb20gY3R4IGltYWdlX2RhdGEgcm9tX3BhdGgpIChmdW4gKCkgLT4gKCkpXG4gIGluXG4gIEV2Lmxpc3RlbiBFdi5jaGFuZ2Ugb25fY2hhbmdlIChFbC5hc190YXJnZXQgc2VsZWN0b3JfZWwpXG5cbmxldCBvbl9jaGVja2JveF9jaGFuZ2UgY2hlY2tib3hfZWwgPVxuICBsZXQgY2hlY2tlZCA9IEVsLnByb3AgKEVsLlByb3AuY2hlY2tlZCkgY2hlY2tib3hfZWwgaW5cbiAgdGhyb3R0bGVkIDo9IGNoZWNrZWRcblxubGV0ICgpID1cbiAgKCogU2V0IHVwIGNhbnZhcyAqKVxuICBsZXQgY2FudmFzID0gZmluZF9lbF9ieV9pZCBcImNhbnZhc1wiIHw+IENhbnZhcy5vZl9lbCBpblxuICBsZXQgY3R4ID0gQzJkLmNyZWF0ZSBjYW52YXMgaW5cbiAgQzJkLnNjYWxlIGN0eCB+c3g6MS41IH5zeToxLjU7XG4gIGxldCBpbWFnZV9kYXRhID0gQzJkLmNyZWF0ZV9pbWFnZV9kYXRhIGN0eCB+dzpnYl93IH5oOmdiX2ggaW5cbiAgbGV0IGZiID0gQXJyYXkubWFrZV9tYXRyaXggZ2JfaCBnYl93IGBMaWdodF9ncmF5IGluXG4gIGRyYXdfZnJhbWVidWZmZXIgY3R4IGltYWdlX2RhdGEgZmI7XG4gICgqIFNldCB1cCB0aHJvdHRsZSBjaGVja2JveCAqKVxuICBsZXQgY2hlY2tib3hfZWwgPSBmaW5kX2VsX2J5X2lkIFwidGhyb3R0bGVcIiBpblxuICBFdi5saXN0ZW4gRXYuY2hhbmdlIChmdW4gXyAtPiBvbl9jaGVja2JveF9jaGFuZ2UgY2hlY2tib3hfZWwpIChFbC5hc190YXJnZXQgY2hlY2tib3hfZWwpO1xuICAoKiBTZXQgdXAgbG9hZCByb20gYnV0dG9uICopXG4gIGxldCBpbnB1dF9lbCA9IGZpbmRfZWxfYnlfaWQgXCJsb2FkLXJvbVwiIGluXG4gIEV2Lmxpc3RlbiBFdi5jaGFuZ2UgKGZ1biBfIC0+IG9uX2xvYWRfcm9tIGN0eCBpbWFnZV9kYXRhIGlucHV0X2VsKSAoRWwuYXNfdGFyZ2V0IGlucHV0X2VsKTtcbiAgKCogU2V0IHVwIHJvbSBzZWxlY3RvciAqKVxuICBsZXQgc2VsZWN0b3JfZWwgPSBmaW5kX2VsX2J5X2lkIFwicm9tLXNlbGVjdG9yXCIgaW5cbiAgc2V0X3VwX3JvbV9zZWxlY3RvciBjdHggaW1hZ2VfZGF0YSBzZWxlY3Rvcl9lbDtcbiAgKCogTG9hZCBpbml0aWFsIHJvbSAqKVxuICBsZXQgcm9tID0gTGlzdC5oZCByb21fb3B0aW9ucyBpblxuICBsZXQgZnV0ID0gcnVuX3NlbGVjdGVkX3JvbSBjdHggaW1hZ2VfZGF0YSByb20ucGF0aCBpblxuICBGdXQuYXdhaXQgZnV0IChmdW4gKCkgLT4gKCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEVuc3VyZSB0aGF0IFthdF9leGl0XSBmdW5jdGlvbnMgYXJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHByb2dyYW0gKilcblxubGV0IF8gPSBkb19hdF9leGl0KClcbiJdfQ==